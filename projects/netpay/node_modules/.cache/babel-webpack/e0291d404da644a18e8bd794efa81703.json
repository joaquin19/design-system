{"ast":null,"code":"import Point from '../geometry/point';\nimport { last } from '../util';\nconst ShapeMap = {\n  l: function (path, options) {\n    const {\n      parameters,\n      position\n    } = options;\n\n    for (let i = 0; i < parameters.length; i += 2) {\n      let point = new Point(parameters[i], parameters[i + 1]);\n\n      if (options.isRelative) {\n        point.translateWith(position);\n      }\n\n      path.lineTo(point.x, point.y);\n      position.x = point.x;\n      position.y = point.y;\n    }\n  },\n  c: function (path, options) {\n    const {\n      parameters,\n      position\n    } = options;\n\n    for (let i = 0; i < parameters.length; i += 6) {\n      let controlOut = new Point(parameters[i], parameters[i + 1]);\n      let controlIn = new Point(parameters[i + 2], parameters[i + 3]);\n      let point = new Point(parameters[i + 4], parameters[i + 5]);\n\n      if (options.isRelative) {\n        controlIn.translateWith(position);\n        controlOut.translateWith(position);\n        point.translateWith(position);\n      }\n\n      path.curveTo(controlOut, controlIn, point);\n      position.x = point.x;\n      position.y = point.y;\n    }\n  },\n  v: function (path, options) {\n    const value = options.isRelative ? 0 : options.position.x;\n    toLineParamaters(options.parameters, true, value);\n    this.l(path, options);\n  },\n  h: function (path, options) {\n    const value = options.isRelative ? 0 : options.position.y;\n    toLineParamaters(options.parameters, false, value);\n    this.l(path, options);\n  },\n  a: function (path, options) {\n    const {\n      parameters,\n      position\n    } = options;\n\n    for (let i = 0; i < parameters.length; i += 7) {\n      const radiusX = parameters[i];\n      const radiusY = parameters[i + 1];\n      const rotation = parameters[i + 2];\n      const largeArc = parameters[i + 3];\n      const swipe = parameters[i + 4];\n      const endPoint = new Point(parameters[i + 5], parameters[i + 6]);\n\n      if (options.isRelative) {\n        endPoint.translateWith(position);\n      }\n\n      if (position.x !== endPoint.x || position.y !== endPoint.y) {\n        path.arcTo(endPoint, radiusX, radiusY, largeArc, swipe, rotation);\n        position.x = endPoint.x;\n        position.y = endPoint.y;\n      }\n    }\n  },\n  s: function (path, options) {\n    const {\n      parameters,\n      position,\n      previousCommand\n    } = options;\n    let lastControlIn;\n\n    if (previousCommand === \"s\" || previousCommand === \"c\") {\n      lastControlIn = last(last(path.paths).segments).controlIn();\n    }\n\n    for (let i = 0; i < parameters.length; i += 4) {\n      let controlIn = new Point(parameters[i], parameters[i + 1]);\n      let endPoint = new Point(parameters[i + 2], parameters[i + 3]);\n      let controlOut;\n\n      if (options.isRelative) {\n        controlIn.translateWith(position);\n        endPoint.translateWith(position);\n      }\n\n      if (lastControlIn) {\n        controlOut = reflectionPoint(lastControlIn, position);\n      } else {\n        controlOut = position.clone();\n      }\n\n      lastControlIn = controlIn;\n      path.curveTo(controlOut, controlIn, endPoint);\n      position.x = endPoint.x;\n      position.y = endPoint.y;\n    }\n  },\n  q: function (path, options) {\n    const {\n      parameters,\n      position\n    } = options;\n\n    for (let i = 0; i < parameters.length; i += 4) {\n      let controlPoint = new Point(parameters[i], parameters[i + 1]);\n      let endPoint = new Point(parameters[i + 2], parameters[i + 3]);\n\n      if (options.isRelative) {\n        controlPoint.translateWith(position);\n        endPoint.translateWith(position);\n      }\n\n      let cubicControlPoints = quadraticToCubicControlPoints(position, controlPoint, endPoint);\n      path.curveTo(cubicControlPoints.controlOut, cubicControlPoints.controlIn, endPoint);\n      position.x = endPoint.x;\n      position.y = endPoint.y;\n    }\n  },\n  t: function (path, options) {\n    const {\n      parameters,\n      position,\n      previousCommand\n    } = options;\n    let controlPoint;\n\n    if (previousCommand === \"q\" || previousCommand === \"t\") {\n      let lastSegment = last(last(path.paths).segments);\n      controlPoint = lastSegment.controlIn().clone().translateWith(position.scaleCopy(-1 / 3)).scale(3 / 2);\n    }\n\n    for (let i = 0; i < parameters.length; i += 2) {\n      let endPoint = new Point(parameters[i], parameters[i + 1]);\n\n      if (options.isRelative) {\n        endPoint.translateWith(position);\n      }\n\n      if (controlPoint) {\n        controlPoint = reflectionPoint(controlPoint, position);\n      } else {\n        controlPoint = position.clone();\n      }\n\n      let cubicControlPoints = quadraticToCubicControlPoints(position, controlPoint, endPoint);\n      path.curveTo(cubicControlPoints.controlOut, cubicControlPoints.controlIn, endPoint);\n      position.x = endPoint.x;\n      position.y = endPoint.y;\n    }\n  }\n};\n\nfunction toLineParamaters(parameters, isVertical, value) {\n  const insertPosition = isVertical ? 0 : 1;\n\n  for (let i = 0; i < parameters.length; i += 2) {\n    parameters.splice(i + insertPosition, 0, value);\n  }\n}\n\nfunction reflectionPoint(point, center) {\n  if (point && center) {\n    return center.scaleCopy(2).translate(-point.x, -point.y);\n  }\n}\n\nconst third = 1 / 3;\n\nfunction quadraticToCubicControlPoints(position, controlPoint, endPoint) {\n  const scaledPoint = controlPoint.clone().scale(2 / 3);\n  return {\n    controlOut: scaledPoint.clone().translateWith(position.scaleCopy(third)),\n    controlIn: scaledPoint.translateWith(endPoint.scaleCopy(third))\n  };\n}\n\nexport default ShapeMap;","map":null,"metadata":{},"sourceType":"module"}