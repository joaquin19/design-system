{"ast":null,"code":"import withAccessors from '../mixins/with-accessors';\nimport HasObservers from '../core/has-observers';\nimport { defined, MIN_NUM, MAX_NUM, round } from '../util';\nimport Matrix from './matrix';\nimport toMatrix from './to-matrix';\n\nclass Point extends withAccessors(HasObservers, [\"x\", \"y\"]) {\n  constructor(x, y) {\n    super();\n    this.x = x || 0;\n    this.y = y || 0;\n  }\n\n  equals(other) {\n    return other && other.x === this.x && other.y === this.y;\n  }\n\n  clone() {\n    return new Point(this.x, this.y);\n  }\n\n  rotate(angle, origin) {\n    const originPoint = Point.create(origin) || Point.ZERO;\n    return this.transform(Matrix.rotate(angle, originPoint.x, originPoint.y));\n  }\n\n  translate(x, y) {\n    this.x += x;\n    this.y += y;\n    this.geometryChange();\n    return this;\n  }\n\n  translateWith(point) {\n    return this.translate(point.x, point.y);\n  }\n\n  move(x, y) {\n    this.x = this.y = 0;\n    return this.translate(x, y);\n  }\n\n  scale(scaleX, scaleY = scaleX) {\n    this.x *= scaleX;\n    this.y *= scaleY;\n    this.geometryChange();\n    return this;\n  }\n\n  scaleCopy(scaleX, scaleY) {\n    return this.clone().scale(scaleX, scaleY);\n  }\n\n  transform(transformation) {\n    const matrix = toMatrix(transformation);\n    const {\n      x,\n      y\n    } = this;\n    this.x = matrix.a * x + matrix.c * y + matrix.e;\n    this.y = matrix.b * x + matrix.d * y + matrix.f;\n    this.geometryChange();\n    return this;\n  }\n\n  transformCopy(transformation) {\n    const point = this.clone();\n\n    if (transformation) {\n      point.transform(transformation);\n    }\n\n    return point;\n  }\n\n  distanceTo(point) {\n    const dx = this.x - point.x;\n    const dy = this.y - point.y;\n    return Math.sqrt(dx * dx + dy * dy);\n  }\n\n  round(digits) {\n    this.x = round(this.x, digits);\n    this.y = round(this.y, digits);\n    this.geometryChange();\n    return this;\n  }\n\n  toArray(digits) {\n    const doRound = defined(digits);\n    const x = doRound ? round(this.x, digits) : this.x;\n    const y = doRound ? round(this.y, digits) : this.y;\n    return [x, y];\n  }\n\n  toString(digits, separator = \" \") {\n    let {\n      x,\n      y\n    } = this;\n\n    if (defined(digits)) {\n      x = round(x, digits);\n      y = round(y, digits);\n    }\n\n    return x + separator + y;\n  }\n\n  static create(arg0, arg1) {\n    if (defined(arg0)) {\n      if (arg0 instanceof Point) {\n        return arg0;\n      } else if (arguments.length === 1 && arg0.length === 2) {\n        return new Point(arg0[0], arg0[1]);\n      }\n\n      return new Point(arg0, arg1);\n    }\n  }\n\n  static min() {\n    let minX = MAX_NUM;\n    let minY = MAX_NUM;\n\n    for (let i = 0; i < arguments.length; i++) {\n      let point = arguments[i];\n      minX = Math.min(point.x, minX);\n      minY = Math.min(point.y, minY);\n    }\n\n    return new Point(minX, minY);\n  }\n\n  static max() {\n    let maxX = MIN_NUM;\n    let maxY = MIN_NUM;\n\n    for (let i = 0; i < arguments.length; i++) {\n      const point = arguments[i];\n      maxX = Math.max(point.x, maxX);\n      maxY = Math.max(point.y, maxY);\n    }\n\n    return new Point(maxX, maxY);\n  }\n\n  static minPoint() {\n    return new Point(MIN_NUM, MIN_NUM);\n  }\n\n  static maxPoint() {\n    return new Point(MAX_NUM, MAX_NUM);\n  }\n\n  static get ZERO() {\n    return new Point(0, 0);\n  }\n\n}\n\nexport default Point;","map":null,"metadata":{},"sourceType":"module"}