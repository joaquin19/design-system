{"ast":null,"code":"/**-----------------------------------------------------------------------------------------\n* Copyright © 2020 Progress Software Corporation. All rights reserved.\n* Licensed under commercial license. See LICENSE.md in the project root for more information\n*-------------------------------------------------------------------------------------------*/\nimport { __decorate, __metadata, __param } from 'tslib';\nimport { Input, ContentChildren, QueryList, Component, NgZone, Directive, Optional, TemplateRef, ContentChild, forwardRef, SkipSelf, Host, NgModule } from '@angular/core';\nimport { saveAs } from '@progress/kendo-file-saver';\nimport { IntlService, ExcelExporter, Workbook } from '@progress/kendo-ooxml';\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from '@progress/kendo-angular-l10n';\nexport * from '@progress/kendo-ooxml';\nimport { toString } from '@telerik/kendo-intl';\nimport { LocalizationService, L10N_PREFIX } from '@progress/kendo-angular-l10n';\nimport { validatePackage } from '@progress/kendo-licensing';\n/* tslint:disable align */\n\n/* tslint:disable:no-use-before-declare */\n\nconst compileTemplate = (templateRef, context, updateContext) => {\n  let embeddedView = templateRef.createEmbeddedView(context);\n\n  const result = data => {\n    updateContext(context, data);\n    embeddedView.detectChanges();\n    return embeddedView.rootNodes.reduce((content, rootNode) => {\n      return content + rootNode.textContent;\n    }, '').trim();\n  };\n\n  result.destroy = () => {\n    embeddedView.destroy();\n    embeddedView = null;\n  };\n\n  return result;\n};\n\nconst updateGroupHeaderContext = (context, data) => {\n  context.$implicit = context.group = data;\n  context.field = data.field;\n  context.value = data.value;\n  context.aggregates = data.aggregates;\n};\n\nconst updateGroupFooterContext = (context, data) => {\n  context.group = data.group;\n  context.$implicit = context.aggregates = data;\n};\n\nconst updateFooterContext = (context, data) => {\n  context.aggregates = data.aggregates;\n};\n/**\n * @hidden\n */\n\n\nconst toExporterColumns = sourceColumns => {\n  const exporterColumns = [];\n  let columnIndex = 0;\n\n  const addColumns = (columns, result, level) => {\n    columns.forEach(column => {\n      if (column.level === level) {\n        const exporterColumn = new ExporterColumn(column, columnIndex);\n        result.push(exporterColumn);\n\n        if (column.children && column.children.some(c => c !== column)) {\n          const children = exporterColumn.columns = [];\n          addColumns(column.children, children, level + 1);\n        } else {\n          columnIndex++;\n        }\n      }\n    });\n  };\n\n  addColumns(sourceColumns, exporterColumns, 0);\n  return exporterColumns;\n};\n/**\n * @hidden\n */\n\n\nconst destroyColumns = columns => {\n  if (columns) {\n    columns.forEach(column => {\n      column.destroy();\n    });\n  }\n};\n/**\n * @hidden\n */\n\n\nclass ExporterColumn {\n  constructor(column, columnIndex) {\n    this.title = column.title;\n    this.field = column.field;\n    this.hidden = column.hidden;\n    this.locked = column.locked;\n    this.width = column.width;\n    this.headerCellOptions = column.headerCellOptions;\n    this.cellOptions = column.cellOptions;\n    this.groupHeaderCellOptions = column.groupHeaderCellOptions;\n    this.groupFooterCellOptions = column.groupFooterCellOptions;\n    this.footerCellOptions = column.footerCellOptions;\n\n    if (column.footerTemplate) {\n      this.footerTemplate = compileTemplate(column.footerTemplate.templateRef, {\n        $implicit: column,\n        column: column,\n        columnIndex: columnIndex\n      }, updateFooterContext);\n    }\n\n    if (column.groupFooterTemplate) {\n      this.groupFooterTemplate = compileTemplate(column.groupFooterTemplate.templateRef, {\n        column: column,\n        field: column.field\n      }, updateGroupFooterContext);\n    }\n\n    if (column.groupHeaderTemplate) {\n      this.groupHeaderTemplate = compileTemplate(column.groupHeaderTemplate.templateRef, {}, updateGroupHeaderContext);\n    }\n\n    if (column.groupHeaderColumnTemplate) {\n      this.groupHeaderColumnTemplate = compileTemplate(column.groupHeaderColumnTemplate.templateRef, {}, updateGroupHeaderContext);\n    }\n  }\n\n  destroy() {\n    if (this.footerTemplate) {\n      this.footerTemplate.destroy();\n    }\n\n    if (this.groupFooterTemplate) {\n      this.groupFooterTemplate.destroy();\n    }\n\n    if (this.groupHeaderTemplate) {\n      this.groupHeaderTemplate.destroy();\n    }\n\n    if (this.groupHeaderColumnTemplate) {\n      this.groupHeaderColumnTemplate.destroy();\n    }\n\n    destroyColumns(this.columns);\n  }\n\n}\n\nIntlService.register({\n  toString\n});\n/**\n *\n * @hidden\n */\n\nconst workbookOptions = options => {\n  const columns = toExporterColumns(options.columns);\n  const exporter = new ExcelExporter({\n    columns: columns,\n    data: options.data,\n    filterable: options.filterable,\n    groups: options.group,\n    paddingCellOptions: options.paddingCellOptions,\n    headerPaddingCellOptions: options.headerPaddingCellOptions,\n    collapsible: options.collapsible,\n    hierarchy: options.hierarchy,\n    aggregates: options.aggregates\n  });\n  const result = exporter.workbook();\n  result.creator = options.creator;\n  result.date = options.date;\n  result.rtl = options.rtl;\n  destroyColumns(columns);\n  return result;\n};\n/**\n * @hidden\n */\n\n\nconst toDataURL = options => {\n  const workbook = new Workbook(options);\n  return workbook.toDataURL();\n};\n/**\n * @hidden\n */\n\n\nconst isWorkbookOptions = value => {\n  return value && value.sheets;\n};\n/**\n * @hidden\n */\n\n\nclass ColumnBase {\n  constructor(parent) {\n    this.parent = parent;\n  }\n  /**\n   * @hidden\n   */\n\n\n  get level() {\n    return this.parent ? this.parent.level + 1 : 0;\n  }\n\n}\n\nColumnBase.ɵfac = function ColumnBase_Factory(t) {\n  ɵngcc0.ɵɵinvalidFactory();\n};\n\nColumnBase.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n  type: ColumnBase,\n  contentQueries: function ColumnBase_ContentQueries(rf, ctx, dirIndex) {\n    if (rf & 1) {\n      ɵngcc0.ɵɵcontentQuery(dirIndex, ColumnBase, 4);\n    }\n\n    if (rf & 2) {\n      let _t;\n\n      ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.children = _t);\n    }\n  },\n  inputs: {\n    title: \"title\",\n    width: \"width\",\n    locked: \"locked\",\n    hidden: \"hidden\",\n    headerCellOptions: \"headerCellOptions\"\n  }\n});\n\n__decorate([Input(), __metadata(\"design:type\", String)], ColumnBase.prototype, \"title\", void 0);\n\n__decorate([Input(), __metadata(\"design:type\", Number)], ColumnBase.prototype, \"width\", void 0);\n\n__decorate([Input(), __metadata(\"design:type\", Boolean)], ColumnBase.prototype, \"locked\", void 0);\n\n__decorate([Input(), __metadata(\"design:type\", Boolean)], ColumnBase.prototype, \"hidden\", void 0);\n\n__decorate([Input(), __metadata(\"design:type\", Object)], ColumnBase.prototype, \"headerCellOptions\", void 0);\n\n__decorate([ContentChildren(ColumnBase), __metadata(\"design:type\", QueryList)], ColumnBase.prototype, \"children\", void 0);\n/**\n * @hidden\n */\n\n\nconst packageMetadata = {\n  name: '@progress/kendo-angular-excel-export',\n  productName: 'Kendo UI for Angular',\n  productCodes: ['KENDOUIANGULAR', 'KENDOUICOMPLETE'],\n  publishDate: 1620213524,\n  version: '',\n  licensingDocsUrl: 'https://www.telerik.com/kendo-angular-ui/my-license/?utm_medium=product&utm_source=kendoangular&utm_campaign=kendo-ui-angular-purchase-license-keys-warning'\n};\n/**\n * Represents the [Kendo UI Excel Export component for Angular]({% slug overview_excelexport %}).\n * Configures the settings for the Excel export of the Kendo UI Grid.\n */\n\nlet ExcelExportComponent = class ExcelExportComponent {\n  constructor(localization, zone) {\n    this.localization = localization;\n    this.zone = zone;\n    /**\n     * Specifies the name of the file that is exported to Excel.\n     * @default \"Export.xlsx\"\n     */\n\n    this.fileName = 'Export.xlsx';\n    /**\n     * @hidden\n     */\n\n    this.columns = new QueryList();\n    validatePackage(packageMetadata);\n    this.saveFile = this.saveFile.bind(this);\n  }\n  /**\n   * Saves the data to Excel.\n   *\n   * @param exportData - An optional parameter. Can be the data that will be exported or [`WorkbookOptions`]({% slug api_excel-export_workbookoptions %}).\n   */\n\n\n  save(exportData) {\n    this.toDataURL(exportData).then(this.saveFile);\n  }\n  /**\n   * Based on the specified columns and data, returns\n   * [`WorkbookOptions`]({% slug api_excel-export_workbookoptions %})\n   * ([see example]({% slug customrowsandcells_excelexport %})).\n   *\n   * @param exportData - The optional data to be exported.\n   * @returns {WorkbookOptions} - The workbook options.\n   */\n\n\n  workbookOptions(exportData) {\n    const currentData = this.getExportData(exportData);\n    const options = workbookOptions({\n      columns: this.columns,\n      data: currentData.data,\n      group: currentData.group,\n      filterable: this.filterable,\n      creator: this.creator,\n      date: this.date,\n      rtl: this.localization.rtl,\n      paddingCellOptions: this.paddingCellOptions,\n      headerPaddingCellOptions: this.headerPaddingCellOptions,\n      collapsible: this.collapsible\n    });\n    return options;\n  }\n  /**\n   * Returns a promise which will be resolved with the file data URI\n   * ([see example]({% slug filesaving_excelexport %})).\n   *\n   * @param exportData - The optional data or [`WorkbookOptions`]({% slug api_excel-export_workbookoptions %}) that will be used to generate the data URI.\n   * @returns {Promise<string>} - The promise that will be resolved by the file data URI.\n   */\n\n\n  toDataURL(exportData) {\n    const options = isWorkbookOptions(exportData) ? exportData : this.workbookOptions(exportData);\n    return this.zone.runOutsideAngular(() => toDataURL(options));\n  }\n\n  getExportData(exportData) {\n    let result;\n\n    if (exportData) {\n      if (Array.isArray(exportData)) {\n        result = {\n          data: exportData\n        };\n      } else {\n        result = exportData;\n      }\n    } else {\n      result = {\n        data: this.data,\n        group: this.group\n      };\n    }\n\n    return result;\n  }\n\n  saveFile(dataURL) {\n    saveAs(dataURL, this.fileName, {\n      forceProxy: this.forceProxy,\n      proxyURL: this.proxyURL\n    });\n  }\n\n};\n\nExcelExportComponent.ɵfac = function ExcelExportComponent_Factory(t) {\n  return new (t || ExcelExportComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocalizationService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone));\n};\n\nExcelExportComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n  type: ExcelExportComponent,\n  selectors: [[\"kendo-excelexport\"]],\n  contentQueries: function ExcelExportComponent_ContentQueries(rf, ctx, dirIndex) {\n    if (rf & 1) {\n      ɵngcc0.ɵɵcontentQuery(dirIndex, ColumnBase, 5);\n    }\n\n    if (rf & 2) {\n      let _t;\n\n      ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.columns = _t);\n    }\n  },\n  inputs: {\n    fileName: \"fileName\",\n    filterable: \"filterable\",\n    collapsible: \"collapsible\",\n    creator: \"creator\",\n    date: \"date\",\n    forceProxy: \"forceProxy\",\n    proxyURL: \"proxyURL\",\n    data: \"data\",\n    group: \"group\",\n    paddingCellOptions: \"paddingCellOptions\",\n    headerPaddingCellOptions: \"headerPaddingCellOptions\"\n  },\n  exportAs: [\"kendoExcelExport\"],\n  features: [ɵngcc0.ɵɵProvidersFeature([LocalizationService, {\n    provide: L10N_PREFIX,\n    useValue: 'kendo.excelexport'\n  }])],\n  decls: 0,\n  vars: 0,\n  template: function ExcelExportComponent_Template(rf, ctx) {},\n  encapsulation: 2\n});\n\n__decorate([Input(), __metadata(\"design:type\", String)], ExcelExportComponent.prototype, \"fileName\", void 0);\n\n__decorate([Input(), __metadata(\"design:type\", Boolean)], ExcelExportComponent.prototype, \"filterable\", void 0);\n\n__decorate([Input(), __metadata(\"design:type\", Boolean)], ExcelExportComponent.prototype, \"collapsible\", void 0);\n\n__decorate([Input(), __metadata(\"design:type\", String)], ExcelExportComponent.prototype, \"creator\", void 0);\n\n__decorate([Input(), __metadata(\"design:type\", Date)], ExcelExportComponent.prototype, \"date\", void 0);\n\n__decorate([Input(), __metadata(\"design:type\", Boolean)], ExcelExportComponent.prototype, \"forceProxy\", void 0);\n\n__decorate([Input(), __metadata(\"design:type\", String)], ExcelExportComponent.prototype, \"proxyURL\", void 0);\n\n__decorate([Input(), __metadata(\"design:type\", Array)], ExcelExportComponent.prototype, \"data\", void 0);\n\n__decorate([Input(), __metadata(\"design:type\", Array)], ExcelExportComponent.prototype, \"group\", void 0);\n\n__decorate([Input(), __metadata(\"design:type\", Object)], ExcelExportComponent.prototype, \"paddingCellOptions\", void 0);\n\n__decorate([Input(), __metadata(\"design:type\", Object)], ExcelExportComponent.prototype, \"headerPaddingCellOptions\", void 0);\n\n__decorate([ContentChildren(ColumnBase, {\n  descendants: true\n}), __metadata(\"design:type\", QueryList)], ExcelExportComponent.prototype, \"columns\", void 0);\n\nExcelExportComponent = __decorate([__metadata(\"design:paramtypes\", [LocalizationService, NgZone])], ExcelExportComponent);\n/**\n * Represents the group header cell template of the Excel Export column component\n * ([see example]({% slug columns_excel-export %}#toc-group-header-template)).\n * Enables you to customize the content of the group header item.\n */\n\nlet GroupHeaderTemplateDirective = class GroupHeaderTemplateDirective {\n  constructor(templateRef) {\n    this.templateRef = templateRef;\n  }\n\n};\n\nGroupHeaderTemplateDirective.ɵfac = function GroupHeaderTemplateDirective_Factory(t) {\n  return new (t || GroupHeaderTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef, 8));\n};\n\nGroupHeaderTemplateDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n  type: GroupHeaderTemplateDirective,\n  selectors: [[\"\", \"kendoExcelExportGroupHeaderTemplate\", \"\"]]\n});\nGroupHeaderTemplateDirective = __decorate([__param(0, Optional()), __metadata(\"design:paramtypes\", [TemplateRef])], GroupHeaderTemplateDirective);\n/**\n * Represents the group header column template of the Excel Export column component\n * ([see example]({% slug columns_excel-export %}#toc-group-header-column-template)).\n */\n\nlet GroupHeaderColumnTemplateDirective = class GroupHeaderColumnTemplateDirective {\n  constructor(templateRef) {\n    this.templateRef = templateRef;\n  }\n\n};\n\nGroupHeaderColumnTemplateDirective.ɵfac = function GroupHeaderColumnTemplateDirective_Factory(t) {\n  return new (t || GroupHeaderColumnTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef, 8));\n};\n\nGroupHeaderColumnTemplateDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n  type: GroupHeaderColumnTemplateDirective,\n  selectors: [[\"\", \"kendoExcelExportGroupHeaderColumnTemplate\", \"\"]]\n});\nGroupHeaderColumnTemplateDirective = __decorate([__param(0, Optional()), __metadata(\"design:paramtypes\", [TemplateRef])], GroupHeaderColumnTemplateDirective);\n/**\n * Represents the group footer cell template of the Excel Export column component\n * ([see example]({% slug columns_excel-export %}#toc-group-footer-template)).\n * Enables you to customize the group footer cell of the column.\n */\n\nlet GroupFooterTemplateDirective = class GroupFooterTemplateDirective {\n  constructor(templateRef) {\n    this.templateRef = templateRef;\n  }\n\n};\n\nGroupFooterTemplateDirective.ɵfac = function GroupFooterTemplateDirective_Factory(t) {\n  return new (t || GroupFooterTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef, 8));\n};\n\nGroupFooterTemplateDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n  type: GroupFooterTemplateDirective,\n  selectors: [[\"\", \"kendoExcelExportGroupFooterTemplate\", \"\"]]\n});\nGroupFooterTemplateDirective = __decorate([__param(0, Optional()), __metadata(\"design:paramtypes\", [TemplateRef])], GroupFooterTemplateDirective);\n/**\n * Represents the footer cell template of the Excel Export column component\n * ([see example]({% slug columns_excel-export %}#toc-footer-template)).\n * Enables you to customize the footer cell of the column.\n */\n\nlet FooterTemplateDirective = class FooterTemplateDirective {\n  constructor(templateRef) {\n    this.templateRef = templateRef;\n  }\n\n};\n\nFooterTemplateDirective.ɵfac = function FooterTemplateDirective_Factory(t) {\n  return new (t || FooterTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef, 8));\n};\n\nFooterTemplateDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n  type: FooterTemplateDirective,\n  selectors: [[\"\", \"kendoExcelExportFooterTemplate\", \"\"]]\n});\nFooterTemplateDirective = __decorate([__param(0, Optional()), __metadata(\"design:paramtypes\", [TemplateRef])], FooterTemplateDirective);\nvar ColumnComponent_1;\n/**\n * Represents the columns of the Kendo UI Excel Export component for Angular.\n */\n\nlet ColumnComponent = ColumnComponent_1 = class ColumnComponent extends ColumnBase {\n  constructor(parent) {\n    super(parent);\n  }\n\n};\n\nColumnComponent.ɵfac = function ColumnComponent_Factory(t) {\n  return new (t || ColumnComponent)(ɵngcc0.ɵɵdirectiveInject(ColumnBase, 13));\n};\n\nColumnComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n  type: ColumnComponent,\n  selectors: [[\"kendo-excelexport-column\"]],\n  contentQueries: function ColumnComponent_ContentQueries(rf, ctx, dirIndex) {\n    if (rf & 1) {\n      ɵngcc0.ɵɵcontentQuery(dirIndex, GroupHeaderTemplateDirective, 5);\n      ɵngcc0.ɵɵcontentQuery(dirIndex, GroupHeaderColumnTemplateDirective, 5);\n      ɵngcc0.ɵɵcontentQuery(dirIndex, GroupFooterTemplateDirective, 5);\n      ɵngcc0.ɵɵcontentQuery(dirIndex, FooterTemplateDirective, 5);\n    }\n\n    if (rf & 2) {\n      let _t;\n\n      ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.groupHeaderTemplate = _t.first);\n      ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.groupHeaderColumnTemplate = _t.first);\n      ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.groupFooterTemplate = _t.first);\n      ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.footerTemplate = _t.first);\n    }\n  },\n  inputs: {\n    field: \"field\",\n    cellOptions: \"cellOptions\",\n    groupHeaderCellOptions: \"groupHeaderCellOptions\",\n    groupFooterCellOptions: \"groupFooterCellOptions\",\n    footerCellOptions: \"footerCellOptions\"\n  },\n  features: [ɵngcc0.ɵɵProvidersFeature([{\n    provide: ColumnBase,\n    useExisting: forwardRef(() => ColumnComponent_1) // tslint:disable-line:no-forward-ref\n\n  }]), ɵngcc0.ɵɵInheritDefinitionFeature],\n  decls: 0,\n  vars: 0,\n  template: function ColumnComponent_Template(rf, ctx) {},\n  encapsulation: 2\n});\n\n__decorate([Input(), __metadata(\"design:type\", String)], ColumnComponent.prototype, \"field\", void 0);\n\n__decorate([Input(), __metadata(\"design:type\", Object)], ColumnComponent.prototype, \"cellOptions\", void 0);\n\n__decorate([Input(), __metadata(\"design:type\", Object)], ColumnComponent.prototype, \"groupHeaderCellOptions\", void 0);\n\n__decorate([Input(), __metadata(\"design:type\", Object)], ColumnComponent.prototype, \"groupFooterCellOptions\", void 0);\n\n__decorate([Input(), __metadata(\"design:type\", Object)], ColumnComponent.prototype, \"footerCellOptions\", void 0);\n\n__decorate([ContentChild(GroupHeaderTemplateDirective, {\n  static: false\n}), __metadata(\"design:type\", GroupHeaderTemplateDirective)], ColumnComponent.prototype, \"groupHeaderTemplate\", void 0);\n\n__decorate([ContentChild(GroupHeaderColumnTemplateDirective, {\n  static: false\n}), __metadata(\"design:type\", GroupHeaderColumnTemplateDirective)], ColumnComponent.prototype, \"groupHeaderColumnTemplate\", void 0);\n\n__decorate([ContentChild(GroupFooterTemplateDirective, {\n  static: false\n}), __metadata(\"design:type\", GroupFooterTemplateDirective)], ColumnComponent.prototype, \"groupFooterTemplate\", void 0);\n\n__decorate([ContentChild(FooterTemplateDirective, {\n  static: false\n}), __metadata(\"design:type\", FooterTemplateDirective)], ColumnComponent.prototype, \"footerTemplate\", void 0);\n\nColumnComponent = ColumnComponent_1 = __decorate([__param(0, SkipSelf()), __param(0, Host()), __param(0, Optional()), __metadata(\"design:paramtypes\", [ColumnBase])], ColumnComponent);\nvar ColumnGroupComponent_1;\n/**\n * Represents the column group component of the Kendo UI Excel Export component.\n */\n\nlet ColumnGroupComponent = ColumnGroupComponent_1 = class ColumnGroupComponent extends ColumnBase {\n  constructor(parent) {\n    super(parent);\n    this.parent = parent;\n  }\n\n};\n\nColumnGroupComponent.ɵfac = function ColumnGroupComponent_Factory(t) {\n  return new (t || ColumnGroupComponent)(ɵngcc0.ɵɵdirectiveInject(ColumnBase, 13));\n};\n\nColumnGroupComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n  type: ColumnGroupComponent,\n  selectors: [[\"kendo-excelexport-column-group\"]],\n  features: [ɵngcc0.ɵɵProvidersFeature([{\n    provide: ColumnBase,\n    useExisting: forwardRef(() => ColumnGroupComponent_1) // tslint:disable-line:no-forward-ref\n\n  }]), ɵngcc0.ɵɵInheritDefinitionFeature],\n  decls: 0,\n  vars: 0,\n  template: function ColumnGroupComponent_Template(rf, ctx) {},\n  encapsulation: 2\n});\nColumnGroupComponent = ColumnGroupComponent_1 = __decorate([__param(0, SkipSelf()), __param(0, Host()), __param(0, Optional()), __metadata(\"design:paramtypes\", [ColumnBase])], ColumnGroupComponent);\nconst declarations = [ExcelExportComponent, ColumnComponent, ColumnGroupComponent, FooterTemplateDirective, GroupFooterTemplateDirective, GroupHeaderTemplateDirective, GroupHeaderColumnTemplateDirective];\n/**\n * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})\n * definition for the Excel Export component.\n *\n * @example\n *\n * ```ts-no-run\n * // Import the ExcelExportModule module\n * import { ExcelExportModule } from '@progress/kendo-angular-excel-export';\n *\n * // The browser platform with a compiler\n * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n *\n * import { NgModule } from '@angular/core';\n *\n * // Import the app component\n * import { AppComponent } from './app.component';\n *\n * // Define the app module\n * _@NgModule({\n *     declarations: [AppComponent], // declare app component\n *     imports:      [BrowserModule, ExcelExportModule], // import ExcelExportModule module\n *     bootstrap:    [AppComponent]\n * })\n * export class AppModule {}\n *\n * // Compile and launch the module\n * platformBrowserDynamic().bootstrapModule(AppModule);\n *\n * ```\n */\n\nlet ExcelExportModule = class ExcelExportModule {};\n\nExcelExportModule.ɵfac = function ExcelExportModule_Factory(t) {\n  return new (t || ExcelExportModule)();\n};\n\nExcelExportModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n  type: ExcelExportModule\n});\nExcelExportModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(ExcelExportModule, {\n    declarations: [ExcelExportComponent, ColumnComponent, ColumnGroupComponent, FooterTemplateDirective, GroupFooterTemplateDirective, GroupHeaderTemplateDirective, GroupHeaderColumnTemplateDirective],\n    exports: [ExcelExportComponent, ColumnComponent, ColumnGroupComponent, FooterTemplateDirective, GroupFooterTemplateDirective, GroupHeaderTemplateDirective, GroupHeaderColumnTemplateDirective]\n  });\n})();\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { GroupHeaderColumnTemplateDirective, ExcelExportComponent, ExcelExportModule, ColumnBase, ColumnComponent, ColumnGroupComponent, FooterTemplateDirective, GroupFooterTemplateDirective, GroupHeaderTemplateDirective, workbookOptions, toDataURL, isWorkbookOptions }; //# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VzIjpbImluZGV4LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OzttSUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OzttSEFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQWFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztpTEFBRTtBQUNGLDJDQUlHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzttTUFBRTtBQUNGLGlEQUlHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O2lMQUFFO0FBQ0YsMkNBSUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7a0tBQUU7QUFDRixzQ0FJRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7O2lKQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBV0c7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztzSkFBRTtBQUNGLDREQVdHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Z2dCQU1zQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzQ29udGVudCI6WyIvKiotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuKiBDb3B5cmlnaHQgwqkgMjAyMCBQcm9ncmVzcyBTb2Z0d2FyZSBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiogTGljZW5zZWQgdW5kZXIgY29tbWVyY2lhbCBsaWNlbnNlLiBTZWUgTElDRU5TRS5tZCBpbiB0aGUgcHJvamVjdCByb290IGZvciBtb3JlIGluZm9ybWF0aW9uXG4qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5pbXBvcnQgeyBfX2RlY29yYXRlLCBfX21ldGFkYXRhLCBfX3BhcmFtIH0gZnJvbSAndHNsaWInO1xuaW1wb3J0IHsgSW5wdXQsIENvbnRlbnRDaGlsZHJlbiwgUXVlcnlMaXN0LCBDb21wb25lbnQsIE5nWm9uZSwgRGlyZWN0aXZlLCBPcHRpb25hbCwgVGVtcGxhdGVSZWYsIENvbnRlbnRDaGlsZCwgZm9yd2FyZFJlZiwgU2tpcFNlbGYsIEhvc3QsIE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBzYXZlQXMgfSBmcm9tICdAcHJvZ3Jlc3Mva2VuZG8tZmlsZS1zYXZlcic7XG5pbXBvcnQgeyBJbnRsU2VydmljZSwgRXhjZWxFeHBvcnRlciwgV29ya2Jvb2sgfSBmcm9tICdAcHJvZ3Jlc3Mva2VuZG8tb294bWwnO1xuZXhwb3J0ICogZnJvbSAnQHByb2dyZXNzL2tlbmRvLW9veG1sJztcbmltcG9ydCB7IHRvU3RyaW5nIH0gZnJvbSAnQHRlbGVyaWsva2VuZG8taW50bCc7XG5pbXBvcnQgeyBMb2NhbGl6YXRpb25TZXJ2aWNlLCBMMTBOX1BSRUZJWCB9IGZyb20gJ0Bwcm9ncmVzcy9rZW5kby1hbmd1bGFyLWwxMG4nO1xuaW1wb3J0IHsgdmFsaWRhdGVQYWNrYWdlIH0gZnJvbSAnQHByb2dyZXNzL2tlbmRvLWxpY2Vuc2luZyc7XG5cbi8qIHRzbGludDpkaXNhYmxlIGFsaWduICovXG4vKiB0c2xpbnQ6ZGlzYWJsZTpuby11c2UtYmVmb3JlLWRlY2xhcmUgKi9cbmNvbnN0IGNvbXBpbGVUZW1wbGF0ZSA9ICh0ZW1wbGF0ZVJlZiwgY29udGV4dCwgdXBkYXRlQ29udGV4dCkgPT4ge1xuICAgIGxldCBlbWJlZGRlZFZpZXcgPSB0ZW1wbGF0ZVJlZi5jcmVhdGVFbWJlZGRlZFZpZXcoY29udGV4dCk7XG4gICAgY29uc3QgcmVzdWx0ID0gKGRhdGEpID0+IHtcbiAgICAgICAgdXBkYXRlQ29udGV4dChjb250ZXh0LCBkYXRhKTtcbiAgICAgICAgZW1iZWRkZWRWaWV3LmRldGVjdENoYW5nZXMoKTtcbiAgICAgICAgcmV0dXJuIGVtYmVkZGVkVmlldy5yb290Tm9kZXMucmVkdWNlKChjb250ZW50LCByb290Tm9kZSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRlbnQgKyByb290Tm9kZS50ZXh0Q29udGVudDtcbiAgICAgICAgfSwgJycpLnRyaW0oKTtcbiAgICB9O1xuICAgIHJlc3VsdC5kZXN0cm95ID0gKCkgPT4ge1xuICAgICAgICBlbWJlZGRlZFZpZXcuZGVzdHJveSgpO1xuICAgICAgICBlbWJlZGRlZFZpZXcgPSBudWxsO1xuICAgIH07XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5jb25zdCB1cGRhdGVHcm91cEhlYWRlckNvbnRleHQgPSAoY29udGV4dCwgZGF0YSkgPT4ge1xuICAgIGNvbnRleHQuJGltcGxpY2l0ID0gY29udGV4dC5ncm91cCA9IGRhdGE7XG4gICAgY29udGV4dC5maWVsZCA9IGRhdGEuZmllbGQ7XG4gICAgY29udGV4dC52YWx1ZSA9IGRhdGEudmFsdWU7XG4gICAgY29udGV4dC5hZ2dyZWdhdGVzID0gZGF0YS5hZ2dyZWdhdGVzO1xufTtcbmNvbnN0IHVwZGF0ZUdyb3VwRm9vdGVyQ29udGV4dCA9IChjb250ZXh0LCBkYXRhKSA9PiB7XG4gICAgY29udGV4dC5ncm91cCA9IGRhdGEuZ3JvdXA7XG4gICAgY29udGV4dC4kaW1wbGljaXQgPSBjb250ZXh0LmFnZ3JlZ2F0ZXMgPSBkYXRhO1xufTtcbmNvbnN0IHVwZGF0ZUZvb3RlckNvbnRleHQgPSAoY29udGV4dCwgZGF0YSkgPT4ge1xuICAgIGNvbnRleHQuYWdncmVnYXRlcyA9IGRhdGEuYWdncmVnYXRlcztcbn07XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgdG9FeHBvcnRlckNvbHVtbnMgPSAoc291cmNlQ29sdW1ucykgPT4ge1xuICAgIGNvbnN0IGV4cG9ydGVyQ29sdW1ucyA9IFtdO1xuICAgIGxldCBjb2x1bW5JbmRleCA9IDA7XG4gICAgY29uc3QgYWRkQ29sdW1ucyA9IChjb2x1bW5zLCByZXN1bHQsIGxldmVsKSA9PiB7XG4gICAgICAgIGNvbHVtbnMuZm9yRWFjaCgoY29sdW1uKSA9PiB7XG4gICAgICAgICAgICBpZiAoY29sdW1uLmxldmVsID09PSBsZXZlbCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGV4cG9ydGVyQ29sdW1uID0gbmV3IEV4cG9ydGVyQ29sdW1uKGNvbHVtbiwgY29sdW1uSW5kZXgpO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGV4cG9ydGVyQ29sdW1uKTtcbiAgICAgICAgICAgICAgICBpZiAoY29sdW1uLmNoaWxkcmVuICYmIGNvbHVtbi5jaGlsZHJlbi5zb21lKGMgPT4gYyAhPT0gY29sdW1uKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjaGlsZHJlbiA9IGV4cG9ydGVyQ29sdW1uLmNvbHVtbnMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgYWRkQ29sdW1ucyhjb2x1bW4uY2hpbGRyZW4sIGNoaWxkcmVuLCBsZXZlbCArIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uSW5kZXgrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgYWRkQ29sdW1ucyhzb3VyY2VDb2x1bW5zLCBleHBvcnRlckNvbHVtbnMsIDApO1xuICAgIHJldHVybiBleHBvcnRlckNvbHVtbnM7XG59O1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGRlc3Ryb3lDb2x1bW5zID0gKGNvbHVtbnMpID0+IHtcbiAgICBpZiAoY29sdW1ucykge1xuICAgICAgICBjb2x1bW5zLmZvckVhY2goY29sdW1uID0+IHtcbiAgICAgICAgICAgIGNvbHVtbi5kZXN0cm95KCk7XG4gICAgICAgIH0pO1xuICAgIH1cbn07XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgRXhwb3J0ZXJDb2x1bW4ge1xuICAgIGNvbnN0cnVjdG9yKGNvbHVtbiwgY29sdW1uSW5kZXgpIHtcbiAgICAgICAgdGhpcy50aXRsZSA9IGNvbHVtbi50aXRsZTtcbiAgICAgICAgdGhpcy5maWVsZCA9IGNvbHVtbi5maWVsZDtcbiAgICAgICAgdGhpcy5oaWRkZW4gPSBjb2x1bW4uaGlkZGVuO1xuICAgICAgICB0aGlzLmxvY2tlZCA9IGNvbHVtbi5sb2NrZWQ7XG4gICAgICAgIHRoaXMud2lkdGggPSBjb2x1bW4ud2lkdGg7XG4gICAgICAgIHRoaXMuaGVhZGVyQ2VsbE9wdGlvbnMgPSBjb2x1bW4uaGVhZGVyQ2VsbE9wdGlvbnM7XG4gICAgICAgIHRoaXMuY2VsbE9wdGlvbnMgPSBjb2x1bW4uY2VsbE9wdGlvbnM7XG4gICAgICAgIHRoaXMuZ3JvdXBIZWFkZXJDZWxsT3B0aW9ucyA9IGNvbHVtbi5ncm91cEhlYWRlckNlbGxPcHRpb25zO1xuICAgICAgICB0aGlzLmdyb3VwRm9vdGVyQ2VsbE9wdGlvbnMgPSBjb2x1bW4uZ3JvdXBGb290ZXJDZWxsT3B0aW9ucztcbiAgICAgICAgdGhpcy5mb290ZXJDZWxsT3B0aW9ucyA9IGNvbHVtbi5mb290ZXJDZWxsT3B0aW9ucztcbiAgICAgICAgaWYgKGNvbHVtbi5mb290ZXJUZW1wbGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5mb290ZXJUZW1wbGF0ZSA9IGNvbXBpbGVUZW1wbGF0ZShjb2x1bW4uZm9vdGVyVGVtcGxhdGUudGVtcGxhdGVSZWYsIHtcbiAgICAgICAgICAgICAgICAkaW1wbGljaXQ6IGNvbHVtbixcbiAgICAgICAgICAgICAgICBjb2x1bW46IGNvbHVtbixcbiAgICAgICAgICAgICAgICBjb2x1bW5JbmRleDogY29sdW1uSW5kZXhcbiAgICAgICAgICAgIH0sIHVwZGF0ZUZvb3RlckNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb2x1bW4uZ3JvdXBGb290ZXJUZW1wbGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5ncm91cEZvb3RlclRlbXBsYXRlID0gY29tcGlsZVRlbXBsYXRlKGNvbHVtbi5ncm91cEZvb3RlclRlbXBsYXRlLnRlbXBsYXRlUmVmLCB7XG4gICAgICAgICAgICAgICAgY29sdW1uOiBjb2x1bW4sXG4gICAgICAgICAgICAgICAgZmllbGQ6IGNvbHVtbi5maWVsZFxuICAgICAgICAgICAgfSwgdXBkYXRlR3JvdXBGb290ZXJDb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29sdW1uLmdyb3VwSGVhZGVyVGVtcGxhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBIZWFkZXJUZW1wbGF0ZSA9IGNvbXBpbGVUZW1wbGF0ZShjb2x1bW4uZ3JvdXBIZWFkZXJUZW1wbGF0ZS50ZW1wbGF0ZVJlZiwge30sIHVwZGF0ZUdyb3VwSGVhZGVyQ29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbHVtbi5ncm91cEhlYWRlckNvbHVtblRlbXBsYXRlKSB7XG4gICAgICAgICAgICB0aGlzLmdyb3VwSGVhZGVyQ29sdW1uVGVtcGxhdGUgPSBjb21waWxlVGVtcGxhdGUoY29sdW1uLmdyb3VwSGVhZGVyQ29sdW1uVGVtcGxhdGUudGVtcGxhdGVSZWYsIHt9LCB1cGRhdGVHcm91cEhlYWRlckNvbnRleHQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIGlmICh0aGlzLmZvb3RlclRlbXBsYXRlKSB7XG4gICAgICAgICAgICB0aGlzLmZvb3RlclRlbXBsYXRlLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5ncm91cEZvb3RlclRlbXBsYXRlKSB7XG4gICAgICAgICAgICB0aGlzLmdyb3VwRm9vdGVyVGVtcGxhdGUuZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmdyb3VwSGVhZGVyVGVtcGxhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBIZWFkZXJUZW1wbGF0ZS5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZ3JvdXBIZWFkZXJDb2x1bW5UZW1wbGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5ncm91cEhlYWRlckNvbHVtblRlbXBsYXRlLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgICAgICBkZXN0cm95Q29sdW1ucyh0aGlzLmNvbHVtbnMpO1xuICAgIH1cbn1cblxuSW50bFNlcnZpY2UucmVnaXN0ZXIoeyB0b1N0cmluZyB9KTtcbi8qKlxuICpcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3Qgd29ya2Jvb2tPcHRpb25zID0gKG9wdGlvbnMpID0+IHtcbiAgICBjb25zdCBjb2x1bW5zID0gdG9FeHBvcnRlckNvbHVtbnMob3B0aW9ucy5jb2x1bW5zKTtcbiAgICBjb25zdCBleHBvcnRlciA9IG5ldyBFeGNlbEV4cG9ydGVyKHtcbiAgICAgICAgY29sdW1uczogY29sdW1ucyxcbiAgICAgICAgZGF0YTogb3B0aW9ucy5kYXRhLFxuICAgICAgICBmaWx0ZXJhYmxlOiBvcHRpb25zLmZpbHRlcmFibGUsXG4gICAgICAgIGdyb3Vwczogb3B0aW9ucy5ncm91cCxcbiAgICAgICAgcGFkZGluZ0NlbGxPcHRpb25zOiBvcHRpb25zLnBhZGRpbmdDZWxsT3B0aW9ucyxcbiAgICAgICAgaGVhZGVyUGFkZGluZ0NlbGxPcHRpb25zOiBvcHRpb25zLmhlYWRlclBhZGRpbmdDZWxsT3B0aW9ucyxcbiAgICAgICAgY29sbGFwc2libGU6IG9wdGlvbnMuY29sbGFwc2libGUsXG4gICAgICAgIGhpZXJhcmNoeTogb3B0aW9ucy5oaWVyYXJjaHksXG4gICAgICAgIGFnZ3JlZ2F0ZXM6IG9wdGlvbnMuYWdncmVnYXRlc1xuICAgIH0pO1xuICAgIGNvbnN0IHJlc3VsdCA9IGV4cG9ydGVyLndvcmtib29rKCk7XG4gICAgcmVzdWx0LmNyZWF0b3IgPSBvcHRpb25zLmNyZWF0b3I7XG4gICAgcmVzdWx0LmRhdGUgPSBvcHRpb25zLmRhdGU7XG4gICAgcmVzdWx0LnJ0bCA9IG9wdGlvbnMucnRsO1xuICAgIGRlc3Ryb3lDb2x1bW5zKGNvbHVtbnMpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IHRvRGF0YVVSTCA9IChvcHRpb25zKSA9PiB7XG4gICAgY29uc3Qgd29ya2Jvb2sgPSBuZXcgV29ya2Jvb2sob3B0aW9ucyk7XG4gICAgcmV0dXJuIHdvcmtib29rLnRvRGF0YVVSTCgpO1xufTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBpc1dvcmtib29rT3B0aW9ucyA9ICh2YWx1ZSkgPT4ge1xuICAgIHJldHVybiB2YWx1ZSAmJiB2YWx1ZS5zaGVldHM7XG59O1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgQ29sdW1uQmFzZSB7XG4gICAgY29uc3RydWN0b3IocGFyZW50KSB7XG4gICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0IGxldmVsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQgPyB0aGlzLnBhcmVudC5sZXZlbCArIDEgOiAwO1xuICAgIH1cbn1cbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIENvbHVtbkJhc2UucHJvdG90eXBlLCBcInRpdGxlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBDb2x1bW5CYXNlLnByb3RvdHlwZSwgXCJ3aWR0aFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIENvbHVtbkJhc2UucHJvdG90eXBlLCBcImxvY2tlZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIENvbHVtbkJhc2UucHJvdG90eXBlLCBcImhpZGRlblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgQ29sdW1uQmFzZS5wcm90b3R5cGUsIFwiaGVhZGVyQ2VsbE9wdGlvbnNcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIENvbnRlbnRDaGlsZHJlbihDb2x1bW5CYXNlKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgUXVlcnlMaXN0KVxuXSwgQ29sdW1uQmFzZS5wcm90b3R5cGUsIFwiY2hpbGRyZW5cIiwgdm9pZCAwKTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IHBhY2thZ2VNZXRhZGF0YSA9IHtcbiAgICBuYW1lOiAnQHByb2dyZXNzL2tlbmRvLWFuZ3VsYXItZXhjZWwtZXhwb3J0JyxcbiAgICBwcm9kdWN0TmFtZTogJ0tlbmRvIFVJIGZvciBBbmd1bGFyJyxcbiAgICBwcm9kdWN0Q29kZXM6IFsnS0VORE9VSUFOR1VMQVInLCAnS0VORE9VSUNPTVBMRVRFJ10sXG4gICAgcHVibGlzaERhdGU6IDE2MjAyMTM1MjQsXG4gICAgdmVyc2lvbjogJycsXG4gICAgbGljZW5zaW5nRG9jc1VybDogJ2h0dHBzOi8vd3d3LnRlbGVyaWsuY29tL2tlbmRvLWFuZ3VsYXItdWkvbXktbGljZW5zZS8/dXRtX21lZGl1bT1wcm9kdWN0JnV0bV9zb3VyY2U9a2VuZG9hbmd1bGFyJnV0bV9jYW1wYWlnbj1rZW5kby11aS1hbmd1bGFyLXB1cmNoYXNlLWxpY2Vuc2Uta2V5cy13YXJuaW5nJ1xufTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBbS2VuZG8gVUkgRXhjZWwgRXhwb3J0IGNvbXBvbmVudCBmb3IgQW5ndWxhcl0oeyUgc2x1ZyBvdmVydmlld19leGNlbGV4cG9ydCAlfSkuXG4gKiBDb25maWd1cmVzIHRoZSBzZXR0aW5ncyBmb3IgdGhlIEV4Y2VsIGV4cG9ydCBvZiB0aGUgS2VuZG8gVUkgR3JpZC5cbiAqL1xubGV0IEV4Y2VsRXhwb3J0Q29tcG9uZW50ID0gY2xhc3MgRXhjZWxFeHBvcnRDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGxvY2FsaXphdGlvbiwgem9uZSkge1xuICAgICAgICB0aGlzLmxvY2FsaXphdGlvbiA9IGxvY2FsaXphdGlvbjtcbiAgICAgICAgdGhpcy56b25lID0gem9uZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZmllcyB0aGUgbmFtZSBvZiB0aGUgZmlsZSB0aGF0IGlzIGV4cG9ydGVkIHRvIEV4Y2VsLlxuICAgICAgICAgKiBAZGVmYXVsdCBcIkV4cG9ydC54bHN4XCJcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZmlsZU5hbWUgPSAnRXhwb3J0Lnhsc3gnO1xuICAgICAgICAvKipcbiAgICAgICAgICogQGhpZGRlblxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jb2x1bW5zID0gbmV3IFF1ZXJ5TGlzdCgpO1xuICAgICAgICB2YWxpZGF0ZVBhY2thZ2UocGFja2FnZU1ldGFkYXRhKTtcbiAgICAgICAgdGhpcy5zYXZlRmlsZSA9IHRoaXMuc2F2ZUZpbGUuYmluZCh0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2F2ZXMgdGhlIGRhdGEgdG8gRXhjZWwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZXhwb3J0RGF0YSAtIEFuIG9wdGlvbmFsIHBhcmFtZXRlci4gQ2FuIGJlIHRoZSBkYXRhIHRoYXQgd2lsbCBiZSBleHBvcnRlZCBvciBbYFdvcmtib29rT3B0aW9uc2BdKHslIHNsdWcgYXBpX2V4Y2VsLWV4cG9ydF93b3JrYm9va29wdGlvbnMgJX0pLlxuICAgICAqL1xuICAgIHNhdmUoZXhwb3J0RGF0YSkge1xuICAgICAgICB0aGlzLnRvRGF0YVVSTChleHBvcnREYXRhKS50aGVuKHRoaXMuc2F2ZUZpbGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBCYXNlZCBvbiB0aGUgc3BlY2lmaWVkIGNvbHVtbnMgYW5kIGRhdGEsIHJldHVybnNcbiAgICAgKiBbYFdvcmtib29rT3B0aW9uc2BdKHslIHNsdWcgYXBpX2V4Y2VsLWV4cG9ydF93b3JrYm9va29wdGlvbnMgJX0pXG4gICAgICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBjdXN0b21yb3dzYW5kY2VsbHNfZXhjZWxleHBvcnQgJX0pKS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBleHBvcnREYXRhIC0gVGhlIG9wdGlvbmFsIGRhdGEgdG8gYmUgZXhwb3J0ZWQuXG4gICAgICogQHJldHVybnMge1dvcmtib29rT3B0aW9uc30gLSBUaGUgd29ya2Jvb2sgb3B0aW9ucy5cbiAgICAgKi9cbiAgICB3b3JrYm9va09wdGlvbnMoZXhwb3J0RGF0YSkge1xuICAgICAgICBjb25zdCBjdXJyZW50RGF0YSA9IHRoaXMuZ2V0RXhwb3J0RGF0YShleHBvcnREYXRhKTtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHdvcmtib29rT3B0aW9ucyh7XG4gICAgICAgICAgICBjb2x1bW5zOiB0aGlzLmNvbHVtbnMsXG4gICAgICAgICAgICBkYXRhOiBjdXJyZW50RGF0YS5kYXRhLFxuICAgICAgICAgICAgZ3JvdXA6IGN1cnJlbnREYXRhLmdyb3VwLFxuICAgICAgICAgICAgZmlsdGVyYWJsZTogdGhpcy5maWx0ZXJhYmxlLFxuICAgICAgICAgICAgY3JlYXRvcjogdGhpcy5jcmVhdG9yLFxuICAgICAgICAgICAgZGF0ZTogdGhpcy5kYXRlLFxuICAgICAgICAgICAgcnRsOiB0aGlzLmxvY2FsaXphdGlvbi5ydGwsXG4gICAgICAgICAgICBwYWRkaW5nQ2VsbE9wdGlvbnM6IHRoaXMucGFkZGluZ0NlbGxPcHRpb25zLFxuICAgICAgICAgICAgaGVhZGVyUGFkZGluZ0NlbGxPcHRpb25zOiB0aGlzLmhlYWRlclBhZGRpbmdDZWxsT3B0aW9ucyxcbiAgICAgICAgICAgIGNvbGxhcHNpYmxlOiB0aGlzLmNvbGxhcHNpYmxlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gb3B0aW9ucztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHByb21pc2Ugd2hpY2ggd2lsbCBiZSByZXNvbHZlZCB3aXRoIHRoZSBmaWxlIGRhdGEgVVJJXG4gICAgICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBmaWxlc2F2aW5nX2V4Y2VsZXhwb3J0ICV9KSkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZXhwb3J0RGF0YSAtIFRoZSBvcHRpb25hbCBkYXRhIG9yIFtgV29ya2Jvb2tPcHRpb25zYF0oeyUgc2x1ZyBhcGlfZXhjZWwtZXhwb3J0X3dvcmtib29rb3B0aW9ucyAlfSkgdGhhdCB3aWxsIGJlIHVzZWQgdG8gZ2VuZXJhdGUgdGhlIGRhdGEgVVJJLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHN0cmluZz59IC0gVGhlIHByb21pc2UgdGhhdCB3aWxsIGJlIHJlc29sdmVkIGJ5IHRoZSBmaWxlIGRhdGEgVVJJLlxuICAgICAqL1xuICAgIHRvRGF0YVVSTChleHBvcnREYXRhKSB7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBpc1dvcmtib29rT3B0aW9ucyhleHBvcnREYXRhKSA/XG4gICAgICAgICAgICBleHBvcnREYXRhIDpcbiAgICAgICAgICAgIHRoaXMud29ya2Jvb2tPcHRpb25zKGV4cG9ydERhdGEpO1xuICAgICAgICByZXR1cm4gdGhpcy56b25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHRvRGF0YVVSTChvcHRpb25zKSk7XG4gICAgfVxuICAgIGdldEV4cG9ydERhdGEoZXhwb3J0RGF0YSkge1xuICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICBpZiAoZXhwb3J0RGF0YSkge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZXhwb3J0RGF0YSkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGV4cG9ydERhdGFcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gZXhwb3J0RGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgICAgICAgICBkYXRhOiB0aGlzLmRhdGEsXG4gICAgICAgICAgICAgICAgZ3JvdXA6IHRoaXMuZ3JvdXBcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgc2F2ZUZpbGUoZGF0YVVSTCkge1xuICAgICAgICBzYXZlQXMoZGF0YVVSTCwgdGhpcy5maWxlTmFtZSwge1xuICAgICAgICAgICAgZm9yY2VQcm94eTogdGhpcy5mb3JjZVByb3h5LFxuICAgICAgICAgICAgcHJveHlVUkw6IHRoaXMucHJveHlVUkxcbiAgICAgICAgfSk7XG4gICAgfVxufTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIEV4Y2VsRXhwb3J0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJmaWxlTmFtZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIEV4Y2VsRXhwb3J0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJmaWx0ZXJhYmxlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgRXhjZWxFeHBvcnRDb21wb25lbnQucHJvdG90eXBlLCBcImNvbGxhcHNpYmxlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBFeGNlbEV4cG9ydENvbXBvbmVudC5wcm90b3R5cGUsIFwiY3JlYXRvclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRGF0ZSlcbl0sIEV4Y2VsRXhwb3J0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJkYXRlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgRXhjZWxFeHBvcnRDb21wb25lbnQucHJvdG90eXBlLCBcImZvcmNlUHJveHlcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIEV4Y2VsRXhwb3J0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJwcm94eVVSTFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpXG5dLCBFeGNlbEV4cG9ydENvbXBvbmVudC5wcm90b3R5cGUsIFwiZGF0YVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpXG5dLCBFeGNlbEV4cG9ydENvbXBvbmVudC5wcm90b3R5cGUsIFwiZ3JvdXBcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIEV4Y2VsRXhwb3J0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJwYWRkaW5nQ2VsbE9wdGlvbnNcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIEV4Y2VsRXhwb3J0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJoZWFkZXJQYWRkaW5nQ2VsbE9wdGlvbnNcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIENvbnRlbnRDaGlsZHJlbihDb2x1bW5CYXNlLCB7IGRlc2NlbmRhbnRzOiB0cnVlIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBRdWVyeUxpc3QpXG5dLCBFeGNlbEV4cG9ydENvbXBvbmVudC5wcm90b3R5cGUsIFwiY29sdW1uc1wiLCB2b2lkIDApO1xuRXhjZWxFeHBvcnRDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBleHBvcnRBczogJ2tlbmRvRXhjZWxFeHBvcnQnLFxuICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLWV4Y2VsZXhwb3J0JyxcbiAgICAgICAgcHJvdmlkZXJzOiBbXG4gICAgICAgICAgICBMb2NhbGl6YXRpb25TZXJ2aWNlLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHByb3ZpZGU6IEwxME5fUFJFRklYLFxuICAgICAgICAgICAgICAgIHVzZVZhbHVlOiAna2VuZG8uZXhjZWxleHBvcnQnXG4gICAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIHRlbXBsYXRlOiBgYFxuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbTG9jYWxpemF0aW9uU2VydmljZSwgTmdab25lXSlcbl0sIEV4Y2VsRXhwb3J0Q29tcG9uZW50KTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBncm91cCBoZWFkZXIgY2VsbCB0ZW1wbGF0ZSBvZiB0aGUgRXhjZWwgRXhwb3J0IGNvbHVtbiBjb21wb25lbnRcbiAqIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgY29sdW1uc19leGNlbC1leHBvcnQgJX0jdG9jLWdyb3VwLWhlYWRlci10ZW1wbGF0ZSkpLlxuICogRW5hYmxlcyB5b3UgdG8gY3VzdG9taXplIHRoZSBjb250ZW50IG9mIHRoZSBncm91cCBoZWFkZXIgaXRlbS5cbiAqL1xubGV0IEdyb3VwSGVhZGVyVGVtcGxhdGVEaXJlY3RpdmUgPSBjbGFzcyBHcm91cEhlYWRlclRlbXBsYXRlRGlyZWN0aXZlIHtcbiAgICBjb25zdHJ1Y3Rvcih0ZW1wbGF0ZVJlZikge1xuICAgICAgICB0aGlzLnRlbXBsYXRlUmVmID0gdGVtcGxhdGVSZWY7XG4gICAgfVxufTtcbkdyb3VwSGVhZGVyVGVtcGxhdGVEaXJlY3RpdmUgPSBfX2RlY29yYXRlKFtcbiAgICBEaXJlY3RpdmUoe1xuICAgICAgICBzZWxlY3RvcjogJ1trZW5kb0V4Y2VsRXhwb3J0R3JvdXBIZWFkZXJUZW1wbGF0ZV0nXG4gICAgfSksXG4gICAgX19wYXJhbSgwLCBPcHRpb25hbCgpKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW1RlbXBsYXRlUmVmXSlcbl0sIEdyb3VwSGVhZGVyVGVtcGxhdGVEaXJlY3RpdmUpO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIGdyb3VwIGhlYWRlciBjb2x1bW4gdGVtcGxhdGUgb2YgdGhlIEV4Y2VsIEV4cG9ydCBjb2x1bW4gY29tcG9uZW50XG4gKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGNvbHVtbnNfZXhjZWwtZXhwb3J0ICV9I3RvYy1ncm91cC1oZWFkZXItY29sdW1uLXRlbXBsYXRlKSkuXG4gKi9cbmxldCBHcm91cEhlYWRlckNvbHVtblRlbXBsYXRlRGlyZWN0aXZlID0gY2xhc3MgR3JvdXBIZWFkZXJDb2x1bW5UZW1wbGF0ZURpcmVjdGl2ZSB7XG4gICAgY29uc3RydWN0b3IodGVtcGxhdGVSZWYpIHtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZVJlZiA9IHRlbXBsYXRlUmVmO1xuICAgIH1cbn07XG5Hcm91cEhlYWRlckNvbHVtblRlbXBsYXRlRGlyZWN0aXZlID0gX19kZWNvcmF0ZShbXG4gICAgRGlyZWN0aXZlKHtcbiAgICAgICAgc2VsZWN0b3I6ICdba2VuZG9FeGNlbEV4cG9ydEdyb3VwSGVhZGVyQ29sdW1uVGVtcGxhdGVdJ1xuICAgIH0pLFxuICAgIF9fcGFyYW0oMCwgT3B0aW9uYWwoKSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtUZW1wbGF0ZVJlZl0pXG5dLCBHcm91cEhlYWRlckNvbHVtblRlbXBsYXRlRGlyZWN0aXZlKTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBncm91cCBmb290ZXIgY2VsbCB0ZW1wbGF0ZSBvZiB0aGUgRXhjZWwgRXhwb3J0IGNvbHVtbiBjb21wb25lbnRcbiAqIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgY29sdW1uc19leGNlbC1leHBvcnQgJX0jdG9jLWdyb3VwLWZvb3Rlci10ZW1wbGF0ZSkpLlxuICogRW5hYmxlcyB5b3UgdG8gY3VzdG9taXplIHRoZSBncm91cCBmb290ZXIgY2VsbCBvZiB0aGUgY29sdW1uLlxuICovXG5sZXQgR3JvdXBGb290ZXJUZW1wbGF0ZURpcmVjdGl2ZSA9IGNsYXNzIEdyb3VwRm9vdGVyVGVtcGxhdGVEaXJlY3RpdmUge1xuICAgIGNvbnN0cnVjdG9yKHRlbXBsYXRlUmVmKSB7XG4gICAgICAgIHRoaXMudGVtcGxhdGVSZWYgPSB0ZW1wbGF0ZVJlZjtcbiAgICB9XG59O1xuR3JvdXBGb290ZXJUZW1wbGF0ZURpcmVjdGl2ZSA9IF9fZGVjb3JhdGUoW1xuICAgIERpcmVjdGl2ZSh7XG4gICAgICAgIHNlbGVjdG9yOiAnW2tlbmRvRXhjZWxFeHBvcnRHcm91cEZvb3RlclRlbXBsYXRlXSdcbiAgICB9KSxcbiAgICBfX3BhcmFtKDAsIE9wdGlvbmFsKCkpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbVGVtcGxhdGVSZWZdKVxuXSwgR3JvdXBGb290ZXJUZW1wbGF0ZURpcmVjdGl2ZSk7XG5cbi8qKlxuICogUmVwcmVzZW50cyB0aGUgZm9vdGVyIGNlbGwgdGVtcGxhdGUgb2YgdGhlIEV4Y2VsIEV4cG9ydCBjb2x1bW4gY29tcG9uZW50XG4gKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGNvbHVtbnNfZXhjZWwtZXhwb3J0ICV9I3RvYy1mb290ZXItdGVtcGxhdGUpKS5cbiAqIEVuYWJsZXMgeW91IHRvIGN1c3RvbWl6ZSB0aGUgZm9vdGVyIGNlbGwgb2YgdGhlIGNvbHVtbi5cbiAqL1xubGV0IEZvb3RlclRlbXBsYXRlRGlyZWN0aXZlID0gY2xhc3MgRm9vdGVyVGVtcGxhdGVEaXJlY3RpdmUge1xuICAgIGNvbnN0cnVjdG9yKHRlbXBsYXRlUmVmKSB7XG4gICAgICAgIHRoaXMudGVtcGxhdGVSZWYgPSB0ZW1wbGF0ZVJlZjtcbiAgICB9XG59O1xuRm9vdGVyVGVtcGxhdGVEaXJlY3RpdmUgPSBfX2RlY29yYXRlKFtcbiAgICBEaXJlY3RpdmUoe1xuICAgICAgICBzZWxlY3RvcjogJ1trZW5kb0V4Y2VsRXhwb3J0Rm9vdGVyVGVtcGxhdGVdJ1xuICAgIH0pLFxuICAgIF9fcGFyYW0oMCwgT3B0aW9uYWwoKSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtUZW1wbGF0ZVJlZl0pXG5dLCBGb290ZXJUZW1wbGF0ZURpcmVjdGl2ZSk7XG5cbnZhciBDb2x1bW5Db21wb25lbnRfMTtcbi8qKlxuICogUmVwcmVzZW50cyB0aGUgY29sdW1ucyBvZiB0aGUgS2VuZG8gVUkgRXhjZWwgRXhwb3J0IGNvbXBvbmVudCBmb3IgQW5ndWxhci5cbiAqL1xubGV0IENvbHVtbkNvbXBvbmVudCA9IENvbHVtbkNvbXBvbmVudF8xID0gY2xhc3MgQ29sdW1uQ29tcG9uZW50IGV4dGVuZHMgQ29sdW1uQmFzZSB7XG4gICAgY29uc3RydWN0b3IocGFyZW50KSB7XG4gICAgICAgIHN1cGVyKHBhcmVudCk7XG4gICAgfVxufTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIENvbHVtbkNvbXBvbmVudC5wcm90b3R5cGUsIFwiZmllbGRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIENvbHVtbkNvbXBvbmVudC5wcm90b3R5cGUsIFwiY2VsbE9wdGlvbnNcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIENvbHVtbkNvbXBvbmVudC5wcm90b3R5cGUsIFwiZ3JvdXBIZWFkZXJDZWxsT3B0aW9uc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgQ29sdW1uQ29tcG9uZW50LnByb3RvdHlwZSwgXCJncm91cEZvb3RlckNlbGxPcHRpb25zXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBDb2x1bW5Db21wb25lbnQucHJvdG90eXBlLCBcImZvb3RlckNlbGxPcHRpb25zXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBDb250ZW50Q2hpbGQoR3JvdXBIZWFkZXJUZW1wbGF0ZURpcmVjdGl2ZSwgeyBzdGF0aWM6IGZhbHNlIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBHcm91cEhlYWRlclRlbXBsYXRlRGlyZWN0aXZlKVxuXSwgQ29sdW1uQ29tcG9uZW50LnByb3RvdHlwZSwgXCJncm91cEhlYWRlclRlbXBsYXRlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBDb250ZW50Q2hpbGQoR3JvdXBIZWFkZXJDb2x1bW5UZW1wbGF0ZURpcmVjdGl2ZSwgeyBzdGF0aWM6IGZhbHNlIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBHcm91cEhlYWRlckNvbHVtblRlbXBsYXRlRGlyZWN0aXZlKVxuXSwgQ29sdW1uQ29tcG9uZW50LnByb3RvdHlwZSwgXCJncm91cEhlYWRlckNvbHVtblRlbXBsYXRlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBDb250ZW50Q2hpbGQoR3JvdXBGb290ZXJUZW1wbGF0ZURpcmVjdGl2ZSwgeyBzdGF0aWM6IGZhbHNlIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBHcm91cEZvb3RlclRlbXBsYXRlRGlyZWN0aXZlKVxuXSwgQ29sdW1uQ29tcG9uZW50LnByb3RvdHlwZSwgXCJncm91cEZvb3RlclRlbXBsYXRlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBDb250ZW50Q2hpbGQoRm9vdGVyVGVtcGxhdGVEaXJlY3RpdmUsIHsgc3RhdGljOiBmYWxzZSB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRm9vdGVyVGVtcGxhdGVEaXJlY3RpdmUpXG5dLCBDb2x1bW5Db21wb25lbnQucHJvdG90eXBlLCBcImZvb3RlclRlbXBsYXRlXCIsIHZvaWQgMCk7XG5Db2x1bW5Db21wb25lbnQgPSBDb2x1bW5Db21wb25lbnRfMSA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHByb3ZpZGU6IENvbHVtbkJhc2UsXG4gICAgICAgICAgICAgICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gQ29sdW1uQ29tcG9uZW50XzEpIC8vIHRzbGludDpkaXNhYmxlLWxpbmU6bm8tZm9yd2FyZC1yZWZcbiAgICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1leGNlbGV4cG9ydC1jb2x1bW4nLFxuICAgICAgICB0ZW1wbGF0ZTogYGBcbiAgICB9KSxcbiAgICBfX3BhcmFtKDAsIFNraXBTZWxmKCkpLCBfX3BhcmFtKDAsIEhvc3QoKSksIF9fcGFyYW0oMCwgT3B0aW9uYWwoKSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtDb2x1bW5CYXNlXSlcbl0sIENvbHVtbkNvbXBvbmVudCk7XG5cbnZhciBDb2x1bW5Hcm91cENvbXBvbmVudF8xO1xuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBjb2x1bW4gZ3JvdXAgY29tcG9uZW50IG9mIHRoZSBLZW5kbyBVSSBFeGNlbCBFeHBvcnQgY29tcG9uZW50LlxuICovXG5sZXQgQ29sdW1uR3JvdXBDb21wb25lbnQgPSBDb2x1bW5Hcm91cENvbXBvbmVudF8xID0gY2xhc3MgQ29sdW1uR3JvdXBDb21wb25lbnQgZXh0ZW5kcyBDb2x1bW5CYXNlIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJlbnQpIHtcbiAgICAgICAgc3VwZXIocGFyZW50KTtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgfVxufTtcbkNvbHVtbkdyb3VwQ29tcG9uZW50ID0gQ29sdW1uR3JvdXBDb21wb25lbnRfMSA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHByb3ZpZGU6IENvbHVtbkJhc2UsXG4gICAgICAgICAgICAgICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gQ29sdW1uR3JvdXBDb21wb25lbnRfMSkgLy8gdHNsaW50OmRpc2FibGUtbGluZTpuby1mb3J3YXJkLXJlZlxuICAgICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLWV4Y2VsZXhwb3J0LWNvbHVtbi1ncm91cCcsXG4gICAgICAgIHRlbXBsYXRlOiBgYFxuICAgIH0pLFxuICAgIF9fcGFyYW0oMCwgU2tpcFNlbGYoKSksIF9fcGFyYW0oMCwgSG9zdCgpKSwgX19wYXJhbSgwLCBPcHRpb25hbCgpKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0NvbHVtbkJhc2VdKVxuXSwgQ29sdW1uR3JvdXBDb21wb25lbnQpO1xuXG5jb25zdCBkZWNsYXJhdGlvbnMgPSBbXG4gICAgRXhjZWxFeHBvcnRDb21wb25lbnQsXG4gICAgQ29sdW1uQ29tcG9uZW50LFxuICAgIENvbHVtbkdyb3VwQ29tcG9uZW50LFxuICAgIEZvb3RlclRlbXBsYXRlRGlyZWN0aXZlLFxuICAgIEdyb3VwRm9vdGVyVGVtcGxhdGVEaXJlY3RpdmUsXG4gICAgR3JvdXBIZWFkZXJUZW1wbGF0ZURpcmVjdGl2ZSxcbiAgICBHcm91cEhlYWRlckNvbHVtblRlbXBsYXRlRGlyZWN0aXZlXG5dO1xuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBbTmdNb2R1bGVdKHt7IHNpdGUuZGF0YS51cmxzLmFuZ3VsYXJbJ25nbW9kdWxlYXBpJ10gfX0pXG4gKiBkZWZpbml0aW9uIGZvciB0aGUgRXhjZWwgRXhwb3J0IGNvbXBvbmVudC5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYHRzLW5vLXJ1blxuICogLy8gSW1wb3J0IHRoZSBFeGNlbEV4cG9ydE1vZHVsZSBtb2R1bGVcbiAqIGltcG9ydCB7IEV4Y2VsRXhwb3J0TW9kdWxlIH0gZnJvbSAnQHByb2dyZXNzL2tlbmRvLWFuZ3VsYXItZXhjZWwtZXhwb3J0JztcbiAqXG4gKiAvLyBUaGUgYnJvd3NlciBwbGF0Zm9ybSB3aXRoIGEgY29tcGlsZXJcbiAqIGltcG9ydCB7IHBsYXRmb3JtQnJvd3NlckR5bmFtaWMgfSBmcm9tICdAYW5ndWxhci9wbGF0Zm9ybS1icm93c2VyLWR5bmFtaWMnO1xuICpcbiAqIGltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG4gKlxuICogLy8gSW1wb3J0IHRoZSBhcHAgY29tcG9uZW50XG4gKiBpbXBvcnQgeyBBcHBDb21wb25lbnQgfSBmcm9tICcuL2FwcC5jb21wb25lbnQnO1xuICpcbiAqIC8vIERlZmluZSB0aGUgYXBwIG1vZHVsZVxuICogX0BOZ01vZHVsZSh7XG4gKiAgICAgZGVjbGFyYXRpb25zOiBbQXBwQ29tcG9uZW50XSwgLy8gZGVjbGFyZSBhcHAgY29tcG9uZW50XG4gKiAgICAgaW1wb3J0czogICAgICBbQnJvd3Nlck1vZHVsZSwgRXhjZWxFeHBvcnRNb2R1bGVdLCAvLyBpbXBvcnQgRXhjZWxFeHBvcnRNb2R1bGUgbW9kdWxlXG4gKiAgICAgYm9vdHN0cmFwOiAgICBbQXBwQ29tcG9uZW50XVxuICogfSlcbiAqIGV4cG9ydCBjbGFzcyBBcHBNb2R1bGUge31cbiAqXG4gKiAvLyBDb21waWxlIGFuZCBsYXVuY2ggdGhlIG1vZHVsZVxuICogcGxhdGZvcm1Ccm93c2VyRHluYW1pYygpLmJvb3RzdHJhcE1vZHVsZShBcHBNb2R1bGUpO1xuICpcbiAqIGBgYFxuICovXG5sZXQgRXhjZWxFeHBvcnRNb2R1bGUgPSBjbGFzcyBFeGNlbEV4cG9ydE1vZHVsZSB7XG59O1xuRXhjZWxFeHBvcnRNb2R1bGUgPSBfX2RlY29yYXRlKFtcbiAgICBOZ01vZHVsZSh7XG4gICAgICAgIGRlY2xhcmF0aW9uczogW2RlY2xhcmF0aW9uc10sXG4gICAgICAgIGV4cG9ydHM6IFtkZWNsYXJhdGlvbnNdXG4gICAgfSlcbl0sIEV4Y2VsRXhwb3J0TW9kdWxlKTtcblxuLyoqXG4gKiBHZW5lcmF0ZWQgYnVuZGxlIGluZGV4LiBEbyBub3QgZWRpdC5cbiAqL1xuXG5leHBvcnQgeyBHcm91cEhlYWRlckNvbHVtblRlbXBsYXRlRGlyZWN0aXZlLCBFeGNlbEV4cG9ydENvbXBvbmVudCwgRXhjZWxFeHBvcnRNb2R1bGUsIENvbHVtbkJhc2UsIENvbHVtbkNvbXBvbmVudCwgQ29sdW1uR3JvdXBDb21wb25lbnQsIEZvb3RlclRlbXBsYXRlRGlyZWN0aXZlLCBHcm91cEZvb3RlclRlbXBsYXRlRGlyZWN0aXZlLCBHcm91cEhlYWRlclRlbXBsYXRlRGlyZWN0aXZlLCB3b3JrYm9va09wdGlvbnMsIHRvRGF0YVVSTCwgaXNXb3JrYm9va09wdGlvbnMgfTtcbiJdfQ==","map":null,"metadata":{},"sourceType":"module"}