{"ast":null,"code":"import TemplateService from './services/template-service';\nimport getter from './utils/getter';\nimport map from './utils/map';\n\nfunction defaultGroupHeaderTemplate(data) {\n  return `${data.title}: ${data.value}`;\n}\n\nfunction createArray(length, callback) {\n  const result = [];\n\n  for (let idx = 0; idx < length; idx++) {\n    result.push(callback(idx));\n  }\n\n  return result;\n}\n\nfunction defaultItemId(item) {\n  return item.id;\n}\n\nclass ExcelExporter {\n  constructor(options) {\n    options.columns = this._trimColumns(options.columns || []);\n    this.allColumns = map(this._leafColumns(options.columns || []), this._prepareColumn);\n    this.columns = this._visibleColumns(this.allColumns);\n    this.options = options;\n    this.data = options.data || [];\n    this.aggregates = options.aggregates || {};\n    this.groups = [].concat(options.groups || []);\n    this.hasGroups = this.groups.length > 0;\n    this.hierarchy = options.hierarchy;\n    this.hasGroupHeaderColumn = this.columns.some(column => column.groupHeaderColumnTemplate);\n    this.collapsible = this.options.collapsible;\n  }\n\n  workbook() {\n    const workbook = {\n      sheets: [{\n        columns: this._columns(),\n        rows: this.hierarchy ? this._hierarchyRows() : this._rows(),\n        freezePane: this._freezePane(),\n        filter: this._filter()\n      }]\n    };\n    return workbook;\n  }\n\n  _trimColumns(columns) {\n    return columns.filter(column => {\n      let result = Boolean(column.field);\n\n      if (!result && column.columns) {\n        result = this._trimColumns(column.columns).length > 0;\n      }\n\n      return result;\n    });\n  }\n\n  _leafColumns(columns) {\n    let result = [];\n\n    for (let idx = 0; idx < columns.length; idx++) {\n      if (!columns[idx].columns) {\n        result.push(columns[idx]);\n      } else {\n        result = result.concat(this._leafColumns(columns[idx].columns));\n      }\n    }\n\n    return result;\n  }\n\n  _prepareColumn(column) {\n    if (!column.field) {\n      return null;\n    }\n\n    let value = function (dataItem) {\n      return getter(column.field, true)(dataItem);\n    };\n\n    let values = null;\n\n    if (column.values) {\n      values = {};\n      column.values.forEach(function (item) {\n        values[item.value] = item.text;\n      });\n\n      value = function (dataItem) {\n        return values[getter(column.field, true)(dataItem)];\n      };\n    }\n\n    return Object.assign({}, column, {\n      value: value,\n      values: values,\n      groupHeaderTemplate: column.groupHeaderTemplate ? TemplateService.compile(column.groupHeaderTemplate) : defaultGroupHeaderTemplate,\n      groupHeaderColumnTemplate: column.groupHeaderColumnTemplate ? TemplateService.compile(column.groupHeaderColumnTemplate) : null,\n      groupFooterTemplate: column.groupFooterTemplate ? TemplateService.compile(column.groupFooterTemplate) : null,\n      footerTemplate: column.footerTemplate ? TemplateService.compile(column.footerTemplate) : null\n    });\n  }\n\n  _filter() {\n    if (!this.options.filterable) {\n      return null;\n    }\n\n    const depth = this._depth();\n\n    return {\n      from: depth,\n      to: depth + this.columns.length - 1\n    };\n  }\n\n  _createPaddingCells(length) {\n    return createArray(length, () => Object.assign({\n      background: \"#dfdfdf\",\n      color: \"#333\"\n    }, this.options.paddingCellOptions));\n  }\n\n  _dataRow(dataItem, level, depth) {\n    let cells = this._createPaddingCells(level); // grouped\n\n\n    if (this.hasGroups && depth && dataItem.items) {\n      cells = cells.concat(this._groupHeaderCells(dataItem, level, depth));\n\n      const rows = this._dataRows(dataItem.items, level + 1);\n\n      rows.unshift({\n        type: \"group-header\",\n        cells: cells,\n        level: this.collapsible ? level : null\n      });\n      return rows.concat(this._footer(dataItem, level));\n    }\n\n    const dataCells = [];\n\n    for (let cellIdx = 0; cellIdx < this.columns.length; cellIdx++) {\n      dataCells[cellIdx] = this._cell(dataItem, this.columns[cellIdx]);\n    }\n\n    if (this.hierarchy) {\n      dataCells[0].colSpan = depth - level + 1;\n    }\n\n    return [{\n      type: \"data\",\n      cells: cells.concat(dataCells),\n      level: this.collapsible ? level : null\n    }];\n  }\n\n  _groupHeaderCells(dataItem, level, depth) {\n    const cells = [];\n    const column = this.allColumns.filter(function (column) {\n      return column.field === dataItem.field;\n    })[0] || {};\n    const title = column && column.title ? column.title : dataItem.field;\n    const template = column ? column.groupHeaderTemplate || column.groupHeaderColumnTemplate : null;\n    const group = Object.assign({\n      title: title,\n      field: dataItem.field,\n      value: column && column.values ? column.values[dataItem.value] : dataItem.value,\n      aggregates: dataItem.aggregates,\n      items: dataItem.items\n    }, dataItem.aggregates[dataItem.field]);\n    const value = template ? template(group) : `${title}: ${dataItem.value}`;\n    cells.push(Object.assign({\n      value: value,\n      background: \"#dfdfdf\",\n      color: \"#333\",\n      colSpan: (this.hasGroupHeaderColumn ? 1 : this.columns.length) + depth - level\n    }, column.groupHeaderCellOptions));\n\n    if (this.hasGroupHeaderColumn) {\n      this.columns.forEach(function (column, index) {\n        if (index > 0) {\n          cells.push(Object.assign({\n            background: \"#dfdfdf\",\n            color: \"#333\",\n            value: column.groupHeaderColumnTemplate ? column.groupHeaderColumnTemplate(Object.assign({\n              group: group\n            }, group, dataItem.aggregates[column.field])) : undefined\n          }, column.groupHeaderCellOptions));\n        }\n      });\n    }\n\n    return cells;\n  }\n\n  _dataRows(dataItems, level) {\n    const depth = this._depth();\n\n    const rows = [];\n\n    for (let idx = 0; idx < dataItems.length; idx++) {\n      rows.push.apply(rows, this._dataRow(dataItems[idx], level, depth));\n    }\n\n    return rows;\n  }\n\n  _hierarchyRows() {\n    const depth = this._depth();\n\n    const data = this.data;\n    const itemLevel = this.hierarchy.itemLevel;\n    const itemId = this.hierarchy.itemId || defaultItemId;\n\n    const hasFooter = this._hasFooterTemplate();\n\n    const rows = [];\n    const parents = [];\n    let previousLevel = 0;\n    let previousItemId;\n\n    if (!hasFooter) {\n      this.collapsible = false;\n    }\n\n    for (let idx = 0; idx < data.length; idx++) {\n      const item = data[idx];\n      const level = itemLevel(item, idx);\n\n      if (hasFooter) {\n        if (level > previousLevel) {\n          parents.push({\n            id: previousItemId,\n            level: previousLevel\n          });\n        } else if (level < previousLevel) {\n          rows.push.apply(rows, this._hierarchyFooterRows(parents, level, depth));\n        }\n\n        previousLevel = level;\n        previousItemId = itemId(item, idx);\n      }\n\n      rows.push.apply(rows, this._dataRow(item, level + 1, depth));\n    }\n\n    if (hasFooter) {\n      rows.push.apply(rows, this._hierarchyFooterRows(parents, 0, depth));\n      const rootAggregate = data.length ? this.aggregates[data[0].parentId] : {};\n      rows.push(this._hierarchyFooter(rootAggregate, 0, depth));\n    }\n\n    this._prependHeaderRows(rows);\n\n    return rows;\n  }\n\n  _hierarchyFooterRows(parents, currentLevel, depth) {\n    const rows = [];\n\n    while (parents.length && parents[parents.length - 1].level >= currentLevel) {\n      const parent = parents.pop();\n      rows.push(this._hierarchyFooter(this.aggregates[parent.id], parent.level + 1, depth));\n    }\n\n    return rows;\n  }\n\n  _hasFooterTemplate() {\n    const columns = this.columns;\n\n    for (let idx = 0; idx < columns.length; idx++) {\n      if (columns[idx].footerTemplate) {\n        return true;\n      }\n    }\n  }\n\n  _hierarchyFooter(aggregates, level, depth) {\n    const cells = this.columns.map(function (column, index) {\n      const colSpan = index ? 1 : depth - level + 1;\n\n      if (column.footerTemplate) {\n        const fieldAggregates = (aggregates || {})[column.field];\n        return Object.assign({\n          background: \"#dfdfdf\",\n          color: \"#333\",\n          colSpan: colSpan,\n          value: column.footerTemplate(Object.assign({\n            aggregates: aggregates\n          }, fieldAggregates))\n        }, column.footerCellOptions);\n      }\n\n      return Object.assign({\n        background: \"#dfdfdf\",\n        color: \"#333\",\n        colSpan: colSpan\n      }, column.footerCellOptions);\n    });\n    return {\n      type: \"footer\",\n      cells: this._createPaddingCells(level).concat(cells),\n      level: this.collapsible ? level : null\n    };\n  }\n\n  _footer(dataItem, level) {\n    const rows = [];\n    const footer = this.columns.some(column => column.groupFooterTemplate);\n    let templateData, group;\n\n    if (footer) {\n      group = {\n        group: {\n          items: dataItem.items,\n          field: dataItem.field,\n          value: dataItem.value\n        }\n      };\n      templateData = {};\n      Object.keys(dataItem.aggregates).forEach(key => {\n        templateData[key] = Object.assign({}, dataItem.aggregates[key], group);\n      });\n    }\n\n    const cells = this.columns.map(column => {\n      if (column.groupFooterTemplate) {\n        let data = Object.assign({}, templateData, dataItem.aggregates[column.field], group);\n        return Object.assign({\n          background: \"#dfdfdf\",\n          color: \"#333\",\n          value: column.groupFooterTemplate(data)\n        }, column.groupFooterCellOptions);\n      }\n\n      return Object.assign({\n        background: \"#dfdfdf\",\n        color: \"#333\"\n      }, column.groupFooterCellOptions);\n    });\n\n    if (footer) {\n      rows.push({\n        type: \"group-footer\",\n        cells: this._createPaddingCells(this.groups.length).concat(cells),\n        level: this.collapsible ? level : null\n      });\n    }\n\n    return rows;\n  }\n\n  _isColumnVisible(column) {\n    return this._visibleColumns([column]).length > 0 && (column.field || column.columns);\n  }\n\n  _visibleColumns(columns) {\n    return columns.filter(column => {\n      let exportable = column.exportable;\n\n      if (typeof exportable === 'object') {\n        exportable = column.exportable.excel;\n      }\n\n      const visibleInExport = !column.hidden && exportable !== false;\n      const visibleInExportOnly = column.hidden && exportable === true;\n      let visible = visibleInExport || visibleInExportOnly;\n\n      if (visible && column.columns) {\n        visible = this._visibleColumns(column.columns).length > 0;\n      }\n\n      return visible;\n    });\n  }\n\n  _headerRow(row, groups) {\n    const headers = row.cells.map(function (cell) {\n      return Object.assign(cell, {\n        colSpan: cell.colSpan > 1 ? cell.colSpan : 1,\n        rowSpan: row.rowSpan > 1 && !cell.colSpan ? row.rowSpan : 1\n      });\n    });\n\n    if (this.hierarchy && headers[0].firstCell) {\n      headers[0].colSpan += this._depth();\n    }\n\n    return {\n      type: \"header\",\n      cells: createArray(groups.length, () => Object.assign({\n        background: \"#7a7a7a\",\n        color: \"#fff\"\n      }, this.options.headerPaddingCellOptions)).concat(headers)\n    };\n  }\n\n  _prependHeaderRows(rows) {\n    const groups = this.groups;\n    const headerRows = [{\n      rowSpan: 1,\n      cells: [],\n      index: 0\n    }];\n\n    this._prepareHeaderRows(headerRows, this.options.columns);\n\n    for (let idx = headerRows.length - 1; idx >= 0; idx--) {\n      rows.unshift(this._headerRow(headerRows[idx], groups));\n    }\n  }\n\n  _prepareHeaderRows(rows, columns, parentCell, parentRow) {\n    const row = parentRow || rows[rows.length - 1];\n    let childRow = rows[row.index + 1];\n    let totalColSpan = 0;\n\n    for (let idx = 0; idx < columns.length; idx++) {\n      const column = columns[idx];\n\n      if (this._isColumnVisible(column)) {\n        const cell = Object.assign({\n          background: \"#7a7a7a\",\n          color: \"#fff\",\n          value: column.title || column.field,\n          colSpan: 0,\n          firstCell: idx === 0 && (!parentCell || parentCell.firstCell)\n        }, column.headerCellOptions);\n        row.cells.push(cell);\n\n        if (column.columns && column.columns.length) {\n          if (!childRow) {\n            childRow = {\n              rowSpan: 0,\n              cells: [],\n              index: rows.length\n            };\n            rows.push(childRow);\n          }\n\n          cell.colSpan = this._trimColumns(this._visibleColumns(column.columns)).length;\n\n          this._prepareHeaderRows(rows, column.columns, cell, childRow);\n\n          totalColSpan += cell.colSpan - 1;\n          row.rowSpan = rows.length - row.index;\n        }\n      }\n    }\n\n    if (parentCell) {\n      parentCell.colSpan += totalColSpan;\n    }\n  }\n\n  _rows() {\n    const rows = this._dataRows(this.data, 0);\n\n    if (this.columns.length) {\n      this._prependHeaderRows(rows);\n\n      let footer = false;\n      const cells = this.columns.map(column => {\n        if (column.footerTemplate) {\n          footer = true;\n          return Object.assign({\n            background: \"#dfdfdf\",\n            color: \"#333\",\n            value: column.footerTemplate(Object.assign({}, this.aggregates, this.aggregates[column.field]))\n          }, column.footerCellOptions);\n        }\n\n        return Object.assign({\n          background: \"#dfdfdf\",\n          color: \"#333\"\n        }, column.footerCellOptions);\n      });\n\n      if (footer) {\n        rows.push({\n          type: \"footer\",\n          cells: this._createPaddingCells(this.groups.length).concat(cells)\n        });\n      }\n    }\n\n    return rows;\n  }\n\n  _headerDepth(columns) {\n    const result = 1;\n    let max = 0;\n\n    for (let idx = 0; idx < columns.length; idx++) {\n      if (columns[idx].columns) {\n        const temp = this._headerDepth(columns[idx].columns);\n\n        if (temp > max) {\n          max = temp;\n        }\n      }\n    }\n\n    return result + max;\n  }\n\n  _freezePane() {\n    const columns = this._visibleColumns(this.options.columns || []);\n\n    const colSplit = this._visibleColumns(this._trimColumns(this._leafColumns(columns.filter(function (column) {\n      return column.locked;\n    })))).length;\n\n    return {\n      rowSplit: this._headerDepth(columns),\n      colSplit: colSplit ? colSplit + this.groups.length : 0\n    };\n  }\n\n  _cell(dataItem, column) {\n    return Object.assign({\n      value: column.value(dataItem)\n    }, column.cellOptions);\n  }\n\n  _depth() {\n    let depth = 0;\n\n    if (this.hierarchy) {\n      depth = this.hierarchy.depth;\n    } else {\n      depth = this.groups.length;\n    }\n\n    return depth;\n  }\n\n  _columns() {\n    const depth = this._depth();\n\n    const columns = createArray(depth, () => ({\n      width: 20\n    }));\n    return columns.concat(this.columns.map(function (column) {\n      return {\n        width: parseInt(column.width, 10),\n        autoWidth: column.width ? false : true\n      };\n    }));\n  }\n\n}\n\nexport default ExcelExporter;","map":null,"metadata":{},"sourceType":"module"}