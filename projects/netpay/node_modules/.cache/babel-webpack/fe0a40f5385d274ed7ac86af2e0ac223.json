{"ast":null,"code":"import Point from '../geometry/point';\nimport ShapeMap from './shape-map';\nconst SEGMENT_REGEX = /([a-df-z]{1})([^a-df-z]*)(z)?/gi;\nconst SPLIT_REGEX = /[,\\s]?([+\\-]?(?:\\d*\\.\\d+|\\d+)(?:[eE][+\\-]?\\d+)?)/g;\nconst MOVE = \"m\";\nconst CLOSE = \"z\";\n\nfunction parseParameters(str) {\n  const parameters = [];\n  str.replace(SPLIT_REGEX, function (match, number) {\n    parameters.push(parseFloat(number));\n  });\n  return parameters;\n}\n\nfunction parsePath(pathInstance, str) {\n  const position = new Point();\n  let previousCommand;\n  str.replace(SEGMENT_REGEX, (match, element, params, closePath) => {\n    let command = element.toLowerCase();\n    const isRelative = command === element;\n    const parameters = parseParameters(params.trim());\n\n    if (command === MOVE) {\n      if (isRelative) {\n        position.x += parameters[0];\n        position.y += parameters[1];\n      } else {\n        position.x = parameters[0];\n        position.y = parameters[1];\n      }\n\n      pathInstance.moveTo(position.x, position.y);\n\n      if (parameters.length > 2) {\n        command = \"l\";\n        parameters.splice(0, 2);\n      }\n    }\n\n    if (ShapeMap[command]) {\n      ShapeMap[command](pathInstance, {\n        parameters: parameters,\n        position: position,\n        isRelative: isRelative,\n        previousCommand: previousCommand\n      });\n\n      if (closePath && closePath.toLowerCase() === CLOSE) {\n        pathInstance.close();\n      }\n    } else if (command !== MOVE) {\n      throw new Error(\"Error while parsing SVG path. Unsupported command: \" + command);\n    }\n\n    previousCommand = command;\n  });\n  return pathInstance;\n}\n\nexport default parsePath;","map":null,"metadata":{},"sourceType":"module"}