{"ast":null,"code":"import HasObservers from '../core/has-observers';\nimport { deg, rad, round } from '../util';\nimport withAccessors from '../mixins/with-accessors';\nimport closeOrLess from './math/close-or-less';\nimport lineIntersection from './math/line-intersection';\nimport ellipseExtremeAngles from './math/ellipse-extreme-angles';\nimport { PRECISION } from './constants';\nimport Point from './point';\nimport Rect from './rect';\nimport transform from './transform';\nconst MAX_INTERVAL = 45;\nconst pow = Math.pow;\nconst accessors = [\"radiusX\", \"radiusY\", \"startAngle\", \"endAngle\", \"anticlockwise\"];\n\nclass Arc extends withAccessors(HasObservers, accessors) {\n  constructor(center = new Point(), options = {}) {\n    super();\n    this.setCenter(center);\n    this.radiusX = options.radiusX;\n    this.radiusY = options.radiusY || options.radiusX;\n    this.startAngle = options.startAngle;\n    this.endAngle = options.endAngle;\n    this.anticlockwise = options.anticlockwise || false;\n    this.xRotation = options.xRotation;\n  }\n\n  clone() {\n    return new Arc(this.center, {\n      radiusX: this.radiusX,\n      radiusY: this.radiusY,\n      startAngle: this.startAngle,\n      endAngle: this.endAngle,\n      anticlockwise: this.anticlockwise\n    });\n  }\n\n  setCenter(value) {\n    this._observerField(\"center\", Point.create(value));\n\n    this.geometryChange();\n    return this;\n  }\n\n  getCenter() {\n    return this.center;\n  }\n\n  pointAt(angle) {\n    const center = this.center;\n    const radian = rad(angle);\n    return new Point(center.x + this.radiusX * Math.cos(radian), center.y + this.radiusY * Math.sin(radian));\n  }\n\n  curvePoints() {\n    const startAngle = this.startAngle;\n    const dir = this.anticlockwise ? -1 : 1;\n    const curvePoints = [this.pointAt(startAngle)];\n\n    const interval = this._arcInterval();\n\n    const intervalAngle = interval.endAngle - interval.startAngle;\n    const subIntervalsCount = Math.ceil(intervalAngle / MAX_INTERVAL);\n    const subIntervalAngle = intervalAngle / subIntervalsCount;\n    let currentAngle = startAngle;\n    let transformation;\n\n    if (this.xRotation) {\n      transformation = transform().rotate(this.xRotation, this.center);\n    }\n\n    for (let i = 1; i <= subIntervalsCount; i++) {\n      const nextAngle = currentAngle + dir * subIntervalAngle;\n\n      const points = this._intervalCurvePoints(currentAngle, nextAngle, transformation);\n\n      curvePoints.push(points.cp1, points.cp2, points.p2);\n      currentAngle = nextAngle;\n    }\n\n    return curvePoints;\n  }\n\n  bbox(matrix) {\n    const interval = this._arcInterval();\n\n    const startAngle = interval.startAngle;\n    const endAngle = interval.endAngle;\n    const extremeAngles = ellipseExtremeAngles(this.center, this.radiusX, this.radiusY, matrix);\n    const extremeX = deg(extremeAngles.x);\n    const extremeY = deg(extremeAngles.y);\n    const endPoint = this.pointAt(endAngle).transformCopy(matrix);\n    let currentAngleX = bboxStartAngle(extremeX, startAngle);\n    let currentAngleY = bboxStartAngle(extremeY, startAngle);\n    let currentPoint = this.pointAt(startAngle).transformCopy(matrix);\n    let minPoint = Point.min(currentPoint, endPoint);\n    let maxPoint = Point.max(currentPoint, endPoint);\n\n    while (currentAngleX < endAngle || currentAngleY < endAngle) {\n      let currentPointX;\n\n      if (currentAngleX < endAngle) {\n        currentPointX = this.pointAt(currentAngleX).transformCopy(matrix);\n        currentAngleX += 90;\n      }\n\n      let currentPointY;\n\n      if (currentAngleY < endAngle) {\n        currentPointY = this.pointAt(currentAngleY).transformCopy(matrix);\n        currentAngleY += 90;\n      }\n\n      currentPoint = new Point(currentPointX.x, currentPointY.y);\n      minPoint = Point.min(minPoint, currentPoint);\n      maxPoint = Point.max(maxPoint, currentPoint);\n    }\n\n    return Rect.fromPoints(minPoint, maxPoint);\n  }\n\n  _arcInterval() {\n    let {\n      startAngle,\n      endAngle,\n      anticlockwise\n    } = this;\n\n    if (anticlockwise) {\n      let oldStart = startAngle;\n      startAngle = endAngle;\n      endAngle = oldStart;\n    }\n\n    if (startAngle > endAngle || anticlockwise && startAngle === endAngle) {\n      endAngle += 360;\n    }\n\n    return {\n      startAngle: startAngle,\n      endAngle: endAngle\n    };\n  }\n\n  _intervalCurvePoints(startAngle, endAngle, transformation) {\n    const p1 = this.pointAt(startAngle);\n    const p2 = this.pointAt(endAngle);\n\n    const p1Derivative = this._derivativeAt(startAngle);\n\n    const p2Derivative = this._derivativeAt(endAngle);\n\n    const t = (rad(endAngle) - rad(startAngle)) / 3;\n    const cp1 = new Point(p1.x + t * p1Derivative.x, p1.y + t * p1Derivative.y);\n    const cp2 = new Point(p2.x - t * p2Derivative.x, p2.y - t * p2Derivative.y);\n\n    if (transformation) {\n      p1.transform(transformation);\n      p2.transform(transformation);\n      cp1.transform(transformation);\n      cp2.transform(transformation);\n    }\n\n    return {\n      p1: p1,\n      cp1: cp1,\n      cp2: cp2,\n      p2: p2\n    };\n  }\n\n  _derivativeAt(angle) {\n    const radian = rad(angle);\n    return new Point(-this.radiusX * Math.sin(radian), this.radiusY * Math.cos(radian));\n  }\n\n  containsPoint(point) {\n    const interval = this._arcInterval();\n\n    const intervalAngle = interval.endAngle - interval.startAngle;\n    const {\n      center,\n      radiusX,\n      radiusY\n    } = this;\n    const distance = center.distanceTo(point);\n    const angleRad = Math.atan2(point.y - center.y, point.x - center.x);\n    const pointRadius = radiusX * radiusY / Math.sqrt(pow(radiusX, 2) * pow(Math.sin(angleRad), 2) + pow(radiusY, 2) * pow(Math.cos(angleRad), 2));\n    const startPoint = this.pointAt(this.startAngle).round(PRECISION);\n    const endPoint = this.pointAt(this.endAngle).round(PRECISION);\n    const intersection = lineIntersection(center, point.round(PRECISION), startPoint, endPoint);\n    let containsPoint;\n\n    if (intervalAngle < 180) {\n      containsPoint = intersection && closeOrLess(center.distanceTo(intersection), distance) && closeOrLess(distance, pointRadius);\n    } else {\n      let angle = calculateAngle(center.x, center.y, radiusX, radiusY, point.x, point.y);\n\n      if (angle !== 360) {\n        angle = (360 + angle) % 360;\n      }\n\n      let inAngleRange = interval.startAngle <= angle && angle <= interval.endAngle;\n      containsPoint = inAngleRange && closeOrLess(distance, pointRadius) || !inAngleRange && (!intersection || intersection.equals(point));\n    }\n\n    return containsPoint;\n  }\n\n  _isOnPath(point, width) {\n    const interval = this._arcInterval();\n\n    const center = this.center;\n    let angle = calculateAngle(center.x, center.y, this.radiusX, this.radiusY, point.x, point.y);\n\n    if (angle !== 360) {\n      angle = (360 + angle) % 360;\n    }\n\n    const inAngleRange = interval.startAngle <= angle && angle <= interval.endAngle;\n    return inAngleRange && this.pointAt(angle).distanceTo(point) <= width;\n  }\n\n  static fromPoints(start, end, rx, ry, largeArc, swipe, rotation) {\n    // eslint-disable-line max-params\n    const arcParameters = normalizeArcParameters({\n      x1: start.x,\n      y1: start.y,\n      x2: end.x,\n      y2: end.y,\n      rx: rx,\n      ry: ry,\n      largeArc: largeArc,\n      swipe: swipe,\n      rotation: rotation\n    });\n    return new Arc(arcParameters.center, {\n      startAngle: arcParameters.startAngle,\n      endAngle: arcParameters.endAngle,\n      radiusX: arcParameters.radiusX,\n      radiusY: arcParameters.radiusY,\n      xRotation: arcParameters.xRotation,\n      anticlockwise: swipe === 0\n    });\n  }\n\n}\n\nfunction calculateAngle(cx, cy, rx, ry, x, y) {\n  const cos = round((x - cx) / rx, 3);\n  const sin = round((y - cy) / ry, 3);\n  return round(deg(Math.atan2(sin, cos)));\n}\n\nfunction normalizeArcParameters(parameters) {\n  let {\n    x1,\n    y1,\n    x2,\n    y2,\n    rx,\n    ry,\n    largeArc,\n    swipe,\n    rotation = 0\n  } = parameters;\n  const radians = rad(rotation);\n  const cosine = Math.cos(radians);\n  const sine = Math.sin(radians);\n  const xT = cosine * (x1 - x2) / 2 + sine * (y1 - y2) / 2;\n  const yT = -sine * (x1 - x2) / 2 + cosine * (y1 - y2) / 2;\n  const sign = largeArc !== swipe ? 1 : -1;\n  const xt2 = Math.pow(xT, 2);\n  const yt2 = Math.pow(yT, 2);\n  let rx2 = Math.pow(rx, 2);\n  let ry2 = Math.pow(ry, 2);\n  let delta = xt2 / rx2 + yt2 / ry2;\n\n  if (delta > 1) {\n    delta = Math.sqrt(xt2 / rx2 + yt2 / ry2);\n    rx = delta * rx;\n    rx2 = Math.pow(rx, 2);\n    ry = delta * ry;\n    ry2 = Math.pow(ry, 2);\n  }\n\n  let constT = sign * Math.sqrt((rx2 * ry2 - rx2 * yt2 - ry2 * xt2) / (rx2 * yt2 + ry2 * xt2)); // due to rounding errors the value could become NaN even after radii correction\n\n  if (isNaN(constT)) {\n    constT = 0;\n  }\n\n  const cxT = constT * (rx * yT) / ry;\n  const cyT = -constT * (ry * xT) / rx;\n  const cx = cosine * cxT - sine * cyT + (x1 + x2) / 2;\n  const cy = sine * cxT + cosine * cyT + (y1 + y2) / 2;\n  const uX = (xT - cxT) / rx;\n  const uY = (yT - cyT) / ry;\n  const vX = -(xT + cxT) / rx;\n  const vY = -(yT + cyT) / ry;\n  const startAngle = (uY >= 0 ? 1 : -1) * deg(Math.acos(uX / Math.sqrt(uX * uX + uY * uY)));\n  const angleCosine = round((uX * vX + uY * vY) / (Math.sqrt(uX * uX + uY * uY) * Math.sqrt(vX * vX + vY * vY)), 10);\n  let angle = (uX * vY - uY * vX >= 0 ? 1 : -1) * deg(Math.acos(angleCosine));\n\n  if (!swipe && angle > 0) {\n    angle -= 360;\n  }\n\n  if (swipe && angle < 0) {\n    angle += 360;\n  }\n\n  let endAngle = startAngle + angle;\n  const signEndAngle = endAngle >= 0 ? 1 : -1;\n  endAngle = Math.abs(endAngle) % 360 * signEndAngle;\n  return {\n    center: new Point(cx, cy),\n    startAngle: startAngle,\n    endAngle: endAngle,\n    radiusX: rx,\n    radiusY: ry,\n    xRotation: rotation\n  };\n}\n\nfunction bboxStartAngle(angle, start) {\n  let startAngle = angle;\n\n  while (startAngle < start) {\n    startAngle += 90;\n  }\n\n  return startAngle;\n}\n\nexport default Arc;","map":null,"metadata":{},"sourceType":"module"}