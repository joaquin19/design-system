{"ast":null,"code":"import { exec, map, groupCombinator } from '../transducers';\nimport { isArray, isPresent } from '../utils';\nimport { aggregateBy } from './aggregate.operators';\nimport { filterBy } from '../filtering/filter-expression.factory';\n/**\n * @hidden\n */\n\nexport const normalizeGroups = descriptors => {\n  descriptors = isArray(descriptors) ? descriptors : [descriptors];\n  return descriptors.map(x => Object.assign({\n    dir: \"asc\"\n  }, x));\n};\nconst identity = map(x => x);\n/**\n * Groups the provided data according to the specified descriptors.\n *\n * @param {Array} data - The data that will be grouped.\n * @param {GroupDescriptor[]} descriptors - The descriptors.\n * @param {any} transformers - For internal use.\n * @param {Array} originalData - For internal use.\n * @returns {(Array<GroupResult<T>> | T[])} - The grouped data.\n *\n * @example\n * ```ts\n *\n * import { groupBy } from '@progress/kendo-data-query';\n *\n * const data = [\n *     { name: \"Pork\", category: \"Food\", subcategory: \"Meat\" },\n *     { name: \"Pepper\", category: \"Food\", subcategory: \"Vegetables\" },\n *     { name: \"Beef\", category: \"Food\", subcategory: \"Meat\" }\n * ];\n *\n * const result = groupBy(data, [{ field: \"subcategory\" }]);\n * ```\n */\n\nexport const groupBy = (data, descriptors = [], transformers = identity, originalData = data) => {\n  descriptors = normalizeGroups(descriptors);\n\n  if (!descriptors.length) {\n    return data;\n  }\n\n  const descriptor = descriptors[0];\n  const initialValue = {};\n  const view = exec(transformers(groupCombinator(descriptor.field)), initialValue, data);\n  const result = [];\n  Object.keys(view).forEach(field => {\n    Object.keys(view[field]).forEach(value => {\n      const group = view[field][value];\n      let aggregateResult = {};\n      let filteredData = originalData;\n\n      if (isPresent(descriptor.aggregates)) {\n        filteredData = filterBy(originalData, {\n          field: descriptor.field,\n          ignoreCase: false,\n          operator: 'eq',\n          value: group.value\n        });\n        aggregateResult = aggregateBy(filteredData, descriptor.aggregates);\n      }\n\n      result[group.__position] = {\n        aggregates: aggregateResult,\n        field: field,\n        items: descriptors.length > 1 ? groupBy(group.items, descriptors.slice(1), identity, filteredData) : group.items,\n        value: group.value\n      };\n    });\n  });\n  return result;\n};","map":null,"metadata":{},"sourceType":"module"}