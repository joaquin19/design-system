{"ast":null,"code":"import QuadRoot from './quad-root';\nimport QuadNode from './quad-node';\nimport { Rect } from '../geometry';\nimport { Class } from '../common';\nimport { append } from '../util';\nconst ROOT_SIZE = 3000;\nconst LEVEL_STEP = 10000;\nconst MAX_LEVEL = 75;\n\nclass ShapesQuadTree extends Class {\n  constructor() {\n    super();\n    this.initRoots();\n  }\n\n  initRoots() {\n    this.rootMap = {};\n    this.root = new QuadRoot();\n    this.rootElements = [];\n  }\n\n  clear() {\n    const rootElements = this.rootElements;\n\n    for (let idx = 0; idx < rootElements.length; idx++) {\n      this.remove(rootElements[idx]);\n    }\n\n    this.initRoots();\n  }\n\n  pointShape(point) {\n    const sectorRoot = (this.rootMap[Math.floor(point.x / ROOT_SIZE)] || {})[Math.floor(point.y / ROOT_SIZE)];\n    let result = this.root.pointShapes(point);\n\n    if (sectorRoot) {\n      result = result.concat(sectorRoot.pointShapes(point));\n    }\n\n    this.assignZindex(result);\n    result.sort(zIndexComparer);\n\n    for (let idx = 0; idx < result.length; idx++) {\n      if (result[idx].containsPoint(point)) {\n        return result[idx];\n      }\n    }\n  }\n\n  assignZindex(elements) {\n    for (let idx = 0; idx < elements.length; idx++) {\n      let element = elements[idx];\n      let zIndex = 0;\n      let levelWeight = Math.pow(LEVEL_STEP, MAX_LEVEL);\n      let parents = [];\n\n      while (element) {\n        parents.push(element);\n        element = element.parent;\n      }\n\n      while (parents.length) {\n        element = parents.pop();\n        zIndex += ((element.parent ? element.parent.children : this.rootElements).indexOf(element) + 1) * levelWeight;\n        levelWeight /= LEVEL_STEP;\n      }\n\n      elements[idx]._zIndex = zIndex;\n    }\n  }\n\n  optionsChange(e) {\n    if (e.field === \"transform\" || e.field === \"stroke.width\") {\n      this.bboxChange(e.element);\n    }\n  }\n\n  geometryChange(e) {\n    this.bboxChange(e.element);\n  }\n\n  bboxChange(element) {\n    if (element.nodeType === \"Group\") {\n      for (let idx = 0; idx < element.children.length; idx++) {\n        this.bboxChange(element.children[idx]);\n      }\n    } else {\n      if (element._quadNode) {\n        element._quadNode.remove(element);\n      }\n\n      this._insertShape(element);\n    }\n  }\n\n  add(elements) {\n    const elementsArray = Array.isArray(elements) ? elements.slice(0) : [elements];\n    append(this.rootElements, elementsArray);\n\n    this._insert(elementsArray);\n  }\n\n  childrenChange(e) {\n    if (e.action === \"remove\") {\n      for (let idx = 0; idx < e.items.length; idx++) {\n        this.remove(e.items[idx]);\n      }\n    } else {\n      this._insert(Array.prototype.slice.call(e.items, 0));\n    }\n  }\n\n  _insert(elements) {\n    let element;\n\n    while (elements.length > 0) {\n      element = elements.pop();\n      element.addObserver(this);\n\n      if (element.nodeType === \"Group\") {\n        append(elements, element.children);\n      } else {\n        this._insertShape(element);\n      }\n    }\n  }\n\n  _insertShape(shape) {\n    const bbox = shape.bbox();\n\n    if (bbox) {\n      const sectors = this.getSectors(bbox);\n      const x = sectors[0][0];\n      const y = sectors[1][0];\n\n      if (this.inRoot(sectors)) {\n        this.root.insert(shape, bbox);\n      } else {\n        const rootMap = this.rootMap;\n\n        if (!rootMap[x]) {\n          rootMap[x] = {};\n        }\n\n        if (!rootMap[x][y]) {\n          rootMap[x][y] = new QuadNode(new Rect([x * ROOT_SIZE, y * ROOT_SIZE], [ROOT_SIZE, ROOT_SIZE]));\n        }\n\n        rootMap[x][y].insert(shape, bbox);\n      }\n    }\n  }\n\n  remove(element) {\n    element.removeObserver(this);\n\n    if (element.nodeType === \"Group\") {\n      const children = element.children;\n\n      for (let idx = 0; idx < children.length; idx++) {\n        this.remove(children[idx]);\n      }\n    } else if (element._quadNode) {\n      element._quadNode.remove(element);\n\n      delete element._quadNode;\n    }\n  }\n\n  inRoot(sectors) {\n    return sectors[0].length > 1 || sectors[1].length > 1;\n  }\n\n  getSectors(rect) {\n    const bottomRight = rect.bottomRight();\n    const bottomX = Math.floor(bottomRight.x / ROOT_SIZE);\n    const bottomY = Math.floor(bottomRight.y / ROOT_SIZE);\n    const sectors = [[], []];\n\n    for (let x = Math.floor(rect.origin.x / ROOT_SIZE); x <= bottomX; x++) {\n      sectors[0].push(x);\n    }\n\n    for (let y = Math.floor(rect.origin.y / ROOT_SIZE); y <= bottomY; y++) {\n      sectors[1].push(y);\n    }\n\n    return sectors;\n  }\n\n}\n\nfunction zIndexComparer(x1, x2) {\n  if (x1._zIndex < x2._zIndex) {\n    return 1;\n  }\n\n  if (x1._zIndex > x2._zIndex) {\n    return -1;\n  }\n\n  return 0;\n}\n\nexport default ShapesQuadTree;","map":null,"metadata":{},"sourceType":"module"}