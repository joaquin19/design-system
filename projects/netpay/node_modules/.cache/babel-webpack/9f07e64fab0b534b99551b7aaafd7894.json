{"ast":null,"code":"import map from './utils/map';\nimport createZip from './utils/create-zip';\nimport IntlService from './services/intl-service';\nimport dateToSerial from './utils/time';\nconst MIME_TYPE = \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\";\nconst DATA_URL_PREFIX = `data:${MIME_TYPE};base64,`;\nconst DATA_URL_OPTIONS = {\n  compression: \"DEFLATE\",\n  type: \"base64\"\n};\nconst BLOB_OPTIONS = {\n  compression: \"DEFLATE\",\n  type: \"blob\"\n};\nconst ARRAYBUFFER_OPTIONS = {\n  compression: \"DEFLATE\",\n  type: \"arraybuffer\"\n};\n/* eslint-disable key-spacing, no-arrow-condition, indent, no-nested-ternary, consistent-return */\n\nfunction toDataURI(content) {\n  return DATA_URL_PREFIX + content;\n}\n\nfunction indexOf(thing, array) {\n  return array.indexOf(thing);\n}\n\nconst parseJSON = JSON.parse.bind(JSON);\n\nfunction ESC(val) {\n  return String(val).replace(/&/g, \"&amp;\").replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\").replace(/\\\"/g, \"&quot;\").replace(/\\'/g, \"&#39;\");\n}\n\nfunction repeat(count, func) {\n  let str = \"\";\n\n  for (let i = 0; i < count; ++i) {\n    str += func(i);\n  }\n\n  return str;\n}\n\nfunction foreach(arr, func) {\n  let str = \"\";\n\n  if (arr != null) {\n    if (Array.isArray(arr)) {\n      for (let i = 0; i < arr.length; ++i) {\n        str += func(arr[i], i);\n      }\n    } else if (typeof arr == \"object\") {\n      Object.keys(arr).forEach((key, i) => {\n        str += func(arr[key], key, i);\n      });\n    }\n  }\n\n  return str;\n}\n\nconst XMLHEAD = '<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\\r';\nconst RELS = `${XMLHEAD}\n            <Relationships xmlns=\"http://schemas.openxmlformats.org/package/2006/relationships\">\n               <Relationship Id=\"rId3\" Type=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships/extended-properties\" Target=\"docProps/app.xml\"/>\n               <Relationship Id=\"rId2\" Type=\"http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties\" Target=\"docProps/core.xml\"/>\n               <Relationship Id=\"rId1\" Type=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument\" Target=\"xl/workbook.xml\"/>\n            </Relationships>`;\n\nconst CORE = ({\n  creator,\n  lastModifiedBy,\n  created,\n  modified\n}) => `${XMLHEAD}\n <cp:coreProperties xmlns:cp=\"http://schemas.openxmlformats.org/package/2006/metadata/core-properties\"\n   xmlns:dc=\"http://purl.org/dc/elements/1.1/\" xmlns:dcterms=\"http://purl.org/dc/terms/\"\n   xmlns:dcmitype=\"http://purl.org/dc/dcmitype/\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\n   <dc:creator>${ESC(creator)}</dc:creator>\n   <cp:lastModifiedBy>${ESC(lastModifiedBy)}</cp:lastModifiedBy>\n   <dcterms:created xsi:type=\"dcterms:W3CDTF\">${ESC(created)}</dcterms:created>\n   <dcterms:modified xsi:type=\"dcterms:W3CDTF\">${ESC(modified)}</dcterms:modified>\n</cp:coreProperties>`;\n\nconst APP = ({\n  sheets\n}) => `${XMLHEAD}\n<Properties xmlns=\"http://schemas.openxmlformats.org/officeDocument/2006/extended-properties\" xmlns:vt=\"http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes\">\n  <Application>Microsoft Excel</Application>\n  <DocSecurity>0</DocSecurity>\n  <ScaleCrop>false</ScaleCrop>\n  <HeadingPairs>\n    <vt:vector size=\"2\" baseType=\"variant\">\n      <vt:variant>\n        <vt:lpstr>Worksheets</vt:lpstr>\n      </vt:variant>\n      <vt:variant>\n        <vt:i4>${sheets.length}</vt:i4>\n      </vt:variant>\n    </vt:vector>\n  </HeadingPairs>\n  <TitlesOfParts>\n    <vt:vector size=\"${sheets.length}\" baseType=\"lpstr\">${foreach(sheets, (sheet, i) => sheet.options.title ? `<vt:lpstr>${ESC(sheet.options.title)}</vt:lpstr>` : `<vt:lpstr>Sheet${i + 1}</vt:lpstr>`)}</vt:vector>\n  </TitlesOfParts>\n  <LinksUpToDate>false</LinksUpToDate>\n  <SharedDoc>false</SharedDoc>\n  <HyperlinksChanged>false</HyperlinksChanged>\n  <AppVersion>14.0300</AppVersion>\n</Properties>`;\n\nconst CONTENT_TYPES = ({\n  sheetCount,\n  commentFiles,\n  drawingFiles\n}) => `${XMLHEAD}\n<Types xmlns=\"http://schemas.openxmlformats.org/package/2006/content-types\">\n  <Default Extension=\"png\" ContentType=\"image/png\"/>\n  <Default Extension=\"gif\" ContentType=\"image/gif\"/>\n  <Default Extension=\"jpg\" ContentType=\"image/jpeg\"/>\n  <Default Extension=\"rels\" ContentType=\"application/vnd.openxmlformats-package.relationships+xml\" />\n  <Default Extension=\"xml\" ContentType=\"application/xml\" />\n  <Default Extension=\"vml\" ContentType=\"application/vnd.openxmlformats-officedocument.vmlDrawing\"/>\n  <Override PartName=\"/xl/workbook.xml\" ContentType=\"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml\" />\n  <Override PartName=\"/xl/styles.xml\" ContentType=\"application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml\"/>\n  <Override PartName=\"/xl/sharedStrings.xml\" ContentType=\"application/vnd.openxmlformats-officedocument.spreadsheetml.sharedStrings+xml\"/>\n  ${repeat(sheetCount, idx => `<Override PartName=\"/xl/worksheets/sheet${idx + 1}.xml\" ContentType=\"application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml\" />`)}\n  ${foreach(commentFiles, filename => `<Override PartName=\"/xl/${filename}\" ContentType=\"application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml\"/>`)}\n  ${foreach(drawingFiles, filename => `<Override PartName=\"/xl/drawings/${filename}\" ContentType=\"application/vnd.openxmlformats-officedocument.drawing+xml\"/>`)}\n  <Override PartName=\"/docProps/core.xml\" ContentType=\"application/vnd.openxmlformats-package.core-properties+xml\" />\n  <Override PartName=\"/docProps/app.xml\" ContentType=\"application/vnd.openxmlformats-officedocument.extended-properties+xml\" />\n</Types>`;\n\nconst WORKBOOK = ({\n  sheets,\n  filterNames,\n  userNames\n}) => `${XMLHEAD}\n<workbook xmlns=\"http://schemas.openxmlformats.org/spreadsheetml/2006/main\" xmlns:r=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships\">\n  <fileVersion appName=\"xl\" lastEdited=\"5\" lowestEdited=\"5\" rupBuild=\"9303\" />\n  <workbookPr defaultThemeVersion=\"124226\" />\n  <bookViews>\n    <workbookView xWindow=\"240\" yWindow=\"45\" windowWidth=\"18195\" windowHeight=\"7995\" />\n  </bookViews>\n  <sheets>\n  ${foreach(sheets, ({\n  options\n}, i) => {\n  const name = options.name || options.title || `Sheet${i + 1}`;\n  return `<sheet name=\"${ESC(name)}\" sheetId=\"${i + 1}\" r:id=\"rId${i + 1}\" />`;\n})}\n  </sheets>\n  ${filterNames.length || userNames.length ? `\n    <definedNames>\n      ${foreach(filterNames, f => `\n         <definedName name=\"_xlnm._FilterDatabase\" hidden=\"1\" localSheetId=\"${f.localSheetId}\">${ESC(quoteSheet(f.name))}!${ESC(f.from)}:${ESC(f.to)}</definedName>`)}\n      ${foreach(userNames, f => `\n         <definedName name=\"${f.name}\" hidden=\"${f.hidden ? 1 : 0}\" ${f.localSheetId != null ? `localSheetId=\"${f.localSheetId}\"` : ''}>${ESC(f.value)}</definedName>`)}\n    </definedNames>` : ''}\n  <calcPr fullCalcOnLoad=\"1\" calcId=\"145621\" />\n</workbook>`;\n\nconst WORKSHEET = ({\n  frozenColumns,\n  frozenRows,\n  columns,\n  defaults,\n  data,\n  index,\n  mergeCells,\n  autoFilter,\n  filter,\n  showGridLines,\n  hyperlinks,\n  validations,\n  defaultCellStyleId,\n  rtl,\n  legacyDrawing,\n  drawing,\n  lastRow,\n  lastCol\n}) => `${XMLHEAD}\n<worksheet xmlns=\"http://schemas.openxmlformats.org/spreadsheetml/2006/main\" xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\" xmlns:r=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships\" xmlns:x14ac=\"http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac\" mc:Ignorable=\"x14ac\">\n   ${lastRow && lastCol ? `<dimension ref=\"A1:${ref(lastRow - 1, lastCol - 1)}\" />` : \"\"}\n\n   <sheetViews>\n     <sheetView ${rtl ? 'rightToLeft=\"1\"' : ''} ${index === 0 ? 'tabSelected=\"1\"' : ''} workbookViewId=\"0\" ${showGridLines === false ? 'showGridLines=\"0\"' : ''}>\n     ${frozenRows || frozenColumns ? `\n       <pane state=\"frozen\"\n         ${frozenColumns ? `xSplit=\"${frozenColumns}\"` : ''}\n         ${frozenRows ? `ySplit=\"${frozenRows}\"` : ''}\n         topLeftCell=\"${String.fromCharCode(65 + (frozenColumns || 0)) + ((frozenRows || 0) + 1)}\"\n       />` : ''}\n     </sheetView>\n   </sheetViews>\n\n   <sheetFormatPr x14ac:dyDescent=\"0.25\" ${!defaults.skipCustomHeight ? 'customHeight=\"1\"' : ''} defaultRowHeight=\"${defaults.rowHeight ? defaults.rowHeight * 0.75 : 15}\"\n     ${defaults.columnWidth ? `defaultColWidth=\"${toWidth(defaults.columnWidth)}\"` : ''} />\n\n   ${defaultCellStyleId != null || columns && columns.length > 0 ? `\n     <cols>\n       ${!columns || !columns.length ? `\n         <col min=\"1\" max=\"16384\" style=\"${defaultCellStyleId}\"\n              ${defaults.columnWidth ? `width=\"${toWidth(defaults.columnWidth)}\"` : ''} /> ` : ''}\n       ${foreach(columns, (column, ci) => {\n  const columnIndex = typeof column.index === \"number\" ? column.index + 1 : ci + 1;\n\n  if (column.width === 0) {\n    return `<col ${defaultCellStyleId != null ? `style=\"${defaultCellStyleId}\"` : ''}\n                        min=\"${columnIndex}\" max=\"${columnIndex}\" hidden=\"1\" customWidth=\"1\" />`;\n  }\n\n  return `<col ${defaultCellStyleId != null ? `style=\"${defaultCellStyleId}\"` : ''}\n                      min=\"${columnIndex}\" max=\"${columnIndex}\" customWidth=\"1\"\n                      ${column.autoWidth ? `width=\"${(column.width * 7 + 5) / 7 * 256 / 256}\" bestFit=\"1\"` : `width=\"${toWidth(column.width)}\"`} />`;\n})}\n     </cols>` : ''}\n\n   <sheetData>\n     ${foreach(data, (row, ri) => {\n  const rowIndex = typeof row.index === \"number\" ? row.index + 1 : ri + 1;\n  return `\n         <row r=\"${rowIndex}\" x14ac:dyDescent=\"0.25\"\n              ${row.level ? `outlineLevel=\"${row.level}\"` : ''}\n              ${row.height === 0 ? 'hidden=\"1\"' : row.height ? `ht=\"${toHeight(row.height)}\" customHeight=\"1\"` : \"\"}>\n           ${foreach(row.data, cell => `\n             <c r=\"${cell.ref}\" ${cell.style ? `s=\"${cell.style}\"` : ''} ${cell.type ? `t=\"${cell.type}\"` : ''}>\n               ${cell.formula != null ? writeFormula(cell.formula) : ''}\n               ${cell.value != null ? `<v>${ESC(cell.value)}</v>` : ''}\n             </c>`)}\n         </row>\n       `;\n})}\n   </sheetData>\n\n   ${autoFilter ? `<autoFilter ref=\"${autoFilter.from}:${autoFilter.to}\"/>` : filter ? spreadsheetFilters(filter) : ''}\n\n   ${mergeCells.length ? `\n     <mergeCells count=\"${mergeCells.length}\">\n       ${foreach(mergeCells, ref => `<mergeCell ref=\"${ref}\"/>`)}\n     </mergeCells>` : ''}\n\n   ${validations.length ? `\n     <dataValidations>\n       ${foreach(validations, val => `\n         <dataValidation sqref=\"${val.sqref.join(\" \")}\"\n                         showErrorMessage=\"${val.showErrorMessage}\"\n                         type=\"${ESC(val.type)}\"\n                         ${val.type !== \"list\" ? `operator=\"${ESC(val.operator)}\"` : ''}\n                         allowBlank=\"${val.allowBlank}\"\n                         showDropDown=\"${val.showDropDown}\"\n                         ${val.error ? `error=\"${ESC(val.error)}\"` : ''}\n                         ${val.errorTitle ? `errorTitle=\"${ESC(val.errorTitle)}\"` : ''}>\n           ${val.formula1 ? `<formula1>${ESC(val.formula1)}</formula1>` : ''}\n           ${val.formula2 ? `<formula2>${ESC(val.formula2)}</formula2>` : ''}\n         </dataValidation>`)}\n     </dataValidations>` : ''}\n\n   ${hyperlinks.length ? `\n     <hyperlinks>\n       ${foreach(hyperlinks, link => `\n         <hyperlink ref=\"${link.ref}\" r:id=\"${link.rId}\"/>`)}\n     </hyperlinks>` : ''}\n\n   <pageMargins left=\"0.7\" right=\"0.7\" top=\"0.75\" bottom=\"0.75\" header=\"0.3\" footer=\"0.3\" />\n   ${drawing ? `<drawing r:id=\"${drawing}\"/>` : ''}\n   ${legacyDrawing ? `<legacyDrawing r:id=\"${legacyDrawing}\"/>` : ''}\n</worksheet>`;\n\nconst WORKBOOK_RELS = ({\n  count\n}) => `${XMLHEAD}\n<Relationships xmlns=\"http://schemas.openxmlformats.org/package/2006/relationships\">\n  ${repeat(count, idx => `\n    <Relationship Id=\"rId${idx + 1}\" Type=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet\" Target=\"worksheets/sheet${idx + 1}.xml\" />`)}\n  <Relationship Id=\"rId${count + 1}\" Type=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles\" Target=\"styles.xml\" />\n  <Relationship Id=\"rId${count + 2}\" Type=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships/sharedStrings\" Target=\"sharedStrings.xml\" />\n</Relationships>`;\n\nconst WORKSHEET_RELS = ({\n  hyperlinks,\n  comments,\n  sheetIndex,\n  drawings\n}) => `${XMLHEAD}\n<Relationships xmlns=\"http://schemas.openxmlformats.org/package/2006/relationships\">\n  ${foreach(hyperlinks, link => `\n    <Relationship Id=\"${link.rId}\" Type=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships/hyperlink\" Target=\"${ESC(link.target)}\" TargetMode=\"External\" />`)}\n  ${!comments.length ? '' : `\n    <Relationship Id=\"comment${sheetIndex}\" Type=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships/comments\" Target=\"../comments${sheetIndex}.xml\"/>\n    <Relationship Id=\"vml${sheetIndex}\" Type=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships/vmlDrawing\" Target=\"../drawings/vmlDrawing${sheetIndex}.vml\"/>`}\n  ${!drawings.length ? '' : `\n    <Relationship Id=\"drw${sheetIndex}\" Type=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships/drawing\" Target=\"../drawings/drawing${sheetIndex}.xml\"/>`}\n</Relationships>`;\n\nconst COMMENTS_XML = ({\n  comments\n}) => `${XMLHEAD}\n<comments xmlns=\"http://schemas.openxmlformats.org/spreadsheetml/2006/main\">\n  <authors>\n    <author></author>\n  </authors>\n  <commentList>\n    ${foreach(comments, comment => `\n      <comment ref=\"${comment.ref}\" authorId=\"0\">\n        <text>\n          <r>\n            <rPr>\n              <sz val=\"8\"/>\n              <color indexed=\"81\"/>\n              <rFont val=\"Tahoma\"/>\n              <charset val=\"1\"/>\n            </rPr>\n            <t>${ESC(comment.text)}</t>\n          </r>\n        </text>\n      </comment>`)}\n  </commentList>\n</comments>`;\n\nconst LEGACY_DRAWING = ({\n  comments\n}) => `\\\n<xml xmlns:v=\"urn:schemas-microsoft-com:vml\"\n     xmlns:o=\"urn:schemas-microsoft-com:office:office\"\n     xmlns:x=\"urn:schemas-microsoft-com:office:excel\">\n  <v:shapetype coordsize=\"21600,21600\" id=\"_x0000_t202\" path=\"m,l,21600r21600,l21600,xe\">\n    <v:stroke joinstyle=\"miter\"/>\n    <v:path gradientshapeok=\"t\" o:connecttype=\"rect\"/>\n  </v:shapetype>\n  ${foreach(comments, comment => `\n    <v:shape type=\"#_x0000_t202\" style=\"visibility: hidden\" fillcolor=\"#ffffe1\" o:insetmode=\"auto\">\n      <v:shadow on=\"t\" color=\"black\" obscured=\"t\"/>\n      <x:ClientData ObjectType=\"Note\">\n        <x:MoveWithCells/>\n        <x:SizeWithCells/>\n        <x:Anchor>${comment.anchor}</x:Anchor>\n        <x:AutoFill>False</x:AutoFill>\n        <x:Row>${comment.row}</x:Row>\n        <x:Column>${comment.col}</x:Column>\n      </x:ClientData>\n    </v:shape>`)}\n</xml>`;\n\nconst DRAWINGS_XML = drawings => `${XMLHEAD}\n<xdr:wsDr xmlns:xdr=\"http://schemas.openxmlformats.org/drawingml/2006/spreadsheetDrawing\"\n          xmlns:a=\"http://schemas.openxmlformats.org/drawingml/2006/main\"\n          xmlns:r=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships\">\n  ${foreach(drawings, (drawing, index) => `\n    <xdr:oneCellAnchor editAs=\"oneCell\">\n      <xdr:from>\n        <xdr:col>${drawing.col}</xdr:col>\n        <xdr:colOff>${drawing.colOffset}</xdr:colOff>\n        <xdr:row>${drawing.row}</xdr:row>\n        <xdr:rowOff>${drawing.rowOffset}</xdr:rowOff>\n      </xdr:from>\n      <xdr:ext cx=\"${drawing.width}\" cy=\"${drawing.height}\" />\n      <xdr:pic>\n        <xdr:nvPicPr>\n          <xdr:cNvPr id=\"${index + 1}\" name=\"Picture ${index + 1}\"/>\n          <xdr:cNvPicPr/>\n        </xdr:nvPicPr>\n        <xdr:blipFill>\n          <a:blip r:embed=\"${drawing.imageId}\"/>\n          <a:stretch>\n            <a:fillRect/>\n          </a:stretch>\n        </xdr:blipFill>\n        <xdr:spPr>\n          <a:prstGeom prst=\"rect\">\n            <a:avLst/>\n          </a:prstGeom>\n        </xdr:spPr>\n      </xdr:pic>\n      <xdr:clientData/>\n    </xdr:oneCellAnchor>`)}\n</xdr:wsDr>`;\n\nconst DRAWINGS_RELS_XML = rels => `${XMLHEAD}\n<Relationships xmlns=\"http://schemas.openxmlformats.org/package/2006/relationships\">\n  ${foreach(rels, rel => `\n    <Relationship Id=\"${rel.rId}\" Type=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships/image\" Target=\"${rel.target}\"/>`)}\n</Relationships>`;\n\nconst SHARED_STRINGS = ({\n  count,\n  uniqueCount,\n  indexes\n}) => `${XMLHEAD}\n<sst xmlns=\"http://schemas.openxmlformats.org/spreadsheetml/2006/main\" count=\"${count}\" uniqueCount=\"${uniqueCount}\">\n  ${foreach(Object.keys(indexes), index => `\n    <si><t xml:space=\"preserve\">${ESC(index.substring(1))}</t></si>`)}\n</sst>`;\n\nconst STYLES = ({\n  formats,\n  fonts,\n  fills,\n  borders,\n  styles\n}) => `${XMLHEAD}\n<styleSheet\n    xmlns=\"http://schemas.openxmlformats.org/spreadsheetml/2006/main\"\n    xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\"\n    mc:Ignorable=\"x14ac\"\n    xmlns:x14ac=\"http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac\">\n  <numFmts count=\"${formats.length}\">\n  ${foreach(formats, (format, fi) => `\n    <numFmt formatCode=\"${ESC(format.format)}\" numFmtId=\"${165 + fi}\" />`)}\n  </numFmts>\n  <fonts count=\"${fonts.length + 1}\" x14ac:knownFonts=\"1\">\n    <font>\n       <sz val=\"11\" />\n       <color theme=\"1\" />\n       <name val=\"Calibri\" />\n       <family val=\"2\" />\n       <scheme val=\"minor\" />\n    </font>\n    ${foreach(fonts, font => `\n    <font>\n      ${font.bold ? '<b/>' : ''}\n      ${font.italic ? '<i/>' : ''}\n      ${font.underline ? '<u/>' : ''}\n      <sz val=\"${font.fontSize || 11}\" />\n      ${font.color ? `<color rgb=\"${ESC(font.color)}\" />` : '<color theme=\"1\" />'}\n      ${font.fontFamily ? `\n        <name val=\"${ESC(font.fontFamily)}\" />\n        <family val=\"2\" />\n      ` : `\n        <name val=\"Calibri\" />\n        <family val=\"2\" />\n        <scheme val=\"minor\" />\n      `}\n    </font>`)}\n  </fonts>\n  <fills count=\"${fills.length + 2}\">\n      <fill><patternFill patternType=\"none\"/></fill>\n      <fill><patternFill patternType=\"gray125\"/></fill>\n    ${foreach(fills, fill => `\n      ${fill.background ? `\n        <fill>\n          <patternFill patternType=\"solid\">\n              <fgColor rgb=\"${ESC(fill.background)}\"/>\n          </patternFill>\n        </fill>\n      ` : ''}`)}\n  </fills>\n  <borders count=\"${borders.length + 1}\">\n    <border><left/><right/><top/><bottom/><diagonal/></border>\n    ${foreach(borders, borderTemplate)}\n  </borders>\n  <cellStyleXfs count=\"1\">\n    <xf borderId=\"0\" fillId=\"0\" fontId=\"0\" />\n  </cellStyleXfs>\n  <cellXfs count=\"${styles.length + 1}\">\n    <xf numFmtId=\"0\" fontId=\"0\" fillId=\"0\" borderId=\"0\" xfId=\"0\" />\n    ${foreach(styles, style => `\n      <xf xfId=\"0\"\n          ${style.fontId ? `fontId=\"${style.fontId}\" applyFont=\"1\"` : ''}\n          ${style.fillId ? `fillId=\"${style.fillId}\" applyFill=\"1\"` : ''}\n          ${style.numFmtId ? `numFmtId=\"${style.numFmtId}\" applyNumberFormat=\"1\"` : ''}\n          ${style.textAlign || style.verticalAlign || style.wrap ? 'applyAlignment=\"1\"' : ''}\n          ${style.borderId ? `borderId=\"${style.borderId}\" applyBorder=\"1\"` : ''}>\n        ${style.textAlign || style.verticalAlign || style.wrap ? `\n        <alignment\n          ${style.textAlign ? `horizontal=\"${ESC(style.textAlign)}\"` : ''}\n          ${style.verticalAlign ? `vertical=\"${ESC(style.verticalAlign)}\"` : ''}\n          ${style.indent ? `indent=\"${ESC(style.indent)}\"` : ''}\n          ${style.wrap ? 'wrapText=\"1\"' : ''} />\n        ` : ''}\n      </xf>\n    `)}\n  </cellXfs>\n  <cellStyles count=\"1\">\n    <cellStyle name=\"Normal\" xfId=\"0\" builtinId=\"0\"/>\n  </cellStyles>\n  <dxfs count=\"0\" />\n  <tableStyles count=\"0\" defaultTableStyle=\"TableStyleMedium2\" defaultPivotStyle=\"PivotStyleMedium9\" />\n</styleSheet>`;\n\nfunction writeFormula(formula) {\n  if (typeof formula == \"string\") {\n    return `<f>${ESC(formula)}</f>`;\n  } // array formulas\n\n\n  return `<f t=\"array\" ref=\"${formula.ref}\">${ESC(formula.src)}</f>`;\n}\n\nfunction numChar(colIndex) {\n  const letter = Math.floor(colIndex / 26) - 1;\n  return (letter >= 0 ? numChar(letter) : \"\") + String.fromCharCode(65 + colIndex % 26);\n}\n\nfunction ref(rowIndex, colIndex) {\n  return numChar(colIndex) + (rowIndex + 1);\n}\n\nfunction $ref(rowIndex, colIndex) {\n  return \"$\" + numChar(colIndex) + \"$\" + (rowIndex + 1);\n}\n\nfunction filterRowIndex(options) {\n  const frozenRows = options.frozenRows || (options.freezePane || {}).rowSplit || 1;\n  return frozenRows - 1;\n}\n\nfunction toWidth(px) {\n  const maximumDigitWidth = 7;\n  return px / maximumDigitWidth - Math.floor(128 / maximumDigitWidth) / 256;\n}\n\nfunction toHeight(px) {\n  return px * 0.75;\n}\n\nfunction stripFunnyChars(value) {\n  return String(value).replace(/[\\x00-\\x09\\x0B\\x0C\\x0E-\\x1F]/g, \"\") // leave CRLF in\n  .replace(/\\r?\\n/g, \"\\r\\n\"); // make sure LF is preceded by CR\n}\n\nclass Worksheet {\n  constructor(options, sharedStrings, styles, borders) {\n    this.options = options;\n    this._strings = sharedStrings;\n    this._styles = styles;\n    this._borders = borders;\n    this._validations = {};\n    this._comments = [];\n    this._drawings = options.drawings || [];\n    this._hyperlinks = (this.options.hyperlinks || []).map((link, i) => Object.assign({}, link, {\n      rId: `link${i}`\n    }));\n  }\n\n  relsToXML() {\n    const hyperlinks = this._hyperlinks;\n    const comments = this._comments;\n    const drawings = this._drawings;\n\n    if (hyperlinks.length || comments.length || drawings.length) {\n      return WORKSHEET_RELS({\n        hyperlinks: hyperlinks,\n        comments: comments,\n        sheetIndex: this.options.sheetIndex,\n        drawings: drawings\n      });\n    }\n  }\n\n  toXML(index) {\n    const mergeCells = this.options.mergedCells || [];\n    const rows = this.options.rows || [];\n    const data = inflate(rows, mergeCells);\n\n    this._readCells(data);\n\n    let autoFilter = this.options.filter;\n    let filter;\n\n    if (autoFilter && typeof autoFilter.from === \"number\" && typeof autoFilter.to === \"number\") {\n      // Grid enables auto filter\n      autoFilter = {\n        from: ref(filterRowIndex(this.options), autoFilter.from),\n        to: ref(filterRowIndex(this.options), autoFilter.to)\n      };\n    } else if (autoFilter && autoFilter.ref && autoFilter.columns) {\n      // this is probably from the Spreadsheet\n      filter = autoFilter;\n      autoFilter = null;\n    }\n\n    const validations = [];\n\n    for (let i in this._validations) {\n      if (Object.prototype.hasOwnProperty.call(this._validations, i)) {\n        validations.push(this._validations[i]);\n      }\n    }\n\n    let defaultCellStyleId = null;\n\n    if (this.options.defaultCellStyle) {\n      defaultCellStyleId = this._lookupStyle(this.options.defaultCellStyle);\n    }\n\n    const freezePane = this.options.freezePane || {};\n    const defaults = this.options.defaults || {};\n    const lastRow = this.options.rows ? this._getLastRow() : 1;\n    const lastCol = this.options.rows ? this._getLastCol() : 1;\n    return WORKSHEET({\n      frozenColumns: this.options.frozenColumns || freezePane.colSplit,\n      frozenRows: this.options.frozenRows || freezePane.rowSplit,\n      columns: this.options.columns,\n      defaults: defaults,\n      data: data,\n      index: index,\n      mergeCells: mergeCells,\n      autoFilter: autoFilter,\n      filter: filter,\n      showGridLines: this.options.showGridLines,\n      hyperlinks: this._hyperlinks,\n      validations: validations,\n      defaultCellStyleId: defaultCellStyleId,\n      rtl: this.options.rtl !== undefined ? this.options.rtl : defaults.rtl,\n      legacyDrawing: this._comments.length ? `vml${this.options.sheetIndex}` : null,\n      drawing: this._drawings.length ? `drw${this.options.sheetIndex}` : null,\n      lastRow: lastRow,\n      lastCol: lastCol\n    });\n  }\n\n  commentsXML() {\n    if (this._comments.length) {\n      return COMMENTS_XML({\n        comments: this._comments\n      });\n    }\n  }\n\n  drawingsXML(images) {\n    if (this._drawings.length) {\n      let rels = {};\n\n      let main = this._drawings.map(drw => {\n        let ref = parseRef(drw.topLeftCell);\n        let img = rels[drw.image];\n\n        if (!img) {\n          img = rels[drw.image] = {\n            rId: `img${drw.image}`,\n            target: images[drw.image].target\n          };\n        }\n\n        return {\n          col: ref.col,\n          colOffset: pixelsToExcel(drw.offsetX),\n          row: ref.row,\n          rowOffset: pixelsToExcel(drw.offsetY),\n          width: pixelsToExcel(drw.width),\n          height: pixelsToExcel(drw.height),\n          imageId: img.rId\n        };\n      });\n\n      return {\n        main: DRAWINGS_XML(main),\n        rels: DRAWINGS_RELS_XML(rels)\n      };\n    }\n  }\n\n  legacyDrawing() {\n    if (this._comments.length) {\n      return LEGACY_DRAWING({\n        comments: this._comments\n      });\n    }\n  }\n\n  _lookupString(value) {\n    const key = \"$\" + value;\n    const index = this._strings.indexes[key];\n    let result;\n\n    if (index !== undefined) {\n      result = index;\n    } else {\n      result = this._strings.indexes[key] = this._strings.uniqueCount;\n      this._strings.uniqueCount++;\n    }\n\n    this._strings.count++;\n    return result;\n  }\n\n  _lookupStyle(style) {\n    const json = JSON.stringify(style);\n\n    if (json === \"{}\") {\n      return 0;\n    }\n\n    let index = indexOf(json, this._styles);\n\n    if (index < 0) {\n      index = this._styles.push(json) - 1;\n    } // There is one default style\n\n\n    return index + 1;\n  }\n\n  _lookupBorder(border) {\n    const json = JSON.stringify(border);\n\n    if (json === \"{}\") {\n      return;\n    }\n\n    let index = indexOf(json, this._borders);\n\n    if (index < 0) {\n      index = this._borders.push(json) - 1;\n    } // There is one default border\n\n\n    return index + 1;\n  }\n\n  _readCells(rowData) {\n    for (let i = 0; i < rowData.length; i++) {\n      const row = rowData[i];\n      const cells = row.cells;\n      row.data = [];\n\n      for (let j = 0; j < cells.length; j++) {\n        const cellData = this._cell(cells[j], row.index, j);\n\n        if (cellData) {\n          row.data.push(cellData);\n        }\n      }\n    }\n  }\n\n  _cell(data, rowIndex, cellIndex) {\n    if (!data || data === EMPTY_CELL) {\n      return null;\n    }\n\n    let value = data.value;\n    let border = {};\n\n    if (data.borderLeft) {\n      border.left = data.borderLeft;\n    }\n\n    if (data.borderRight) {\n      border.right = data.borderRight;\n    }\n\n    if (data.borderTop) {\n      border.top = data.borderTop;\n    }\n\n    if (data.borderBottom) {\n      border.bottom = data.borderBottom;\n    }\n\n    border = this._lookupBorder(border);\n    const defStyle = this.options.defaultCellStyle || {};\n    let style = {\n      borderId: border\n    };\n\n    (function (add) {\n      add(\"color\");\n      add(\"background\");\n      add(\"bold\");\n      add(\"italic\");\n      add(\"underline\");\n\n      if (!add(\"fontFamily\")) {\n        add(\"fontName\", \"fontFamily\");\n      }\n\n      add(\"fontSize\");\n      add(\"format\");\n\n      if (!add(\"textAlign\")) {\n        add(\"hAlign\", \"textAlign\");\n      }\n\n      if (!add(\"verticalAlign\")) {\n        add(\"vAlign\", \"verticalAlign\");\n      }\n\n      add(\"wrap\");\n      add(\"indent\");\n    })(function (prop, target) {\n      let val = data[prop];\n\n      if (val === undefined) {\n        val = defStyle[prop];\n      }\n\n      if (val !== undefined) {\n        style[target || prop] = val;\n        return true;\n      }\n    });\n\n    const columns = this.options.columns || [];\n    const column = columns[cellIndex];\n    let type = typeof value;\n\n    if (column && column.autoWidth && (!data.colSpan || data.colSpan === 1)) {\n      let displayValue = value; // XXX: let's not bring kendo.toString in only for this.\n      //      better wait until the spreadsheet engine is available as a separate\n      //      component, then we can use a real Excel-like formatter.\n      //\n\n      if (type === \"number\") {\n        // kendo.toString will not behave exactly like the Excel format\n        // Still, it's the best we have available for estimating the character count.\n        displayValue = IntlService.toString(value, data.format);\n      }\n\n      column.width = Math.max(column.width || 0, String(displayValue).length);\n    }\n\n    if (type === \"string\") {\n      value = stripFunnyChars(value);\n      value = this._lookupString(value);\n      type = \"s\";\n    } else if (type === \"number\") {\n      type = \"n\";\n    } else if (type === \"boolean\") {\n      type = \"b\";\n      value = Number(value);\n    } else if (value && value.getTime) {\n      type = null;\n      value = dateToSerial(value);\n\n      if (!style.format) {\n        style.format = \"mm-dd-yy\";\n      }\n    } else {\n      type = null;\n      value = null;\n    }\n\n    style = this._lookupStyle(style);\n    const cellName = ref(rowIndex, cellIndex);\n\n    if (data.validation) {\n      this._addValidation(data.validation, cellName);\n    }\n\n    if (data.comment) {\n      let anchor = [cellIndex + 1, // start column\n      15, // start column offset\n      rowIndex, // start row\n      10, // start row offset\n      cellIndex + 3, // end column\n      15, // end column offset\n      rowIndex + 3, // end row\n      4 // end row offset\n      ];\n\n      this._comments.push({\n        ref: cellName,\n        text: data.comment,\n        row: rowIndex,\n        col: cellIndex,\n        anchor: anchor.join(\", \")\n      });\n    }\n\n    return {\n      value: value,\n      formula: data.formula,\n      type: type,\n      style: style,\n      ref: cellName\n    };\n  }\n\n  _addValidation(v, ref) {\n    const tmp = {\n      showErrorMessage: v.type === \"reject\" ? 1 : 0,\n      formula1: v.from,\n      formula2: v.to,\n      type: MAP_EXCEL_TYPE[v.dataType] || v.dataType,\n      operator: MAP_EXCEL_OPERATOR[v.comparerType] || v.comparerType,\n      allowBlank: v.allowNulls ? 1 : 0,\n      showDropDown: v.showButton ? 0 : 1,\n      // LOL, Excel!\n      error: v.messageTemplate,\n      errorTitle: v.titleTemplate\n    };\n    const json = JSON.stringify(tmp);\n\n    if (!this._validations[json]) {\n      this._validations[json] = tmp;\n      tmp.sqref = [];\n    }\n\n    this._validations[json].sqref.push(ref);\n  }\n\n  _getLastRow() {\n    return countData(this.options.rows);\n  }\n\n  _getLastCol() {\n    let last = 0;\n    this.options.rows.forEach(function (row) {\n      if (row.cells) {\n        last = Math.max(last, countData(row.cells));\n      }\n    });\n    return last;\n  }\n\n}\n\nfunction countData(data) {\n  let last = data.length;\n  data.forEach(function (el) {\n    if (el.index && el.index >= last) {\n      last = el.index + 1;\n    }\n  });\n  return last;\n}\n\nconst MAP_EXCEL_OPERATOR = {\n  // includes only what differs; key is our operator, value is Excel\n  // operator.\n  greaterThanOrEqualTo: \"greaterThanOrEqual\",\n  lessThanOrEqualTo: \"lessThanOrEqual\"\n};\nconst MAP_EXCEL_TYPE = {\n  number: \"decimal\"\n};\nconst defaultFormats = {\n  \"General\": 0,\n  \"0\": 1,\n  \"0.00\": 2,\n  \"#,##0\": 3,\n  \"#,##0.00\": 4,\n  \"0%\": 9,\n  \"0.00%\": 10,\n  \"0.00E+00\": 11,\n  \"# ?/?\": 12,\n  \"# ??/??\": 13,\n  \"mm-dd-yy\": 14,\n  \"d-mmm-yy\": 15,\n  \"d-mmm\": 16,\n  \"mmm-yy\": 17,\n  \"h:mm AM/PM\": 18,\n  \"h:mm:ss AM/PM\": 19,\n  \"h:mm\": 20,\n  \"h:mm:ss\": 21,\n  \"m/d/yy h:mm\": 22,\n  \"#,##0 ;(#,##0)\": 37,\n  \"#,##0 ;[Red](#,##0)\": 38,\n  \"#,##0.00;(#,##0.00)\": 39,\n  \"#,##0.00;[Red](#,##0.00)\": 40,\n  \"mm:ss\": 45,\n  \"[h]:mm:ss\": 46,\n  \"mmss.0\": 47,\n  \"##0.0E+0\": 48,\n  \"@\": 49,\n  \"[$-404]e/m/d\": 27,\n  \"m/d/yy\": 30,\n  \"t0\": 59,\n  \"t0.00\": 60,\n  \"t#,##0\": 61,\n  \"t#,##0.00\": 62,\n  \"t0%\": 67,\n  \"t0.00%\": 68,\n  \"t# ?/?\": 69,\n  \"t# ??/??\": 70\n};\n\nfunction convertColor(value) {\n  let color = value;\n\n  if (color.length < 6) {\n    color = color.replace(/(\\w)/g, function ($0, $1) {\n      return $1 + $1;\n    });\n  }\n\n  color = color.substring(1).toUpperCase();\n\n  if (color.length < 8) {\n    color = \"FF\" + color;\n  }\n\n  return color;\n}\n\nclass Workbook {\n  constructor(options) {\n    this.options = options || {};\n    this._strings = {\n      indexes: {},\n      count: 0,\n      uniqueCount: 0\n    };\n    this._styles = [];\n    this._borders = [];\n    this._images = this.options.images;\n    this._imgId = 0;\n    this._sheets = map(this.options.sheets || [], (options, i) => {\n      options.defaults = this.options;\n      options.sheetIndex = i + 1;\n      return new Worksheet(options, this._strings, this._styles, this._borders);\n    });\n  }\n\n  imageFilename(mimeType) {\n    const id = ++this._imgId;\n\n    switch (mimeType) {\n      case \"image/jpg\":\n      case \"image/jpeg\":\n        return `image${id}.jpg`;\n\n      case \"image/png\":\n        return `image${id}.png`;\n\n      case \"image/gif\":\n        return `image${id}.gif`;\n\n      default:\n        return `image${id}.bin`;\n      // XXX: anything better to do here?\n    }\n  }\n\n  toZIP() {\n    const zip = createZip();\n    const docProps = zip.folder(\"docProps\");\n    docProps.file(\"core.xml\", CORE({\n      creator: this.options.creator || \"Kendo UI\",\n      lastModifiedBy: this.options.creator || \"Kendo UI\",\n      created: this.options.date || new Date().toJSON(),\n      modified: this.options.date || new Date().toJSON()\n    }));\n    const sheetCount = this._sheets.length;\n    docProps.file(\"app.xml\", APP({\n      sheets: this._sheets\n    }));\n    const rels = zip.folder(\"_rels\");\n    rels.file(\".rels\", RELS);\n    const xl = zip.folder(\"xl\");\n    const xlRels = xl.folder(\"_rels\");\n    xlRels.file(\"workbook.xml.rels\", WORKBOOK_RELS({\n      count: sheetCount\n    }));\n\n    if (this._images) {\n      const media = xl.folder(\"media\");\n      Object.keys(this._images).forEach(id => {\n        const img = this._images[id];\n        const filename = this.imageFilename(img.type);\n        media.file(filename, img.data);\n        img.target = `../media/${filename}`;\n      });\n    }\n\n    const sheetIds = {};\n    xl.file(\"workbook.xml\", WORKBOOK({\n      sheets: this._sheets,\n      filterNames: map(this._sheets, function (sheet, index) {\n        const options = sheet.options;\n        const sheetName = options.name || options.title || \"Sheet\" + (index + 1);\n        sheetIds[sheetName.toLowerCase()] = index;\n        const filter = options.filter;\n\n        if (filter) {\n          if (filter.ref) {\n            // spreadsheet provides `ref`\n            let a = filter.ref.split(\":\");\n            let from = parseRef(a[0]);\n            let to = parseRef(a[1]);\n            return {\n              localSheetId: index,\n              name: sheetName,\n              from: $ref(from.row, from.col),\n              to: $ref(to.row, to.col)\n            };\n          } else if (typeof filter.from !== \"undefined\" && typeof filter.to !== \"undefined\") {\n            // grid does this\n            return {\n              localSheetId: index,\n              name: sheetName,\n              from: $ref(filterRowIndex(options), filter.from),\n              to: $ref(filterRowIndex(options), filter.to)\n            };\n          }\n        }\n      }),\n      userNames: map(this.options.names || [], function (def) {\n        return {\n          name: def.localName,\n          localSheetId: def.sheet ? sheetIds[def.sheet.toLowerCase()] : null,\n          value: def.value,\n          hidden: def.hidden\n        };\n      })\n    }));\n    const worksheets = xl.folder(\"worksheets\");\n    const drawings = xl.folder(\"drawings\");\n    const drawingsRels = drawings.folder(\"_rels\");\n    const sheetRels = worksheets.folder(\"_rels\");\n    const commentFiles = [];\n    const drawingFiles = [];\n\n    for (let idx = 0; idx < sheetCount; idx++) {\n      const sheet = this._sheets[idx];\n      const sheetName = `sheet${idx + 1}.xml`;\n      const sheetXML = sheet.toXML(idx); // must be called before relsToXML\n\n      const relsXML = sheet.relsToXML();\n      const commentsXML = sheet.commentsXML();\n      const legacyDrawing = sheet.legacyDrawing();\n      const drawingsXML = sheet.drawingsXML(this._images);\n\n      if (relsXML) {\n        sheetRels.file(sheetName + \".rels\", relsXML);\n      }\n\n      if (commentsXML) {\n        let name = `comments${sheet.options.sheetIndex}.xml`;\n        xl.file(name, commentsXML);\n        commentFiles.push(name);\n      }\n\n      if (legacyDrawing) {\n        drawings.file(`vmlDrawing${sheet.options.sheetIndex}.vml`, legacyDrawing);\n      }\n\n      if (drawingsXML) {\n        let name = `drawing${sheet.options.sheetIndex}.xml`;\n        drawings.file(name, drawingsXML.main);\n        drawingsRels.file(`${name}.rels`, drawingsXML.rels);\n        drawingFiles.push(name);\n      }\n\n      worksheets.file(sheetName, sheetXML);\n    }\n\n    const borders = map(this._borders, parseJSON);\n    const styles = map(this._styles, parseJSON);\n\n    const hasFont = function (style) {\n      return style.underline || style.bold || style.italic || style.color || style.fontFamily || style.fontSize;\n    };\n\n    const convertFontSize = function (value) {\n      let fontInPx = Number(value);\n      let fontInPt;\n\n      if (fontInPx) {\n        fontInPt = fontInPx * 3 / 4;\n      }\n\n      return fontInPt;\n    };\n\n    const fonts = map(styles, function (style) {\n      if (style.fontSize) {\n        style.fontSize = convertFontSize(style.fontSize);\n      }\n\n      if (style.color) {\n        style.color = convertColor(style.color);\n      }\n\n      if (hasFont(style)) {\n        return style;\n      }\n    });\n    const formats = map(styles, function (style) {\n      if (style.format && defaultFormats[style.format] === undefined) {\n        return style;\n      }\n    });\n    const fills = map(styles, function (style) {\n      if (style.background) {\n        style.background = convertColor(style.background);\n        return style;\n      }\n    });\n    xl.file(\"styles.xml\", STYLES({\n      fonts: fonts,\n      fills: fills,\n      formats: formats,\n      borders: borders,\n      styles: map(styles, function (style) {\n        const result = {};\n\n        if (hasFont(style)) {\n          result.fontId = indexOf(style, fonts) + 1;\n        }\n\n        if (style.background) {\n          result.fillId = indexOf(style, fills) + 2;\n        }\n\n        result.textAlign = style.textAlign;\n        result.indent = style.indent;\n        result.verticalAlign = style.verticalAlign;\n        result.wrap = style.wrap;\n        result.borderId = style.borderId;\n\n        if (style.format) {\n          if (defaultFormats[style.format] !== undefined) {\n            result.numFmtId = defaultFormats[style.format];\n          } else {\n            result.numFmtId = 165 + indexOf(style, formats);\n          }\n        }\n\n        return result;\n      })\n    }));\n    xl.file(\"sharedStrings.xml\", SHARED_STRINGS(this._strings));\n    zip.file(\"[Content_Types].xml\", CONTENT_TYPES({\n      sheetCount: sheetCount,\n      commentFiles: commentFiles,\n      drawingFiles: drawingFiles\n    }));\n    return zip;\n  }\n\n  toDataURL() {\n    const zip = this.toZIP();\n    return zip.generateAsync ? zip.generateAsync(DATA_URL_OPTIONS).then(toDataURI) : toDataURI(zip.generate(DATA_URL_OPTIONS));\n  }\n\n  toBlob() {\n    const zip = this.toZIP();\n\n    if (zip.generateAsync) {\n      return zip.generateAsync(BLOB_OPTIONS);\n    }\n\n    return new Blob([zip.generate(ARRAYBUFFER_OPTIONS)], {\n      type: MIME_TYPE\n    });\n  }\n\n}\n\nfunction borderStyle(width) {\n  let alias = \"thin\";\n\n  if (width === 2) {\n    alias = \"medium\";\n  } else if (width === 3) {\n    alias = \"thick\";\n  }\n\n  return alias;\n}\n\nfunction borderSideTemplate(name, style) {\n  let result = \"\";\n\n  if (style) {\n    result += \"<\" + name + \" style=\\\"\" + borderStyle(style.size) + \"\\\">\";\n\n    if (style.color) {\n      result += \"<color rgb=\\\"\" + convertColor(style.color) + \"\\\"/>\";\n    }\n\n    result += \"</\" + name + \">\";\n  }\n\n  return result;\n}\n\nfunction borderTemplate(border) {\n  return \"<border>\" + borderSideTemplate(\"left\", border.left) + borderSideTemplate(\"right\", border.right) + borderSideTemplate(\"top\", border.top) + borderSideTemplate(\"bottom\", border.bottom) + \"</border>\";\n}\n\nconst EMPTY_CELL = {};\n\nfunction inflate(rows, mergedCells) {\n  const rowData = [];\n  const rowsByIndex = [];\n  indexRows(rows, function (row, index) {\n    const data = {\n      _source: row,\n      index: index,\n      height: row.height,\n      level: row.level,\n      cells: []\n    };\n    rowData.push(data);\n    rowsByIndex[index] = data;\n  });\n  const sorted = sortByIndex(rowData).slice(0);\n  const ctx = {\n    rowData: rowData,\n    rowsByIndex: rowsByIndex,\n    mergedCells: mergedCells\n  };\n\n  for (let i = 0; i < sorted.length; i++) {\n    fillCells(sorted[i], ctx);\n    delete sorted[i]._source;\n  }\n\n  return sortByIndex(rowData);\n}\n\nfunction indexRows(rows, callback) {\n  for (let i = 0; i < rows.length; i++) {\n    const row = rows[i];\n\n    if (!row) {\n      continue;\n    }\n\n    let index = row.index;\n\n    if (typeof index !== \"number\") {\n      index = i;\n    }\n\n    callback(row, index);\n  }\n}\n\nfunction sortByIndex(items) {\n  return items.sort(function (a, b) {\n    return a.index - b.index;\n  });\n}\n\nfunction pushUnique(array, el) {\n  if (array.indexOf(el) < 0) {\n    array.push(el);\n  }\n}\n\nfunction getSpan(mergedCells, ref) {\n  for (let i = 0; i < mergedCells.length; ++i) {\n    const range = mergedCells[i];\n    const a = range.split(\":\");\n    let topLeft = a[0];\n\n    if (topLeft === ref) {\n      let bottomRight = a[1];\n      topLeft = parseRef(topLeft);\n      bottomRight = parseRef(bottomRight);\n      return {\n        rowSpan: bottomRight.row - topLeft.row + 1,\n        colSpan: bottomRight.col - topLeft.col + 1\n      };\n    }\n  }\n}\n\nfunction parseRef(ref) {\n  function getcol(str) {\n    let upperStr = str.toUpperCase();\n    let col = 0;\n\n    for (let i = 0; i < upperStr.length; ++i) {\n      col = col * 26 + upperStr.charCodeAt(i) - 64;\n    }\n\n    return col - 1;\n  }\n\n  function getrow(str) {\n    return parseInt(str, 10) - 1;\n  }\n\n  const m = /^([a-z]+)(\\d+)$/i.exec(ref);\n  return {\n    row: getrow(m[2]),\n    col: getcol(m[1])\n  };\n}\n\nfunction pixelsToExcel(px) {\n  return Math.round(px * 9525);\n}\n\nfunction fillCells(data, ctx) {\n  const row = data._source;\n  const rowIndex = data.index;\n  const cells = row.cells;\n  const cellData = data.cells;\n\n  if (!cells) {\n    return;\n  }\n\n  for (let i = 0; i < cells.length; i++) {\n    const cell = cells[i] || EMPTY_CELL;\n    let rowSpan = cell.rowSpan || 1;\n    let colSpan = cell.colSpan || 1;\n    const cellIndex = insertCell(cellData, cell);\n    const topLeftRef = ref(rowIndex, cellIndex);\n\n    if (rowSpan === 1 && colSpan === 1) {\n      // could still be merged: the spreadsheet does not send\n      // rowSpan/colSpan, but mergedCells is already populated.\n      // https://github.com/telerik/kendo-ui-core/issues/2401\n      const tmp = getSpan(ctx.mergedCells, topLeftRef);\n\n      if (tmp) {\n        colSpan = tmp.colSpan;\n        rowSpan = tmp.rowSpan;\n      }\n    }\n\n    spanCell(cell, cellData, cellIndex, colSpan);\n\n    if (rowSpan > 1 || colSpan > 1) {\n      pushUnique(ctx.mergedCells, topLeftRef + \":\" + ref(rowIndex + rowSpan - 1, cellIndex + colSpan - 1));\n    }\n\n    if (rowSpan > 1) {\n      for (let ri = rowIndex + 1; ri < rowIndex + rowSpan; ri++) {\n        let nextRow = ctx.rowsByIndex[ri];\n\n        if (!nextRow) {\n          nextRow = ctx.rowsByIndex[ri] = {\n            index: ri,\n            cells: []\n          };\n          ctx.rowData.push(nextRow);\n        }\n\n        spanCell(cell, nextRow.cells, cellIndex - 1, colSpan + 1);\n      }\n    }\n  }\n}\n\nfunction insertCell(data, cell) {\n  let index;\n\n  if (typeof cell.index === \"number\") {\n    index = cell.index;\n    insertCellAt(data, cell, cell.index);\n  } else {\n    index = appendCell(data, cell);\n  }\n\n  return index;\n}\n\nfunction insertCellAt(data, cell, index) {\n  data[index] = cell;\n}\n\nfunction appendCell(data, cell) {\n  let index = data.length;\n\n  for (let i = 0; i < data.length + 1; i++) {\n    if (!data[i]) {\n      data[i] = cell;\n      index = i;\n      break;\n    }\n  }\n\n  return index;\n}\n\nfunction spanCell(cell, row, startIndex, colSpan) {\n  for (let i = 1; i < colSpan; i++) {\n    const tmp = {\n      borderTop: cell.borderTop,\n      borderRight: cell.borderRight,\n      borderBottom: cell.borderBottom,\n      borderLeft: cell.borderLeft\n    };\n    insertCellAt(row, tmp, startIndex + i);\n  }\n}\n\nconst SPREADSHEET_FILTERS = ({\n  ref,\n  columns,\n  generators\n}) => `\n<autoFilter ref=\"${ref}\">\n  ${foreach(columns, col => `\n    <filterColumn colId=\"${col.index}\">\n      ${generators[col.filter](col)}\n    </filterColumn>\n  `)}\n</autoFilter>`;\n\nconst SPREADSHEET_CUSTOM_FILTER = ({\n  logic,\n  criteria\n}) => `\n<customFilters ${logic === 'and' ? 'and=\"1\"' : ''}>\n${foreach(criteria, f => {\n  let op = spreadsheetFilters.customOperator(f);\n  let val = spreadsheetFilters.customValue(f);\n  return `<customFilter ${op ? `operator=\"${op}\"` : ''} val=\"${val}\"/>`;\n})}\n</customFilters>`;\n\nconst SPREADSHEET_DYNAMIC_FILTER = ({\n  type\n}) => `<dynamicFilter type=\"${spreadsheetFilters.dynamicFilterType(type)}\" />`;\n\nconst SPREADSHEET_TOP_FILTER = ({\n  type,\n  value\n}) => `<top10 percent=\"${/percent$/i.test(type) ? 1 : 0}\"\n       top=\"${/^top/i.test(type) ? 1 : 0}\"\n       val=\"${value}\" />`;\n\nconst SPREADSHEET_VALUE_FILTER = ({\n  blanks,\n  values\n}) => `<filters ${blanks ? 'blank=\"1\"' : ''}>\n    ${foreach(values, value => `\n      <filter val=\"${value}\" />`)}\n  </filters>`;\n\nfunction spreadsheetFilters(filter) {\n  return SPREADSHEET_FILTERS({\n    ref: filter.ref,\n    columns: filter.columns,\n    generators: {\n      custom: SPREADSHEET_CUSTOM_FILTER,\n      dynamic: SPREADSHEET_DYNAMIC_FILTER,\n      top: SPREADSHEET_TOP_FILTER,\n      value: SPREADSHEET_VALUE_FILTER\n    }\n  });\n}\n\nspreadsheetFilters.customOperator = function (f) {\n  return {\n    eq: \"equal\",\n    gt: \"greaterThan\",\n    gte: \"greaterThanOrEqual\",\n    lt: \"lessThan\",\n    lte: \"lessThanOrEqual\",\n    ne: \"notEqual\",\n    // These are not in the spec, but seems to be how Excel does\n    // it (see customValue below).  For the non-negated versions,\n    // the operator attribute is missing completely.\n    doesnotstartwith: \"notEqual\",\n    doesnotendwith: \"notEqual\",\n    doesnotcontain: \"notEqual\",\n    doesnotmatch: \"notEqual\"\n  }[f.operator.toLowerCase()];\n};\n\nfunction quoteSheet(name) {\n  if (/^\\'/.test(name)) {\n    // assume already quoted, the Spreadsheet does it.\n    return name;\n  }\n\n  if (/^[a-z_][a-z0-9_]*$/i.test(name)) {\n    return name; // no need to quote it\n  }\n\n  return \"'\" + name.replace(/\\x27/g, \"\\\\'\") + \"'\";\n}\n\nspreadsheetFilters.customValue = function (f) {\n  function esc(str) {\n    return str.replace(/([*?])/g, \"~$1\");\n  }\n\n  switch (f.operator.toLowerCase()) {\n    case \"startswith\":\n    case \"doesnotstartwith\":\n      return esc(f.value) + \"*\";\n\n    case \"endswith\":\n    case \"doesnotendwith\":\n      return \"*\" + esc(f.value);\n\n    case \"contains\":\n    case \"doesnotcontain\":\n      return \"*\" + esc(f.value) + \"*\";\n\n    default:\n      return f.value;\n  }\n};\n\nspreadsheetFilters.dynamicFilterType = function (type) {\n  return {\n    quarter1: \"Q1\",\n    quarter2: \"Q2\",\n    quarter3: \"Q3\",\n    quarter4: \"Q4\",\n    january: \"M1\",\n    february: \"M2\",\n    march: \"M3\",\n    april: \"M4\",\n    may: \"M5\",\n    june: \"M6\",\n    july: \"M7\",\n    august: \"M8\",\n    september: \"M9\",\n    october: \"M10\",\n    november: \"M11\",\n    december: \"M12\"\n  }[type.toLowerCase()] || type;\n};\n\nexport { Workbook, Worksheet };","map":null,"metadata":{},"sourceType":"module"}