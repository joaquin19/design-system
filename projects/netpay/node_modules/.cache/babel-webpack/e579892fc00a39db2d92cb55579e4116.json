{"ast":null,"code":"import { isPresent, isNumeric, isDate } from './utils';\nimport { getter } from './accessor';\n\nconst valueToString = value => {\n  value = isPresent(value) && value.getTime ? value.getTime() : value;\n  return value + \"\";\n};\n/**\n * @hidden\n */\n\n\nexport const groupCombinator = field => {\n  const prop = getter(field, true);\n  let position = 0;\n  return (agg, value) => {\n    agg[field] = agg[field] || {};\n    const groupValue = prop(value);\n    const key = valueToString(groupValue);\n    const values = agg[field][key] || {\n      __position: position++,\n      aggregates: {},\n      items: [],\n      value: groupValue\n    };\n    values.items.push(value);\n    agg[field][key] = values;\n    return agg;\n  };\n};\n/**\n * @hidden\n */\n\nexport const expandAggregates = (result = {}) => {\n  Object.keys(result).forEach(field => {\n    const aggregates = result[field];\n    Object.keys(aggregates).forEach(aggregate => {\n      aggregates[aggregate] = aggregates[aggregate].result();\n    });\n  });\n  return result;\n};\n\nconst aggregatesFuncs = name => ({\n  average: () => {\n    let value = 0;\n    let count = 0;\n    return {\n      calc: curr => {\n        if (isNumeric(curr)) {\n          value += curr;\n          count++;\n        } else {\n          value = curr;\n        }\n      },\n      result: () => isNumeric(value) ? value / count : value\n    };\n  },\n  count: () => {\n    let state = 0;\n    return {\n      calc: () => state++,\n      result: () => state\n    };\n  },\n  max: () => {\n    let state = Number.NEGATIVE_INFINITY;\n    return {\n      calc: value => {\n        state = isNumeric(state) || isDate(state) ? state : value;\n\n        if (state < value && (isNumeric(value) || isDate(value))) {\n          state = value;\n        }\n      },\n      result: () => state\n    };\n  },\n  min: () => {\n    let state = Number.POSITIVE_INFINITY;\n    return {\n      calc: value => {\n        state = isNumeric(state) || isDate(state) ? state : value;\n\n        if (state > value && (isNumeric(value) || isDate(value))) {\n          state = value;\n        }\n      },\n      result: () => state\n    };\n  },\n  sum: () => {\n    let state = 0;\n    return {\n      calc: value => {\n        value = isPresent(value) ? value : 0;\n        state += value;\n      },\n      result: () => state\n    };\n  }\n})[name]();\n/**\n * @hidden\n */\n\n\nexport const aggregatesCombinator = descriptors => {\n  const functions = descriptors.map(descriptor => {\n    const fieldAccessor = getter(descriptor.field, true);\n    const aggregateName = (descriptor.aggregate || \"\").toLowerCase();\n    const aggregateAccessor = getter(aggregateName, true);\n    return (state, value) => {\n      const fieldAggregates = state[descriptor.field] || {};\n      const aggregateFunction = aggregateAccessor(fieldAggregates) || aggregatesFuncs(aggregateName);\n      aggregateFunction.calc(fieldAccessor(value));\n      fieldAggregates[descriptor.aggregate] = aggregateFunction;\n      state[descriptor.field] = fieldAggregates;\n      return state;\n    };\n  });\n  return (state, value) => functions.reduce((agg, calc) => calc(agg, value), state);\n};\n/**\n * @hidden\n * Adds the value to the `arr` and produces a new array.\n *\n * > The original array will be modified.\n */\n\nexport const concat = (arr, value) => {\n  arr.push(value);\n  return arr;\n};\n/**\n * @hidden\n * Returns a reducer that will apply the specified transformation to the value.\n */\n\nexport const map = transform => reduce => (acc, curr, index) => reduce(acc, transform(curr, index));\n/**\n * @hidden\n * Returns a reducer that will filter out items which do not match the `Predicate`.\n */\n\nexport const filter = predicate => reduce => (acc, curr) => predicate(curr) ? reduce(acc, curr) : acc;\n/**\n * @hidden\n */\n\nexport const isTransformerResult = source => {\n  return isPresent(source.__value);\n};\n\nconst reduced = x => {\n  if (isTransformerResult(x)) {\n    return x;\n  }\n\n  return {\n    __value: x,\n    reduced: true\n  };\n};\n/**\n * @hidden\n * Returns a reducer that will take the specified number of items.\n */\n\n\nexport const take = count => reduce => (acc, curr) => count-- > 0 ? reduce(acc, curr) : reduced(acc);\n/**\n * @hidden\n * Returns a reducer that will take the specified number of items.\n */\n\nexport const takeWhile = predicate => reduce => (acc, curr) => predicate(curr) ? reduce(acc, curr) : reduced(acc);\n/**\n * @hidden\n * Returns a reducer that will skip the specified number of items.\n */\n\nexport const skip = count => reduce => (acc, curr) => count-- <= 0 ? reduce(acc, curr) : acc;\n/**\n * @hidden\n * Transforms the data by applying the supplied transformer.\n */\n\nexport const exec = (transform, initialValue, data) => {\n  let result = initialValue;\n\n  for (let idx = 0, length = data.length; idx < length; idx++) {\n    result = transform(result, data[idx], idx);\n\n    if (isTransformerResult(result)) {\n      result = result.__value;\n      break;\n    }\n  }\n\n  return result;\n};","map":null,"metadata":{},"sourceType":"module"}