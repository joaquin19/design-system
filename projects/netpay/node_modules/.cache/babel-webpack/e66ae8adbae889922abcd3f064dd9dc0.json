{"ast":null,"code":"import { isCompositeFilterDescriptor } from '../filtering/filter-descriptor.interface';\nimport { isPresent, isNotNullOrEmptyString, isArray } from '../utils';\nimport { getter } from '../accessor';\nimport { compose, ifElse, identity } from '../funcs';\nimport { isStringValue, isDateValue, quote, serializeFilters, toUTC, encodeValue } from '../filter-serialization.common';\n\nconst toQueryString = values => values.reduce((acc, [key, value]) => [...acc, `${key}=${value}`], []);\n\nconst toObject = values => values.reduce((acc, [key, value]) => Object.assign({}, acc, {\n  [key]: value\n}), {});\n\nconst pairwise = key => value => [key, value];\n\nconst empty = () => null;\n\nconst isNotEmptyArray = value => isPresent(value) && isArray(value) && value.length > 0;\n\nconst has = accessor => value => isPresent(accessor(value));\n\nconst isNotEmpty = accessor => value => isNotEmptyArray(accessor(value));\n\nconst runOrEmpty = (predicate, fn) => ifElse(predicate, fn, empty);\n\nconst calcPage = ({\n  skip,\n  take\n}) => Math.floor((skip || 0) / take) + 1;\n\nconst formatDescriptors = (accessor, formatter) => state => accessor(state).map(formatter).join(\"~\");\n\nconst removeAfter = what => str => str.slice(0, str.indexOf(what));\n\nconst replace = patterns => compose(...patterns.map(([left, right]) => s => s.replace(new RegExp(left, \"g\"), right)));\n\nconst sanitizeDateLiterals = replace([[\"\\\"\", \"\"], [\":\", \"-\"]]);\nconst removeAfterDot = removeAfter(\".\");\n\nconst directionFormatter = ({\n  field,\n  dir = \"asc\"\n}) => `${field}-${dir}`;\n\nconst aggregateFormatter = ({\n  field,\n  aggregate\n}) => `${field}-${aggregate}`;\n\nconst take = getter(\"take\");\nconst aggregates = getter(\"aggregates\");\nconst skip = getter(\"skip\");\nconst group = getter(\"group\");\nconst sort = getter(\"sort\", true);\nconst formatSort = formatDescriptors(sort, directionFormatter);\nconst formatGroup = formatDescriptors(group, directionFormatter);\nconst formatAggregates = formatDescriptors(aggregates, aggregateFormatter);\n\nconst prefixDateValue = value => `datetime'${value}'`;\n\nconst formatDateValue = compose(prefixDateValue, removeAfterDot, sanitizeDateLiterals, JSON.stringify, toUTC);\n\nconst formatDate = ({\n  field,\n  value,\n  ignoreCase,\n  operator\n}) => ({\n  value: formatDateValue(value),\n  field,\n  ignoreCase,\n  operator\n});\n\nconst normalizeSort = state => Object.assign({}, state, {\n  sort: (sort(state) || []).filter(({\n    dir\n  }) => isNotNullOrEmptyString(dir))\n});\n\nconst transformSkip = compose(pairwise('page'), calcPage);\nconst transformTake = compose(pairwise('pageSize'), take);\nconst transformGroup = compose(pairwise('group'), formatGroup);\nconst transformSort = compose(pairwise('sort'), formatSort);\nconst transformAggregates = compose(pairwise('aggregate'), formatAggregates);\nconst serializePage = runOrEmpty(has(skip), transformSkip);\nconst serializePageSize = runOrEmpty(has(take), transformTake);\nconst serializeGroup = runOrEmpty(isNotEmpty(group), transformGroup);\nconst serializeAggregates = runOrEmpty(has(aggregates), transformAggregates);\nconst serializeSort = compose(runOrEmpty(isNotEmpty(sort), transformSort), normalizeSort);\n\nconst hasField = ({\n  field\n}) => isNotNullOrEmptyString(field);\n\nconst filterFormatter = ({\n  field,\n  operator,\n  value\n}) => `${field}~${operator}~${value}`;\n\nconst dateFormatter = ifElse(isDateValue, compose(filterFormatter, formatDate), filterFormatter);\n\nconst typedFormatter = encode => runOrEmpty(hasField, ifElse(isStringValue, compose(filterFormatter, quote, encode ? encodeValue : identity), dateFormatter));\n\nconst join = ({\n  logic\n}) => `~${logic}~`;\n\nconst serialize = encode => serializeFilters(filter => ifElse(isCompositeFilterDescriptor, serialize(encode), typedFormatter(encode))(filter), join);\n\nconst serializeFilter = ({\n  filter\n}, encode) => {\n  if (filter && filter.filters) {\n    const filters = serialize(encode)(filter);\n\n    if (filters.length) {\n      return ['filter', filters];\n    }\n  }\n\n  return null;\n};\n\nconst rules = (state, encode = true) => key => ({\n  \"aggregates\": serializeAggregates(state),\n  \"filter\": serializeFilter(state, encode),\n  \"group\": serializeGroup(state),\n  \"skip\": serializePage(state),\n  \"sort\": serializeSort(state),\n  \"take\": serializePageSize(state)\n})[key];\n/**\n * Converts a [DataSourceRequestState]({% slug api_kendo-data-query_datasourcerequeststate %}) into a string\n * that is comparable with the `DataSourceRequest` format in UI for ASP.NET MVC.\n *\n * @param {DataRequestState} state - The state that will be serialized.\n * @returns {string} - The serialized state.\n *\n * @example\n * {% platform_content angular %}\n * ```ts\n *  import {\n *      toDataSourceRequestString,\n *      translateDataSourceResultGroups,\n *      translateAggregateResults\n * } from '@progress/kendo-data-query';\n *\n * export class Service {\n *  private BASE_URL: string = '...';\n *\n *  constructor(private http: Http) { }\n *\n *  // Omitted for brevity...\n *\n *  private fetch(state: DataSourceRequestState): Observable<DataResult> {\n *   const queryStr = `${toDataSourceRequestString(state)}`; //serialize the state\n *   const hasGroups = state.group && state.group.length;\n *\n *   return this.http\n *       .get(`${this.BASE_URL}?${queryStr}`) //send the state to the server\n *       .map(response => response.json())\n *       .map(({Data, Total, AggregateResults}) => // process the response\n *           (<GridDataResult>{\n *               //if there are groups convert them to compatible format\n *               data: hasGroups ? translateDataSourceResultGroups(Data) : Data,\n *               total: Total,\n *               // convert the aggregates if such exists\n *               aggregateResult: translateAggregateResults(AggregateResults)\n *           })\n *       );\n *  }\n * }\n * ```\n * {% endplatform_content %}\n *\n * {% platform_content react %}\n * ```jsx\n * import React from 'react';\n * import { toDataSourceRequestString, translateDataSourceResultGroups } from '@progress/kendo-data-query';\n *\n * export function withState(WrappedGrid) {\n *     return class StatefullGrid extends React.Component {\n *         constructor(props) {\n *             super(props);\n *             this.state = { dataState: { skip: 0, take: 20 } };\n *         }\n *\n *         render() {\n *             return (\n *                 <WrappedGrid\n *                     filterable={true}\n *                     sortable={true}\n *                     pageable={{ pageSizes: true }}\n *                     {...this.props}\n *                     total={this.state.total}\n *                     data={this.state.data}\n *                     skip={this.state.dataState.skip}\n *                     pageSize={this.state.dataState.take}\n *                     filter={this.state.dataState.filter}\n *                     sort={this.state.dataState.sort}\n *                     dataStateChange={this.dataStateChange}\n *                 />\n *             );\n *         }\n *\n *         componentDidMount() {\n *             this.fetchData(this.state.dataState);\n *         }\n *\n *         dataStateChange = (changeEvent) => {\n *             this.setState({ dataState: changeEvent.data });\n *             this.fetchData(changeEvent.data);\n *         }\n *\n *         fetchData(dataState) {\n *             const queryStr = `${toDataSourceRequestString(dataState)}`; // Serialize the state\n *             const hasGroups = dataState.group && dataState.group.length;\n *\n *             const base_url = 'api/Products';\n *             const init = { method: 'GET', accept: 'application/json', headers: {} };\n *\n *             fetch(`${base_url}?${queryStr}`, init)\n *                 .then(response => response.json())\n *                 .then(({ data, total }) => {\n *                     this.setState({\n *                         data: hasGroups ? translateDataSourceResultGroups(data) : data,\n *                         total,\n *                         dataState\n *                     });\n *                 });\n *         }\n *     }\n * }\n * ```\n * {% endplatform_content %}\n */\n\n\nexport const toDataSourceRequestString = state => toQueryString(Object.keys(state).map(rules(state)).filter(isPresent)).join('&');\n/**\n * Converts a [DataSourceRequestState]({% slug api_kendo-data-query_datasourcerequeststate %}) into an object\n * that is compatible with the `DataSourceRequest` format in UI for ASP.NET MVC.\n *\n * @param {DataRequestState} state - The state that will be serialized.\n * @returns {any} - The serialized state.\n */\n\nexport const toDataSourceRequest = state => toObject(Object.keys(state).map(rules(state, false)).filter(isPresent));","map":null,"metadata":{},"sourceType":"module"}