{"ast":null,"code":"import { Deflate, Inflate } from '@progress/pako-esm';\n/**\n * Let the user use/change some implementations.\n */\n\nvar external = {\n  Promise: Promise\n};\nconst support = {\n  base64: true,\n  array: true,\n  string: true,\n  nodebuffer: false,\n  nodestream: false,\n\n  get arraybuffer() {\n    return typeof ArrayBuffer !== \"undefined\" && typeof Uint8Array !== \"undefined\";\n  },\n\n  // Returns true if JSZip can read/generate Uint8Array, false otherwise.\n  get uint8array() {\n    return typeof Uint8Array !== \"undefined\";\n  },\n\n  get blob() {\n    return blob();\n  }\n\n};\n\nlet blob = function () {\n  let supported;\n\n  if (typeof ArrayBuffer === \"undefined\") {\n    supported = false;\n  } else {\n    const buffer = new ArrayBuffer(0);\n\n    try {\n      supported = new Blob([buffer], {\n        type: \"application/zip\"\n      }).size === 0;\n    } catch (e) {\n      supported = false;\n    }\n  }\n\n  blob = () => supported;\n\n  return supported;\n};\n/* eslint-disable */\n// private property\n\n\nconst _keyStr = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\"; // public method for encoding\n\nconst encode = function (input) {\n  let output = [];\n  let chr1, chr2, chr3, enc1, enc2, enc3, enc4;\n  let i = 0,\n      len = input.length,\n      remainingBytes = len;\n  let isArray = typeof input !== \"string\";\n\n  while (i < input.length) {\n    remainingBytes = len - i;\n\n    if (!isArray) {\n      chr1 = input.charCodeAt(i++);\n      chr2 = i < len ? input.charCodeAt(i++) : 0;\n      chr3 = i < len ? input.charCodeAt(i++) : 0;\n    } else {\n      chr1 = input[i++];\n      chr2 = i < len ? input[i++] : 0;\n      chr3 = i < len ? input[i++] : 0;\n    }\n\n    enc1 = chr1 >> 2;\n    enc2 = (chr1 & 3) << 4 | chr2 >> 4;\n    enc3 = remainingBytes > 1 ? (chr2 & 15) << 2 | chr3 >> 6 : 64;\n    enc4 = remainingBytes > 2 ? chr3 & 63 : 64;\n    output.push(_keyStr.charAt(enc1) + _keyStr.charAt(enc2) + _keyStr.charAt(enc3) + _keyStr.charAt(enc4));\n  }\n\n  return output.join(\"\");\n}; // public method for decoding\n\n\nconst decode = function (input) {\n  let chr1, chr2, chr3;\n  let enc1, enc2, enc3, enc4;\n  let i = 0,\n      resultIndex = 0;\n  let dataUrlPrefix = \"data:\";\n\n  if (input.substr(0, dataUrlPrefix.length) === dataUrlPrefix) {\n    // This is a common error: people give a data url\n    // (data:image/png;base64,iVBOR...) with a {base64: true} and\n    // wonders why things don't work.\n    // We can detect that the string input looks like a data url but we\n    // *can't* be sure it is one: removing everything up to the comma would\n    // be too dangerous.\n    throw new Error(\"Invalid base64 input, it looks like a data url.\");\n  }\n\n  input = input.replace(/[^A-Za-z0-9\\+\\/\\=]/g, \"\");\n  let totalLength = input.length * 3 / 4;\n\n  if (input.charAt(input.length - 1) === _keyStr.charAt(64)) {\n    totalLength--;\n  }\n\n  if (input.charAt(input.length - 2) === _keyStr.charAt(64)) {\n    totalLength--;\n  }\n\n  if (totalLength % 1 !== 0) {\n    // totalLength is not an integer, the length does not match a valid\n    // base64 content. That can happen if:\n    // - the input is not a base64 content\n    // - the input is *almost* a base64 content, with a extra chars at the\n    //   beginning or at the end\n    // - the input uses a base64 letiant (base64url for example)\n    throw new Error(\"Invalid base64 input, bad content length.\");\n  }\n\n  let output;\n\n  if (support.uint8array) {\n    output = new Uint8Array(totalLength | 0);\n  } else {\n    output = new Array(totalLength | 0);\n  }\n\n  while (i < input.length) {\n    enc1 = _keyStr.indexOf(input.charAt(i++));\n    enc2 = _keyStr.indexOf(input.charAt(i++));\n    enc3 = _keyStr.indexOf(input.charAt(i++));\n    enc4 = _keyStr.indexOf(input.charAt(i++));\n    chr1 = enc1 << 2 | enc2 >> 4;\n    chr2 = (enc2 & 15) << 4 | enc3 >> 2;\n    chr3 = (enc3 & 3) << 6 | enc4;\n    output[resultIndex++] = chr1;\n\n    if (enc3 !== 64) {\n      output[resultIndex++] = chr2;\n    }\n\n    if (enc4 !== 64) {\n      output[resultIndex++] = chr3;\n    }\n  }\n\n  return output;\n};\n/* eslint-disable */\n\n/**\n * Convert a string that pass as a \"binary string\": it should represent a byte\n * array but may have > 255 char codes. Be sure to take only the first byte\n * and returns the byte array.\n * @param {String} str the string to transform.\n * @return {Array|Uint8Array} the string in a binary format.\n */\n\n\nfunction string2binary(str) {\n  var result = null;\n\n  if (support.uint8array) {\n    result = new Uint8Array(str.length);\n  } else {\n    result = new Array(str.length);\n  }\n\n  return stringToArrayLike(str, result);\n}\n/**\n * Create a new blob with the given content and the given type.\n * @param {String|ArrayBuffer} part the content to put in the blob. DO NOT use\n * an Uint8Array because the stock browser of android 4 won't accept it (it\n * will be silently converted to a string, \"[object Uint8Array]\").\n *\n * Use only ONE part to build the blob to avoid a memory leak in IE11 / Edge:\n * when a large amount of Array is used to create the Blob, the amount of\n * memory consumed is nearly 100 times the original data amount.\n *\n * @param {String} type the mime type of the blob.\n * @return {Blob} the created blob.\n */\n\n\nconst newBlob = function (part, type) {\n  checkSupport(\"blob\"); // Blob constructor\n\n  return new Blob([part], {\n    type: type\n  });\n};\n/**\n * The identity function.\n * @param {Object} input the input.\n * @return {Object} the same input.\n */\n\n\nfunction identity(input) {\n  return input;\n}\n/**\n * Fill in an array with a string.\n * @param {String} str the string to use.\n * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to fill in (will be mutated).\n * @return {Array|ArrayBuffer|Uint8Array|Buffer} the updated array.\n */\n\n\nfunction stringToArrayLike(str, array) {\n  for (var i = 0; i < str.length; ++i) {\n    array[i] = str.charCodeAt(i) & 0xFF;\n  }\n\n  return array;\n}\n/**\n * Transform an array of int into a string, chunk by chunk.\n * See the performances notes on arrayLikeToString.\n * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to transform.\n * @param {String} type the type of the array.\n * @param {Integer} chunk the chunk size.\n * @return {String} the resulting string.\n * @throws Error if the chunk is too big for the stack.\n */\n\n\nfunction stringifyByChunk(array, type, chunk) {\n  var result = [],\n      k = 0,\n      len = array.length; // shortcut\n\n  if (len <= chunk) {\n    return String.fromCharCode.apply(null, array);\n  }\n\n  while (k < len) {\n    if (type === \"array\") {\n      result.push(String.fromCharCode.apply(null, array.slice(k, Math.min(k + chunk, len))));\n    } else {\n      result.push(String.fromCharCode.apply(null, array.subarray(k, Math.min(k + chunk, len))));\n    }\n\n    k += chunk;\n  }\n\n  return result.join(\"\");\n}\n/**\n * Call String.fromCharCode on every item in the array.\n * This is the naive implementation, which generate A LOT of intermediate string.\n * This should be used when everything else fail.\n * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to transform.\n * @return {String} the result.\n */\n\n\nfunction stringifyByChar(array) {\n  var resultStr = \"\";\n\n  for (var i = 0; i < array.length; i++) {\n    resultStr += String.fromCharCode(array[i]);\n  }\n\n  return resultStr;\n}\n/**\n * true if the browser accepts to use String.fromCharCode on Uint8Array\n */\n\n\nlet fromCharCodeSupportsTypedArrays = () => {\n  let supported;\n\n  try {\n    supported = support.uint8array && String.fromCharCode.apply(null, new Uint8Array(1)).length === 1;\n  } catch (e) {\n    supported = false;\n  }\n\n  fromCharCodeSupportsTypedArrays = () => supported;\n\n  return supported;\n};\n/**\n * Transform an array-like object to a string.\n * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to transform.\n * @return {String} the result.\n */\n\n\nfunction arrayLikeToString(array) {\n  // Performances notes :\n  // --------------------\n  // String.fromCharCode.apply(null, array) is the fastest, see\n  // see http://jsperf.com/converting-a-uint8array-to-a-string/2\n  // but the stack is limited (and we can get huge arrays !).\n  //\n  // result += String.fromCharCode(array[i]); generate too many strings !\n  //\n  // This code is inspired by http://jsperf.com/arraybuffer-to-string-apply-performance/2\n  // TODO : we now have workers that split the work. Do we still need that ?\n  var chunk = 65536,\n      type = getTypeOf(array),\n      canUseApply = true;\n\n  if (type === \"uint8array\") {\n    canUseApply = fromCharCodeSupportsTypedArrays();\n  }\n\n  if (canUseApply) {\n    while (chunk > 1) {\n      try {\n        return stringifyByChunk(array, type, chunk);\n      } catch (e) {\n        chunk = Math.floor(chunk / 2);\n      }\n    }\n  } // no apply or chunk error : slow and painful algorithm\n  // default browser on android 4.*\n\n\n  return stringifyByChar(array);\n}\n\nconst applyFromCharCode = arrayLikeToString;\n/**\n * Copy the data from an array-like to an other array-like.\n * @param {Array|ArrayBuffer|Uint8Array|Buffer} arrayFrom the origin array.\n * @param {Array|ArrayBuffer|Uint8Array|Buffer} arrayTo the destination array which will be mutated.\n * @return {Array|ArrayBuffer|Uint8Array|Buffer} the updated destination array.\n */\n\nfunction arrayLikeToArrayLike(arrayFrom, arrayTo) {\n  for (var i = 0; i < arrayFrom.length; i++) {\n    arrayTo[i] = arrayFrom[i];\n  }\n\n  return arrayTo;\n} // a matrix containing functions to transform everything into everything.\n\n\nvar transform = {\n  // string to ?\n  \"string\": {\n    \"string\": identity,\n    \"array\": function (input) {\n      return stringToArrayLike(input, new Array(input.length));\n    },\n    \"arraybuffer\": function (input) {\n      return transform[\"string\"][\"uint8array\"](input).buffer;\n    },\n    \"uint8array\": function (input) {\n      return stringToArrayLike(input, new Uint8Array(input.length));\n    }\n  },\n  // array to ?\n  \"array\": {\n    \"string\": arrayLikeToString,\n    \"array\": identity,\n    \"arraybuffer\": function (input) {\n      return new Uint8Array(input).buffer;\n    },\n    \"uint8array\": function (input) {\n      return new Uint8Array(input);\n    }\n  },\n  // arraybuffer to ?\n  \"arraybuffer\": {\n    \"string\": function (input) {\n      return arrayLikeToString(new Uint8Array(input));\n    },\n    \"array\": function (input) {\n      return arrayLikeToArrayLike(new Uint8Array(input), new Array(input.byteLength));\n    },\n    \"arraybuffer\": identity,\n    \"uint8array\": function (input) {\n      return new Uint8Array(input);\n    }\n  },\n  // uint8array to ?\n  \"uint8array\": {\n    \"string\": arrayLikeToString,\n    \"array\": function (input) {\n      return arrayLikeToArrayLike(input, new Array(input.length));\n    },\n    \"arraybuffer\": function (input) {\n      return input.buffer;\n    },\n    \"uint8array\": identity\n  }\n};\n/**\n * Transform an input into any type.\n * The supported output type are : string, array, uint8array, arraybuffer.\n * If no output type is specified, the unmodified input will be returned.\n * @param {String} outputType the output type.\n * @param {String|Array|ArrayBuffer|Uint8Array|Buffer} input the input to convert.\n * @throws {Error} an Error if the browser doesn't support the requested output type.\n */\n\nconst transformTo = function (outputType, input) {\n  if (!input) {\n    // undefined, null, etc\n    // an empty string won't harm.\n    input = \"\";\n  }\n\n  if (!outputType) {\n    return input;\n  }\n\n  checkSupport(outputType);\n  var inputType = getTypeOf(input);\n  var result = transform[inputType][outputType](input);\n  return result;\n};\n/**\n * Return the type of the input.\n * The type will be in a format valid for JSZip.utils.transformTo : string, array, uint8array, arraybuffer.\n * @param {Object} input the input to identify.\n * @return {String} the (lowercase) type of the input.\n */\n\n\nconst getTypeOf = function (input) {\n  if (typeof input === \"string\") {\n    return \"string\";\n  }\n\n  if (Object.prototype.toString.call(input) === \"[object Array]\") {\n    return \"array\";\n  }\n\n  if (support.uint8array && input instanceof Uint8Array) {\n    return \"uint8array\";\n  }\n\n  if (support.arraybuffer && input instanceof ArrayBuffer) {\n    return \"arraybuffer\";\n  }\n};\n/**\n * Throw an exception if the type is not supported.\n * @param {String} type the type to check.\n * @throws {Error} an Error if the browser doesn't support the requested type.\n */\n\n\nconst checkSupport = function (type) {\n  var supported = support[type.toLowerCase()];\n\n  if (!supported) {\n    throw new Error(type + \" is not supported by this platform\");\n  }\n};\n\nconst MAX_VALUE_16BITS = 65535;\nconst MAX_VALUE_32BITS = -1; // well, \"\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\" is parsed as -1\n\n/**\n * Prettify a string read as binary.\n * @param {string} str the string to prettify.\n * @return {string} a pretty string.\n */\n\nconst pretty = function (str) {\n  var res = '',\n      code,\n      i;\n\n  for (i = 0; i < (str || \"\").length; i++) {\n    code = str.charCodeAt(i);\n    res += '\\\\x' + (code < 16 ? \"0\" : \"\") + code.toString(16).toUpperCase();\n  }\n\n  return res;\n};\n/**\n * Defer the call of a function.\n * @param {Function} callback the function to call asynchronously.\n * @param {Array} args the arguments to give to the callback.\n */\n\n\nconst delay = function (callback, args, self) {\n  setTimeout(function () {\n    callback.apply(self || null, args || []);\n  }, 0);\n};\n/**\n * Merge the objects passed as parameters into a new one.\n * @private\n * @param {...Object} var_args All objects to merge.\n * @return {Object} a new object with the data of the others.\n */\n\n\nconst extend = function () {\n  var result = {},\n      i,\n      attr;\n\n  for (i = 0; i < arguments.length; i++) {\n    // arguments is not enumerable in some browsers\n    for (attr in arguments[i]) {\n      if (Object.hasOwnProperty.call(arguments[i], attr) && typeof result[attr] === \"undefined\") {\n        result[attr] = arguments[i][attr];\n      }\n    }\n  }\n\n  return result;\n};\n/**\n * Transform arbitrary content into a Promise.\n * @param {String} name a name for the content being processed.\n * @param {Object} inputData the content to process.\n * @param {Boolean} isBinary true if the content is not an unicode string\n * @param {Boolean} isOptimizedBinaryString true if the string content only has one byte per character.\n * @param {Boolean} isBase64 true if the string content is encoded with base64.\n * @return {Promise} a promise in a format usable by JSZip.\n */\n\n\nconst prepareContent = function (name, inputData, isBinary, isOptimizedBinaryString, isBase64) {\n  // if inputData is already a promise, this flatten it.\n  var promise = external.Promise.resolve(inputData).then(function (data) {\n    var isBlob = support.blob && (data instanceof Blob || ['[object File]', '[object Blob]'].indexOf(Object.prototype.toString.call(data)) !== -1);\n\n    if (isBlob && typeof FileReader !== \"undefined\") {\n      return new external.Promise(function (resolve, reject) {\n        var reader = new FileReader();\n\n        reader.onload = function (e) {\n          resolve(e.target.result);\n        };\n\n        reader.onerror = function (e) {\n          reject(e.target.error);\n        };\n\n        reader.readAsArrayBuffer(data);\n      });\n    } else {\n      return data;\n    }\n  });\n  return promise.then(function (data) {\n    var dataType = getTypeOf(data);\n\n    if (!dataType) {\n      return external.Promise.reject(new Error(\"Can't read the data of '\" + name + \"'. Is it \" + \"in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?\"));\n    } // special case : it's way easier to work with Uint8Array than with ArrayBuffer\n\n\n    if (dataType === \"arraybuffer\") {\n      data = transformTo(\"uint8array\", data);\n    } else if (dataType === \"string\") {\n      if (isBase64) {\n        data = decode(data);\n      } else if (isBinary) {\n        // optimizedBinaryString === true means that the file has already been filtered with a 0xFF mask\n        if (isOptimizedBinaryString !== true) {\n          // this is a string, not in a base64 format.\n          // Be sure that this is a correct \"binary string\"\n          data = string2binary(data);\n        }\n      }\n    }\n\n    return data;\n  });\n};\n/* eslint-disable */\n\n/**\n * A worker that does nothing but passing chunks to the next one. This is like\n * a nodejs stream but with some differences. On the good side :\n * - it works on IE 6-9 without any issue / polyfill\n * - it weights less than the full dependencies bundled with browserify\n * - it forwards errors (no need to declare an error handler EVERYWHERE)\n *\n * A chunk is an object with 2 attributes : `meta` and `data`. The former is an\n * object containing anything (`percent` for example), see each worker for more\n * details. The latter is the real data (String, Uint8Array, etc).\n *\n * @constructor\n * @param {String} name the name of the stream (mainly used for debugging purposes)\n */\n\n\nclass GenericWorker {\n  constructor(name) {\n    // the name of the worker\n    this.name = name || \"default\"; // an object containing metadata about the workers chain\n\n    this.streamInfo = {}; // an error which happened when the worker was paused\n\n    this.generatedError = null; // an object containing metadata to be merged by this worker into the general metadata\n\n    this.extraStreamInfo = {}; // true if the stream is paused (and should not do anything), false otherwise\n\n    this.isPaused = true; // true if the stream is finished (and should not do anything), false otherwise\n\n    this.isFinished = false; // true if the stream is locked to prevent further structure updates (pipe), false otherwise\n\n    this.isLocked = false; // the event listeners\n\n    this._listeners = {\n      'data': [],\n      'end': [],\n      'error': []\n    }; // the previous worker, if any\n\n    this.previous = null;\n  }\n  /**\n   * Push a chunk to the next workers.\n   * @param {Object} chunk the chunk to push\n   */\n\n\n  push(chunk) {\n    this.emit(\"data\", chunk);\n  }\n  /**\n   * End the stream.\n   * @return {Boolean} true if this call ended the worker, false otherwise.\n   */\n\n\n  end() {\n    if (this.isFinished) {\n      return false;\n    }\n\n    this.flush();\n\n    try {\n      this.emit(\"end\");\n      this.cleanUp();\n      this.isFinished = true;\n    } catch (e) {\n      this.emit(\"error\", e);\n    }\n\n    return true;\n  }\n  /**\n   * End the stream with an error.\n   * @param {Error} e the error which caused the premature end.\n   * @return {Boolean} true if this call ended the worker with an error, false otherwise.\n   */\n\n\n  error(e) {\n    if (this.isFinished) {\n      return false;\n    }\n\n    if (this.isPaused) {\n      this.generatedError = e;\n    } else {\n      this.isFinished = true;\n      this.emit(\"error\", e); // in the workers chain exploded in the middle of the chain,\n      // the error event will go downward but we also need to notify\n      // workers upward that there has been an error.\n\n      if (this.previous) {\n        this.previous.error(e);\n      }\n\n      this.cleanUp();\n    }\n\n    return true;\n  }\n  /**\n   * Add a callback on an event.\n   * @param {String} name the name of the event (data, end, error)\n   * @param {Function} listener the function to call when the event is triggered\n   * @return {GenericWorker} the current object for chainability\n   */\n\n\n  on(name, listener) {\n    this._listeners[name].push(listener);\n\n    return this;\n  }\n  /**\n   * Clean any references when a worker is ending.\n   */\n\n\n  cleanUp() {\n    this.streamInfo = this.generatedError = this.extraStreamInfo = null;\n    this._listeners = [];\n  }\n  /**\n   * Trigger an event. This will call registered callback with the provided arg.\n   * @param {String} name the name of the event (data, end, error)\n   * @param {Object} arg the argument to call the callback with.\n   */\n\n\n  emit(name, arg) {\n    if (this._listeners[name]) {\n      for (var i = 0; i < this._listeners[name].length; i++) {\n        this._listeners[name][i].call(this, arg);\n      }\n    }\n  }\n  /**\n   * Chain a worker with an other.\n   * @param {Worker} next the worker receiving events from the current one.\n   * @return {worker} the next worker for chainability\n   */\n\n\n  pipe(next) {\n    return next.registerPrevious(this);\n  }\n  /**\n   * Same as `pipe` in the other direction.\n   * Using an API with `pipe(next)` is very easy.\n   * Implementing the API with the point of view of the next one registering\n   * a source is easier, see the ZipFileWorker.\n   * @param {Worker} previous the previous worker, sending events to this one\n   * @return {Worker} the current worker for chainability\n   */\n\n\n  registerPrevious(previous) {\n    if (this.isLocked) {\n      throw new Error(\"The stream '\" + this + \"' has already been used.\");\n    } // sharing the streamInfo...\n\n\n    this.streamInfo = previous.streamInfo; // ... and adding our own bits\n\n    this.mergeStreamInfo();\n    this.previous = previous;\n    var self = this;\n    previous.on('data', function (chunk) {\n      self.processChunk(chunk);\n    });\n    previous.on('end', function () {\n      self.end();\n    });\n    previous.on('error', function (e) {\n      self.error(e);\n    });\n    return this;\n  }\n  /**\n   * Pause the stream so it doesn't send events anymore.\n   * @return {Boolean} true if this call paused the worker, false otherwise.\n   */\n\n\n  pause() {\n    if (this.isPaused || this.isFinished) {\n      return false;\n    }\n\n    this.isPaused = true;\n\n    if (this.previous) {\n      this.previous.pause();\n    }\n\n    return true;\n  }\n  /**\n   * Resume a paused stream.\n   * @return {Boolean} true if this call resumed the worker, false otherwise.\n   */\n\n\n  resume() {\n    if (!this.isPaused || this.isFinished) {\n      return false;\n    }\n\n    this.isPaused = false; // if true, the worker tried to resume but failed\n\n    var withError = false;\n\n    if (this.generatedError) {\n      this.error(this.generatedError);\n      withError = true;\n    }\n\n    if (this.previous) {\n      this.previous.resume();\n    }\n\n    return !withError;\n  }\n  /**\n   * Flush any remaining bytes as the stream is ending.\n   */\n\n\n  flush() {}\n  /**\n   * Process a chunk. This is usually the method overridden.\n   * @param {Object} chunk the chunk to process.\n   */\n\n\n  processChunk(chunk) {\n    this.push(chunk);\n  }\n  /**\n   * Add a key/value to be added in the workers chain streamInfo once activated.\n   * @param {String} key the key to use\n   * @param {Object} value the associated value\n   * @return {Worker} the current worker for chainability\n   */\n\n\n  withStreamInfo(key, value) {\n    this.extraStreamInfo[key] = value;\n    this.mergeStreamInfo();\n    return this;\n  }\n  /**\n   * Merge this worker's streamInfo into the chain's streamInfo.\n   */\n\n\n  mergeStreamInfo() {\n    for (var key in this.extraStreamInfo) {\n      if (!this.extraStreamInfo.hasOwnProperty(key)) {\n        continue;\n      }\n\n      this.streamInfo[key] = this.extraStreamInfo[key];\n    }\n  }\n  /**\n   * Lock the stream to prevent further updates on the workers chain.\n   * After calling this method, all calls to pipe will fail.\n   */\n\n\n  lock() {\n    if (this.isLocked) {\n      throw new Error(\"The stream '\" + this + \"' has already been used.\");\n    }\n\n    this.isLocked = true;\n\n    if (this.previous) {\n      this.previous.lock();\n    }\n  }\n  /**\n   *\n   * Pretty print the workers chain.\n   */\n\n\n  toString() {\n    var me = \"Worker \" + this.name;\n\n    if (this.previous) {\n      return this.previous + \" -> \" + me;\n    } else {\n      return me;\n    }\n  }\n\n}\n/* eslint-disable */\n\n/**\n * The following functions come from pako, from pako/lib/utils/strings\n * released under the MIT license, see pako https://github.com/nodeca/pako/\n */\n// Returns the utf8 lengths (calculated by first byte of sequence)\n// Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,\n// because max possible codepoint is 0x10ffff\n\n\nlet utf8len = function (c) {\n  const _utf8len = new Array(256);\n\n  for (let i = 0; i < 256; i++) {\n    _utf8len[i] = i >= 252 ? 6 : i >= 248 ? 5 : i >= 240 ? 4 : i >= 224 ? 3 : i >= 192 ? 2 : 1;\n  }\n\n  _utf8len[254] = _utf8len[254] = 1; // Invalid sequence start\n  // Memoize table after first call\n\n  utf8len = function (c) {\n    return _utf8len[c];\n  };\n\n  return _utf8len[c];\n}; // convert string to array (typed, when possible)\n\n\nvar string2buf = function (str) {\n  var buf,\n      c,\n      c2,\n      m_pos,\n      i,\n      str_len = str.length,\n      buf_len = 0; // count binary size\n\n  for (m_pos = 0; m_pos < str_len; m_pos++) {\n    c = str.charCodeAt(m_pos);\n\n    if ((c & 0xfc00) === 0xd800 && m_pos + 1 < str_len) {\n      c2 = str.charCodeAt(m_pos + 1);\n\n      if ((c2 & 0xfc00) === 0xdc00) {\n        c = 0x10000 + (c - 0xd800 << 10) + (c2 - 0xdc00);\n        m_pos++;\n      }\n    }\n\n    buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;\n  } // allocate buffer\n\n\n  if (support.uint8array) {\n    buf = new Uint8Array(buf_len);\n  } else {\n    buf = new Array(buf_len);\n  } // convert\n\n\n  for (i = 0, m_pos = 0; i < buf_len; m_pos++) {\n    c = str.charCodeAt(m_pos);\n\n    if ((c & 0xfc00) === 0xd800 && m_pos + 1 < str_len) {\n      c2 = str.charCodeAt(m_pos + 1);\n\n      if ((c2 & 0xfc00) === 0xdc00) {\n        c = 0x10000 + (c - 0xd800 << 10) + (c2 - 0xdc00);\n        m_pos++;\n      }\n    }\n\n    if (c < 0x80) {\n      /* one byte */\n      buf[i++] = c;\n    } else if (c < 0x800) {\n      /* two bytes */\n      buf[i++] = 0xC0 | c >>> 6;\n      buf[i++] = 0x80 | c & 0x3f;\n    } else if (c < 0x10000) {\n      /* three bytes */\n      buf[i++] = 0xE0 | c >>> 12;\n      buf[i++] = 0x80 | c >>> 6 & 0x3f;\n      buf[i++] = 0x80 | c & 0x3f;\n    } else {\n      /* four bytes */\n      buf[i++] = 0xf0 | c >>> 18;\n      buf[i++] = 0x80 | c >>> 12 & 0x3f;\n      buf[i++] = 0x80 | c >>> 6 & 0x3f;\n      buf[i++] = 0x80 | c & 0x3f;\n    }\n  }\n\n  return buf;\n}; // Calculate max possible position in utf8 buffer,\n// that will not break sequence. If that's not possible\n// - (very small limits) return max size as is.\n//\n// buf[] - utf8 bytes array\n// max   - length limit (mandatory);\n\n\nvar utf8border = function (buf, max) {\n  var pos;\n  max = max || buf.length;\n\n  if (max > buf.length) {\n    max = buf.length;\n  } // go back from last position, until start of sequence found\n\n\n  pos = max - 1;\n\n  while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) {\n    pos--;\n  } // Fuckup - very small and broken sequence,\n  // return max, because we should return something anyway.\n\n\n  if (pos < 0) {\n    return max;\n  } // If we came to start of buffer - that means vuffer is too small,\n  // return max too.\n\n\n  if (pos === 0) {\n    return max;\n  }\n\n  return pos + utf8len(buf[pos]) > max ? pos : max;\n}; // convert array to string\n\n\nvar buf2string = function (buf) {\n  var i, out, c, c_len;\n  var len = buf.length; // Reserve max possible length (2 words per char)\n  // NB: by unknown reasons, Array is significantly faster for\n  //     String.fromCharCode.apply than Uint16Array.\n\n  var utf16buf = new Array(len * 2);\n\n  for (out = 0, i = 0; i < len;) {\n    c = buf[i++]; // quick process ascii\n\n    if (c < 0x80) {\n      utf16buf[out++] = c;\n      continue;\n    }\n\n    c_len = utf8len(c); // skip 5 & 6 byte codes\n\n    if (c_len > 4) {\n      utf16buf[out++] = 0xfffd;\n      i += c_len - 1;\n      continue;\n    } // apply mask on first byte\n\n\n    c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07; // join the rest\n\n    while (c_len > 1 && i < len) {\n      c = c << 6 | buf[i++] & 0x3f;\n      c_len--;\n    } // terminated by end of string?\n\n\n    if (c_len > 1) {\n      utf16buf[out++] = 0xfffd;\n      continue;\n    }\n\n    if (c < 0x10000) {\n      utf16buf[out++] = c;\n    } else {\n      c -= 0x10000;\n      utf16buf[out++] = 0xd800 | c >> 10 & 0x3ff;\n      utf16buf[out++] = 0xdc00 | c & 0x3ff;\n    }\n  } // shrinkBuf(utf16buf, out)\n\n\n  if (utf16buf.length !== out) {\n    if (utf16buf.subarray) {\n      utf16buf = utf16buf.subarray(0, out);\n    } else {\n      utf16buf.length = out;\n    }\n  } // return String.fromCharCode.apply(null, utf16buf);\n\n\n  return applyFromCharCode(utf16buf);\n}; // That's all for the pako functions.\n\n/**\n * Transform a javascript string into an array (typed if possible) of bytes,\n * UTF-8 encoded.\n * @param {String} str the string to encode\n * @return {Array|Uint8Array|Buffer} the UTF-8 encoded string.\n */\n\n\nconst utf8encode = function utf8encode(str) {\n  return string2buf(str);\n};\n/**\n * Transform a bytes array (or a representation) representing an UTF-8 encoded\n * string into a javascript string.\n * @param {Array|Uint8Array|Buffer} buf the data de decode\n * @return {String} the decoded string.\n */\n\n\nconst utf8decode = function utf8decode(buf) {\n  buf = transformTo(support.uint8array ? \"uint8array\" : \"array\", buf);\n  return buf2string(buf);\n};\n/**\n * A worker to decode utf8 encoded binary chunks into string chunks.\n * @constructor\n */\n\n\nclass Utf8DecodeWorker extends GenericWorker {\n  constructor() {\n    super(\"utf-8 decode\"); // the last bytes if a chunk didn't end with a complete codepoint.\n\n    this.leftOver = null;\n  }\n  /**\n   * @see GenericWorker.processChunk\n   */\n\n\n  processChunk(chunk) {\n    var data = transformTo(support.uint8array ? \"uint8array\" : \"array\", chunk.data); // 1st step, re-use what's left of the previous chunk\n\n    if (this.leftOver && this.leftOver.length) {\n      if (support.uint8array) {\n        var previousData = data;\n        data = new Uint8Array(previousData.length + this.leftOver.length);\n        data.set(this.leftOver, 0);\n        data.set(previousData, this.leftOver.length);\n      } else {\n        data = this.leftOver.concat(data);\n      }\n\n      this.leftOver = null;\n    }\n\n    var nextBoundary = utf8border(data);\n    var usableData = data;\n\n    if (nextBoundary !== data.length) {\n      if (support.uint8array) {\n        usableData = data.subarray(0, nextBoundary);\n        this.leftOver = data.subarray(nextBoundary, data.length);\n      } else {\n        usableData = data.slice(0, nextBoundary);\n        this.leftOver = data.slice(nextBoundary, data.length);\n      }\n    }\n\n    this.push({\n      data: utf8decode(usableData),\n      meta: chunk.meta\n    });\n  }\n  /**\n   * @see GenericWorker.flush\n   */\n\n\n  flush() {\n    if (this.leftOver && this.leftOver.length) {\n      this.push({\n        data: utf8decode(this.leftOver),\n        meta: {}\n      });\n      this.leftOver = null;\n    }\n  }\n\n}\n/**\n * A worker to endcode string chunks into utf8 encoded binary chunks.\n * @constructor\n */\n\n\nclass Utf8EncodeWorker extends GenericWorker {\n  constructor() {\n    super(\"utf-8 encode\");\n  }\n  /**\n   * @see GenericWorker.processChunk\n   */\n\n\n  processChunk(chunk) {\n    this.push({\n      data: utf8encode(chunk.data),\n      meta: chunk.meta\n    });\n  }\n\n}\n/**\n * A worker which convert chunks to a specified type.\n * @constructor\n * @param {String} destType the destination type.\n */\n\n\nclass ConvertWorker extends GenericWorker {\n  constructor(destType) {\n    super(\"ConvertWorker to \" + destType);\n    this.destType = destType;\n  }\n  /**\n   * @see GenericWorker.processChunk\n   */\n\n\n  processChunk(chunk) {\n    this.push({\n      data: transformTo(this.destType, chunk.data),\n      meta: chunk.meta\n    });\n  }\n\n}\n/* eslint-disable */\n\n/**\n * Apply the final transformation of the data. If the user wants a Blob for\n * example, it's easier to work with an U8intArray and finally do the\n * ArrayBuffer/Blob conversion.\n * @param {String} type the name of the final type\n * @param {String|Uint8Array|Buffer} content the content to transform\n * @param {String} mimeType the mime type of the content, if applicable.\n * @return {String|Uint8Array|ArrayBuffer|Buffer|Blob} the content in the right format.\n */\n\n\nfunction transformZipOutput(type, content, mimeType) {\n  switch (type) {\n    case \"blob\":\n      return newBlob(transformTo(\"arraybuffer\", content), mimeType);\n\n    case \"base64\":\n      return encode(content);\n\n    default:\n      return transformTo(type, content);\n  }\n}\n/**\n * Concatenate an array of data of the given type.\n * @param {String} type the type of the data in the given array.\n * @param {Array} dataArray the array containing the data chunks to concatenate\n * @return {String|Uint8Array|Buffer} the concatenated data\n * @throws Error if the asked type is unsupported\n */\n\n\nfunction concat(type, dataArray) {\n  var i,\n      index = 0,\n      res = null,\n      totalLength = 0;\n\n  for (i = 0; i < dataArray.length; i++) {\n    totalLength += dataArray[i].length;\n  }\n\n  switch (type) {\n    case \"string\":\n      return dataArray.join(\"\");\n\n    case \"array\":\n      return Array.prototype.concat.apply([], dataArray);\n\n    case \"uint8array\":\n      res = new Uint8Array(totalLength);\n\n      for (i = 0; i < dataArray.length; i++) {\n        res.set(dataArray[i], index);\n        index += dataArray[i].length;\n      }\n\n      return res;\n\n    default:\n      throw new Error(\"concat : unsupported type '\" + type + \"'\");\n  }\n}\n/**\n * Listen a StreamHelper, accumulate its content and concatenate it into a\n * complete block.\n * @param {StreamHelper} helper the helper to use.\n * @param {Function} updateCallback a callback called on each update. Called\n * with one arg :\n * - the metadata linked to the update received.\n * @return Promise the promise for the accumulation.\n */\n\n\nfunction accumulate(helper, updateCallback) {\n  return new external.Promise(function (resolve, reject) {\n    var dataArray = [];\n    var chunkType = helper._internalType,\n        resultType = helper._outputType,\n        mimeType = helper._mimeType;\n    helper.on('data', function (data, meta) {\n      dataArray.push(data);\n\n      if (updateCallback) {\n        updateCallback(meta);\n      }\n    }).on('error', function (err) {\n      dataArray = [];\n      reject(err);\n    }).on('end', function () {\n      try {\n        var result = transformZipOutput(resultType, concat(chunkType, dataArray), mimeType);\n        resolve(result);\n      } catch (e) {\n        reject(e);\n      }\n\n      dataArray = [];\n    }).resume();\n  });\n}\n/**\n * An helper to easily use workers outside of JSZip.\n * @constructor\n * @param {Worker} worker the worker to wrap\n * @param {String} outputType the type of data expected by the use\n * @param {String} mimeType the mime type of the content, if applicable.\n */\n\n\nclass StreamHelper {\n  constructor(worker, outputType, mimeType) {\n    var internalType = outputType;\n\n    switch (outputType) {\n      case \"blob\":\n      case \"arraybuffer\":\n        internalType = \"uint8array\";\n        break;\n\n      case \"base64\":\n        internalType = \"string\";\n        break;\n    }\n\n    try {\n      // the type used internally\n      this._internalType = internalType; // the type used to output results\n\n      this._outputType = outputType; // the mime type\n\n      this._mimeType = mimeType;\n      checkSupport(internalType);\n      this._worker = worker.pipe(new ConvertWorker(internalType)); // the last workers can be rewired without issues but we need to\n      // prevent any updates on previous workers.\n\n      worker.lock();\n    } catch (e) {\n      this._worker = new GenericWorker(\"error\");\n\n      this._worker.error(e);\n    }\n  }\n  /**\n   * Listen a StreamHelper, accumulate its content and concatenate it into a\n   * complete block.\n   * @param {Function} updateCb the update callback.\n   * @return Promise the promise for the accumulation.\n   */\n\n\n  accumulate(updateCb) {\n    return accumulate(this, updateCb);\n  }\n  /**\n   * Add a listener on an event triggered on a stream.\n   * @param {String} evt the name of the event\n   * @param {Function} fn the listener\n   * @return {StreamHelper} the current helper.\n   */\n\n\n  on(evt, fn) {\n    var self = this;\n\n    if (evt === \"data\") {\n      this._worker.on(evt, function (chunk) {\n        fn.call(self, chunk.data, chunk.meta);\n      });\n    } else {\n      this._worker.on(evt, function () {\n        delay(fn, arguments, self);\n      });\n    }\n\n    return this;\n  }\n  /**\n   * Resume the flow of chunks.\n   * @return {StreamHelper} the current helper.\n   */\n\n\n  resume() {\n    delay(this._worker.resume, [], this._worker);\n    return this;\n  }\n  /**\n   * Pause the flow of chunks.\n   * @return {StreamHelper} the current helper.\n   */\n\n\n  pause() {\n    this._worker.pause();\n\n    return this;\n  }\n\n}\n\nconst base64 = false;\nconst binary = false;\nconst dir = false;\nconst createFolders = true;\nconst date = null;\nconst compression = null;\nconst compressionOptions = null;\nconst comment = null;\nconst unixPermissions = null;\nconst dosPermissions = null;\nvar defaults = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  base64: base64,\n  binary: binary,\n  dir: dir,\n  createFolders: createFolders,\n  date: date,\n  compression: compression,\n  compressionOptions: compressionOptions,\n  comment: comment,\n  unixPermissions: unixPermissions,\n  dosPermissions: dosPermissions\n});\n/* eslint-disable */\n// the size of the generated chunks\n// TODO expose this as a public variable\n\nconst DEFAULT_BLOCK_SIZE = 16 * 1024;\n/**\n * A worker that reads a content and emits chunks.\n * @constructor\n * @param {Promise} dataP the promise of the data to split\n */\n\nclass DataWorker extends GenericWorker {\n  constructor(dataP) {\n    super(\"DataWorker\");\n    var self = this;\n    this.dataIsReady = false;\n    this.index = 0;\n    this.max = 0;\n    this.data = null;\n    this.type = \"\";\n    this._tickScheduled = false;\n    dataP.then(function (data) {\n      self.dataIsReady = true;\n      self.data = data;\n      self.max = data && data.length || 0;\n      self.type = getTypeOf(data);\n\n      if (!self.isPaused) {\n        self._tickAndRepeat();\n      }\n    }, function (e) {\n      self.error(e);\n    });\n  }\n  /**\n   * @see GenericWorker.cleanUp\n   */\n\n\n  cleanUp() {\n    super.cleanUp();\n    this.data = null;\n  }\n  /**\n   * @see GenericWorker.resume\n   */\n\n\n  resume() {\n    if (!super.resume()) {\n      return false;\n    }\n\n    if (!this._tickScheduled && this.dataIsReady) {\n      this._tickScheduled = true;\n      delay(this._tickAndRepeat, [], this);\n    }\n\n    return true;\n  }\n  /**\n   * Trigger a tick a schedule an other call to this function.\n   */\n\n\n  _tickAndRepeat() {\n    this._tickScheduled = false;\n\n    if (this.isPaused || this.isFinished) {\n      return;\n    }\n\n    this._tick();\n\n    if (!this.isFinished) {\n      delay(this._tickAndRepeat, [], this);\n      this._tickScheduled = true;\n    }\n  }\n\n  /**\n   * Read and push a chunk.\n   */\n  _tick() {\n    if (this.isPaused || this.isFinished) {\n      return false;\n    }\n\n    var size = DEFAULT_BLOCK_SIZE;\n    var data = null,\n        nextIndex = Math.min(this.max, this.index + size);\n\n    if (this.index >= this.max) {\n      // EOF\n      return this.end();\n    } else {\n      switch (this.type) {\n        case \"string\":\n          data = this.data.substring(this.index, nextIndex);\n          break;\n\n        case \"uint8array\":\n          data = this.data.subarray(this.index, nextIndex);\n          break;\n\n        case \"array\":\n          data = this.data.slice(this.index, nextIndex);\n          break;\n      }\n\n      this.index = nextIndex;\n      return this.push({\n        data: data,\n        meta: {\n          percent: this.max ? this.index / this.max * 100 : 0\n        }\n      });\n    }\n  }\n\n}\n/**\n * A worker which calculate the total length of the data flowing through.\n * @constructor\n * @param {String} propName the name used to expose the length\n */\n\n\nclass DataLengthProbe extends GenericWorker {\n  constructor(propName) {\n    super(\"DataLengthProbe for \" + propName);\n    this.propName = propName;\n    this.withStreamInfo(propName, 0);\n  }\n  /**\n   * @see GenericWorker.processChunk\n   */\n\n\n  processChunk(chunk) {\n    if (chunk) {\n      const length = this.streamInfo[this.propName] || 0;\n      this.streamInfo[this.propName] = length + chunk.data.length;\n    }\n\n    super.processChunk(chunk);\n  }\n\n}\n/* eslint-disable */\n\n/**\n * The following functions come from pako, from pako/lib/zlib/crc32.js\n * released under the MIT license, see pako https://github.com/nodeca/pako/\n */\n\n\nlet makeTable = function () {\n  // Use ordinary array, since untyped makes no boost here\n  const table = [];\n\n  for (let n = 0; n < 256; n++) {\n    let c = n;\n\n    for (let k = 0; k < 8; k++) {\n      c = c & 1 ? 0xEDB88320 ^ c >>> 1 : c >>> 1;\n    }\n\n    table[n] = c;\n  } // Memoize table on first call.\n\n\n  makeTable = function () {\n    return table;\n  };\n\n  return table;\n};\n\nfunction crc32(crc, buf, len, pos) {\n  const t = makeTable();\n  let end = pos + len;\n  crc = crc ^ -1;\n\n  for (let i = pos; i < end; i++) {\n    crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 0xFF];\n  }\n\n  return crc ^ -1; // >>> 0;\n} // That's all for the pako functions.\n\n/**\n * Compute the crc32 of a string.\n * This is almost the same as the function crc32, but for strings. Using the\n * same function for the two use cases leads to horrible performances.\n * @param {Number} crc the starting value of the crc.\n * @param {String} str the string to use.\n * @param {Number} len the length of the string.\n * @param {Number} pos the starting position for the crc32 computation.\n * @return {Number} the computed crc32.\n */\n\n\nfunction crc32str(crc, str, len, pos) {\n  const t = makeTable();\n  let end = pos + len;\n  crc = crc ^ -1;\n\n  for (let i = pos; i < end; i++) {\n    crc = crc >>> 8 ^ t[(crc ^ str.charCodeAt(i)) & 0xFF];\n  }\n\n  return crc ^ -1; // >>> 0;\n}\n\nfunction crc32wrapper(input, crc) {\n  if (typeof input === \"undefined\" || !input.length) {\n    return 0;\n  }\n\n  const isArray = getTypeOf(input) !== \"string\";\n\n  if (isArray) {\n    return crc32(crc | 0, input, input.length, 0);\n  } else {\n    return crc32str(crc | 0, input, input.length, 0);\n  }\n}\n/**\n * A worker which calculate the crc32 of the data flowing through.\n * @constructor\n */\n\n\nclass Crc32Probe extends GenericWorker {\n  constructor() {\n    super(\"Crc32Probe\");\n    this.withStreamInfo(\"crc32\", 0);\n  }\n  /**\n   * @see GenericWorker.processChunk\n   */\n\n\n  processChunk(chunk) {\n    this.streamInfo.crc32 = crc32wrapper(chunk.data, this.streamInfo.crc32 || 0);\n    this.push(chunk);\n  }\n\n}\n/* eslint-disable */\n\n/**\n * Represent a compressed object, with everything needed to decompress it.\n * @constructor\n * @param {number} compressedSize the size of the data compressed.\n * @param {number} uncompressedSize the size of the data after decompression.\n * @param {number} crc32 the crc32 of the decompressed file.\n * @param {object} compression the type of compression, see lib/compressions.js.\n * @param {String|ArrayBuffer|Uint8Array|Buffer} data the compressed data.\n */\n\n\nclass CompressedObject {\n  constructor(compressedSize, uncompressedSize, crc32, compression, data) {\n    this.compressedSize = compressedSize;\n    this.uncompressedSize = uncompressedSize;\n    this.crc32 = crc32;\n    this.compression = compression;\n    this.compressedContent = data;\n  }\n  /**\n   * Create a worker to get the uncompressed content.\n   * @return {GenericWorker} the worker.\n   */\n\n\n  getContentWorker() {\n    var worker = new DataWorker(external.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new DataLengthProbe(\"data_length\"));\n    var that = this;\n    worker.on(\"end\", function () {\n      if (this.streamInfo['data_length'] !== that.uncompressedSize) {\n        throw new Error(\"Bug : uncompressed data size mismatch\");\n      }\n    });\n    return worker;\n  }\n  /**\n   * Create a worker to get the compressed content.\n   * @return {GenericWorker} the worker.\n   */\n\n\n  getCompressedWorker() {\n    return new DataWorker(external.Promise.resolve(this.compressedContent)).withStreamInfo(\"compressedSize\", this.compressedSize).withStreamInfo(\"uncompressedSize\", this.uncompressedSize).withStreamInfo(\"crc32\", this.crc32).withStreamInfo(\"compression\", this.compression);\n  }\n  /**\n   * Chain the given worker with other workers to compress the content with the\n   * given compression.\n   * @param {GenericWorker} uncompressedWorker the worker to pipe.\n   * @param {Object} compression the compression object.\n   * @param {Object} compressionOptions the options to use when compressing.\n   * @return {GenericWorker} the new worker compressing the content.\n   */\n\n\n  static createWorkerFrom(uncompressedWorker, compression, compressionOptions) {\n    return uncompressedWorker.pipe(new Crc32Probe()).pipe(new DataLengthProbe(\"uncompressedSize\")).pipe(compression.compressWorker(compressionOptions)).pipe(new DataLengthProbe(\"compressedSize\")).withStreamInfo(\"compression\", compression);\n  }\n\n}\n/* eslint-disable */\n\n/**\n * A simple object representing a file in the zip file.\n * @constructor\n * @param {string} name the name of the file\n * @param {String|ArrayBuffer|Uint8Array|Buffer} data the data\n * @param {Object} options the options of the file\n */\n\n\nclass ZipObject {\n  constructor(name, data, options) {\n    this.name = name;\n    this.dir = options.dir;\n    this.date = options.date;\n    this.comment = options.comment;\n    this.unixPermissions = options.unixPermissions;\n    this.dosPermissions = options.dosPermissions;\n    this._data = data;\n    this._dataBinary = options.binary; // keep only the compression\n\n    this.options = {\n      compression: options.compression,\n      compressionOptions: options.compressionOptions\n    };\n  }\n  /**\n   * Create an internal stream for the content of this object.\n   * @param {String} type the type of each chunk.\n   * @return StreamHelper the stream.\n   */\n\n\n  internalStream(type) {\n    var result = null,\n        outputType = \"string\";\n\n    try {\n      if (!type) {\n        throw new Error(\"No output type specified.\");\n      }\n\n      outputType = type.toLowerCase();\n      var askUnicodeString = outputType === \"string\" || outputType === \"text\";\n\n      if (outputType === \"binarystring\" || outputType === \"text\") {\n        outputType = \"string\";\n      }\n\n      result = this._decompressWorker();\n      var isUnicodeString = !this._dataBinary;\n\n      if (isUnicodeString && !askUnicodeString) {\n        result = result.pipe(new Utf8EncodeWorker());\n      }\n\n      if (!isUnicodeString && askUnicodeString) {\n        result = result.pipe(new Utf8DecodeWorker());\n      }\n    } catch (e) {\n      result = new GenericWorker(\"error\");\n      result.error(e);\n    }\n\n    return new StreamHelper(result, outputType, \"\");\n  }\n  /**\n   * Prepare the content in the asked type.\n   * @param {String} type the type of the result.\n   * @param {Function} onUpdate a function to call on each internal update.\n   * @return Promise the promise of the result.\n   */\n\n\n  async(type, onUpdate) {\n    return this.internalStream(type).accumulate(onUpdate);\n  }\n  /**\n   * Return a worker for the compressed content.\n   * @private\n   * @param {Object} compression the compression object to use.\n   * @param {Object} compressionOptions the options to use when compressing.\n   * @return Worker the worker.\n   */\n\n\n  _compressWorker(compression, compressionOptions) {\n    if (this._data instanceof CompressedObject && this._data.compression.magic === compression.magic) {\n      return this._data.getCompressedWorker();\n    } else {\n      var result = this._decompressWorker();\n\n      if (!this._dataBinary) {\n        result = result.pipe(new Utf8EncodeWorker());\n      }\n\n      return CompressedObject.createWorkerFrom(result, compression, compressionOptions);\n    }\n  }\n  /**\n   * Return a worker for the decompressed content.\n   * @private\n   * @return Worker the worker.\n   */\n\n\n  _decompressWorker() {\n    if (this._data instanceof CompressedObject) {\n      return this._data.getContentWorker();\n    } else if (this._data instanceof GenericWorker) {\n      return this._data;\n    } else {\n      return new DataWorker(this._data);\n    }\n  }\n\n}\n\nlet arrayType = function () {\n  const useTypedArray = typeof Uint8Array !== 'undefined' && typeof Uint16Array !== 'undefined' && typeof Uint32Array !== 'undefined';\n  const resolved = useTypedArray ? \"uint8array\" : \"array\";\n\n  arrayType = function () {\n    return resolved;\n  };\n};\n/**\n * Create a worker that uses pako to inflate/deflate.\n * @constructor\n * @param {String} action the name of the pako function to call : either \"Deflate\" or \"Inflate\".\n * @param {Object} options the options to use when (de)compressing.\n */\n\n\nclass FlateWorker extends GenericWorker {\n  constructor(action, options) {\n    super(\"FlateWorker/\" + action);\n    this._pako = null;\n    this._pakoAction = action;\n    this._pakoOptions = options; // the `meta` object from the last chunk received\n    // this allow this worker to pass around metadata\n\n    this.meta = {};\n  }\n  /**\n   * @see GenericWorker.processChunk\n   */\n\n\n  processChunk(chunk) {\n    this.meta = chunk.meta;\n\n    if (this._pako === null) {\n      this._createPako();\n    }\n\n    this._pako.push(transformTo(arrayType(), chunk.data), false);\n  }\n  /**\n   * @see GenericWorker.flush\n   */\n\n\n  flush() {\n    super.flush();\n\n    if (this._pako === null) {\n      this._createPako();\n    }\n\n    this._pako.push([], true);\n  }\n  /**\n   * @see GenericWorker.cleanUp\n   */\n\n\n  cleanUp() {\n    super.cleanUp();\n    this._pako = null;\n  }\n  /**\n   * Create the _pako object.\n   * TODO: lazy-loading this object isn't the best solution but it's the\n   * quickest. The best solution is to lazy-load the worker list. See also the\n   * issue #446.\n   */\n\n\n  _createPako() {\n    const params = {\n      raw: true,\n      level: this._pakoOptions.level || -1 // default compression\n\n    };\n    this._pako = this._pakoAction === 'Deflate' ? new Deflate(params) : new Inflate(params);\n\n    this._pako.onData = data => {\n      this.push({\n        data: data,\n        meta: this.meta\n      });\n    };\n  }\n\n}\n\nvar DEFLATE = {\n  magic: \"\\x08\\x00\",\n  compressWorker: function (compressionOptions) {\n    return new FlateWorker(\"Deflate\", compressionOptions);\n  },\n  uncompressWorker: function () {\n    return new FlateWorker(\"Inflate\", {});\n  }\n};\nconst STORE = {\n  magic: \"\\x00\\x00\",\n  compressWorker: function () {\n    return new GenericWorker(\"STORE compression\");\n  },\n  uncompressWorker: function () {\n    return new GenericWorker(\"STORE decompression\");\n  }\n};\nvar compressions = {\n  STORE,\n  DEFLATE\n};\nconst LOCAL_FILE_HEADER = \"PK\\x03\\x04\";\nconst CENTRAL_FILE_HEADER = \"PK\\x01\\x02\";\nconst CENTRAL_DIRECTORY_END = \"PK\\x05\\x06\";\nconst ZIP64_CENTRAL_DIRECTORY_LOCATOR = \"PK\\x06\\x07\";\nconst ZIP64_CENTRAL_DIRECTORY_END = \"PK\\x06\\x06\";\nconst DATA_DESCRIPTOR = \"PK\\x07\\x08\";\n/* eslint-disable */\n\n/**\n * Transform an integer into a string in hexadecimal.\n * @private\n * @param {number} dec the number to convert.\n * @param {number} bytes the number of bytes to generate.\n * @returns {string} the result.\n */\n\nvar decToHex = function (dec, bytes) {\n  var hex = \"\",\n      i;\n\n  for (i = 0; i < bytes; i++) {\n    hex += String.fromCharCode(dec & 0xff);\n    dec = dec >>> 8;\n  }\n\n  return hex;\n};\n/**\n * Generate the UNIX part of the external file attributes.\n * @param {Object} unixPermissions the unix permissions or null.\n * @param {Boolean} isDir true if the entry is a directory, false otherwise.\n * @return {Number} a 32 bit integer.\n *\n * adapted from http://unix.stackexchange.com/questions/14705/the-zip-formats-external-file-attribute :\n *\n * TTTTsstrwxrwxrwx0000000000ADVSHR\n * ^^^^____________________________ file type, see zipinfo.c (UNX_*)\n *     ^^^_________________________ setuid, setgid, sticky\n *        ^^^^^^^^^________________ permissions\n *                 ^^^^^^^^^^______ not used ?\n *                           ^^^^^^ DOS attribute bits : Archive, Directory, Volume label, System file, Hidden, Read only\n */\n\n\nvar generateUnixExternalFileAttr = function (unixPermissions, isDir) {\n  var result = unixPermissions;\n\n  if (!unixPermissions) {\n    // I can't use octal values in strict mode, hence the hexa.\n    //  040775 => 0x41fd\n    // 0100664 => 0x81b4\n    result = isDir ? 0x41fd : 0x81b4;\n  }\n\n  return (result & 0xFFFF) << 16;\n};\n/**\n * Generate the DOS part of the external file attributes.\n * @param {Object} dosPermissions the dos permissions or null.\n * @param {Boolean} isDir true if the entry is a directory, false otherwise.\n * @return {Number} a 32 bit integer.\n *\n * Bit 0     Read-Only\n * Bit 1     Hidden\n * Bit 2     System\n * Bit 3     Volume Label\n * Bit 4     Directory\n * Bit 5     Archive\n */\n\n\nvar generateDosExternalFileAttr = function (dosPermissions, isDir) {\n  // the dir flag is already set for compatibility\n  return (dosPermissions || 0) & 0x3F;\n};\n/**\n * Generate the various parts used in the construction of the final zip file.\n * @param {Object} streamInfo the hash with information about the compressed file.\n * @param {Boolean} streamedContent is the content streamed ?\n * @param {Boolean} streamingEnded is the stream finished ?\n * @param {number} offset the current offset from the start of the zip file.\n * @param {String} platform let's pretend we are this platform (change platform dependents fields)\n * @param {Function} encodeFileName the function to encode the file name / comment.\n * @return {Object} the zip parts.\n */\n\n\nvar generateZipParts = function (streamInfo, streamedContent, streamingEnded, offset, platform, encodeFileName) {\n  var file = streamInfo['file'],\n      compression = streamInfo['compression'],\n      useCustomEncoding = encodeFileName !== utf8encode,\n      encodedFileName = transformTo(\"string\", encodeFileName(file.name)),\n      utfEncodedFileName = transformTo(\"string\", utf8encode(file.name)),\n      comment = file.comment,\n      encodedComment = transformTo(\"string\", encodeFileName(comment)),\n      utfEncodedComment = transformTo(\"string\", utf8encode(comment)),\n      useUTF8ForFileName = utfEncodedFileName.length !== file.name.length,\n      useUTF8ForComment = utfEncodedComment.length !== comment.length,\n      dosTime,\n      dosDate,\n      extraFields = \"\",\n      unicodePathExtraField = \"\",\n      unicodeCommentExtraField = \"\",\n      dir = file.dir,\n      date = file.date;\n  var dataInfo = {\n    crc32: 0,\n    compressedSize: 0,\n    uncompressedSize: 0\n  }; // if the content is streamed, the sizes/crc32 are only available AFTER\n  // the end of the stream.\n\n  if (!streamedContent || streamingEnded) {\n    dataInfo.crc32 = streamInfo['crc32'];\n    dataInfo.compressedSize = streamInfo['compressedSize'];\n    dataInfo.uncompressedSize = streamInfo['uncompressedSize'];\n  }\n\n  var bitflag = 0;\n\n  if (streamedContent) {\n    // Bit 3: the sizes/crc32 are set to zero in the local header.\n    // The correct values are put in the data descriptor immediately\n    // following the compressed data.\n    bitflag |= 0x0008;\n  }\n\n  if (!useCustomEncoding && (useUTF8ForFileName || useUTF8ForComment)) {\n    // Bit 11: Language encoding flag (EFS).\n    bitflag |= 0x0800;\n  }\n\n  var extFileAttr = 0;\n  var versionMadeBy = 0;\n\n  if (dir) {\n    // dos or unix, we set the dos dir flag\n    extFileAttr |= 0x00010;\n  }\n\n  if (platform === \"UNIX\") {\n    versionMadeBy = 0x031E; // UNIX, version 3.0\n\n    extFileAttr |= generateUnixExternalFileAttr(file.unixPermissions, dir);\n  } else {\n    // DOS or other, fallback to DOS\n    versionMadeBy = 0x0014; // DOS, version 2.0\n\n    extFileAttr |= generateDosExternalFileAttr(file.dosPermissions);\n  } // date\n  // @see http://www.delorie.com/djgpp/doc/rbinter/it/52/13.html\n  // @see http://www.delorie.com/djgpp/doc/rbinter/it/65/16.html\n  // @see http://www.delorie.com/djgpp/doc/rbinter/it/66/16.html\n\n\n  dosTime = date.getUTCHours();\n  dosTime = dosTime << 6;\n  dosTime = dosTime | date.getUTCMinutes();\n  dosTime = dosTime << 5;\n  dosTime = dosTime | date.getUTCSeconds() / 2;\n  dosDate = date.getUTCFullYear() - 1980;\n  dosDate = dosDate << 4;\n  dosDate = dosDate | date.getUTCMonth() + 1;\n  dosDate = dosDate << 5;\n  dosDate = dosDate | date.getUTCDate();\n\n  if (useUTF8ForFileName) {\n    // set the unicode path extra field. unzip needs at least one extra\n    // field to correctly handle unicode path, so using the path is as good\n    // as any other information. This could improve the situation with\n    // other archive managers too.\n    // This field is usually used without the utf8 flag, with a non\n    // unicode path in the header (winrar, winzip). This helps (a bit)\n    // with the messy Windows' default compressed folders feature but\n    // breaks on p7zip which doesn't seek the unicode path extra field.\n    // So for now, UTF-8 everywhere !\n    unicodePathExtraField = // Version\n    decToHex(1, 1) + // NameCRC32\n    decToHex(crc32wrapper(encodedFileName), 4) + // UnicodeName\n    utfEncodedFileName;\n    extraFields += // Info-ZIP Unicode Path Extra Field\n    \"\\x75\\x70\" + // size\n    decToHex(unicodePathExtraField.length, 2) + // content\n    unicodePathExtraField;\n  }\n\n  if (useUTF8ForComment) {\n    unicodeCommentExtraField = // Version\n    decToHex(1, 1) + // CommentCRC32\n    decToHex(crc32wrapper(encodedComment), 4) + // UnicodeName\n    utfEncodedComment;\n    extraFields += // Info-ZIP Unicode Path Extra Field\n    \"\\x75\\x63\" + // size\n    decToHex(unicodeCommentExtraField.length, 2) + // content\n    unicodeCommentExtraField;\n  }\n\n  var header = \"\"; // version needed to extract\n\n  header += \"\\x0A\\x00\"; // general purpose bit flag\n\n  header += decToHex(bitflag, 2); // compression method\n\n  header += compression.magic; // last mod file time\n\n  header += decToHex(dosTime, 2); // last mod file date\n\n  header += decToHex(dosDate, 2); // crc-32\n\n  header += decToHex(dataInfo.crc32, 4); // compressed size\n\n  header += decToHex(dataInfo.compressedSize, 4); // uncompressed size\n\n  header += decToHex(dataInfo.uncompressedSize, 4); // file name length\n\n  header += decToHex(encodedFileName.length, 2); // extra field length\n\n  header += decToHex(extraFields.length, 2);\n  var fileRecord = LOCAL_FILE_HEADER + header + encodedFileName + extraFields;\n  var dirRecord = CENTRAL_FILE_HEADER + // version made by (00: DOS)\n  decToHex(versionMadeBy, 2) + // file header (common to file and central directory)\n  header + // file comment length\n  decToHex(encodedComment.length, 2) + // disk number start\n  \"\\x00\\x00\" + // internal file attributes TODO\n  \"\\x00\\x00\" + // external file attributes\n  decToHex(extFileAttr, 4) + // relative offset of local header\n  decToHex(offset, 4) + // file name\n  encodedFileName + // extra field\n  extraFields + // file comment\n  encodedComment;\n  return {\n    fileRecord: fileRecord,\n    dirRecord: dirRecord\n  };\n};\n/**\n * Generate the EOCD record.\n * @param {Number} entriesCount the number of entries in the zip file.\n * @param {Number} centralDirLength the length (in bytes) of the central dir.\n * @param {Number} localDirLength the length (in bytes) of the local dir.\n * @param {String} comment the zip file comment as a binary string.\n * @param {Function} encodeFileName the function to encode the comment.\n * @return {String} the EOCD record.\n */\n\n\nvar generateCentralDirectoryEnd = function (entriesCount, centralDirLength, localDirLength, comment, encodeFileName) {\n  var dirEnd = \"\";\n  var encodedComment = transformTo(\"string\", encodeFileName(comment)); // end of central dir signature\n\n  dirEnd = CENTRAL_DIRECTORY_END + // number of this disk\n  \"\\x00\\x00\" + // number of the disk with the start of the central directory\n  \"\\x00\\x00\" + // total number of entries in the central directory on this disk\n  decToHex(entriesCount, 2) + // total number of entries in the central directory\n  decToHex(entriesCount, 2) + // size of the central directory   4 bytes\n  decToHex(centralDirLength, 4) + // offset of start of central directory with respect to the starting disk number\n  decToHex(localDirLength, 4) + // .ZIP file comment length\n  decToHex(encodedComment.length, 2) + // .ZIP file comment\n  encodedComment;\n  return dirEnd;\n};\n/**\n * Generate data descriptors for a file entry.\n * @param {Object} streamInfo the hash generated by a worker, containing information\n * on the file entry.\n * @return {String} the data descriptors.\n */\n\n\nvar generateDataDescriptors = function (streamInfo) {\n  var descriptor = \"\";\n  descriptor = DATA_DESCRIPTOR + // crc-32                          4 bytes\n  decToHex(streamInfo['crc32'], 4) + // compressed size                 4 bytes\n  decToHex(streamInfo['compressedSize'], 4) + // uncompressed size               4 bytes\n  decToHex(streamInfo['uncompressedSize'], 4);\n  return descriptor;\n};\n/**\n * A worker to concatenate other workers to create a zip file.\n * @param {Boolean} streamFiles `true` to stream the content of the files,\n * `false` to accumulate it.\n * @param {String} comment the comment to use.\n * @param {String} platform the platform to use, \"UNIX\" or \"DOS\".\n * @param {Function} encodeFileName the function to encode file names and comments.\n */\n\n\nclass ZipFileWorker extends GenericWorker {\n  constructor(streamFiles, comment, platform, encodeFileName) {\n    super(\"ZipFileWorker\"); // The number of bytes written so far. This doesn't count accumulated chunks.\n\n    this.bytesWritten = 0; // The comment of the zip file\n\n    this.zipComment = comment; // The platform \"generating\" the zip file.\n\n    this.zipPlatform = platform; // the function to encode file names and comments.\n\n    this.encodeFileName = encodeFileName; // Should we stream the content of the files ?\n\n    this.streamFiles = streamFiles; // If `streamFiles` is false, we will need to accumulate the content of the\n    // files to calculate sizes / crc32 (and write them *before* the content).\n    // This boolean indicates if we are accumulating chunks (it will change a lot\n    // during the lifetime of this worker).\n\n    this.accumulate = false; // The buffer receiving chunks when accumulating content.\n\n    this.contentBuffer = []; // The list of generated directory records.\n\n    this.dirRecords = []; // The offset (in bytes) from the beginning of the zip file for the current source.\n\n    this.currentSourceOffset = 0; // The total number of entries in this zip file.\n\n    this.entriesCount = 0; // the name of the file currently being added, null when handling the end of the zip file.\n    // Used for the emitted metadata.\n\n    this.currentFile = null;\n    this._sources = [];\n  }\n  /**\n   * @see GenericWorker.push\n   */\n\n\n  push(chunk) {\n    var currentFilePercent = chunk.meta.percent || 0;\n    var entriesCount = this.entriesCount;\n    var remainingFiles = this._sources.length;\n\n    if (this.accumulate) {\n      this.contentBuffer.push(chunk);\n    } else {\n      this.bytesWritten += chunk.data.length;\n      super.push({\n        data: chunk.data,\n        meta: {\n          currentFile: this.currentFile,\n          percent: entriesCount ? (currentFilePercent + 100 * (entriesCount - remainingFiles - 1)) / entriesCount : 100\n        }\n      });\n    }\n  }\n  /**\n   * The worker started a new source (an other worker).\n   * @param {Object} streamInfo the streamInfo object from the new source.\n   */\n\n\n  openedSource(streamInfo) {\n    this.currentSourceOffset = this.bytesWritten;\n    this.currentFile = streamInfo['file'].name;\n    var streamedContent = this.streamFiles && !streamInfo['file'].dir; // don't stream folders (because they don't have any content)\n\n    if (streamedContent) {\n      var record = generateZipParts(streamInfo, streamedContent, false, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);\n      this.push({\n        data: record.fileRecord,\n        meta: {\n          percent: 0\n        }\n      });\n    } else {\n      // we need to wait for the whole file before pushing anything\n      this.accumulate = true;\n    }\n  }\n  /**\n   * The worker finished a source (an other worker).\n   * @param {Object} streamInfo the streamInfo object from the finished source.\n   */\n\n\n  closedSource(streamInfo) {\n    this.accumulate = false;\n    var streamedContent = this.streamFiles && !streamInfo['file'].dir;\n    var record = generateZipParts(streamInfo, streamedContent, true, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);\n    this.dirRecords.push(record.dirRecord);\n\n    if (streamedContent) {\n      // after the streamed file, we put data descriptors\n      this.push({\n        data: generateDataDescriptors(streamInfo),\n        meta: {\n          percent: 100\n        }\n      });\n    } else {\n      // the content wasn't streamed, we need to push everything now\n      // first the file record, then the content\n      this.push({\n        data: record.fileRecord,\n        meta: {\n          percent: 0\n        }\n      });\n\n      while (this.contentBuffer.length) {\n        this.push(this.contentBuffer.shift());\n      }\n    }\n\n    this.currentFile = null;\n  }\n  /**\n   * @see GenericWorker.flush\n   */\n\n\n  flush() {\n    var localDirLength = this.bytesWritten;\n\n    for (var i = 0; i < this.dirRecords.length; i++) {\n      this.push({\n        data: this.dirRecords[i],\n        meta: {\n          percent: 100\n        }\n      });\n    }\n\n    var centralDirLength = this.bytesWritten - localDirLength;\n    var dirEnd = generateCentralDirectoryEnd(this.dirRecords.length, centralDirLength, localDirLength, this.zipComment, this.encodeFileName);\n    this.push({\n      data: dirEnd,\n      meta: {\n        percent: 100\n      }\n    });\n  }\n  /**\n   * Prepare the next source to be read.\n   */\n\n\n  prepareNextSource() {\n    this.previous = this._sources.shift();\n    this.openedSource(this.previous.streamInfo);\n\n    if (this.isPaused) {\n      this.previous.pause();\n    } else {\n      this.previous.resume();\n    }\n  }\n  /**\n   * @see GenericWorker.registerPrevious\n   */\n\n\n  registerPrevious(previous) {\n    this._sources.push(previous);\n\n    var self = this;\n    previous.on('data', function (chunk) {\n      self.processChunk(chunk);\n    });\n    previous.on('end', function () {\n      self.closedSource(self.previous.streamInfo);\n\n      if (self._sources.length) {\n        self.prepareNextSource();\n      } else {\n        self.end();\n      }\n    });\n    previous.on('error', function (e) {\n      self.error(e);\n    });\n    return this;\n  }\n  /**\n   * @see GenericWorker.resume\n   */\n\n\n  resume() {\n    if (!super.resume()) {\n      return false;\n    }\n\n    if (!this.previous && this._sources.length) {\n      this.prepareNextSource();\n      return true;\n    }\n\n    if (!this.previous && !this._sources.length && !this.generatedError) {\n      this.end();\n      return true;\n    }\n  }\n  /**\n   * @see GenericWorker.error\n   */\n\n\n  error(e) {\n    var sources = this._sources;\n\n    if (!super.error(e)) {\n      return false;\n    }\n\n    for (var i = 0; i < sources.length; i++) {\n      try {\n        sources[i].error(e);\n      } catch (e) {// the `error` exploded, nothing to do\n      }\n    }\n\n    return true;\n  }\n  /**\n   * @see GenericWorker.lock\n   */\n\n\n  lock() {\n    super.lock();\n    var sources = this._sources;\n\n    for (var i = 0; i < sources.length; i++) {\n      sources[i].lock();\n    }\n  }\n\n}\n/* eslint-disable */\n\n/**\n * Find the compression to use.\n * @param {String} fileCompression the compression defined at the file level, if any.\n * @param {String} zipCompression the compression defined at the load() level.\n * @return {Object} the compression object to use.\n */\n\n\nvar getCompression = function (fileCompression, zipCompression) {\n  var compressionName = fileCompression || zipCompression;\n  var compression = compressions[compressionName];\n\n  if (!compression) {\n    throw new Error(compressionName + \" is not a valid compression method !\");\n  }\n\n  return compression;\n};\n/**\n * Create a worker to generate a zip file.\n * @param {JSZip} zip the JSZip instance at the right root level.\n * @param {Object} options to generate the zip file.\n * @param {String} comment the comment to use.\n */\n\n\nconst generateWorker = function (zip, options, comment) {\n  var zipFileWorker = new ZipFileWorker(options.streamFiles, comment, options.platform, options.encodeFileName);\n  var entriesCount = 0;\n\n  try {\n    zip.forEach(function (relativePath, file) {\n      entriesCount++;\n      var compression = getCompression(file.options.compression, options.compression);\n      var compressionOptions = file.options.compressionOptions || options.compressionOptions || {};\n      var dir = file.dir,\n          date = file.date;\n\n      file._compressWorker(compression, compressionOptions).withStreamInfo(\"file\", {\n        name: relativePath,\n        dir: dir,\n        date: date,\n        comment: file.comment || \"\",\n        unixPermissions: file.unixPermissions,\n        dosPermissions: file.dosPermissions\n      }).pipe(zipFileWorker);\n    });\n    zipFileWorker.entriesCount = entriesCount;\n  } catch (e) {\n    zipFileWorker.error(e);\n  }\n\n  return zipFileWorker;\n};\n/* eslint-disable */\n\n\nclass DataReader {\n  constructor(data) {\n    this.data = data; // type : see implementation\n\n    this.length = data.length;\n    this.index = 0;\n    this.zero = 0;\n  }\n  /**\n   * Check that the offset will not go too far.\n   * @param {string} offset the additional offset to check.\n   * @throws {Error} an Error if the offset is out of bounds.\n   */\n\n\n  checkOffset(offset) {\n    this.checkIndex(this.index + offset);\n  }\n  /**\n   * Check that the specified index will not be too far.\n   * @param {string} newIndex the index to check.\n   * @throws {Error} an Error if the index is out of bounds.\n   */\n\n\n  checkIndex(newIndex) {\n    if (this.length < this.zero + newIndex || newIndex < 0) {\n      throw new Error(\"End of data reached (data length = \" + this.length + \", asked index = \" + newIndex + \"). Corrupted zip ?\");\n    }\n  }\n  /**\n   * Change the index.\n   * @param {number} newIndex The new index.\n   * @throws {Error} if the new index is out of the data.\n   */\n\n\n  setIndex(newIndex) {\n    this.checkIndex(newIndex);\n    this.index = newIndex;\n  }\n  /**\n   * Skip the next n bytes.\n   * @param {number} n the number of bytes to skip.\n   * @throws {Error} if the new index is out of the data.\n   */\n\n\n  skip(n) {\n    this.setIndex(this.index + n);\n  }\n  /**\n   * Get the byte at the specified index.\n   * @param {number} i the index to use.\n   * @return {number} a byte.\n   */\n\n\n  byteAt(i) {// see implementations\n  }\n  /**\n   * Get the next number with a given byte size.\n   * @param {number} size the number of bytes to read.\n   * @return {number} the corresponding number.\n   */\n\n\n  readInt(size) {\n    var result = 0,\n        i;\n    this.checkOffset(size);\n\n    for (i = this.index + size - 1; i >= this.index; i--) {\n      result = (result << 8) + this.byteAt(i);\n    }\n\n    this.index += size;\n    return result;\n  }\n  /**\n   * Get the next string with a given byte size.\n   * @param {number} size the number of bytes to read.\n   * @return {string} the corresponding string.\n   */\n\n\n  readString(size) {\n    return transformTo(\"string\", this.readData(size));\n  }\n  /**\n   * Get raw data without conversion, <size> bytes.\n   * @param {number} size the number of bytes to read.\n   * @return {Object} the raw data, implementation specific.\n   */\n\n\n  readData(size) {// see implementations\n  }\n  /**\n   * Find the last occurrence of a zip signature (4 bytes).\n   * @param {string} sig the signature to find.\n   * @return {number} the index of the last occurrence, -1 if not found.\n   */\n\n\n  lastIndexOfSignature(sig) {// see implementations\n  }\n  /**\n   * Read the signature (4 bytes) at the current position and compare it with sig.\n   * @param {string} sig the expected signature\n   * @return {boolean} true if the signature matches, false otherwise.\n   */\n\n\n  readAndCheckSignature(sig) {// see implementations\n  }\n  /**\n   * Get the next date.\n   * @return {Date} the date.\n   */\n\n\n  readDate() {\n    var dostime = this.readInt(4);\n    return new Date(Date.UTC((dostime >> 25 & 0x7f) + 1980, // year\n    (dostime >> 21 & 0x0f) - 1, // month\n    dostime >> 16 & 0x1f, // day\n    dostime >> 11 & 0x1f, // hour\n    dostime >> 5 & 0x3f, // minute\n    (dostime & 0x1f) << 1)); // second\n  }\n\n}\n/* eslint-disable */\n\n\nclass ArrayReader extends DataReader {\n  constructor(data) {\n    super(data);\n\n    for (var i = 0; i < this.data.length; i++) {\n      data[i] = data[i] & 0xFF;\n    }\n  }\n  /**\n   * @see DataReader.byteAt\n   */\n\n\n  byteAt(i) {\n    return this.data[this.zero + i];\n  }\n  /**\n   * @see DataReader.lastIndexOfSignature\n   */\n\n\n  lastIndexOfSignature(sig) {\n    var sig0 = sig.charCodeAt(0),\n        sig1 = sig.charCodeAt(1),\n        sig2 = sig.charCodeAt(2),\n        sig3 = sig.charCodeAt(3);\n\n    for (var i = this.length - 4; i >= 0; --i) {\n      if (this.data[i] === sig0 && this.data[i + 1] === sig1 && this.data[i + 2] === sig2 && this.data[i + 3] === sig3) {\n        return i - this.zero;\n      }\n    }\n\n    return -1;\n  }\n  /**\n   * @see DataReader.readAndCheckSignature\n   */\n\n\n  readAndCheckSignature(sig) {\n    var sig0 = sig.charCodeAt(0),\n        sig1 = sig.charCodeAt(1),\n        sig2 = sig.charCodeAt(2),\n        sig3 = sig.charCodeAt(3),\n        data = this.readData(4);\n    return sig0 === data[0] && sig1 === data[1] && sig2 === data[2] && sig3 === data[3];\n  }\n  /**\n   * @see DataReader.readData\n   */\n\n\n  readData(size) {\n    this.checkOffset(size);\n\n    if (size === 0) {\n      return [];\n    }\n\n    var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);\n    this.index += size;\n    return result;\n  }\n\n}\n\nclass StringReader extends DataReader {\n  constructor(data) {\n    super(data);\n  }\n  /**\n   * @see DataReader.byteAt\n   */\n\n\n  byteAt(i) {\n    return this.data.charCodeAt(this.zero + i);\n  }\n  /**\n   * @see DataReader.lastIndexOfSignature\n   */\n\n\n  lastIndexOfSignature(sig) {\n    return this.data.lastIndexOf(sig) - this.zero;\n  }\n  /**\n   * @see DataReader.readAndCheckSignature\n   */\n\n\n  readAndCheckSignature(sig) {\n    const data = this.readData(4);\n    return sig === data;\n  }\n  /**\n   * @see DataReader.readData\n   */\n\n\n  readData(size) {\n    this.checkOffset(size); // this will work because the constructor applied the \"& 0xff\" mask.\n\n    const result = this.data.slice(this.zero + this.index, this.zero + this.index + size);\n    this.index += size;\n    return result;\n  }\n\n}\n/* eslint-disable */\n\n\nclass Uint8ArrayReader extends ArrayReader {\n  constructor(data) {\n    super(data);\n  }\n  /**\n   * @see DataReader.readData\n   */\n\n\n  readData(size) {\n    this.checkOffset(size);\n\n    if (size === 0) {\n      // in IE10, when using subarray(idx, idx), we get the array [0x00] instead of [].\n      return new Uint8Array(0);\n    }\n\n    var result = this.data.subarray(this.zero + this.index, this.zero + this.index + size);\n    this.index += size;\n    return result;\n  }\n\n}\n/**\n * Create a reader adapted to the data.\n * @param {String|ArrayBuffer|Uint8Array|Buffer} data the data to read.\n * @return {DataReader} the data reader.\n */\n\n\nfunction readerFor(data) {\n  const type = getTypeOf(data);\n  checkSupport(type);\n\n  if (type === \"string\" && !support.uint8array) {\n    return new StringReader(data);\n  }\n\n  if (support.uint8array) {\n    return new Uint8ArrayReader(transformTo(\"uint8array\", data));\n  }\n\n  return new ArrayReader(transformTo(\"array\", data));\n}\n/* eslint-disable */\n\n\nvar MADE_BY_DOS = 0x00;\nvar MADE_BY_UNIX = 0x03;\n/**\n * Find a compression registered in JSZip.\n * @param {string} compressionMethod the method magic to find.\n * @return {Object|null} the JSZip compression object, null if none found.\n */\n\nvar findCompression = function (compressionMethod) {\n  for (var method in compressions) {\n    if (!compressions.hasOwnProperty(method)) {\n      continue;\n    }\n\n    if (compressions[method].magic === compressionMethod) {\n      return compressions[method];\n    }\n  }\n\n  return null;\n}; // class ZipEntry {{{\n\n/**\n * An entry in the zip file.\n * @constructor\n * @param {Object} options Options of the current file.\n * @param {Object} loadOptions Options for loading the stream.\n */\n\n\nclass ZipEntry {\n  constructor(options, loadOptions) {\n    this.options = options;\n    this.loadOptions = loadOptions;\n  }\n  /**\n   * say if the file is encrypted.\n   * @return {boolean} true if the file is encrypted, false otherwise.\n   */\n\n\n  isEncrypted() {\n    // bit 1 is set\n    return (this.bitFlag & 0x0001) === 0x0001;\n  }\n  /**\n   * say if the file has utf-8 filename/comment.\n   * @return {boolean} true if the filename/comment is in utf-8, false otherwise.\n   */\n\n\n  useUTF8() {\n    // bit 11 is set\n    return (this.bitFlag & 0x0800) === 0x0800;\n  }\n  /**\n   * Read the local part of a zip file and add the info in this object.\n   * @param {DataReader} reader the reader to use.\n   */\n\n\n  readLocalPart(reader) {\n    var compression, localExtraFieldsLength; // we already know everything from the central dir !\n    // If the central dir data are false, we are doomed.\n    // On the bright side, the local part is scary  : zip64, data descriptors, both, etc.\n    // The less data we get here, the more reliable this should be.\n    // Let's skip the whole header and dash to the data !\n\n    reader.skip(22); // in some zip created on windows, the filename stored in the central dir contains \\ instead of /.\n    // Strangely, the filename here is OK.\n    // I would love to treat these zip files as corrupted (see http://www.info-zip.org/FAQ.html#backslashes\n    // or APPNOTE#4.4.17.1, \"All slashes MUST be forward slashes '/'\") but there are a lot of bad zip generators...\n    // Search \"unzip mismatching \"local\" filename continuing with \"central\" filename version\" on\n    // the internet.\n    //\n    // I think I see the logic here : the central directory is used to display\n    // content and the local directory is used to extract the files. Mixing / and \\\n    // may be used to display \\ to windows users and use / when extracting the files.\n    // Unfortunately, this lead also to some issues : http://seclists.org/fulldisclosure/2009/Sep/394\n\n    this.fileNameLength = reader.readInt(2);\n    localExtraFieldsLength = reader.readInt(2); // can't be sure this will be the same as the central dir\n    // the fileName is stored as binary data, the handleUTF8 method will take care of the encoding.\n\n    this.fileName = reader.readData(this.fileNameLength);\n    reader.skip(localExtraFieldsLength);\n\n    if (this.compressedSize === -1 || this.uncompressedSize === -1) {\n      throw new Error(\"Bug or corrupted zip : didn't get enough information from the central directory \" + \"(compressedSize === -1 || uncompressedSize === -1)\");\n    }\n\n    compression = findCompression(this.compressionMethod);\n\n    if (compression === null) {\n      // no compression found\n      throw new Error(\"Corrupted zip : compression \" + pretty(this.compressionMethod) + \" unknown (inner file : \" + transformTo(\"string\", this.fileName) + \")\");\n    }\n\n    this.decompressed = new CompressedObject(this.compressedSize, this.uncompressedSize, this.crc32, compression, reader.readData(this.compressedSize));\n  }\n  /**\n   * Read the central part of a zip file and add the info in this object.\n   * @param {DataReader} reader the reader to use.\n   */\n\n\n  readCentralPart(reader) {\n    this.versionMadeBy = reader.readInt(2);\n    reader.skip(2); // this.versionNeeded = reader.readInt(2);\n\n    this.bitFlag = reader.readInt(2);\n    this.compressionMethod = reader.readString(2);\n    this.date = reader.readDate();\n    this.crc32 = reader.readInt(4);\n    this.compressedSize = reader.readInt(4);\n    this.uncompressedSize = reader.readInt(4);\n    var fileNameLength = reader.readInt(2);\n    this.extraFieldsLength = reader.readInt(2);\n    this.fileCommentLength = reader.readInt(2);\n    this.diskNumberStart = reader.readInt(2);\n    this.internalFileAttributes = reader.readInt(2);\n    this.externalFileAttributes = reader.readInt(4);\n    this.localHeaderOffset = reader.readInt(4);\n\n    if (this.isEncrypted()) {\n      throw new Error(\"Encrypted zip are not supported\");\n    } // will be read in the local part, see the comments there\n\n\n    reader.skip(fileNameLength);\n    this.readExtraFields(reader);\n    this.parseZIP64ExtraField(reader);\n    this.fileComment = reader.readData(this.fileCommentLength);\n  }\n  /**\n   * Parse the external file attributes and get the unix/dos permissions.\n   */\n\n\n  processAttributes() {\n    this.unixPermissions = null;\n    this.dosPermissions = null;\n    var madeBy = this.versionMadeBy >> 8; // Check if we have the DOS directory flag set.\n    // We look for it in the DOS and UNIX permissions\n    // but some unknown platform could set it as a compatibility flag.\n\n    this.dir = this.externalFileAttributes & 0x0010 ? true : false;\n\n    if (madeBy === MADE_BY_DOS) {\n      // first 6 bits (0 to 5)\n      this.dosPermissions = this.externalFileAttributes & 0x3F;\n    }\n\n    if (madeBy === MADE_BY_UNIX) {\n      this.unixPermissions = this.externalFileAttributes >> 16 & 0xFFFF; // the octal permissions are in (this.unixPermissions & 0x01FF).toString(8);\n    } // fail safe : if the name ends with a / it probably means a folder\n\n\n    if (!this.dir && this.fileNameStr.slice(-1) === '/') {\n      this.dir = true;\n    }\n  }\n  /**\n   * Parse the ZIP64 extra field and merge the info in the current ZipEntry.\n   * @param {DataReader} reader the reader to use.\n   */\n\n\n  parseZIP64ExtraField(reader) {\n    if (!this.extraFields[0x0001]) {\n      return;\n    } // should be something, preparing the extra reader\n\n\n    var extraReader = readerFor(this.extraFields[0x0001].value); // I really hope that these 64bits integer can fit in 32 bits integer, because js\n    // won't let us have more.\n\n    if (this.uncompressedSize === MAX_VALUE_32BITS) {\n      this.uncompressedSize = extraReader.readInt(8);\n    }\n\n    if (this.compressedSize === MAX_VALUE_32BITS) {\n      this.compressedSize = extraReader.readInt(8);\n    }\n\n    if (this.localHeaderOffset === MAX_VALUE_32BITS) {\n      this.localHeaderOffset = extraReader.readInt(8);\n    }\n\n    if (this.diskNumberStart === MAX_VALUE_32BITS) {\n      this.diskNumberStart = extraReader.readInt(4);\n    }\n  }\n  /**\n   * Read the central part of a zip file and add the info in this object.\n   * @param {DataReader} reader the reader to use.\n   */\n\n\n  readExtraFields(reader) {\n    var end = reader.index + this.extraFieldsLength,\n        extraFieldId,\n        extraFieldLength,\n        extraFieldValue;\n\n    if (!this.extraFields) {\n      this.extraFields = {};\n    }\n\n    while (reader.index < end) {\n      extraFieldId = reader.readInt(2);\n      extraFieldLength = reader.readInt(2);\n      extraFieldValue = reader.readData(extraFieldLength);\n      this.extraFields[extraFieldId] = {\n        id: extraFieldId,\n        length: extraFieldLength,\n        value: extraFieldValue\n      };\n    }\n  }\n  /**\n   * Apply an UTF8 transformation if needed.\n   */\n\n\n  handleUTF8() {\n    var decodeParamType = support.uint8array ? \"uint8array\" : \"array\";\n\n    if (this.useUTF8()) {\n      this.fileNameStr = utf8decode(this.fileName);\n      this.fileCommentStr = utf8decode(this.fileComment);\n    } else {\n      var upath = this.findExtraFieldUnicodePath();\n\n      if (upath !== null) {\n        this.fileNameStr = upath;\n      } else {\n        // ASCII text or unsupported code page\n        var fileNameByteArray = transformTo(decodeParamType, this.fileName);\n        this.fileNameStr = this.loadOptions.decodeFileName(fileNameByteArray);\n      }\n\n      var ucomment = this.findExtraFieldUnicodeComment();\n\n      if (ucomment !== null) {\n        this.fileCommentStr = ucomment;\n      } else {\n        // ASCII text or unsupported code page\n        var commentByteArray = transformTo(decodeParamType, this.fileComment);\n        this.fileCommentStr = this.loadOptions.decodeFileName(commentByteArray);\n      }\n    }\n  }\n  /**\n   * Find the unicode path declared in the extra field, if any.\n   * @return {String} the unicode path, null otherwise.\n   */\n\n\n  findExtraFieldUnicodePath() {\n    var upathField = this.extraFields[0x7075];\n\n    if (upathField) {\n      var extraReader = readerFor(upathField.value); // wrong version\n\n      if (extraReader.readInt(1) !== 1) {\n        return null;\n      } // the crc of the filename changed, this field is out of date.\n\n\n      if (crc32wrapper(this.fileName) !== extraReader.readInt(4)) {\n        return null;\n      }\n\n      return utf8decode(extraReader.readData(upathField.length - 5));\n    }\n\n    return null;\n  }\n  /**\n   * Find the unicode comment declared in the extra field, if any.\n   * @return {String} the unicode comment, null otherwise.\n   */\n\n\n  findExtraFieldUnicodeComment() {\n    var ucommentField = this.extraFields[0x6375];\n\n    if (ucommentField) {\n      var extraReader = readerFor(ucommentField.value); // wrong version\n\n      if (extraReader.readInt(1) !== 1) {\n        return null;\n      } // the crc of the comment changed, this field is out of date.\n\n\n      if (crc32wrapper(this.fileComment) !== extraReader.readInt(4)) {\n        return null;\n      }\n\n      return utf8decode(extraReader.readData(ucommentField.length - 5));\n    }\n\n    return null;\n  }\n\n}\n/* eslint-disable */\n//  class ZipEntries {{{\n\n/**\n * All the entries in the zip file.\n * @constructor\n * @param {Object} loadOptions Options for loading the stream.\n */\n\n\nclass ZipEntries {\n  constructor(loadOptions) {\n    this.files = [];\n    this.loadOptions = loadOptions;\n  }\n  /**\n   * Check that the reader is on the specified signature.\n   * @param {string} expectedSignature the expected signature.\n   * @throws {Error} if it is an other signature.\n   */\n\n\n  checkSignature(expectedSignature) {\n    if (!this.reader.readAndCheckSignature(expectedSignature)) {\n      this.reader.index -= 4;\n      var signature = this.reader.readString(4);\n      throw new Error(\"Corrupted zip or bug: unexpected signature \" + \"(\" + pretty(signature) + \", expected \" + pretty(expectedSignature) + \")\");\n    }\n  }\n  /**\n   * Check if the given signature is at the given index.\n   * @param {number} askedIndex the index to check.\n   * @param {string} expectedSignature the signature to expect.\n   * @return {boolean} true if the signature is here, false otherwise.\n   */\n\n\n  isSignature(askedIndex, expectedSignature) {\n    var currentIndex = this.reader.index;\n    this.reader.setIndex(askedIndex);\n    var signature = this.reader.readString(4);\n    var result = signature === expectedSignature;\n    this.reader.setIndex(currentIndex);\n    return result;\n  }\n  /**\n   * Read the end of the central directory.\n   */\n\n\n  readBlockEndOfCentral() {\n    this.diskNumber = this.reader.readInt(2);\n    this.diskWithCentralDirStart = this.reader.readInt(2);\n    this.centralDirRecordsOnThisDisk = this.reader.readInt(2);\n    this.centralDirRecords = this.reader.readInt(2);\n    this.centralDirSize = this.reader.readInt(4);\n    this.centralDirOffset = this.reader.readInt(4);\n    this.zipCommentLength = this.reader.readInt(2); // warning : the encoding depends of the system locale\n    // On a linux machine with LANG=en_US.utf8, this field is utf8 encoded.\n    // On a windows machine, this field is encoded with the localized windows code page.\n\n    var zipComment = this.reader.readData(this.zipCommentLength);\n    var decodeParamType = support.uint8array ? \"uint8array\" : \"array\"; // To get consistent behavior with the generation part, we will assume that\n    // this is utf8 encoded unless specified otherwise.\n\n    var decodeContent = transformTo(decodeParamType, zipComment);\n    this.zipComment = this.loadOptions.decodeFileName(decodeContent);\n  }\n  /**\n   * Read the end of the Zip 64 central directory.\n   * Not merged with the method readEndOfCentral :\n   * The end of central can coexist with its Zip64 brother,\n   * I don't want to read the wrong number of bytes !\n   */\n\n\n  readBlockZip64EndOfCentral() {\n    this.zip64EndOfCentralSize = this.reader.readInt(8);\n    this.reader.skip(4); // this.versionMadeBy = this.reader.readString(2);\n    // this.versionNeeded = this.reader.readInt(2);\n\n    this.diskNumber = this.reader.readInt(4);\n    this.diskWithCentralDirStart = this.reader.readInt(4);\n    this.centralDirRecordsOnThisDisk = this.reader.readInt(8);\n    this.centralDirRecords = this.reader.readInt(8);\n    this.centralDirSize = this.reader.readInt(8);\n    this.centralDirOffset = this.reader.readInt(8);\n    this.zip64ExtensibleData = {};\n    var extraDataSize = this.zip64EndOfCentralSize - 44,\n        index = 0,\n        extraFieldId,\n        extraFieldLength,\n        extraFieldValue;\n\n    while (index < extraDataSize) {\n      extraFieldId = this.reader.readInt(2);\n      extraFieldLength = this.reader.readInt(4);\n      extraFieldValue = this.reader.readData(extraFieldLength);\n      this.zip64ExtensibleData[extraFieldId] = {\n        id: extraFieldId,\n        length: extraFieldLength,\n        value: extraFieldValue\n      };\n    }\n  }\n  /**\n   * Read the end of the Zip 64 central directory locator.\n   */\n\n\n  readBlockZip64EndOfCentralLocator() {\n    this.diskWithZip64CentralDirStart = this.reader.readInt(4);\n    this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8);\n    this.disksCount = this.reader.readInt(4);\n\n    if (this.disksCount > 1) {\n      throw new Error(\"Multi-volumes zip are not supported\");\n    }\n  }\n  /**\n   * Read the local files, based on the offset read in the central part.\n   */\n\n\n  readLocalFiles() {\n    var i, file;\n\n    for (i = 0; i < this.files.length; i++) {\n      file = this.files[i];\n      this.reader.setIndex(file.localHeaderOffset);\n      this.checkSignature(LOCAL_FILE_HEADER);\n      file.readLocalPart(this.reader);\n      file.handleUTF8();\n      file.processAttributes();\n    }\n  }\n  /**\n   * Read the central directory.\n   */\n\n\n  readCentralDir() {\n    var file;\n    this.reader.setIndex(this.centralDirOffset);\n\n    while (this.reader.readAndCheckSignature(CENTRAL_FILE_HEADER)) {\n      file = new ZipEntry({\n        zip64: this.zip64\n      }, this.loadOptions);\n      file.readCentralPart(this.reader);\n      this.files.push(file);\n    }\n\n    if (this.centralDirRecords !== this.files.length) {\n      if (this.centralDirRecords !== 0 && this.files.length === 0) {\n        // We expected some records but couldn't find ANY.\n        // This is really suspicious, as if something went wrong.\n        throw new Error(\"Corrupted zip or bug: expected \" + this.centralDirRecords + \" records in central dir, got \" + this.files.length);\n      }\n    }\n  }\n  /**\n   * Read the end of central directory.\n   */\n\n\n  readEndOfCentral() {\n    var offset = this.reader.lastIndexOfSignature(CENTRAL_DIRECTORY_END);\n\n    if (offset < 0) {\n      // Check if the content is a truncated zip or complete garbage.\n      // A \"LOCAL_FILE_HEADER\" is not required at the beginning (auto\n      // extractible zip for example) but it can give a good hint.\n      // If an ajax request was used without responseType, we will also\n      // get unreadable data.\n      var isGarbage = !this.isSignature(0, LOCAL_FILE_HEADER);\n\n      if (isGarbage) {\n        throw new Error(\"Can't find end of central directory : is this a zip file ? \" + \"If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html\");\n      } else {\n        throw new Error(\"Corrupted zip: can't find end of central directory\");\n      }\n    }\n\n    this.reader.setIndex(offset);\n    var endOfCentralDirOffset = offset;\n    this.checkSignature(CENTRAL_DIRECTORY_END);\n    this.readBlockEndOfCentral();\n    /* extract from the zip spec :\n        4)  If one of the fields in the end of central directory\n            record is too small to hold required data, the field\n            should be set to -1 (0xFFFF or 0xFFFFFFFF) and the\n            ZIP64 format record should be created.\n        5)  The end of central directory record and the\n            Zip64 end of central directory locator record must\n            reside on the same disk when splitting or spanning\n            an archive.\n     */\n\n    if (this.diskNumber === MAX_VALUE_16BITS || this.diskWithCentralDirStart === MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === MAX_VALUE_16BITS || this.centralDirRecords === MAX_VALUE_16BITS || this.centralDirSize === MAX_VALUE_32BITS || this.centralDirOffset === MAX_VALUE_32BITS) {\n      this.zip64 = true;\n      /*\n      Warning : the zip64 extension is supported, but ONLY if the 64bits integer read from\n      the zip file can fit into a 32bits integer. This cannot be solved : JavaScript represents\n      all numbers as 64-bit double precision IEEE 754 floating point numbers.\n      So, we have 53bits for integers and bitwise operations treat everything as 32bits.\n      see https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Operators/Bitwise_Operators\n      and http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-262.pdf section 8.5\n      */\n      // should look for a zip64 EOCD locator\n\n      offset = this.reader.lastIndexOfSignature(ZIP64_CENTRAL_DIRECTORY_LOCATOR);\n\n      if (offset < 0) {\n        throw new Error(\"Corrupted zip: can't find the ZIP64 end of central directory locator\");\n      }\n\n      this.reader.setIndex(offset);\n      this.checkSignature(ZIP64_CENTRAL_DIRECTORY_LOCATOR);\n      this.readBlockZip64EndOfCentralLocator(); // now the zip64 EOCD record\n\n      if (!this.isSignature(this.relativeOffsetEndOfZip64CentralDir, ZIP64_CENTRAL_DIRECTORY_END)) {\n        // console.warn(\"ZIP64 end of central directory not where expected.\");\n        this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(ZIP64_CENTRAL_DIRECTORY_END);\n\n        if (this.relativeOffsetEndOfZip64CentralDir < 0) {\n          throw new Error(\"Corrupted zip: can't find the ZIP64 end of central directory\");\n        }\n      }\n\n      this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir);\n      this.checkSignature(ZIP64_CENTRAL_DIRECTORY_END);\n      this.readBlockZip64EndOfCentral();\n    }\n\n    var expectedEndOfCentralDirOffset = this.centralDirOffset + this.centralDirSize;\n\n    if (this.zip64) {\n      expectedEndOfCentralDirOffset += 20; // end of central dir 64 locator\n\n      expectedEndOfCentralDirOffset += 12\n      /* should not include the leading 12 bytes */\n      + this.zip64EndOfCentralSize;\n    }\n\n    var extraBytes = endOfCentralDirOffset - expectedEndOfCentralDirOffset;\n\n    if (extraBytes > 0) {\n      // console.warn(extraBytes, \"extra bytes at beginning or within zipfile\");\n      if (this.isSignature(endOfCentralDirOffset, CENTRAL_FILE_HEADER)) ;else {\n        // the offset is wrong, update the \"zero\" of the reader\n        // this happens if data has been prepended (crx files for example)\n        this.reader.zero = extraBytes;\n      }\n    } else if (extraBytes < 0) {\n      throw new Error(\"Corrupted zip: missing \" + Math.abs(extraBytes) + \" bytes.\");\n    }\n  }\n\n  prepareReader(data) {\n    this.reader = readerFor(data);\n  }\n  /**\n   * Read a zip file and create ZipEntries.\n   * @param {String|ArrayBuffer|Uint8Array|Buffer} data the binary string representing a zip file.\n   */\n\n\n  load(data) {\n    this.prepareReader(data);\n    this.readEndOfCentral();\n    this.readCentralDir();\n    this.readLocalFiles();\n  }\n\n}\n/* eslint-disable */\n\n/**\n * Check the CRC32 of an entry.\n * @param {ZipEntry} zipEntry the zip entry to check.\n * @return {Promise} the result.\n */\n\n\nfunction checkEntryCRC32(zipEntry) {\n  return new external.Promise(function (resolve, reject) {\n    var worker = zipEntry.decompressed.getContentWorker().pipe(new Crc32Probe());\n    worker.on(\"error\", function (e) {\n      reject(e);\n    }).on(\"end\", function () {\n      if (worker.streamInfo.crc32 !== zipEntry.decompressed.crc32) {\n        reject(new Error(\"Corrupted zip : CRC32 mismatch\"));\n      } else {\n        resolve();\n      }\n    }).resume();\n  });\n}\n\nfunction load(data, options) {\n  var zip = this;\n  options = extend(options || {}, {\n    base64: false,\n    checkCRC32: false,\n    optimizedBinaryString: false,\n    createFolders: false,\n    decodeFileName: utf8decode\n  });\n  return prepareContent(\"the loaded zip file\", data, true, options.optimizedBinaryString, options.base64).then(function (data) {\n    var zipEntries = new ZipEntries(options);\n    zipEntries.load(data);\n    return zipEntries;\n  }).then(function checkCRC32(zipEntries) {\n    var promises = [external.Promise.resolve(zipEntries)];\n    var files = zipEntries.files;\n\n    if (options.checkCRC32) {\n      for (var i = 0; i < files.length; i++) {\n        promises.push(checkEntryCRC32(files[i]));\n      }\n    }\n\n    return external.Promise.all(promises);\n  }).then(function addFiles(results) {\n    var zipEntries = results.shift();\n    var files = zipEntries.files;\n\n    for (var i = 0; i < files.length; i++) {\n      var input = files[i];\n      zip.file(input.fileNameStr, input.decompressed, {\n        binary: true,\n        optimizedBinaryString: true,\n        date: input.date,\n        dir: input.dir,\n        comment: input.fileCommentStr.length ? input.fileCommentStr : null,\n        unixPermissions: input.unixPermissions,\n        dosPermissions: input.dosPermissions,\n        createFolders: options.createFolders\n      });\n    }\n\n    if (zipEntries.zipComment.length) {\n      zip.comment = zipEntries.zipComment;\n    }\n\n    return zip;\n  });\n}\n/* eslint-disable */\n\n/**\n * Add a file in the current folder.\n * @private\n * @param {string} name the name of the file\n * @param {String|ArrayBuffer|Uint8Array|Buffer} data the data of the file\n * @param {Object} originalOptions the options of the file\n * @return {Object} the new file.\n */\n\n\nvar fileAdd = function (name, data, originalOptions) {\n  // be sure sub folders exist\n  var dataType = getTypeOf(data),\n      parent;\n  /*\n   * Correct options.\n   */\n\n  var o = extend(originalOptions || {}, defaults);\n  o.date = o.date || new Date();\n\n  if (o.compression !== null) {\n    o.compression = o.compression.toUpperCase();\n  }\n\n  if (typeof o.unixPermissions === \"string\") {\n    o.unixPermissions = parseInt(o.unixPermissions, 8);\n  } // UNX_IFDIR  0040000 see zipinfo.c\n\n\n  if (o.unixPermissions && o.unixPermissions & 0x4000) {\n    o.dir = true;\n  } // Bit 4    Directory\n\n\n  if (o.dosPermissions && o.dosPermissions & 0x0010) {\n    o.dir = true;\n  }\n\n  if (o.dir) {\n    name = forceTrailingSlash(name);\n  }\n\n  if (o.createFolders && (parent = parentFolder(name))) {\n    folderAdd.call(this, parent, true);\n  }\n\n  var isUnicodeString = dataType === \"string\" && o.binary === false && o.base64 === false;\n\n  if (!originalOptions || typeof originalOptions.binary === \"undefined\") {\n    o.binary = !isUnicodeString;\n  }\n\n  var isCompressedEmpty = data instanceof CompressedObject && data.uncompressedSize === 0;\n\n  if (isCompressedEmpty || o.dir || !data || data.length === 0) {\n    o.base64 = false;\n    o.binary = true;\n    data = \"\";\n    o.compression = \"STORE\";\n    dataType = \"string\";\n  }\n  /*\n   * Convert content to fit.\n   */\n\n\n  var zipObjectContent = null;\n\n  if (data instanceof CompressedObject || data instanceof GenericWorker) {\n    zipObjectContent = data;\n  } else {\n    zipObjectContent = prepareContent(name, data, o.binary, o.optimizedBinaryString, o.base64);\n  }\n\n  var object = new ZipObject(name, zipObjectContent, o);\n  this.files[name] = object;\n  /*\n  TODO: we can't throw an exception because we have async promises\n  (we can have a promise of a Date() for example) but returning a\n  promise is useless because file(name, data) returns the JSZip\n  object for chaining. Should we break that to allow the user\n  to catch the error ?\n   return external.Promise.resolve(zipObjectContent)\n  .then(function () {\n      return object;\n  });\n  */\n};\n/**\n * Find the parent folder of the path.\n * @private\n * @param {string} path the path to use\n * @return {string} the parent folder, or \"\"\n */\n\n\nvar parentFolder = function (path) {\n  if (path.slice(-1) === '/') {\n    path = path.substring(0, path.length - 1);\n  }\n\n  var lastSlash = path.lastIndexOf('/');\n  return lastSlash > 0 ? path.substring(0, lastSlash) : \"\";\n};\n/**\n * Returns the path with a slash at the end.\n * @private\n * @param {String} path the path to check.\n * @return {String} the path with a trailing slash.\n */\n\n\nvar forceTrailingSlash = function (path) {\n  // Check the name ends with a /\n  if (path.slice(-1) !== \"/\") {\n    path += \"/\"; // IE doesn't like substr(-1)\n  }\n\n  return path;\n};\n/**\n * Add a (sub) folder in the current folder.\n * @private\n * @param {string} name the folder's name\n * @param {boolean=} [createFolders] If true, automatically create sub\n *  folders. Defaults to false.\n * @return {Object} the new folder.\n */\n\n\nvar folderAdd = function (name, createFolders$1) {\n  createFolders$1 = typeof createFolders$1 !== 'undefined' ? createFolders$1 : createFolders;\n  name = forceTrailingSlash(name); // Does this folder already exist?\n\n  if (!this.files[name]) {\n    fileAdd.call(this, name, null, {\n      dir: true,\n      createFolders: createFolders$1\n    });\n  }\n\n  return this.files[name];\n};\n/**\n* Cross-window, cross-Node-context regular expression detection\n* @param  {Object}  object Anything\n* @return {Boolean}        true if the object is a regular expression,\n* false otherwise\n*/\n\n\nfunction isRegExp(object) {\n  return Object.prototype.toString.call(object) === \"[object RegExp]\";\n}\n/**\n * Representation a of zip file in js\n * @constructor\n */\n\n\nclass JSZip {\n  constructor() {\n    if (arguments.length) {\n      throw new Error(\"The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.\");\n    } // object containing the files :\n    // {\n    //   \"folder/\" : {...},\n    //   \"folder/data.txt\" : {...}\n    // }\n    // NOTE: we use a null prototype because we do not\n    // want filenames like \"toString\" coming from a zip file\n    // to overwrite methods and attributes in a normal Object.\n\n\n    this.files = Object.create(null);\n    this.comment = null; // Where we are in the hierarchy\n\n    this.root = \"\";\n\n    this.clone = function () {\n      const newObj = new JSZip();\n\n      for (const i in this) {\n        if (typeof this[i] !== \"function\") {\n          newObj[i] = this[i];\n        }\n      }\n\n      return newObj;\n    };\n  }\n  /**\n   * @see loadAsync\n   */\n\n\n  load() {\n    throw new Error(\"This method has been removed in JSZip 3.0, please check the upgrade guide.\");\n  }\n  /**\n   * Call a callback function for each entry at this folder level.\n   * @param {Function} cb the callback function:\n   * function (relativePath, file) {...}\n   * It takes 2 arguments : the relative path and the file.\n   */\n\n\n  forEach(cb) {\n    var filename, relativePath, file;\n\n    for (filename in this.files) {\n      file = this.files[filename];\n      relativePath = filename.slice(this.root.length, filename.length);\n\n      if (relativePath && filename.slice(0, this.root.length) === this.root) {\n        // the file is in the current root\n        cb(relativePath, file); // TODO reverse the parameters ? need to be clean AND consistent with the filter search fn...\n      }\n    }\n  }\n  /**\n   * Filter nested files/folders with the specified function.\n   * @param {Function} search the predicate to use :\n   * function (relativePath, file) {...}\n   * It takes 2 arguments : the relative path and the file.\n   * @return {Array} An array of matching elements.\n   */\n\n\n  filter(search) {\n    var result = [];\n    this.forEach(function (relativePath, entry) {\n      if (search(relativePath, entry)) {\n        // the file matches the function\n        result.push(entry);\n      }\n    });\n    return result;\n  }\n  /**\n   * Add a file to the zip file, or search a file.\n   * @param   {string|RegExp} name The name of the file to add (if data is defined),\n   * the name of the file to find (if no data) or a regex to match files.\n   * @param   {String|ArrayBuffer|Uint8Array|Buffer} data  The file data, either raw or base64 encoded\n   * @param   {Object} o     File options\n   * @return  {JSZip|Object|Array} this JSZip object (when adding a file),\n   * a file (when searching by string) or an array of files (when searching by regex).\n   */\n\n\n  file(name, data, o) {\n    if (arguments.length === 1) {\n      if (isRegExp(name)) {\n        var regexp = name;\n        return this.filter(function (relativePath, file) {\n          return !file.dir && regexp.test(relativePath);\n        });\n      } else {\n        // text\n        var obj = this.files[this.root + name];\n\n        if (obj && !obj.dir) {\n          return obj;\n        } else {\n          return null;\n        }\n      }\n    } else {\n      // more than one argument : we have data !\n      name = this.root + name;\n      fileAdd.call(this, name, data, o);\n    }\n\n    return this;\n  }\n  /**\n   * Add a directory to the zip file, or search.\n   * @param   {String|RegExp} arg The name of the directory to add, or a regex to search folders.\n   * @return  {JSZip} an object with the new directory as the root, or an array containing matching folders.\n   */\n\n\n  folder(arg) {\n    if (!arg) {\n      return this;\n    }\n\n    if (isRegExp(arg)) {\n      return this.filter(function (relativePath, file) {\n        return file.dir && arg.test(relativePath);\n      });\n    } // else, name is a new folder\n\n\n    var name = this.root + arg;\n    var newFolder = folderAdd.call(this, name); // Allow chaining by returning a new object with this folder as the root\n\n    var ret = this.clone();\n    ret.root = newFolder.name;\n    return ret;\n  }\n  /**\n   * Delete a file, or a directory and all sub-files, from the zip\n   * @param {string} name the name of the file to delete\n   * @return {JSZip} this JSZip object\n   */\n\n\n  remove(name) {\n    name = this.root + name;\n    var file = this.files[name];\n\n    if (!file) {\n      // Look for any folders\n      if (name.slice(-1) !== \"/\") {\n        name += \"/\";\n      }\n\n      file = this.files[name];\n    }\n\n    if (file && !file.dir) {\n      // file\n      delete this.files[name];\n    } else {\n      // maybe a folder, delete recursively\n      var kids = this.filter(function (relativePath, file) {\n        return file.name.slice(0, name.length) === name;\n      });\n\n      for (var i = 0; i < kids.length; i++) {\n        delete this.files[kids[i].name];\n      }\n    }\n\n    return this;\n  }\n  /**\n   * Generate the complete zip file\n   * @param {Object} options the options to generate the zip file :\n   * - compression, \"STORE\" by default.\n   * - type, \"base64\" by default. Values are : string, base64, uint8array, arraybuffer, blob.\n   * @return {String|Uint8Array|ArrayBuffer|Buffer|Blob} the zip file\n   */\n\n\n  generate(options) {\n    throw new Error(\"This method has been removed in JSZip 3.0, please check the upgrade guide.\");\n  }\n  /**\n   * Generate the complete zip file as an internal stream.\n   * @param {Object} options the options to generate the zip file :\n   * - compression, \"STORE\" by default.\n   * - type, \"base64\" by default. Values are : string, base64, uint8array, arraybuffer, blob.\n   * @return {StreamHelper} the streamed zip file.\n   */\n\n\n  generateInternalStream(options) {\n    var worker,\n        opts = {};\n\n    try {\n      opts = extend(options || {}, {\n        streamFiles: false,\n        compression: \"STORE\",\n        compressionOptions: null,\n        type: \"\",\n        platform: \"DOS\",\n        comment: null,\n        mimeType: 'application/zip',\n        encodeFileName: utf8encode\n      });\n      opts.type = opts.type.toLowerCase();\n      opts.compression = opts.compression.toUpperCase(); // \"binarystring\" is preferred but the internals use \"string\".\n\n      if (opts.type === \"binarystring\") {\n        opts.type = \"string\";\n      }\n\n      if (!opts.type) {\n        throw new Error(\"No output type specified.\");\n      }\n\n      checkSupport(opts.type); // accept nodejs `process.platform`\n\n      if (opts.platform === 'darwin' || opts.platform === 'freebsd' || opts.platform === 'linux' || opts.platform === 'sunos') {\n        opts.platform = \"UNIX\";\n      }\n\n      if (opts.platform === 'win32') {\n        opts.platform = \"DOS\";\n      }\n\n      var comment = opts.comment || this.comment || \"\";\n      worker = generateWorker(this, opts, comment);\n    } catch (e) {\n      worker = new GenericWorker(\"error\");\n      worker.error(e);\n    }\n\n    return new StreamHelper(worker, opts.type || \"string\", opts.mimeType);\n  }\n  /**\n   * Generate the complete zip file asynchronously.\n   * @see generateInternalStream\n   */\n\n\n  generateAsync(options, onUpdate) {\n    return this.generateInternalStream(options).accumulate(onUpdate);\n  }\n\n  loadAsync(data, options) {\n    return load.apply(this, [data, options]);\n  }\n\n  static loadAsync(content, options) {\n    return new JSZip().loadAsync(content, options);\n  }\n\n  static get support() {\n    return support;\n  }\n\n  static get defaults() {\n    return defaults;\n  }\n\n  static get version() {\n    return \"3.2.2-esm\";\n  }\n\n  static get external() {\n    return external;\n  }\n\n}\n\nexport { JSZip as default };","map":null,"metadata":{},"sourceType":"module"}