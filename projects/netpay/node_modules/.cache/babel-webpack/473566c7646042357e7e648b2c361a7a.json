{"ast":null,"code":"import GeometryArc from '../geometry/arc';\nimport Element from './element';\nimport { Path } from './path';\nimport paintable from '../mixins/paintable';\nimport measurable from '../mixins/measurable';\nimport withGeometry from '../mixins/with-geometry';\nimport { defined } from '../util';\nconst DEFAULT_STROKE = \"#000\";\n\nclass Arc extends paintable(measurable(withGeometry(Element))) {\n  get nodeType() {\n    return \"Arc\";\n  }\n\n  constructor(geometry = new GeometryArc(), options = {}) {\n    super(options);\n    this.geometry(geometry);\n\n    if (!defined(this.options.stroke)) {\n      this.stroke(DEFAULT_STROKE);\n    }\n  }\n\n  _bbox(matrix) {\n    return this._geometry.bbox(matrix);\n  }\n\n  rawBBox() {\n    return this.geometry().bbox();\n  }\n\n  toPath() {\n    const path = new Path();\n    const curvePoints = this.geometry().curvePoints();\n\n    if (curvePoints.length > 0) {\n      path.moveTo(curvePoints[0].x, curvePoints[0].y);\n\n      for (let i = 1; i < curvePoints.length; i += 3) {\n        path.curveTo(curvePoints[i], curvePoints[i + 1], curvePoints[i + 2]);\n      }\n    }\n\n    return path;\n  }\n\n  _containsPoint(point) {\n    return this.geometry().containsPoint(point);\n  }\n\n  _isOnPath(point) {\n    return this.geometry()._isOnPath(point, this.options.stroke.width / 2);\n  }\n\n}\n\nexport default Arc;","map":null,"metadata":{},"sourceType":"module"}