{"ast":null,"code":"import { isCompositeFilterDescriptor } from './filtering/filter-descriptor.interface';\nimport { compose, ifElse } from './funcs';\nimport { normalizeField, quote, toLower, isDateValue, isStringValue, serializeFilters, encodeValue, toUTC } from './filter-serialization.common';\nimport { normalizeFilters } from './filtering/filter.operators';\n\nconst formatDate = ({\n  utcDates\n}) => ({\n  field,\n  value,\n  ignoreCase,\n  operator\n}) => ({\n  value: JSON.stringify(!utcDates ? toUTC(value) : value).replace(/\"/g, \"\"),\n  field,\n  ignoreCase,\n  operator\n});\n\nconst fnFormatter = ({\n  operator\n}) => ({\n  field,\n  value\n}) => `${operator}(${field},${value})`;\n\nconst singleOperatorFormatter = ({\n  operator\n}) => ({\n  field,\n  value\n}) => `${field} ${operator} ${value}`;\n\nconst stringFormat = formatter => compose(formatter, encodeValue, quote, toLower, normalizeField);\n\nconst stringFnOperator = settings => stringFormat(fnFormatter(settings));\n\nconst stringOperator = settings => stringFormat(singleOperatorFormatter(settings));\n\nconst numericOperator = settings => compose(singleOperatorFormatter(settings), normalizeField);\n\nconst dateOperator = settings => compose(singleOperatorFormatter(settings), normalizeField, formatDate(settings));\n\nconst ifDate = settings => ifElse(isDateValue, dateOperator(settings), numericOperator(settings));\n\nconst typedOperator = settings => ifElse(isStringValue, stringOperator(settings), ifDate(settings));\n\nconst appendEqual = str => `${str} eq -1`;\n\nconst nonValueExpression = formatter => compose(formatter, normalizeField);\n\nconst filterOperators = (operator, settings) => ({\n  contains: stringFnOperator(Object.assign({}, settings, {\n    operator: \"contains\"\n  })),\n  doesnotcontain: compose(appendEqual, stringFnOperator(Object.assign({}, settings, {\n    operator: \"indexof\"\n  }))),\n  endswith: stringFnOperator(Object.assign({}, settings, {\n    operator: \"endswith\"\n  })),\n  eq: typedOperator(Object.assign({}, settings, {\n    operator: \"eq\"\n  })),\n  gt: typedOperator(Object.assign({}, settings, {\n    operator: \"gt\"\n  })),\n  gte: typedOperator(Object.assign({}, settings, {\n    operator: \"ge\"\n  })),\n  isempty: nonValueExpression(({\n    field\n  }) => `${field} eq ''`),\n  isnotempty: nonValueExpression(({\n    field\n  }) => `${field} ne ''`),\n  isnotnull: nonValueExpression(({\n    field\n  }) => `${field} ne null`),\n  isnull: nonValueExpression(({\n    field\n  }) => `${field} eq null`),\n  lt: typedOperator(Object.assign({}, settings, {\n    operator: \"lt\"\n  })),\n  lte: typedOperator(Object.assign({}, settings, {\n    operator: \"le\"\n  })),\n  neq: typedOperator(Object.assign({}, settings, {\n    operator: \"ne\"\n  })),\n  startswith: stringFnOperator(Object.assign({}, settings, {\n    operator: \"startswith\"\n  }))\n})[operator];\n\nconst join = x => ` ${x.logic} `;\n\nconst serialize = settings => x => filterOperators(x.operator, settings)(x);\n\nconst serializeAll = settings => serializeFilters(filter => ifElse(isCompositeFilterDescriptor, serializeAll(settings), serialize(settings))(filter), join);\n/**\n * @hidden\n */\n\n\nexport const serializeFilter = (filter, settings = {}) => {\n  if (filter.filters && filter.filters.length) {\n    return \"$filter=\" + serializeAll(settings)(normalizeFilters(filter));\n  }\n\n  return \"\";\n};","map":null,"metadata":{},"sourceType":"module"}