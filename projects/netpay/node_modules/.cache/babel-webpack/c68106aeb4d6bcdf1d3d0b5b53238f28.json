{"ast":null,"code":"/**-----------------------------------------------------------------------------------------\n* Copyright © 2020 Progress Software Corporation. All rights reserved.\n* Licensed under commercial license. See LICENSE.md in the project root for more information\n*-------------------------------------------------------------------------------------------*/\nimport { __decorate, __metadata } from 'tslib';\nimport { EventEmitter, Input, Output, Directive, ElementRef, NgZone, NgModule, Renderer2, Injectable, Component } from '@angular/core';\nimport Draggable from '@telerik/kendo-draggable';\nimport { CommonModule } from '@angular/common';\nimport { auditTime } from 'rxjs/operators';\nimport { merge, fromEvent, from } from 'rxjs';\nimport * as ɵngcc0 from '@angular/core';\n\nconst isDocumentAvailable = () => typeof document !== 'undefined';\n\nconst isChanged = (propertyName, changes, skipFirstChange = true) => typeof changes[propertyName] !== 'undefined' && (!changes[propertyName].isFirstChange() || !skipFirstChange) && changes[propertyName].previousValue !== changes[propertyName].currentValue;\n\nconst anyChanged = (propertyNames, changes, skipFirstChange = true) => propertyNames.some(name => isChanged(name, changes, skipFirstChange));\n\nconst hasObservers = emitter => emitter && emitter.observers.length > 0;\n\nconst guid = () => {\n  let id = \"\";\n\n  for (let i = 0; i < 32; i++) {\n    const random = Math.random() * 16 | 0; // tslint:disable-line:no-bitwise\n\n    if (i === 8 || i === 12 || i === 16 || i === 20) {\n      id += \"-\";\n    } // tslint:disable-next-line:no-bitwise\n\n\n    id += (i === 12 ? 4 : i === 16 ? random & 3 | 8 : random).toString(16);\n  }\n\n  return id;\n};\n\nlet DraggableDirective = /*#__PURE__*/(() => {\n  let DraggableDirective = class DraggableDirective {\n    constructor(element, ngZone) {\n      this.element = element;\n      this.ngZone = ngZone;\n      this.enableDrag = true;\n      this.kendoPress = new EventEmitter();\n      this.kendoDrag = new EventEmitter();\n      this.kendoRelease = new EventEmitter();\n    }\n\n    ngOnInit() {\n      this.toggleDraggable();\n    }\n\n    ngOnChanges(changes) {\n      if (isChanged('enableDrag', changes)) {\n        this.toggleDraggable();\n      }\n    }\n\n    ngOnDestroy() {\n      this.destroyDraggable();\n    }\n\n    toggleDraggable() {\n      if (isDocumentAvailable()) {\n        this.destroyDraggable();\n\n        if (this.enableDrag) {\n          this.draggable = new Draggable({\n            drag: e => this.kendoDrag.next(e),\n            press: e => this.kendoPress.next(e),\n            release: e => this.kendoRelease.next(e)\n          });\n          this.ngZone.runOutsideAngular(() => this.draggable.bindTo(this.element.nativeElement));\n        }\n      }\n    }\n\n    destroyDraggable() {\n      if (this.draggable) {\n        this.draggable.destroy();\n        this.draggable = null;\n      }\n    }\n\n  };\n\n  DraggableDirective.ɵfac = function DraggableDirective_Factory(t) {\n    return new (t || DraggableDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone));\n  };\n\n  DraggableDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: DraggableDirective,\n    selectors: [[\"\", \"kendoDraggable\", \"\"]],\n    inputs: {\n      enableDrag: \"enableDrag\"\n    },\n    outputs: {\n      kendoPress: \"kendoPress\",\n      kendoDrag: \"kendoDrag\",\n      kendoRelease: \"kendoRelease\"\n    },\n    features: [ɵngcc0.ɵɵNgOnChangesFeature]\n  });\n\n  __decorate([Input(), __metadata(\"design:type\", Boolean)], DraggableDirective.prototype, \"enableDrag\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], DraggableDirective.prototype, \"kendoPress\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], DraggableDirective.prototype, \"kendoDrag\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], DraggableDirective.prototype, \"kendoRelease\", void 0);\n\n  DraggableDirective = __decorate([__metadata(\"design:paramtypes\", [ElementRef, NgZone])], DraggableDirective);\n  /**\n   * @hidden\n   */\n\n  return DraggableDirective;\n})();\nlet DraggableModule = /*#__PURE__*/(() => {\n  let DraggableModule = class DraggableModule {};\n\n  DraggableModule.ɵfac = function DraggableModule_Factory(t) {\n    return new (t || DraggableModule)();\n  };\n\n  DraggableModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: DraggableModule\n  });\n  DraggableModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    imports: [[CommonModule]]\n  });\n  return DraggableModule;\n})();\n\nconst closestInScope = (node, predicate, scope) => {\n  while (node && node !== scope && !predicate(node)) {\n    node = node.parentNode;\n  }\n\n  if (node !== scope) {\n    return node;\n  }\n};\n\nconst closest = (node, predicate) => {\n  while (node && !predicate(node)) {\n    node = node.parentNode;\n  }\n\n  return node;\n};\n\nconst contains = (parent, node, matchSelf = false) => {\n  const outside = !closest(node, child => child === parent);\n\n  if (outside) {\n    return false;\n  }\n\n  const el = closest(node, child => child === node);\n  return el && (matchSelf || el !== parent);\n};\n\nconst findElement = (node, predicate, matchSelf = true) => {\n  if (!node) {\n    return;\n  }\n\n  if (matchSelf && predicate(node)) {\n    return node;\n  }\n\n  node = node.firstChild;\n\n  while (node) {\n    if (node.nodeType === 1) {\n      const element = findElement(node, predicate);\n\n      if (element) {\n        return element;\n      }\n    }\n\n    node = node.nextSibling;\n  }\n};\n\nconst focusableRegex = /^(?:a|input|select|option|textarea|button|object)$/i;\n\nconst isFocusable = element => {\n  if (!element.tagName) {\n    return false;\n  }\n\n  const tagName = element.tagName.toLowerCase();\n  const hasTabIndex = Boolean(element.getAttribute('tabIndex'));\n  const focusable = !element.disabled && focusableRegex.test(tagName);\n  return focusable || hasTabIndex;\n};\n\nconst isVisible = element => {\n  const rect = element.getBoundingClientRect();\n  const hasSize = rect.width > 0 && rect.height > 0;\n  const hasPosition = rect.x !== 0 && rect.y !== 0; // Elements can have zero size due to styling, but they will still count as visible.\n  // For example, the selection checkbox has no size, but is made visible through styling.\n\n  return (hasSize || hasPosition) && window.getComputedStyle(element).visibility !== 'hidden';\n};\n\nconst isFocusableWithTabKey = (element, checkVisibility = true) => {\n  if (!isFocusable(element)) {\n    return false;\n  }\n\n  const tabIndex = element.getAttribute('tabIndex');\n  const visible = !checkVisibility || isVisible(element);\n  return visible && tabIndex !== '-1';\n};\n\nconst findFocusableChild = (element, checkVisibility = true) => {\n  return findElement(element, node => isFocusableWithTabKey(node, checkVisibility), false);\n};\n\nconst findFocusable = (element, checkVisibility = true) => {\n  return findElement(element, node => isFocusableWithTabKey(node, checkVisibility));\n};\n\nconst toClassList = classNames => String(classNames).trim().split(' ');\n\nconst hasClasses = (element, classNames) => {\n  const namesList = toClassList(classNames);\n  return Boolean(toClassList(element.className).find(className => namesList.indexOf(className) >= 0));\n};\n\nconst matchesClasses = classNames => element => hasClasses(element, classNames);\n\nconst NODE_NAME_PREDICATES = {};\n\nconst matchesNodeName = nodeName => {\n  if (!NODE_NAME_PREDICATES[nodeName]) {\n    NODE_NAME_PREDICATES[nodeName] = element => String(element.nodeName).toLowerCase() === nodeName.toLowerCase();\n  }\n\n  return NODE_NAME_PREDICATES[nodeName];\n};\n/**\n * Normalizes a scroll position value in RTL mode.\n */\n\n\nfunction rtlScrollPosition(position, element, initial) {\n  let result = position;\n\n  if (initial < 0) {\n    result = -position;\n  } else if (initial > 0) {\n    result = element.scrollWidth - element.offsetWidth - position;\n  }\n\n  return result;\n}\n/* tslint:disable:no-input-rename */\n\n/**\n * @hidden\n */\n\n\nlet EventsOutsideAngularDirective = /*#__PURE__*/(() => {\n  let EventsOutsideAngularDirective = class EventsOutsideAngularDirective {\n    constructor(element, ngZone, renderer) {\n      this.element = element;\n      this.ngZone = ngZone;\n      this.renderer = renderer;\n      this.events = {};\n    }\n\n    ngOnInit() {\n      if (!this.element || !this.element.nativeElement) {\n        return;\n      }\n\n      const events = this.events;\n      this.subscriptions = [];\n      this.ngZone.runOutsideAngular(() => {\n        for (let name in events) {\n          if (events.hasOwnProperty(name)) {\n            this.subscriptions.push(this.renderer.listen(this.element.nativeElement, name, this.scope ? events[name].bind(this.scope) : events[name]));\n          }\n        }\n      });\n    }\n\n    ngOnDestroy() {\n      if (this.subscriptions) {\n        for (let idx = 0; idx < this.subscriptions.length; idx++) {\n          this.subscriptions[idx]();\n        }\n\n        this.subscriptions = null;\n      }\n    }\n\n  };\n\n  EventsOutsideAngularDirective.ɵfac = function EventsOutsideAngularDirective_Factory(t) {\n    return new (t || EventsOutsideAngularDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2));\n  };\n\n  EventsOutsideAngularDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: EventsOutsideAngularDirective,\n    selectors: [[\"\", \"kendoEventsOutsideAngular\", \"\"]],\n    inputs: {\n      events: [\"kendoEventsOutsideAngular\", \"events\"],\n      scope: \"scope\"\n    }\n  });\n\n  __decorate([Input('kendoEventsOutsideAngular'), __metadata(\"design:type\", Object)], EventsOutsideAngularDirective.prototype, \"events\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", Object)], EventsOutsideAngularDirective.prototype, \"scope\", void 0);\n\n  EventsOutsideAngularDirective = __decorate([__metadata(\"design:paramtypes\", [ElementRef, NgZone, Renderer2])], EventsOutsideAngularDirective);\n  /**\n   * @hidden\n   */\n\n  return EventsOutsideAngularDirective;\n})();\nlet EventsModule = /*#__PURE__*/(() => {\n  let EventsModule = class EventsModule {};\n\n  EventsModule.ɵfac = function EventsModule_Factory(t) {\n    return new (t || EventsModule)();\n  };\n\n  EventsModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: EventsModule\n  });\n  EventsModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({});\n  return EventsModule;\n})();\n\nclass ResizeService {\n  constructor(resizeBatchService) {\n    this.resizeBatchService = resizeBatchService;\n    this.resize = new EventEmitter();\n    this.acceptedSize = false;\n    this.state = 0\n    /* Initial */\n    ;\n  }\n\n  acceptSize(size = this.measure()) {\n    this.lastWidth = size.width;\n    this.lastHeight = size.height;\n    this.acceptedSize = true;\n  }\n\n  checkChanges() {\n    if (!isDocumentAvailable()) {\n      return;\n    }\n\n    if (this.state === 0\n    /* Initial */\n    ) {\n      this.state = 1\n      /* Initializing */\n      ; // batch initial measure\n\n      this.resizeBatchService.schedule(this, this.init);\n    }\n  }\n\n  destroy() {\n    this.resizeBatchService.cancel(this);\n  }\n\n  checkSize() {\n    if (!this.parentElement) {\n      return;\n    }\n\n    const {\n      width,\n      height\n    } = this.measure();\n    const sameSize = width === this.lastWidth && height === this.lastHeight;\n\n    if (sameSize) {\n      return;\n    }\n\n    this.lastWidth = width;\n    this.lastHeight = height;\n    this.acceptedSize = false;\n    this.resize.emit();\n    return true;\n  }\n\n  initSize() {\n    const size = this.measure();\n    this.lastWidth = size.width;\n    this.lastHeight = size.height;\n  }\n\n  measure() {\n    let width = 0;\n    let height = 0;\n\n    if (this.parentElement) {\n      height = this.parentElement.offsetHeight;\n      width = this.parentElement.offsetWidth;\n    }\n\n    return {\n      height,\n      width\n    };\n  }\n\n} // tslint:disable:deprecation\n\n\nconst div = style => {\n  const el = document.createElement('div');\n  el.style.cssText = style;\n  return el;\n};\n\nconst computedProp = (elem, prop) => getComputedStyle(elem, null).getPropertyValue(prop);\n\nconst WRAP_STYLE = 'position: absolute; display: block; left: 0; top: 0; right: 0; bottom: 0; z-index: -1;' + 'overflow: hidden; visibility: hidden;';\nconst EXPAND_CHILD_STYLE = 'position: absolute; left: 0; top: 0; transition: 0s;';\nconst SHRINK_CHILD_STYLE = EXPAND_CHILD_STYLE + 'width: 200%; height: 200%;';\n\nclass ResizeCompatService extends ResizeService {\n  constructor(resizeBatchService, element, ngZone) {\n    super(resizeBatchService);\n    this.element = element;\n    this.ngZone = ngZone;\n  }\n\n  checkChanges() {\n    if (this.state === 2\n    /* Initialized */\n    ) {\n      if (!this.resizeBatchService.isScheduled(this)) {\n        this.resizeBatchService.schedule(this, this.checkSize);\n      }\n\n      return;\n    }\n\n    super.checkChanges();\n  }\n\n  destroy() {\n    super.destroy();\n\n    if (this.subscription) {\n      this.subscription.unsubscribe();\n    }\n\n    if (this.expand) {\n      const element = this.element.nativeElement;\n      element.removeChild(this.expand);\n      element.removeChild(this.shrink);\n      this.expand.removeChild(this.expandChild);\n      this.expand = this.expandChild = this.shrink = this.element = null;\n    }\n  }\n\n  checkSize() {\n    if (super.checkSize()) {\n      this.reset();\n      return true;\n    }\n  }\n\n  init() {\n    const parentElement = this.parentElement = this.element.nativeElement.parentElement;\n\n    if (computedProp(parentElement, 'position') === 'static') {\n      parentElement.style.position = 'relative';\n    }\n\n    this.state = 2\n    /* Initialized */\n    ;\n    this.render();\n    this.reset();\n    this.initSize();\n    this.subscribe();\n  }\n\n  render() {\n    const element = this.element.nativeElement;\n    element.style.cssText = WRAP_STYLE;\n    element.setAttribute('dir', 'ltr');\n    this.expand = div(WRAP_STYLE);\n    this.expandChild = div(EXPAND_CHILD_STYLE);\n    this.expand.appendChild(this.expandChild);\n    element.appendChild(this.expand);\n    this.shrink = div(WRAP_STYLE);\n    const shrinkChild = div(SHRINK_CHILD_STYLE);\n    this.shrink.appendChild(shrinkChild);\n    element.appendChild(this.shrink);\n  }\n\n  reset() {\n    const expandChild = this.expandChild;\n    expandChild.style.width = 100000 + 'px';\n    expandChild.style.height = 100000 + 'px';\n    const expand = this.expand;\n    expand.scrollLeft = 100000;\n    expand.scrollTop = 100000;\n    const shrink = this.shrink;\n    shrink.scrollLeft = 100000;\n    shrink.scrollTop = 100000;\n  }\n\n  subscribe() {\n    this.ngZone.runOutsideAngular(() => {\n      this.subscription = merge(fromEvent(this.shrink, 'scroll'), fromEvent(this.expand, 'scroll')).subscribe(() => {\n        this.checkSize();\n      });\n    });\n  }\n\n}\n\nconst HAS_OBSERVER = typeof ResizeObserver !== 'undefined';\n/**\n * @hidden\n */\n\nclass ResizeObserverService extends ResizeService {\n  constructor(resizeBatchService, element, ngZone) {\n    super(resizeBatchService);\n    this.element = element;\n    this.ngZone = ngZone;\n  }\n\n  static supported() {\n    return HAS_OBSERVER;\n  }\n\n  destroy() {\n    super.destroy();\n\n    if (this.resizeObserver) {\n      this.resizeObserver.disconnect();\n      this.resizeObserver = null;\n    }\n\n    this.parentElement = null;\n  }\n\n  init() {\n    this.parentElement = this.element.nativeElement.parentElement;\n    this.initSize();\n    this.state = 2\n    /* Initialized */\n    ;\n    this.ngZone.runOutsideAngular(() => {\n      this.resizeObserver = new ResizeObserver(() => {\n        this.checkSize();\n      });\n      this.resizeObserver.observe(this.parentElement);\n    });\n  }\n\n}\n/* tslint:disable:align */\n\n/**\n * @hidden\n */\n\n\nlet ResizeBatchService = /*#__PURE__*/(() => {\n  let ResizeBatchService = class ResizeBatchService {\n    constructor(ngZone) {\n      this.ngZone = ngZone;\n      this.scheduled = [];\n      this.resolvedPromise = Promise.resolve(null);\n      this.flush = this.flush.bind(this);\n    }\n\n    schedule(instance, method) {\n      this.scheduled.push({\n        instance,\n        method\n      });\n\n      if (!this.subscription) {\n        this.ngZone.runOutsideAngular(() => {\n          this.subscription = from(this.resolvedPromise).subscribe(this.flush);\n        });\n      }\n    }\n\n    isScheduled(instance) {\n      return Boolean(this.scheduled.find(item => item.instance === instance));\n    }\n\n    cancel(instance) {\n      const scheduled = this.scheduled;\n      const count = scheduled.length;\n\n      for (let idx = 0; idx < count; idx++) {\n        if (scheduled[idx].instance === instance) {\n          scheduled.splice(idx, 1);\n\n          if (!scheduled.length) {\n            this.unsubscribe();\n          }\n\n          return;\n        }\n      }\n    }\n\n    ngOnDestroy() {\n      this.unsubscribe();\n    }\n\n    unsubscribe() {\n      if (this.subscription) {\n        this.subscription.unsubscribe();\n        this.subscription = null;\n      }\n    }\n\n    flush() {\n      this.scheduled.forEach(item => {\n        item.method.call(item.instance);\n      });\n      this.scheduled = [];\n      this.unsubscribe();\n    }\n\n  };\n\n  ResizeBatchService.ɵfac = function ResizeBatchService_Factory(t) {\n    return new (t || ResizeBatchService)(ɵngcc0.ɵɵinject(ɵngcc0.NgZone));\n  };\n\n  ResizeBatchService.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: ResizeBatchService,\n    factory: function (t) {\n      return ResizeBatchService.ɵfac(t);\n    }\n  });\n  ResizeBatchService = __decorate([__metadata(\"design:paramtypes\", [NgZone])], ResizeBatchService);\n  /**\n   * Emit up to 10 resize events per second by default.\n   * Chosen as a compromise between responsiveness and performance.\n   */\n\n  return ResizeBatchService;\n})();\nconst DEFAULT_RATE_LIMIT = 10;\n/**\n * Resize Sensor Component\n *\n * Triggers a \"resize\" event whenever the parent DOM element size changes.\n */\n\nlet ResizeSensorComponent = /*#__PURE__*/(() => {\n  let ResizeSensorComponent = class ResizeSensorComponent {\n    constructor(resizeBatchService, element, ngZone) {\n      /**\n       * The maximum number of resize events to emit per second.\n       *\n       * Defaults to 10.\n       */\n      this.rateLimit = DEFAULT_RATE_LIMIT;\n      /**\n       * Fires when the parent DOM element has been resized.\n       */\n\n      this.resize = new EventEmitter();\n      const serviceType = ResizeObserverService.supported() ? ResizeObserverService : ResizeCompatService;\n      this.resizeService = new serviceType(resizeBatchService, element, ngZone);\n      const throttleTime = 1000 / (this.rateLimit || DEFAULT_RATE_LIMIT);\n      this.subscription = this.resizeService.resize.pipe(auditTime(throttleTime)).subscribe(() => {\n        if (!this.resizeService.acceptedSize) {\n          this.resize.emit();\n        }\n      });\n    }\n\n    ngAfterViewChecked() {\n      this.resizeService.checkChanges();\n    }\n\n    ngOnDestroy() {\n      this.subscription.unsubscribe();\n      this.resizeService.destroy();\n    }\n\n    acceptSize(size) {\n      this.resizeService.acceptSize(size);\n    }\n\n  };\n\n  ResizeSensorComponent.ɵfac = function ResizeSensorComponent_Factory(t) {\n    return new (t || ResizeSensorComponent)(ɵngcc0.ɵɵdirectiveInject(ResizeBatchService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone));\n  };\n\n  ResizeSensorComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: ResizeSensorComponent,\n    selectors: [[\"kendo-resize-sensor\"]],\n    inputs: {\n      rateLimit: \"rateLimit\"\n    },\n    outputs: {\n      resize: \"resize\"\n    },\n    decls: 0,\n    vars: 0,\n    template: function ResizeSensorComponent_Template(rf, ctx) {},\n    encapsulation: 2\n  });\n\n  __decorate([Input(), __metadata(\"design:type\", Number)], ResizeSensorComponent.prototype, \"rateLimit\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], ResizeSensorComponent.prototype, \"resize\", void 0);\n\n  ResizeSensorComponent = __decorate([__metadata(\"design:paramtypes\", [ResizeBatchService, ElementRef, NgZone])], ResizeSensorComponent);\n  return ResizeSensorComponent;\n})();\nconst COMPONENT_DIRECTIVES = [ResizeSensorComponent];\n/**\n * Resize Sensor module\n */\n\nlet ResizeSensorModule = /*#__PURE__*/(() => {\n  let ResizeSensorModule = class ResizeSensorModule {};\n\n  ResizeSensorModule.ɵfac = function ResizeSensorModule_Factory(t) {\n    return new (t || ResizeSensorModule)();\n  };\n\n  ResizeSensorModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: ResizeSensorModule\n  });\n  ResizeSensorModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    providers: [ResizeBatchService]\n  });\n  return ResizeSensorModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(DraggableModule, {\n    declarations: function () {\n      return [DraggableDirective];\n    },\n    imports: function () {\n      return [CommonModule];\n    },\n    exports: function () {\n      return [DraggableDirective];\n    }\n  });\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(EventsModule, {\n    declarations: [EventsOutsideAngularDirective],\n    exports: [EventsOutsideAngularDirective]\n  });\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(ResizeSensorModule, {\n    declarations: [ResizeSensorComponent],\n    exports: [ResizeSensorComponent]\n  });\n})();\n\nclass KendoInput {}\n/**\n * Enum with key codes.\n */\n\n\nvar Keys = /*#__PURE__*/(() => {\n  (function (Keys) {\n    Keys[Keys[\"Alt\"] = 18] = \"Alt\";\n    Keys[Keys[\"ArrowDown\"] = 40] = \"ArrowDown\";\n    Keys[Keys[\"ArrowLeft\"] = 37] = \"ArrowLeft\";\n    Keys[Keys[\"ArrowRight\"] = 39] = \"ArrowRight\";\n    Keys[Keys[\"ArrowUp\"] = 38] = \"ArrowUp\";\n    Keys[Keys[\"Backspace\"] = 8] = \"Backspace\";\n    Keys[Keys[\"Control\"] = 17] = \"Control\";\n    Keys[Keys[\"Delete\"] = 46] = \"Delete\";\n    Keys[Keys[\"Digit0\"] = 48] = \"Digit0\";\n    Keys[Keys[\"Digit1\"] = 49] = \"Digit1\";\n    Keys[Keys[\"Digit2\"] = 50] = \"Digit2\";\n    Keys[Keys[\"Digit3\"] = 51] = \"Digit3\";\n    Keys[Keys[\"Digit4\"] = 52] = \"Digit4\";\n    Keys[Keys[\"Digit5\"] = 53] = \"Digit5\";\n    Keys[Keys[\"Digit6\"] = 54] = \"Digit6\";\n    Keys[Keys[\"Digit7\"] = 55] = \"Digit7\";\n    Keys[Keys[\"Digit8\"] = 56] = \"Digit8\";\n    Keys[Keys[\"Digit9\"] = 57] = \"Digit9\";\n    Keys[Keys[\"End\"] = 35] = \"End\";\n    Keys[Keys[\"Enter\"] = 13] = \"Enter\";\n    Keys[Keys[\"Escape\"] = 27] = \"Escape\";\n    Keys[Keys[\"F1\"] = 112] = \"F1\";\n    Keys[Keys[\"F2\"] = 113] = \"F2\";\n    Keys[Keys[\"F10\"] = 121] = \"F10\";\n    Keys[Keys[\"Home\"] = 36] = \"Home\";\n    Keys[Keys[\"Insert\"] = 45] = \"Insert\";\n    Keys[Keys[\"KeyA\"] = 65] = \"KeyA\";\n    Keys[Keys[\"KeyB\"] = 66] = \"KeyB\";\n    Keys[Keys[\"KeyC\"] = 67] = \"KeyC\";\n    Keys[Keys[\"KeyD\"] = 68] = \"KeyD\";\n    Keys[Keys[\"KeyE\"] = 69] = \"KeyE\";\n    Keys[Keys[\"KeyF\"] = 70] = \"KeyF\";\n    Keys[Keys[\"KeyG\"] = 71] = \"KeyG\";\n    Keys[Keys[\"KeyH\"] = 72] = \"KeyH\";\n    Keys[Keys[\"KeyI\"] = 73] = \"KeyI\";\n    Keys[Keys[\"KeyJ\"] = 74] = \"KeyJ\";\n    Keys[Keys[\"KeyK\"] = 75] = \"KeyK\";\n    Keys[Keys[\"KeyL\"] = 76] = \"KeyL\";\n    Keys[Keys[\"KeyM\"] = 77] = \"KeyM\";\n    Keys[Keys[\"KeyN\"] = 78] = \"KeyN\";\n    Keys[Keys[\"KeyO\"] = 79] = \"KeyO\";\n    Keys[Keys[\"KeyP\"] = 80] = \"KeyP\";\n    Keys[Keys[\"KeyQ\"] = 81] = \"KeyQ\";\n    Keys[Keys[\"KeyR\"] = 82] = \"KeyR\";\n    Keys[Keys[\"KeyS\"] = 83] = \"KeyS\";\n    Keys[Keys[\"KeyT\"] = 84] = \"KeyT\";\n    Keys[Keys[\"KeyU\"] = 85] = \"KeyU\";\n    Keys[Keys[\"KeyV\"] = 86] = \"KeyV\";\n    Keys[Keys[\"KeyW\"] = 87] = \"KeyW\";\n    Keys[Keys[\"KeyX\"] = 88] = \"KeyX\";\n    Keys[Keys[\"KeyY\"] = 89] = \"KeyY\";\n    Keys[Keys[\"KeyZ\"] = 90] = \"KeyZ\";\n    Keys[Keys[\"NumpadDecimal\"] = 110] = \"NumpadDecimal\";\n    Keys[Keys[\"PageDown\"] = 34] = \"PageDown\";\n    Keys[Keys[\"PageUp\"] = 33] = \"PageUp\";\n    Keys[Keys[\"Shift\"] = 16] = \"Shift\";\n    Keys[Keys[\"Space\"] = 32] = \"Space\";\n    Keys[Keys[\"Tab\"] = 9] = \"Tab\";\n  })(Keys || (Keys = {}));\n\n  return Keys;\n})();\n\nclass PreventableEvent {\n  constructor() {\n    this.prevented = false;\n  }\n  /**\n   * Prevents the default action for a specified event.\n   * In this way, the source component suppresses\n   * the built-in behavior that follows the event.\n   */\n\n\n  preventDefault() {\n    this.prevented = true;\n  }\n  /**\n   * Returns `true` if the event was prevented\n   * by any of its subscribers.\n   *\n   * @returns `true` if the default action was prevented.\n   * Otherwise, returns `false`.\n   */\n\n\n  isDefaultPrevented() {\n    return this.prevented;\n  }\n\n}\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { ResizeService, PreventableEvent, DraggableDirective, DraggableModule, closestInScope, closest, contains, findElement, findFocusableChild, findFocusable, hasClasses, isFocusableWithTabKey, isFocusable, isVisible, matchesClasses, matchesNodeName, rtlScrollPosition, EventsOutsideAngularDirective, EventsModule, ResizeSensorComponent, ResizeBatchService, ResizeCompatService, ResizeObserverService, ResizeSensorModule, KendoInput, isDocumentAvailable, isChanged, anyChanged, hasObservers, guid, Keys }; //# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VzIjpbImluZGV4LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztvVEFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBSUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OzRGQU9vQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztzUEFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FJRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OzhEQU1pQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O2dLQUFFO0FBQ0YsaUNBRUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7bVRBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBS0c7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzttTUFPdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXNDb250ZW50IjpbIi8qKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4qIENvcHlyaWdodCDCqSAyMDIwIFByb2dyZXNzIFNvZnR3YXJlIENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuKiBMaWNlbnNlZCB1bmRlciBjb21tZXJjaWFsIGxpY2Vuc2UuIFNlZSBMSUNFTlNFLm1kIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIG1vcmUgaW5mb3JtYXRpb25cbiotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmltcG9ydCB7IF9fZGVjb3JhdGUsIF9fbWV0YWRhdGEgfSBmcm9tICd0c2xpYic7XG5pbXBvcnQgeyBFdmVudEVtaXR0ZXIsIElucHV0LCBPdXRwdXQsIERpcmVjdGl2ZSwgRWxlbWVudFJlZiwgTmdab25lLCBOZ01vZHVsZSwgUmVuZGVyZXIyLCBJbmplY3RhYmxlLCBDb21wb25lbnQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCBEcmFnZ2FibGUgZnJvbSAnQHRlbGVyaWsva2VuZG8tZHJhZ2dhYmxlJztcbmltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBhdWRpdFRpbWUgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBtZXJnZSwgZnJvbUV2ZW50LCBmcm9tIH0gZnJvbSAncnhqcyc7XG5cbmNvbnN0IGlzRG9jdW1lbnRBdmFpbGFibGUgPSAoKSA9PiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnO1xuXG5jb25zdCBpc0NoYW5nZWQgPSAocHJvcGVydHlOYW1lLCBjaGFuZ2VzLCBza2lwRmlyc3RDaGFuZ2UgPSB0cnVlKSA9PiAodHlwZW9mIGNoYW5nZXNbcHJvcGVydHlOYW1lXSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAoIWNoYW5nZXNbcHJvcGVydHlOYW1lXS5pc0ZpcnN0Q2hhbmdlKCkgfHwgIXNraXBGaXJzdENoYW5nZSkgJiZcbiAgICBjaGFuZ2VzW3Byb3BlcnR5TmFtZV0ucHJldmlvdXNWYWx1ZSAhPT0gY2hhbmdlc1twcm9wZXJ0eU5hbWVdLmN1cnJlbnRWYWx1ZSk7XG5cbmNvbnN0IGFueUNoYW5nZWQgPSAocHJvcGVydHlOYW1lcywgY2hhbmdlcywgc2tpcEZpcnN0Q2hhbmdlID0gdHJ1ZSkgPT4gcHJvcGVydHlOYW1lcy5zb21lKG5hbWUgPT4gaXNDaGFuZ2VkKG5hbWUsIGNoYW5nZXMsIHNraXBGaXJzdENoYW5nZSkpO1xuXG5jb25zdCBoYXNPYnNlcnZlcnMgPSAoZW1pdHRlcikgPT4gZW1pdHRlciAmJiBlbWl0dGVyLm9ic2VydmVycy5sZW5ndGggPiAwO1xuXG5jb25zdCBndWlkID0gKCkgPT4ge1xuICAgIGxldCBpZCA9IFwiXCI7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAzMjsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHJhbmRvbSA9IE1hdGgucmFuZG9tKCkgKiAxNiB8IDA7IC8vIHRzbGludDpkaXNhYmxlLWxpbmU6bm8tYml0d2lzZVxuICAgICAgICBpZiAoaSA9PT0gOCB8fCBpID09PSAxMiB8fCBpID09PSAxNiB8fCBpID09PSAyMCkge1xuICAgICAgICAgICAgaWQgKz0gXCItXCI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWJpdHdpc2VcbiAgICAgICAgaWQgKz0gKGkgPT09IDEyID8gNCA6IChpID09PSAxNiA/IChyYW5kb20gJiAzIHwgOCkgOiByYW5kb20pKS50b1N0cmluZygxNik7XG4gICAgfVxuICAgIHJldHVybiBpZDtcbn07XG5cbmxldCBEcmFnZ2FibGVEaXJlY3RpdmUgPSBjbGFzcyBEcmFnZ2FibGVEaXJlY3RpdmUge1xuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnQsIG5nWm9uZSkge1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICB0aGlzLm5nWm9uZSA9IG5nWm9uZTtcbiAgICAgICAgdGhpcy5lbmFibGVEcmFnID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5rZW5kb1ByZXNzID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLmtlbmRvRHJhZyA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5rZW5kb1JlbGVhc2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgfVxuICAgIG5nT25Jbml0KCkge1xuICAgICAgICB0aGlzLnRvZ2dsZURyYWdnYWJsZSgpO1xuICAgIH1cbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzKSB7XG4gICAgICAgIGlmIChpc0NoYW5nZWQoJ2VuYWJsZURyYWcnLCBjaGFuZ2VzKSkge1xuICAgICAgICAgICAgdGhpcy50b2dnbGVEcmFnZ2FibGUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5kZXN0cm95RHJhZ2dhYmxlKCk7XG4gICAgfVxuICAgIHRvZ2dsZURyYWdnYWJsZSgpIHtcbiAgICAgICAgaWYgKGlzRG9jdW1lbnRBdmFpbGFibGUoKSkge1xuICAgICAgICAgICAgdGhpcy5kZXN0cm95RHJhZ2dhYmxlKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5lbmFibGVEcmFnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kcmFnZ2FibGUgPSBuZXcgRHJhZ2dhYmxlKHtcbiAgICAgICAgICAgICAgICAgICAgZHJhZzogKGUpID0+IHRoaXMua2VuZG9EcmFnLm5leHQoZSksXG4gICAgICAgICAgICAgICAgICAgIHByZXNzOiAoZSkgPT4gdGhpcy5rZW5kb1ByZXNzLm5leHQoZSksXG4gICAgICAgICAgICAgICAgICAgIHJlbGVhc2U6IChlKSA9PiB0aGlzLmtlbmRvUmVsZWFzZS5uZXh0KGUpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5uZ1pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4gdGhpcy5kcmFnZ2FibGUuYmluZFRvKHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVzdHJveURyYWdnYWJsZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuZHJhZ2dhYmxlKSB7XG4gICAgICAgICAgICB0aGlzLmRyYWdnYWJsZS5kZXN0cm95KCk7XG4gICAgICAgICAgICB0aGlzLmRyYWdnYWJsZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG59O1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIERyYWdnYWJsZURpcmVjdGl2ZS5wcm90b3R5cGUsIFwiZW5hYmxlRHJhZ1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbl0sIERyYWdnYWJsZURpcmVjdGl2ZS5wcm90b3R5cGUsIFwia2VuZG9QcmVzc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbl0sIERyYWdnYWJsZURpcmVjdGl2ZS5wcm90b3R5cGUsIFwia2VuZG9EcmFnXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBPdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxuXSwgRHJhZ2dhYmxlRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJrZW5kb1JlbGVhc2VcIiwgdm9pZCAwKTtcbkRyYWdnYWJsZURpcmVjdGl2ZSA9IF9fZGVjb3JhdGUoW1xuICAgIERpcmVjdGl2ZSh7XG4gICAgICAgIHNlbGVjdG9yOiAnW2tlbmRvRHJhZ2dhYmxlXSdcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0VsZW1lbnRSZWYsIE5nWm9uZV0pXG5dLCBEcmFnZ2FibGVEaXJlY3RpdmUpO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xubGV0IERyYWdnYWJsZU1vZHVsZSA9IGNsYXNzIERyYWdnYWJsZU1vZHVsZSB7XG59O1xuRHJhZ2dhYmxlTW9kdWxlID0gX19kZWNvcmF0ZShbXG4gICAgTmdNb2R1bGUoe1xuICAgICAgICBkZWNsYXJhdGlvbnM6IFtEcmFnZ2FibGVEaXJlY3RpdmVdLFxuICAgICAgICBleHBvcnRzOiBbRHJhZ2dhYmxlRGlyZWN0aXZlXSxcbiAgICAgICAgaW1wb3J0czogW0NvbW1vbk1vZHVsZV1cbiAgICB9KVxuXSwgRHJhZ2dhYmxlTW9kdWxlKTtcblxuY29uc3QgY2xvc2VzdEluU2NvcGUgPSAobm9kZSwgcHJlZGljYXRlLCBzY29wZSkgPT4ge1xuICAgIHdoaWxlIChub2RlICYmIG5vZGUgIT09IHNjb3BlICYmICFwcmVkaWNhdGUobm9kZSkpIHtcbiAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICB9XG4gICAgaWYgKG5vZGUgIT09IHNjb3BlKSB7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbn07XG5cbmNvbnN0IGNsb3Nlc3QgPSAobm9kZSwgcHJlZGljYXRlKSA9PiB7XG4gICAgd2hpbGUgKG5vZGUgJiYgIXByZWRpY2F0ZShub2RlKSkge1xuICAgICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbn07XG5cbmNvbnN0IGNvbnRhaW5zID0gKHBhcmVudCwgbm9kZSwgbWF0Y2hTZWxmID0gZmFsc2UpID0+IHtcbiAgICBjb25zdCBvdXRzaWRlID0gIWNsb3Nlc3Qobm9kZSwgKGNoaWxkKSA9PiBjaGlsZCA9PT0gcGFyZW50KTtcbiAgICBpZiAob3V0c2lkZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGVsID0gY2xvc2VzdChub2RlLCAoY2hpbGQpID0+IGNoaWxkID09PSBub2RlKTtcbiAgICByZXR1cm4gZWwgJiYgKG1hdGNoU2VsZiB8fCBlbCAhPT0gcGFyZW50KTtcbn07XG5cbmNvbnN0IGZpbmRFbGVtZW50ID0gKG5vZGUsIHByZWRpY2F0ZSwgbWF0Y2hTZWxmID0gdHJ1ZSkgPT4ge1xuICAgIGlmICghbm9kZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChtYXRjaFNlbGYgJiYgcHJlZGljYXRlKG5vZGUpKSB7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgICBub2RlID0gbm9kZS5maXJzdENoaWxkO1xuICAgIHdoaWxlIChub2RlKSB7XG4gICAgICAgIGlmIChub2RlLm5vZGVUeXBlID09PSAxKSB7XG4gICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gZmluZEVsZW1lbnQobm9kZSwgcHJlZGljYXRlKTtcbiAgICAgICAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbm9kZSA9IG5vZGUubmV4dFNpYmxpbmc7XG4gICAgfVxufTtcblxuY29uc3QgZm9jdXNhYmxlUmVnZXggPSAvXig/OmF8aW5wdXR8c2VsZWN0fG9wdGlvbnx0ZXh0YXJlYXxidXR0b258b2JqZWN0KSQvaTtcbmNvbnN0IGlzRm9jdXNhYmxlID0gKGVsZW1lbnQpID0+IHtcbiAgICBpZiAoIWVsZW1lbnQudGFnTmFtZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHRhZ05hbWUgPSBlbGVtZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKTtcbiAgICBjb25zdCBoYXNUYWJJbmRleCA9IEJvb2xlYW4oZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3RhYkluZGV4JykpO1xuICAgIGNvbnN0IGZvY3VzYWJsZSA9ICFlbGVtZW50LmRpc2FibGVkICYmIGZvY3VzYWJsZVJlZ2V4LnRlc3QodGFnTmFtZSk7XG4gICAgcmV0dXJuIGZvY3VzYWJsZSB8fCBoYXNUYWJJbmRleDtcbn07XG5cbmNvbnN0IGlzVmlzaWJsZSA9IChlbGVtZW50KSA9PiB7XG4gICAgY29uc3QgcmVjdCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgY29uc3QgaGFzU2l6ZSA9IHJlY3Qud2lkdGggPiAwICYmIHJlY3QuaGVpZ2h0ID4gMDtcbiAgICBjb25zdCBoYXNQb3NpdGlvbiA9IHJlY3QueCAhPT0gMCAmJiByZWN0LnkgIT09IDA7XG4gICAgLy8gRWxlbWVudHMgY2FuIGhhdmUgemVybyBzaXplIGR1ZSB0byBzdHlsaW5nLCBidXQgdGhleSB3aWxsIHN0aWxsIGNvdW50IGFzIHZpc2libGUuXG4gICAgLy8gRm9yIGV4YW1wbGUsIHRoZSBzZWxlY3Rpb24gY2hlY2tib3ggaGFzIG5vIHNpemUsIGJ1dCBpcyBtYWRlIHZpc2libGUgdGhyb3VnaCBzdHlsaW5nLlxuICAgIHJldHVybiAoaGFzU2l6ZSB8fCBoYXNQb3NpdGlvbikgJiYgd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkudmlzaWJpbGl0eSAhPT0gJ2hpZGRlbic7XG59O1xuXG5jb25zdCBpc0ZvY3VzYWJsZVdpdGhUYWJLZXkgPSAoZWxlbWVudCwgY2hlY2tWaXNpYmlsaXR5ID0gdHJ1ZSkgPT4ge1xuICAgIGlmICghaXNGb2N1c2FibGUoZWxlbWVudCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCB0YWJJbmRleCA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCd0YWJJbmRleCcpO1xuICAgIGNvbnN0IHZpc2libGUgPSAhY2hlY2tWaXNpYmlsaXR5IHx8IGlzVmlzaWJsZShlbGVtZW50KTtcbiAgICByZXR1cm4gdmlzaWJsZSAmJiB0YWJJbmRleCAhPT0gJy0xJztcbn07XG5cbmNvbnN0IGZpbmRGb2N1c2FibGVDaGlsZCA9IChlbGVtZW50LCBjaGVja1Zpc2liaWxpdHkgPSB0cnVlKSA9PiB7XG4gICAgcmV0dXJuIGZpbmRFbGVtZW50KGVsZW1lbnQsIChub2RlKSA9PiBpc0ZvY3VzYWJsZVdpdGhUYWJLZXkobm9kZSwgY2hlY2tWaXNpYmlsaXR5KSwgZmFsc2UpO1xufTtcblxuY29uc3QgZmluZEZvY3VzYWJsZSA9IChlbGVtZW50LCBjaGVja1Zpc2liaWxpdHkgPSB0cnVlKSA9PiB7XG4gICAgcmV0dXJuIGZpbmRFbGVtZW50KGVsZW1lbnQsIChub2RlKSA9PiBpc0ZvY3VzYWJsZVdpdGhUYWJLZXkobm9kZSwgY2hlY2tWaXNpYmlsaXR5KSk7XG59O1xuXG5jb25zdCB0b0NsYXNzTGlzdCA9IChjbGFzc05hbWVzKSA9PiBTdHJpbmcoY2xhc3NOYW1lcykudHJpbSgpLnNwbGl0KCcgJyk7XG5jb25zdCBoYXNDbGFzc2VzID0gKGVsZW1lbnQsIGNsYXNzTmFtZXMpID0+IHtcbiAgICBjb25zdCBuYW1lc0xpc3QgPSB0b0NsYXNzTGlzdChjbGFzc05hbWVzKTtcbiAgICByZXR1cm4gQm9vbGVhbih0b0NsYXNzTGlzdChlbGVtZW50LmNsYXNzTmFtZSkuZmluZCgoY2xhc3NOYW1lKSA9PiBuYW1lc0xpc3QuaW5kZXhPZihjbGFzc05hbWUpID49IDApKTtcbn07XG5cbmNvbnN0IG1hdGNoZXNDbGFzc2VzID0gKGNsYXNzTmFtZXMpID0+IChlbGVtZW50KSA9PiBoYXNDbGFzc2VzKGVsZW1lbnQsIGNsYXNzTmFtZXMpO1xuXG5jb25zdCBOT0RFX05BTUVfUFJFRElDQVRFUyA9IHt9O1xuY29uc3QgbWF0Y2hlc05vZGVOYW1lID0gKG5vZGVOYW1lKSA9PiB7XG4gICAgaWYgKCFOT0RFX05BTUVfUFJFRElDQVRFU1tub2RlTmFtZV0pIHtcbiAgICAgICAgTk9ERV9OQU1FX1BSRURJQ0FURVNbbm9kZU5hbWVdID0gKGVsZW1lbnQpID0+IFN0cmluZyhlbGVtZW50Lm5vZGVOYW1lKS50b0xvd2VyQ2FzZSgpID09PSBub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cbiAgICByZXR1cm4gTk9ERV9OQU1FX1BSRURJQ0FURVNbbm9kZU5hbWVdO1xufTtcblxuLyoqXG4gKiBOb3JtYWxpemVzIGEgc2Nyb2xsIHBvc2l0aW9uIHZhbHVlIGluIFJUTCBtb2RlLlxuICovXG5mdW5jdGlvbiBydGxTY3JvbGxQb3NpdGlvbihwb3NpdGlvbiwgZWxlbWVudCwgaW5pdGlhbCkge1xuICAgIGxldCByZXN1bHQgPSBwb3NpdGlvbjtcbiAgICBpZiAoaW5pdGlhbCA8IDApIHtcbiAgICAgICAgcmVzdWx0ID0gLXBvc2l0aW9uO1xuICAgIH1cbiAgICBlbHNlIGlmIChpbml0aWFsID4gMCkge1xuICAgICAgICByZXN1bHQgPSBlbGVtZW50LnNjcm9sbFdpZHRoIC0gZWxlbWVudC5vZmZzZXRXaWR0aCAtIHBvc2l0aW9uO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKiB0c2xpbnQ6ZGlzYWJsZTpuby1pbnB1dC1yZW5hbWUgKi9cbi8qKlxuICogQGhpZGRlblxuICovXG5sZXQgRXZlbnRzT3V0c2lkZUFuZ3VsYXJEaXJlY3RpdmUgPSBjbGFzcyBFdmVudHNPdXRzaWRlQW5ndWxhckRpcmVjdGl2ZSB7XG4gICAgY29uc3RydWN0b3IoZWxlbWVudCwgbmdab25lLCByZW5kZXJlcikge1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICB0aGlzLm5nWm9uZSA9IG5nWm9uZTtcbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgICAgICB0aGlzLmV2ZW50cyA9IHt9O1xuICAgIH1cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmVsZW1lbnQgfHwgIXRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZXZlbnRzID0gdGhpcy5ldmVudHM7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucyA9IFtdO1xuICAgICAgICB0aGlzLm5nWm9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XG4gICAgICAgICAgICBmb3IgKGxldCBuYW1lIGluIGV2ZW50cykge1xuICAgICAgICAgICAgICAgIGlmIChldmVudHMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLnB1c2godGhpcy5yZW5kZXJlci5saXN0ZW4odGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQsIG5hbWUsIHRoaXMuc2NvcGUgPyBldmVudHNbbmFtZV0uYmluZCh0aGlzLnNjb3BlKSA6IGV2ZW50c1tuYW1lXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICBpZiAodGhpcy5zdWJzY3JpcHRpb25zKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpZHggPSAwOyBpZHggPCB0aGlzLnN1YnNjcmlwdGlvbnMubGVuZ3RoOyBpZHgrKykge1xuICAgICAgICAgICAgICAgIHRoaXMuc3Vic2NyaXB0aW9uc1tpZHhdKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxufTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCdrZW5kb0V2ZW50c091dHNpZGVBbmd1bGFyJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIEV2ZW50c091dHNpZGVBbmd1bGFyRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJldmVudHNcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIEV2ZW50c091dHNpZGVBbmd1bGFyRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJzY29wZVwiLCB2b2lkIDApO1xuRXZlbnRzT3V0c2lkZUFuZ3VsYXJEaXJlY3RpdmUgPSBfX2RlY29yYXRlKFtcbiAgICBEaXJlY3RpdmUoe1xuICAgICAgICBzZWxlY3RvcjogJ1trZW5kb0V2ZW50c091dHNpZGVBbmd1bGFyXSdcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0VsZW1lbnRSZWYsXG4gICAgICAgIE5nWm9uZSxcbiAgICAgICAgUmVuZGVyZXIyXSlcbl0sIEV2ZW50c091dHNpZGVBbmd1bGFyRGlyZWN0aXZlKTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmxldCBFdmVudHNNb2R1bGUgPSBjbGFzcyBFdmVudHNNb2R1bGUge1xufTtcbkV2ZW50c01vZHVsZSA9IF9fZGVjb3JhdGUoW1xuICAgIE5nTW9kdWxlKHtcbiAgICAgICAgZGVjbGFyYXRpb25zOiBbRXZlbnRzT3V0c2lkZUFuZ3VsYXJEaXJlY3RpdmVdLFxuICAgICAgICBleHBvcnRzOiBbRXZlbnRzT3V0c2lkZUFuZ3VsYXJEaXJlY3RpdmVdXG4gICAgfSlcbl0sIEV2ZW50c01vZHVsZSk7XG5cbmNsYXNzIFJlc2l6ZVNlcnZpY2Uge1xuICAgIGNvbnN0cnVjdG9yKHJlc2l6ZUJhdGNoU2VydmljZSkge1xuICAgICAgICB0aGlzLnJlc2l6ZUJhdGNoU2VydmljZSA9IHJlc2l6ZUJhdGNoU2VydmljZTtcbiAgICAgICAgdGhpcy5yZXNpemUgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuYWNjZXB0ZWRTaXplID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc3RhdGUgPSAwIC8qIEluaXRpYWwgKi87XG4gICAgfVxuICAgIGFjY2VwdFNpemUoc2l6ZSA9IHRoaXMubWVhc3VyZSgpKSB7XG4gICAgICAgIHRoaXMubGFzdFdpZHRoID0gc2l6ZS53aWR0aDtcbiAgICAgICAgdGhpcy5sYXN0SGVpZ2h0ID0gc2l6ZS5oZWlnaHQ7XG4gICAgICAgIHRoaXMuYWNjZXB0ZWRTaXplID0gdHJ1ZTtcbiAgICB9XG4gICAgY2hlY2tDaGFuZ2VzKCkge1xuICAgICAgICBpZiAoIWlzRG9jdW1lbnRBdmFpbGFibGUoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnN0YXRlID09PSAwIC8qIEluaXRpYWwgKi8pIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAxIC8qIEluaXRpYWxpemluZyAqLztcbiAgICAgICAgICAgIC8vIGJhdGNoIGluaXRpYWwgbWVhc3VyZVxuICAgICAgICAgICAgdGhpcy5yZXNpemVCYXRjaFNlcnZpY2Uuc2NoZWR1bGUodGhpcywgdGhpcy5pbml0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLnJlc2l6ZUJhdGNoU2VydmljZS5jYW5jZWwodGhpcyk7XG4gICAgfVxuICAgIGNoZWNrU2l6ZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnBhcmVudEVsZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IHRoaXMubWVhc3VyZSgpO1xuICAgICAgICBjb25zdCBzYW1lU2l6ZSA9IHdpZHRoID09PSB0aGlzLmxhc3RXaWR0aCAmJiBoZWlnaHQgPT09IHRoaXMubGFzdEhlaWdodDtcbiAgICAgICAgaWYgKHNhbWVTaXplKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sYXN0V2lkdGggPSB3aWR0aDtcbiAgICAgICAgdGhpcy5sYXN0SGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICB0aGlzLmFjY2VwdGVkU2l6ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnJlc2l6ZS5lbWl0KCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpbml0U2l6ZSgpIHtcbiAgICAgICAgY29uc3Qgc2l6ZSA9IHRoaXMubWVhc3VyZSgpO1xuICAgICAgICB0aGlzLmxhc3RXaWR0aCA9IHNpemUud2lkdGg7XG4gICAgICAgIHRoaXMubGFzdEhlaWdodCA9IHNpemUuaGVpZ2h0O1xuICAgIH1cbiAgICBtZWFzdXJlKCkge1xuICAgICAgICBsZXQgd2lkdGggPSAwO1xuICAgICAgICBsZXQgaGVpZ2h0ID0gMDtcbiAgICAgICAgaWYgKHRoaXMucGFyZW50RWxlbWVudCkge1xuICAgICAgICAgICAgaGVpZ2h0ID0gdGhpcy5wYXJlbnRFbGVtZW50Lm9mZnNldEhlaWdodDtcbiAgICAgICAgICAgIHdpZHRoID0gdGhpcy5wYXJlbnRFbGVtZW50Lm9mZnNldFdpZHRoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGhlaWdodCwgd2lkdGggfTtcbiAgICB9XG59XG5cbi8vIHRzbGludDpkaXNhYmxlOmRlcHJlY2F0aW9uXG5jb25zdCBkaXYgPSBzdHlsZSA9PiB7XG4gICAgY29uc3QgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBlbC5zdHlsZS5jc3NUZXh0ID0gc3R5bGU7XG4gICAgcmV0dXJuIGVsO1xufTtcbmNvbnN0IGNvbXB1dGVkUHJvcCA9IChlbGVtLCBwcm9wKSA9PiBnZXRDb21wdXRlZFN0eWxlKGVsZW0sIG51bGwpLmdldFByb3BlcnR5VmFsdWUocHJvcCk7XG5jb25zdCBXUkFQX1NUWUxFID0gJ3Bvc2l0aW9uOiBhYnNvbHV0ZTsgZGlzcGxheTogYmxvY2s7IGxlZnQ6IDA7IHRvcDogMDsgcmlnaHQ6IDA7IGJvdHRvbTogMDsgei1pbmRleDogLTE7JyArXG4gICAgJ292ZXJmbG93OiBoaWRkZW47IHZpc2liaWxpdHk6IGhpZGRlbjsnO1xuY29uc3QgRVhQQU5EX0NISUxEX1NUWUxFID0gJ3Bvc2l0aW9uOiBhYnNvbHV0ZTsgbGVmdDogMDsgdG9wOiAwOyB0cmFuc2l0aW9uOiAwczsnO1xuY29uc3QgU0hSSU5LX0NISUxEX1NUWUxFID0gRVhQQU5EX0NISUxEX1NUWUxFICsgJ3dpZHRoOiAyMDAlOyBoZWlnaHQ6IDIwMCU7JztcbmNsYXNzIFJlc2l6ZUNvbXBhdFNlcnZpY2UgZXh0ZW5kcyBSZXNpemVTZXJ2aWNlIHtcbiAgICBjb25zdHJ1Y3RvcihyZXNpemVCYXRjaFNlcnZpY2UsIGVsZW1lbnQsIG5nWm9uZSkge1xuICAgICAgICBzdXBlcihyZXNpemVCYXRjaFNlcnZpY2UpO1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICB0aGlzLm5nWm9uZSA9IG5nWm9uZTtcbiAgICB9XG4gICAgY2hlY2tDaGFuZ2VzKCkge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gMiAvKiBJbml0aWFsaXplZCAqLykge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnJlc2l6ZUJhdGNoU2VydmljZS5pc1NjaGVkdWxlZCh0aGlzKSkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVzaXplQmF0Y2hTZXJ2aWNlLnNjaGVkdWxlKHRoaXMsIHRoaXMuY2hlY2tTaXplKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzdXBlci5jaGVja0NoYW5nZXMoKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgc3VwZXIuZGVzdHJveSgpO1xuICAgICAgICBpZiAodGhpcy5zdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZXhwYW5kKSB7XG4gICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgICAgICBlbGVtZW50LnJlbW92ZUNoaWxkKHRoaXMuZXhwYW5kKTtcbiAgICAgICAgICAgIGVsZW1lbnQucmVtb3ZlQ2hpbGQodGhpcy5zaHJpbmspO1xuICAgICAgICAgICAgdGhpcy5leHBhbmQucmVtb3ZlQ2hpbGQodGhpcy5leHBhbmRDaGlsZCk7XG4gICAgICAgICAgICB0aGlzLmV4cGFuZCA9IHRoaXMuZXhwYW5kQ2hpbGQgPSB0aGlzLnNocmluayA9IHRoaXMuZWxlbWVudCA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2hlY2tTaXplKCkge1xuICAgICAgICBpZiAoc3VwZXIuY2hlY2tTaXplKCkpIHtcbiAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGluaXQoKSB7XG4gICAgICAgIGNvbnN0IHBhcmVudEVsZW1lbnQgPSB0aGlzLnBhcmVudEVsZW1lbnQgPSB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudC5wYXJlbnRFbGVtZW50O1xuICAgICAgICBpZiAoY29tcHV0ZWRQcm9wKHBhcmVudEVsZW1lbnQsICdwb3NpdGlvbicpID09PSAnc3RhdGljJykge1xuICAgICAgICAgICAgcGFyZW50RWxlbWVudC5zdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGF0ZSA9IDIgLyogSW5pdGlhbGl6ZWQgKi87XG4gICAgICAgIHRoaXMucmVuZGVyKCk7XG4gICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgdGhpcy5pbml0U2l6ZSgpO1xuICAgICAgICB0aGlzLnN1YnNjcmliZSgpO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudDtcbiAgICAgICAgZWxlbWVudC5zdHlsZS5jc3NUZXh0ID0gV1JBUF9TVFlMRTtcbiAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2RpcicsICdsdHInKTtcbiAgICAgICAgdGhpcy5leHBhbmQgPSBkaXYoV1JBUF9TVFlMRSk7XG4gICAgICAgIHRoaXMuZXhwYW5kQ2hpbGQgPSBkaXYoRVhQQU5EX0NISUxEX1NUWUxFKTtcbiAgICAgICAgdGhpcy5leHBhbmQuYXBwZW5kQ2hpbGQodGhpcy5leHBhbmRDaGlsZCk7XG4gICAgICAgIGVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5leHBhbmQpO1xuICAgICAgICB0aGlzLnNocmluayA9IGRpdihXUkFQX1NUWUxFKTtcbiAgICAgICAgY29uc3Qgc2hyaW5rQ2hpbGQgPSBkaXYoU0hSSU5LX0NISUxEX1NUWUxFKTtcbiAgICAgICAgdGhpcy5zaHJpbmsuYXBwZW5kQ2hpbGQoc2hyaW5rQ2hpbGQpO1xuICAgICAgICBlbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuc2hyaW5rKTtcbiAgICB9XG4gICAgcmVzZXQoKSB7XG4gICAgICAgIGNvbnN0IGV4cGFuZENoaWxkID0gdGhpcy5leHBhbmRDaGlsZDtcbiAgICAgICAgZXhwYW5kQ2hpbGQuc3R5bGUud2lkdGggPSAxMDAwMDAgKyAncHgnO1xuICAgICAgICBleHBhbmRDaGlsZC5zdHlsZS5oZWlnaHQgPSAxMDAwMDAgKyAncHgnO1xuICAgICAgICBjb25zdCBleHBhbmQgPSB0aGlzLmV4cGFuZDtcbiAgICAgICAgZXhwYW5kLnNjcm9sbExlZnQgPSAxMDAwMDA7XG4gICAgICAgIGV4cGFuZC5zY3JvbGxUb3AgPSAxMDAwMDA7XG4gICAgICAgIGNvbnN0IHNocmluayA9IHRoaXMuc2hyaW5rO1xuICAgICAgICBzaHJpbmsuc2Nyb2xsTGVmdCA9IDEwMDAwMDtcbiAgICAgICAgc2hyaW5rLnNjcm9sbFRvcCA9IDEwMDAwMDtcbiAgICB9XG4gICAgc3Vic2NyaWJlKCkge1xuICAgICAgICB0aGlzLm5nWm9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbiA9IG1lcmdlKGZyb21FdmVudCh0aGlzLnNocmluaywgJ3Njcm9sbCcpLCBmcm9tRXZlbnQodGhpcy5leHBhbmQsICdzY3JvbGwnKSlcbiAgICAgICAgICAgICAgICAuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmNoZWNrU2l6ZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuY29uc3QgSEFTX09CU0VSVkVSID0gdHlwZW9mIFJlc2l6ZU9ic2VydmVyICE9PSAndW5kZWZpbmVkJztcbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBSZXNpemVPYnNlcnZlclNlcnZpY2UgZXh0ZW5kcyBSZXNpemVTZXJ2aWNlIHtcbiAgICBjb25zdHJ1Y3RvcihyZXNpemVCYXRjaFNlcnZpY2UsIGVsZW1lbnQsIG5nWm9uZSkge1xuICAgICAgICBzdXBlcihyZXNpemVCYXRjaFNlcnZpY2UpO1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICB0aGlzLm5nWm9uZSA9IG5nWm9uZTtcbiAgICB9XG4gICAgc3RhdGljIHN1cHBvcnRlZCgpIHtcbiAgICAgICAgcmV0dXJuIEhBU19PQlNFUlZFUjtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgc3VwZXIuZGVzdHJveSgpO1xuICAgICAgICBpZiAodGhpcy5yZXNpemVPYnNlcnZlcikge1xuICAgICAgICAgICAgdGhpcy5yZXNpemVPYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICB0aGlzLnJlc2l6ZU9ic2VydmVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBhcmVudEVsZW1lbnQgPSBudWxsO1xuICAgIH1cbiAgICBpbml0KCkge1xuICAgICAgICB0aGlzLnBhcmVudEVsZW1lbnQgPSB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudC5wYXJlbnRFbGVtZW50O1xuICAgICAgICB0aGlzLmluaXRTaXplKCk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSAyIC8qIEluaXRpYWxpemVkICovO1xuICAgICAgICB0aGlzLm5nWm9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnJlc2l6ZU9ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmNoZWNrU2l6ZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnJlc2l6ZU9ic2VydmVyLm9ic2VydmUodGhpcy5wYXJlbnRFbGVtZW50KTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG4vKiB0c2xpbnQ6ZGlzYWJsZTphbGlnbiAqL1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmxldCBSZXNpemVCYXRjaFNlcnZpY2UgPSBjbGFzcyBSZXNpemVCYXRjaFNlcnZpY2Uge1xuICAgIGNvbnN0cnVjdG9yKG5nWm9uZSkge1xuICAgICAgICB0aGlzLm5nWm9uZSA9IG5nWm9uZTtcbiAgICAgICAgdGhpcy5zY2hlZHVsZWQgPSBbXTtcbiAgICAgICAgdGhpcy5yZXNvbHZlZFByb21pc2UgPSBQcm9taXNlLnJlc29sdmUobnVsbCk7XG4gICAgICAgIHRoaXMuZmx1c2ggPSB0aGlzLmZsdXNoLmJpbmQodGhpcyk7XG4gICAgfVxuICAgIHNjaGVkdWxlKGluc3RhbmNlLCBtZXRob2QpIHtcbiAgICAgICAgdGhpcy5zY2hlZHVsZWQucHVzaCh7IGluc3RhbmNlLCBtZXRob2QgfSk7XG4gICAgICAgIGlmICghdGhpcy5zdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMubmdab25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbiA9IGZyb20odGhpcy5yZXNvbHZlZFByb21pc2UpXG4gICAgICAgICAgICAgICAgICAgIC5zdWJzY3JpYmUodGhpcy5mbHVzaCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpc1NjaGVkdWxlZChpbnN0YW5jZSkge1xuICAgICAgICByZXR1cm4gQm9vbGVhbih0aGlzLnNjaGVkdWxlZC5maW5kKGl0ZW0gPT4gaXRlbS5pbnN0YW5jZSA9PT0gaW5zdGFuY2UpKTtcbiAgICB9XG4gICAgY2FuY2VsKGluc3RhbmNlKSB7XG4gICAgICAgIGNvbnN0IHNjaGVkdWxlZCA9IHRoaXMuc2NoZWR1bGVkO1xuICAgICAgICBjb25zdCBjb3VudCA9IHNjaGVkdWxlZC5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IGlkeCA9IDA7IGlkeCA8IGNvdW50OyBpZHgrKykge1xuICAgICAgICAgICAgaWYgKHNjaGVkdWxlZFtpZHhdLmluc3RhbmNlID09PSBpbnN0YW5jZSkge1xuICAgICAgICAgICAgICAgIHNjaGVkdWxlZC5zcGxpY2UoaWR4LCAxKTtcbiAgICAgICAgICAgICAgICBpZiAoIXNjaGVkdWxlZC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICB9XG4gICAgdW5zdWJzY3JpYmUoKSB7XG4gICAgICAgIGlmICh0aGlzLnN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgdGhpcy5zdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaXB0aW9uID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmbHVzaCgpIHtcbiAgICAgICAgdGhpcy5zY2hlZHVsZWQuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICAgIGl0ZW0ubWV0aG9kLmNhbGwoaXRlbS5pbnN0YW5jZSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnNjaGVkdWxlZCA9IFtdO1xuICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxufTtcblJlc2l6ZUJhdGNoU2VydmljZSA9IF9fZGVjb3JhdGUoW1xuICAgIEluamVjdGFibGUoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW05nWm9uZV0pXG5dLCBSZXNpemVCYXRjaFNlcnZpY2UpO1xuXG4vKipcbiAqIEVtaXQgdXAgdG8gMTAgcmVzaXplIGV2ZW50cyBwZXIgc2Vjb25kIGJ5IGRlZmF1bHQuXG4gKiBDaG9zZW4gYXMgYSBjb21wcm9taXNlIGJldHdlZW4gcmVzcG9uc2l2ZW5lc3MgYW5kIHBlcmZvcm1hbmNlLlxuICovXG5jb25zdCBERUZBVUxUX1JBVEVfTElNSVQgPSAxMDtcbi8qKlxuICogUmVzaXplIFNlbnNvciBDb21wb25lbnRcbiAqXG4gKiBUcmlnZ2VycyBhIFwicmVzaXplXCIgZXZlbnQgd2hlbmV2ZXIgdGhlIHBhcmVudCBET00gZWxlbWVudCBzaXplIGNoYW5nZXMuXG4gKi9cbmxldCBSZXNpemVTZW5zb3JDb21wb25lbnQgPSBjbGFzcyBSZXNpemVTZW5zb3JDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKHJlc2l6ZUJhdGNoU2VydmljZSwgZWxlbWVudCwgbmdab25lKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbWF4aW11bSBudW1iZXIgb2YgcmVzaXplIGV2ZW50cyB0byBlbWl0IHBlciBzZWNvbmQuXG4gICAgICAgICAqXG4gICAgICAgICAqIERlZmF1bHRzIHRvIDEwLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yYXRlTGltaXQgPSBERUZBVUxUX1JBVEVfTElNSVQ7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyB3aGVuIHRoZSBwYXJlbnQgRE9NIGVsZW1lbnQgaGFzIGJlZW4gcmVzaXplZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVzaXplID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICBjb25zdCBzZXJ2aWNlVHlwZSA9IFJlc2l6ZU9ic2VydmVyU2VydmljZS5zdXBwb3J0ZWQoKSA/IFJlc2l6ZU9ic2VydmVyU2VydmljZSA6IFJlc2l6ZUNvbXBhdFNlcnZpY2U7XG4gICAgICAgIHRoaXMucmVzaXplU2VydmljZSA9IG5ldyBzZXJ2aWNlVHlwZShyZXNpemVCYXRjaFNlcnZpY2UsIGVsZW1lbnQsIG5nWm9uZSk7XG4gICAgICAgIGNvbnN0IHRocm90dGxlVGltZSA9IDEwMDAgLyAodGhpcy5yYXRlTGltaXQgfHwgREVGQVVMVF9SQVRFX0xJTUlUKTtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb24gPSB0aGlzLnJlc2l6ZVNlcnZpY2UucmVzaXplXG4gICAgICAgICAgICAucGlwZShhdWRpdFRpbWUodGhyb3R0bGVUaW1lKSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnJlc2l6ZVNlcnZpY2UuYWNjZXB0ZWRTaXplKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXNpemUuZW1pdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbmdBZnRlclZpZXdDaGVja2VkKCkge1xuICAgICAgICB0aGlzLnJlc2l6ZVNlcnZpY2UuY2hlY2tDaGFuZ2VzKCk7XG4gICAgfVxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICB0aGlzLnJlc2l6ZVNlcnZpY2UuZGVzdHJveSgpO1xuICAgIH1cbiAgICBhY2NlcHRTaXplKHNpemUpIHtcbiAgICAgICAgdGhpcy5yZXNpemVTZXJ2aWNlLmFjY2VwdFNpemUoc2l6ZSk7XG4gICAgfVxufTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIFJlc2l6ZVNlbnNvckNvbXBvbmVudC5wcm90b3R5cGUsIFwicmF0ZUxpbWl0XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBPdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxuXSwgUmVzaXplU2Vuc29yQ29tcG9uZW50LnByb3RvdHlwZSwgXCJyZXNpemVcIiwgdm9pZCAwKTtcblJlc2l6ZVNlbnNvckNvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tcmVzaXplLXNlbnNvcicsXG4gICAgICAgIHRlbXBsYXRlOiAnJ1xuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbUmVzaXplQmF0Y2hTZXJ2aWNlLCBFbGVtZW50UmVmLCBOZ1pvbmVdKVxuXSwgUmVzaXplU2Vuc29yQ29tcG9uZW50KTtcblxuY29uc3QgQ09NUE9ORU5UX0RJUkVDVElWRVMgPSBbUmVzaXplU2Vuc29yQ29tcG9uZW50XTtcbi8qKlxuICogUmVzaXplIFNlbnNvciBtb2R1bGVcbiAqL1xubGV0IFJlc2l6ZVNlbnNvck1vZHVsZSA9IGNsYXNzIFJlc2l6ZVNlbnNvck1vZHVsZSB7XG59O1xuUmVzaXplU2Vuc29yTW9kdWxlID0gX19kZWNvcmF0ZShbXG4gICAgTmdNb2R1bGUoe1xuICAgICAgICBkZWNsYXJhdGlvbnM6IFtDT01QT05FTlRfRElSRUNUSVZFU10sXG4gICAgICAgIGV4cG9ydHM6IFtDT01QT05FTlRfRElSRUNUSVZFU10sXG4gICAgICAgIHByb3ZpZGVyczogW1Jlc2l6ZUJhdGNoU2VydmljZV1cbiAgICB9KVxuXSwgUmVzaXplU2Vuc29yTW9kdWxlKTtcblxuY2xhc3MgS2VuZG9JbnB1dCB7XG59XG5cbi8qKlxuICogRW51bSB3aXRoIGtleSBjb2Rlcy5cbiAqL1xudmFyIEtleXM7XG4oZnVuY3Rpb24gKEtleXMpIHtcbiAgICBLZXlzW0tleXNbXCJBbHRcIl0gPSAxOF0gPSBcIkFsdFwiO1xuICAgIEtleXNbS2V5c1tcIkFycm93RG93blwiXSA9IDQwXSA9IFwiQXJyb3dEb3duXCI7XG4gICAgS2V5c1tLZXlzW1wiQXJyb3dMZWZ0XCJdID0gMzddID0gXCJBcnJvd0xlZnRcIjtcbiAgICBLZXlzW0tleXNbXCJBcnJvd1JpZ2h0XCJdID0gMzldID0gXCJBcnJvd1JpZ2h0XCI7XG4gICAgS2V5c1tLZXlzW1wiQXJyb3dVcFwiXSA9IDM4XSA9IFwiQXJyb3dVcFwiO1xuICAgIEtleXNbS2V5c1tcIkJhY2tzcGFjZVwiXSA9IDhdID0gXCJCYWNrc3BhY2VcIjtcbiAgICBLZXlzW0tleXNbXCJDb250cm9sXCJdID0gMTddID0gXCJDb250cm9sXCI7XG4gICAgS2V5c1tLZXlzW1wiRGVsZXRlXCJdID0gNDZdID0gXCJEZWxldGVcIjtcbiAgICBLZXlzW0tleXNbXCJEaWdpdDBcIl0gPSA0OF0gPSBcIkRpZ2l0MFwiO1xuICAgIEtleXNbS2V5c1tcIkRpZ2l0MVwiXSA9IDQ5XSA9IFwiRGlnaXQxXCI7XG4gICAgS2V5c1tLZXlzW1wiRGlnaXQyXCJdID0gNTBdID0gXCJEaWdpdDJcIjtcbiAgICBLZXlzW0tleXNbXCJEaWdpdDNcIl0gPSA1MV0gPSBcIkRpZ2l0M1wiO1xuICAgIEtleXNbS2V5c1tcIkRpZ2l0NFwiXSA9IDUyXSA9IFwiRGlnaXQ0XCI7XG4gICAgS2V5c1tLZXlzW1wiRGlnaXQ1XCJdID0gNTNdID0gXCJEaWdpdDVcIjtcbiAgICBLZXlzW0tleXNbXCJEaWdpdDZcIl0gPSA1NF0gPSBcIkRpZ2l0NlwiO1xuICAgIEtleXNbS2V5c1tcIkRpZ2l0N1wiXSA9IDU1XSA9IFwiRGlnaXQ3XCI7XG4gICAgS2V5c1tLZXlzW1wiRGlnaXQ4XCJdID0gNTZdID0gXCJEaWdpdDhcIjtcbiAgICBLZXlzW0tleXNbXCJEaWdpdDlcIl0gPSA1N10gPSBcIkRpZ2l0OVwiO1xuICAgIEtleXNbS2V5c1tcIkVuZFwiXSA9IDM1XSA9IFwiRW5kXCI7XG4gICAgS2V5c1tLZXlzW1wiRW50ZXJcIl0gPSAxM10gPSBcIkVudGVyXCI7XG4gICAgS2V5c1tLZXlzW1wiRXNjYXBlXCJdID0gMjddID0gXCJFc2NhcGVcIjtcbiAgICBLZXlzW0tleXNbXCJGMVwiXSA9IDExMl0gPSBcIkYxXCI7XG4gICAgS2V5c1tLZXlzW1wiRjJcIl0gPSAxMTNdID0gXCJGMlwiO1xuICAgIEtleXNbS2V5c1tcIkYxMFwiXSA9IDEyMV0gPSBcIkYxMFwiO1xuICAgIEtleXNbS2V5c1tcIkhvbWVcIl0gPSAzNl0gPSBcIkhvbWVcIjtcbiAgICBLZXlzW0tleXNbXCJJbnNlcnRcIl0gPSA0NV0gPSBcIkluc2VydFwiO1xuICAgIEtleXNbS2V5c1tcIktleUFcIl0gPSA2NV0gPSBcIktleUFcIjtcbiAgICBLZXlzW0tleXNbXCJLZXlCXCJdID0gNjZdID0gXCJLZXlCXCI7XG4gICAgS2V5c1tLZXlzW1wiS2V5Q1wiXSA9IDY3XSA9IFwiS2V5Q1wiO1xuICAgIEtleXNbS2V5c1tcIktleURcIl0gPSA2OF0gPSBcIktleURcIjtcbiAgICBLZXlzW0tleXNbXCJLZXlFXCJdID0gNjldID0gXCJLZXlFXCI7XG4gICAgS2V5c1tLZXlzW1wiS2V5RlwiXSA9IDcwXSA9IFwiS2V5RlwiO1xuICAgIEtleXNbS2V5c1tcIktleUdcIl0gPSA3MV0gPSBcIktleUdcIjtcbiAgICBLZXlzW0tleXNbXCJLZXlIXCJdID0gNzJdID0gXCJLZXlIXCI7XG4gICAgS2V5c1tLZXlzW1wiS2V5SVwiXSA9IDczXSA9IFwiS2V5SVwiO1xuICAgIEtleXNbS2V5c1tcIktleUpcIl0gPSA3NF0gPSBcIktleUpcIjtcbiAgICBLZXlzW0tleXNbXCJLZXlLXCJdID0gNzVdID0gXCJLZXlLXCI7XG4gICAgS2V5c1tLZXlzW1wiS2V5TFwiXSA9IDc2XSA9IFwiS2V5TFwiO1xuICAgIEtleXNbS2V5c1tcIktleU1cIl0gPSA3N10gPSBcIktleU1cIjtcbiAgICBLZXlzW0tleXNbXCJLZXlOXCJdID0gNzhdID0gXCJLZXlOXCI7XG4gICAgS2V5c1tLZXlzW1wiS2V5T1wiXSA9IDc5XSA9IFwiS2V5T1wiO1xuICAgIEtleXNbS2V5c1tcIktleVBcIl0gPSA4MF0gPSBcIktleVBcIjtcbiAgICBLZXlzW0tleXNbXCJLZXlRXCJdID0gODFdID0gXCJLZXlRXCI7XG4gICAgS2V5c1tLZXlzW1wiS2V5UlwiXSA9IDgyXSA9IFwiS2V5UlwiO1xuICAgIEtleXNbS2V5c1tcIktleVNcIl0gPSA4M10gPSBcIktleVNcIjtcbiAgICBLZXlzW0tleXNbXCJLZXlUXCJdID0gODRdID0gXCJLZXlUXCI7XG4gICAgS2V5c1tLZXlzW1wiS2V5VVwiXSA9IDg1XSA9IFwiS2V5VVwiO1xuICAgIEtleXNbS2V5c1tcIktleVZcIl0gPSA4Nl0gPSBcIktleVZcIjtcbiAgICBLZXlzW0tleXNbXCJLZXlXXCJdID0gODddID0gXCJLZXlXXCI7XG4gICAgS2V5c1tLZXlzW1wiS2V5WFwiXSA9IDg4XSA9IFwiS2V5WFwiO1xuICAgIEtleXNbS2V5c1tcIktleVlcIl0gPSA4OV0gPSBcIktleVlcIjtcbiAgICBLZXlzW0tleXNbXCJLZXlaXCJdID0gOTBdID0gXCJLZXlaXCI7XG4gICAgS2V5c1tLZXlzW1wiTnVtcGFkRGVjaW1hbFwiXSA9IDExMF0gPSBcIk51bXBhZERlY2ltYWxcIjtcbiAgICBLZXlzW0tleXNbXCJQYWdlRG93blwiXSA9IDM0XSA9IFwiUGFnZURvd25cIjtcbiAgICBLZXlzW0tleXNbXCJQYWdlVXBcIl0gPSAzM10gPSBcIlBhZ2VVcFwiO1xuICAgIEtleXNbS2V5c1tcIlNoaWZ0XCJdID0gMTZdID0gXCJTaGlmdFwiO1xuICAgIEtleXNbS2V5c1tcIlNwYWNlXCJdID0gMzJdID0gXCJTcGFjZVwiO1xuICAgIEtleXNbS2V5c1tcIlRhYlwiXSA9IDldID0gXCJUYWJcIjtcbn0pKEtleXMgfHwgKEtleXMgPSB7fSkpO1xuXG5jbGFzcyBQcmV2ZW50YWJsZUV2ZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5wcmV2ZW50ZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJldmVudHMgdGhlIGRlZmF1bHQgYWN0aW9uIGZvciBhIHNwZWNpZmllZCBldmVudC5cbiAgICAgKiBJbiB0aGlzIHdheSwgdGhlIHNvdXJjZSBjb21wb25lbnQgc3VwcHJlc3Nlc1xuICAgICAqIHRoZSBidWlsdC1pbiBiZWhhdmlvciB0aGF0IGZvbGxvd3MgdGhlIGV2ZW50LlxuICAgICAqL1xuICAgIHByZXZlbnREZWZhdWx0KCkge1xuICAgICAgICB0aGlzLnByZXZlbnRlZCA9IHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYHRydWVgIGlmIHRoZSBldmVudCB3YXMgcHJldmVudGVkXG4gICAgICogYnkgYW55IG9mIGl0cyBzdWJzY3JpYmVycy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgZGVmYXVsdCBhY3Rpb24gd2FzIHByZXZlbnRlZC5cbiAgICAgKiBPdGhlcndpc2UsIHJldHVybnMgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBpc0RlZmF1bHRQcmV2ZW50ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByZXZlbnRlZDtcbiAgICB9XG59XG5cbi8qKlxuICogR2VuZXJhdGVkIGJ1bmRsZSBpbmRleC4gRG8gbm90IGVkaXQuXG4gKi9cblxuZXhwb3J0IHsgUmVzaXplU2VydmljZSwgUHJldmVudGFibGVFdmVudCwgRHJhZ2dhYmxlRGlyZWN0aXZlLCBEcmFnZ2FibGVNb2R1bGUsIGNsb3Nlc3RJblNjb3BlLCBjbG9zZXN0LCBjb250YWlucywgZmluZEVsZW1lbnQsIGZpbmRGb2N1c2FibGVDaGlsZCwgZmluZEZvY3VzYWJsZSwgaGFzQ2xhc3NlcywgaXNGb2N1c2FibGVXaXRoVGFiS2V5LCBpc0ZvY3VzYWJsZSwgaXNWaXNpYmxlLCBtYXRjaGVzQ2xhc3NlcywgbWF0Y2hlc05vZGVOYW1lLCBydGxTY3JvbGxQb3NpdGlvbiwgRXZlbnRzT3V0c2lkZUFuZ3VsYXJEaXJlY3RpdmUsIEV2ZW50c01vZHVsZSwgUmVzaXplU2Vuc29yQ29tcG9uZW50LCBSZXNpemVCYXRjaFNlcnZpY2UsIFJlc2l6ZUNvbXBhdFNlcnZpY2UsIFJlc2l6ZU9ic2VydmVyU2VydmljZSwgUmVzaXplU2Vuc29yTW9kdWxlLCBLZW5kb0lucHV0LCBpc0RvY3VtZW50QXZhaWxhYmxlLCBpc0NoYW5nZWQsIGFueUNoYW5nZWQsIGhhc09ic2VydmVycywgZ3VpZCwgS2V5cyB9O1xuIl19","map":null,"metadata":{},"sourceType":"module"}