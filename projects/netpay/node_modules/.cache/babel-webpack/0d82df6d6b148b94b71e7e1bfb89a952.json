{"ast":null,"code":"import { isCompositeFilterDescriptor } from \"./filter-descriptor.interface\";\nimport { getter } from \"../accessor\";\nimport { isFunction, isPresent, isDate, isString, isBlank, isNumeric } from \"../utils\";\nconst logic = {\n  \"or\": {\n    concat: (acc, fn) => a => acc(a) || fn(a),\n    identity: () => false\n  },\n  \"and\": {\n    concat: (acc, fn) => a => acc(a) && fn(a),\n    identity: () => true\n  }\n};\nconst operatorsMap = {\n  contains: (a, b) => (a || \"\").indexOf(b) >= 0,\n  doesnotcontain: (a, b) => (a || \"\").indexOf(b) === -1,\n  doesnotendwith: (a, b) => (a || \"\").indexOf(b, (a || \"\").length - (b || \"\").length) < 0,\n  doesnotstartwith: (a, b) => (a || \"\").lastIndexOf(b, 0) === -1,\n  endswith: (a, b) => (a || \"\").indexOf(b, (a || \"\").length - (b || \"\").length) >= 0,\n  eq: (a, b) => a === b,\n  gt: (a, b) => a > b,\n  gte: (a, b) => a >= b,\n  isempty: a => a === '',\n  isnotempty: a => a !== '',\n  isnotnull: a => isPresent(a),\n  isnull: a => isBlank(a),\n  lt: (a, b) => a < b,\n  lte: (a, b) => a <= b,\n  neq: (a, b) => a != b,\n  startswith: (a, b) => (a || \"\").lastIndexOf(b, 0) === 0\n};\nconst dateRegExp = /^\\/Date\\((.*?)\\)\\/$/;\n\nconst convertValue = (value, ignoreCase) => {\n  if (value != null && isString(value)) {\n    const date = dateRegExp.exec(value);\n\n    if (date) {\n      return new Date(+date[1]).getTime();\n    } else if (ignoreCase) {\n      return value.toLowerCase();\n    }\n  } else if (value != null && isDate(value)) {\n    return value.getTime();\n  }\n\n  return value;\n};\n\nconst typedGetter = (prop, value, ignoreCase) => {\n  if (!isPresent(value)) {\n    return prop;\n  }\n\n  let acc = prop;\n\n  if (isString(value)) {\n    const date = dateRegExp.exec(value);\n\n    if (date) {\n      value = new Date(+date[1]);\n    } else {\n      acc = a => {\n        const x = prop(a);\n\n        if (typeof x === 'string' && ignoreCase) {\n          return x.toLowerCase();\n        } else {\n          return isNumeric(x) ? x + \"\" : x;\n        }\n      };\n    }\n  }\n\n  if (isDate(value)) {\n    return a => {\n      const x = acc(a);\n      return isDate(x) ? x.getTime() : x;\n    };\n  }\n\n  return acc;\n};\n\nconst transformFilter = ({\n  field,\n  ignoreCase,\n  value,\n  operator\n}) => {\n  field = !isPresent(field) ? a => a : field;\n  ignoreCase = isPresent(ignoreCase) ? ignoreCase : true;\n  const itemProp = typedGetter(isFunction(field) ? field : getter(field, true), value, ignoreCase);\n  value = convertValue(value, ignoreCase);\n  const op = isFunction(operator) ? operator : operatorsMap[operator];\n  return a => op(itemProp(a), value, ignoreCase);\n};\n/**\n * @hidden\n */\n\n\nexport const transformCompositeFilter = filter => {\n  const combiner = logic[filter.logic];\n  return filter.filters.filter(isPresent).map(x => isCompositeFilterDescriptor(x) ? transformCompositeFilter(x) : transformFilter(x)).reduce(combiner.concat, combiner.identity);\n};","map":null,"metadata":{},"sourceType":"module"}