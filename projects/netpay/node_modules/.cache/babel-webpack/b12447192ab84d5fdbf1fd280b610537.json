{"ast":null,"code":"/**-----------------------------------------------------------------------------------------\n* Copyright © 2021 Progress Software Corporation. All rights reserved.\n* Licensed under commercial license. See LICENSE.md in the project root for more information\n*-------------------------------------------------------------------------------------------*/\nimport { __decorate, __metadata, __param } from 'tslib';\nimport { Injectable, EventEmitter, Injector, InjectionToken, Input, Output, HostBinding, Component, Inject, ElementRef, Renderer2, NgZone, TemplateRef, ViewChild, ChangeDetectionStrategy, ChangeDetectorRef, isDevMode, Directive, forwardRef, ContentChild, Optional, ViewContainerRef, HostListener, ViewChildren, QueryList, ContentChildren, IterableDiffers, NgModule } from '@angular/core';\nimport { NG_VALUE_ACCESSOR, NG_VALIDATORS, NgControl } from '@angular/forms';\nimport { LocalizationService, L10N_PREFIX, RTL, ComponentMessages } from '@progress/kendo-angular-l10n';\nimport { getDate, isEqual, cloneDate, addDays, addDecades, addCenturies, firstDecadeOfCentury, lastDecadeOfCentury, firstYearOfDecade, createDate, durationInCenturies, addYears, lastYearOfDecade, durationInDecades, addWeeks, addMonths, firstDayOfMonth, lastDayOfMonth, dayOfWeek, durationInMonths, firstMonthOfYear, lastMonthOfYear, durationInYears, weekInYear } from '@progress/kendo-date-math';\nimport { isDocumentAvailable, KendoInput, guid, hasObservers, Keys, EventsModule, ResizeSensorModule } from '@progress/kendo-angular-common';\nimport { validatePackage } from '@progress/kendo-licensing';\nimport { IntlService, IntlModule } from '@progress/kendo-angular-intl';\nimport { ReplaySubject, Observable, Subject, combineLatest, of, interval, animationFrameScheduler, fromEvent, EMPTY, from, Subscription, BehaviorSubject, merge } from 'rxjs';\nimport { map, scan, takeWhile, tap, filter, debounceTime } from 'rxjs/operators';\nimport { PopupService, PopupModule } from '@progress/kendo-angular-popup';\nimport { CommonModule } from '@angular/common';\nimport { touchEnabled } from '@progress/kendo-common';\n/**\n * @hidden\n */\n\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from '@progress/kendo-angular-intl';\nimport * as ɵngcc2 from '@angular/common';\nimport * as ɵngcc3 from '@progress/kendo-angular-common';\nimport * as ɵngcc4 from '@progress/kendo-angular-l10n';\nimport * as ɵngcc5 from '@progress/kendo-angular-popup';\nconst _c0 = [\"*\"];\nconst _c1 = [\"list\"];\n\nfunction NavigationComponent_li_4_ng_template_2_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵtext(0);\n  }\n\n  if (rf & 2) {\n    const date_r2 = ɵngcc0.ɵɵnextContext().$implicit;\n    const ctx_r4 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵtextInterpolate(ctx_r4.service.navigationTitle(date_r2));\n  }\n}\n\nfunction NavigationComponent_li_4_ng_template_3_Template(rf, ctx) {}\n\nconst _c2 = function (a0, a1, a2) {\n  return {\n    $implicit: a0,\n    activeView: a1,\n    date: a2\n  };\n};\n\nfunction NavigationComponent_li_4_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"li\");\n    ɵngcc0.ɵɵelementStart(1, \"span\");\n    ɵngcc0.ɵɵtemplate(2, NavigationComponent_li_4_ng_template_2_Template, 1, 1, \"ng-template\", 5);\n    ɵngcc0.ɵɵtemplate(3, NavigationComponent_li_4_ng_template_3_Template, 0, 0, \"ng-template\", 6);\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const date_r2 = ctx.$implicit;\n    const index_r3 = ctx.index;\n    const ctx_r1 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵattribute(\"data-date-index\", index_r3);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵclassProp(\"k-calendar-navigation-marker\", ctx_r1.service.isRangeStart(date_r2));\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngIf\", !ctx_r1.templateRef);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngIf\", ctx_r1.templateRef)(\"ngTemplateOutlet\", ctx_r1.templateRef)(\"ngTemplateOutletContext\", ɵngcc0.ɵɵpureFunction3(7, _c2, ctx_r1.service.navigationTitle(date_r2), ctx_r1.activeViewValue, date_r2));\n  }\n}\n\nconst _c3 = function (a0) {\n  return {\n    click: a0\n  };\n};\n\nfunction ViewListComponent_table_1_th_3_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"th\", 11);\n    ɵngcc0.ɵɵtext(1);\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const name_r5 = ctx.$implicit;\n    const ctx_r4 = ɵngcc0.ɵɵnextContext(2);\n    ɵngcc0.ɵɵstyleProp(\"width\", ctx_r4.colWidth, \"%\");\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵtextInterpolate(name_r5);\n  }\n}\n\nfunction ViewListComponent_table_1_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"table\", 7);\n    ɵngcc0.ɵɵelementStart(1, \"thead\", 8);\n    ɵngcc0.ɵɵelementStart(2, \"tr\", 9);\n    ɵngcc0.ɵɵtemplate(3, ViewListComponent_table_1_th_3_Template, 2, 3, \"th\", 10);\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵadvance(3);\n    ɵngcc0.ɵɵproperty(\"ngForOf\", ctx_r0.weekNames);\n  }\n}\n\nfunction ViewListComponent_col_6_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelement(0, \"col\");\n  }\n}\n\nfunction ViewListComponent_tbody_7_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r9 = ɵngcc0.ɵɵgetCurrentView();\n\n    ɵngcc0.ɵɵelementStart(0, \"tbody\", 12);\n    ɵngcc0.ɵɵlistener(\"cellClick\", function ViewListComponent_tbody_7_Template_tbody_cellClick_0_listener($event) {\n      ɵngcc0.ɵɵrestoreView(_r9);\n      const ctx_r8 = ɵngcc0.ɵɵnextContext();\n      return ctx_r8.cellClick.emit($event);\n    })(\"weekNumberCellClick\", function ViewListComponent_tbody_7_Template_tbody_weekNumberCellClick_0_listener($event) {\n      ɵngcc0.ɵɵrestoreView(_r9);\n      const ctx_r10 = ɵngcc0.ɵɵnextContext();\n      return ctx_r10.weekNumberCellClick.emit($event);\n    });\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const date_r7 = ctx.$implicit;\n    const ctx_r3 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵproperty(\"activeView\", ctx_r3.activeView)(\"isActive\", ctx_r3.isActive)(\"min\", ctx_r3.min)(\"max\", ctx_r3.max)(\"cellUID\", ctx_r3.cellUID)(\"focusedDate\", ctx_r3.focusedDate)(\"selectedDates\", ctx_r3.selectedDates)(\"weekNumber\", ctx_r3.weekNumber)(\"templateRef\", ctx_r3.cellTemplateRef)(\"weekNumberTemplateRef\", ctx_r3.weekNumberTemplateRef)(\"viewDate\", date_r7);\n  }\n}\n\nfunction CalendarComponent_ng_container_1_kendo_calendar_navigation_1_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r4 = ɵngcc0.ɵɵgetCurrentView();\n\n    ɵngcc0.ɵɵelementStart(0, \"kendo-calendar-navigation\", 5);\n    ɵngcc0.ɵɵlistener(\"valueChange\", function CalendarComponent_ng_container_1_kendo_calendar_navigation_1_Template_kendo_calendar_navigation_valueChange_0_listener($event) {\n      ɵngcc0.ɵɵrestoreView(_r4);\n      const ctx_r3 = ɵngcc0.ɵɵnextContext(2);\n      return ctx_r3.handleNavigation($event);\n    })(\"pageChange\", function CalendarComponent_ng_container_1_kendo_calendar_navigation_1_Template_kendo_calendar_navigation_pageChange_0_listener() {\n      ɵngcc0.ɵɵrestoreView(_r4);\n      const ctx_r5 = ɵngcc0.ɵɵnextContext(2);\n      return ctx_r5.onPageChange();\n    });\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r2 = ɵngcc0.ɵɵnextContext(2);\n    ɵngcc0.ɵɵproperty(\"activeView\", ctx_r2.activeViewEnum)(\"focusedDate\", ctx_r2.focusedDate)(\"min\", ctx_r2.min)(\"max\", ctx_r2.max)(\"templateRef\", ctx_r2.navigationItemTemplate == null ? null : ctx_r2.navigationItemTemplate.templateRef);\n  }\n}\n\nfunction CalendarComponent_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r7 = ɵngcc0.ɵɵgetCurrentView();\n\n    ɵngcc0.ɵɵelementContainerStart(0);\n    ɵngcc0.ɵɵtemplate(1, CalendarComponent_ng_container_1_kendo_calendar_navigation_1_Template, 1, 5, \"kendo-calendar-navigation\", 2);\n    ɵngcc0.ɵɵelementStart(2, \"kendo-calendar-viewlist\", 3);\n    ɵngcc0.ɵɵlistener(\"todayButtonClick\", function CalendarComponent_ng_container_1_Template_kendo_calendar_viewlist_todayButtonClick_2_listener($event) {\n      ɵngcc0.ɵɵrestoreView(_r7);\n      const ctx_r6 = ɵngcc0.ɵɵnextContext();\n      return ctx_r6.handleDateChange({\n        selectedDates: [$event],\n        focusedDate: $event\n      });\n    })(\"cellClick\", function CalendarComponent_ng_container_1_Template_kendo_calendar_viewlist_cellClick_2_listener($event) {\n      ɵngcc0.ɵɵrestoreView(_r7);\n      const ctx_r8 = ɵngcc0.ɵɵnextContext();\n      return ctx_r8.handleCellClick($event);\n    })(\"weekNumberCellClick\", function CalendarComponent_ng_container_1_Template_kendo_calendar_viewlist_weekNumberCellClick_2_listener($event) {\n      ɵngcc0.ɵɵrestoreView(_r7);\n      const ctx_r9 = ɵngcc0.ɵɵnextContext();\n      return ctx_r9.handleWeekNumberClick($event);\n    })(\"activeDateChange\", function CalendarComponent_ng_container_1_Template_kendo_calendar_viewlist_activeDateChange_2_listener($event) {\n      ɵngcc0.ɵɵrestoreView(_r7);\n      const ctx_r10 = ɵngcc0.ɵɵnextContext();\n      return ctx_r10.emitEvent(ctx_r10.activeViewDateChange, $event);\n    })(\"pageChange\", function CalendarComponent_ng_container_1_Template_kendo_calendar_viewlist_pageChange_2_listener() {\n      ɵngcc0.ɵɵrestoreView(_r7);\n      const ctx_r11 = ɵngcc0.ɵɵnextContext();\n      return ctx_r11.onPageChange();\n    });\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵelementStart(3, \"kendo-resize-sensor\", 4);\n    ɵngcc0.ɵɵlistener(\"resize\", function CalendarComponent_ng_container_1_Template_kendo_resize_sensor_resize_3_listener() {\n      ɵngcc0.ɵɵrestoreView(_r7);\n      const ctx_r12 = ɵngcc0.ɵɵnextContext();\n      return ctx_r12.onResize();\n    });\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = ɵngcc0.ɵɵnextContext();\n    let tmp_3_0;\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngIf\", ctx_r0.navigation);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"activeView\", ctx_r0.activeViewEnum)(\"isActive\", ctx_r0.isActive)(\"cellTemplateRef\", (tmp_3_0 = ctx_r0.activeCellTemplate()) == null ? null : tmp_3_0.templateRef)(\"headerTitleTemplateRef\", ctx_r0.headerTitleTemplate == null ? null : ctx_r0.headerTitleTemplate.templateRef)(\"weekNumberTemplateRef\", ctx_r0.weekNumberTemplate == null ? null : ctx_r0.weekNumberTemplate.templateRef)(\"cellUID\", ctx_r0.cellUID)(\"min\", ctx_r0.min)(\"max\", ctx_r0.max)(\"focusedDate\", ctx_r0.focusedDate)(\"weekNumber\", ctx_r0.weekNumber)(\"selectedDates\", ctx_r0.selectedDates);\n  }\n}\n\nfunction CalendarComponent_ng_container_2_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r15 = ɵngcc0.ɵɵgetCurrentView();\n\n    ɵngcc0.ɵɵelementContainerStart(0);\n    ɵngcc0.ɵɵelementStart(1, \"kendo-multiviewcalendar\", 6, 7);\n    ɵngcc0.ɵɵlistener(\"activeViewChange\", function CalendarComponent_ng_container_2_Template_kendo_multiviewcalendar_activeViewChange_1_listener($event) {\n      ɵngcc0.ɵɵrestoreView(_r15);\n      const ctx_r14 = ɵngcc0.ɵɵnextContext();\n      return ctx_r14.handleActiveViewChange($event);\n    })(\"valueChange\", function CalendarComponent_ng_container_2_Template_kendo_multiviewcalendar_valueChange_1_listener($event) {\n      ɵngcc0.ɵɵrestoreView(_r15);\n\n      const _r13 = ɵngcc0.ɵɵreference(2);\n\n      const ctx_r16 = ɵngcc0.ɵɵnextContext();\n      return ctx_r16.handleMultiViewCalendarValueChange($event, _r13.focusedDate);\n    });\n    ɵngcc0.ɵɵelement(3, \"kendo-multiviewcalendar-messages\", 8);\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r1 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"views\", 1)(\"min\", ctx_r1.min)(\"max\", ctx_r1.max)(\"isActive\", ctx_r1.isActive)(\"activeView\", ctx_r1.activeView)(\"bottomView\", ctx_r1.bottomView)(\"topView\", ctx_r1.topView)(\"weekNumber\", ctx_r1.weekNumber)(\"animateNavigation\", ctx_r1.animateNavigation)(\"cellTemplate\", ctx_r1.activeCellTemplate())(\"monthCellTemplate\", ctx_r1.monthCellTemplate)(\"yearCellTemplate\", ctx_r1.yearCellTemplate)(\"decadeCellTemplate\", ctx_r1.decadeCellTemplate)(\"centuryCellTemplate\", ctx_r1.centuryCellTemplate)(\"headerTitleTemplate\", ctx_r1.headerTitleTemplate)(\"weekNumberTemplate\", ctx_r1.weekNumberTemplate)(\"focusedDate\", ctx_r1.focusedDate)(\"selection\", ctx_r1.selection)(\"value\", ctx_r1.value)(\"disabledDates\", ctx_r1.disabledDates);\n    ɵngcc0.ɵɵadvance(2);\n    ɵngcc0.ɵɵproperty(\"today\", ctx_r1.localization.get(\"today\"))(\"prevButtonTitle\", ctx_r1.localization.get(\"prevButtonTitle\"))(\"nextButtonTitle\", ctx_r1.localization.get(\"nextButtonTitle\"));\n  }\n}\n\nconst _c10 = [\"dateInput\"];\nconst _c11 = [\"wrap\"];\n\nfunction DateInputComponent_span_5_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r5 = ɵngcc0.ɵɵgetCurrentView();\n\n    ɵngcc0.ɵɵelementStart(0, \"span\", 6);\n    ɵngcc0.ɵɵlistener(\"mousedown\", function DateInputComponent_span_5_Template_span_mousedown_0_listener($event) {\n      return $event.preventDefault();\n    });\n    ɵngcc0.ɵɵelementStart(1, \"span\", 7);\n    ɵngcc0.ɵɵlistener(\"mousedown\", function DateInputComponent_span_5_Template_span_mousedown_1_listener() {\n      ɵngcc0.ɵɵrestoreView(_r5);\n      const ctx_r4 = ɵngcc0.ɵɵnextContext();\n      return ctx_r4.arrowDirection = ctx_r4.arrow.Up;\n    })(\"mouseleave\", function DateInputComponent_span_5_Template_span_mouseleave_1_listener() {\n      ɵngcc0.ɵɵrestoreView(_r5);\n      const ctx_r6 = ɵngcc0.ɵɵnextContext();\n      return ctx_r6.arrowDirection = ctx_r6.arrow.None;\n    })(\"click\", function DateInputComponent_span_5_Template_span_click_1_listener() {\n      ɵngcc0.ɵɵrestoreView(_r5);\n      const ctx_r7 = ɵngcc0.ɵɵnextContext();\n      return ctx_r7.handleButtonClick(1);\n    });\n    ɵngcc0.ɵɵelement(2, \"span\", 8);\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵelementStart(3, \"span\", 9);\n    ɵngcc0.ɵɵlistener(\"click\", function DateInputComponent_span_5_Template_span_click_3_listener() {\n      ɵngcc0.ɵɵrestoreView(_r5);\n      const ctx_r8 = ɵngcc0.ɵɵnextContext();\n      return ctx_r8.handleButtonClick(-1);\n    })(\"mousedown\", function DateInputComponent_span_5_Template_span_mousedown_3_listener() {\n      ɵngcc0.ɵɵrestoreView(_r5);\n      const ctx_r9 = ɵngcc0.ɵɵnextContext();\n      return ctx_r9.arrowDirection = ctx_r9.arrow.Down;\n    })(\"mouseleave\", function DateInputComponent_span_5_Template_span_mouseleave_3_listener() {\n      ɵngcc0.ɵɵrestoreView(_r5);\n      const ctx_r10 = ɵngcc0.ɵɵnextContext();\n      return ctx_r10.arrowDirection = ctx_r10.arrow.None;\n    });\n    ɵngcc0.ɵɵelement(4, \"span\", 10);\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r2 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵclassProp(\"k-state-active\", ctx_r2.arrowDirection === ctx_r2.arrow.Up);\n    ɵngcc0.ɵɵproperty(\"title\", ctx_r2.localization.get(\"increment\"));\n    ɵngcc0.ɵɵattribute(\"aria-label\", ctx_r2.localization.get(\"increment\"));\n    ɵngcc0.ɵɵadvance(2);\n    ɵngcc0.ɵɵclassProp(\"k-state-active\", ctx_r2.arrowDirection === ctx_r2.arrow.Down);\n    ɵngcc0.ɵɵproperty(\"title\", ctx_r2.localization.get(\"decrement\"));\n    ɵngcc0.ɵɵattribute(\"aria-label\", ctx_r2.localization.get(\"decrement\"));\n  }\n}\n\nconst _c16 = function (a0, a1, a2, a3, a4, a5, a6) {\n  return {\n    click: a0,\n    focus: a1,\n    mousedown: a2,\n    touchstart: a3,\n    dragstart: a4,\n    drop: a5,\n    blur: a6\n  };\n};\n\nconst _c17 = [\"container\"];\nconst _c18 = [\"popupTemplate\"];\nconst _c19 = [\"wrapper\"];\n\nfunction DatePickerComponent_ng_template_9_ng_template_3_Template(rf, ctx) {}\n\nconst _c28 = function (a0) {\n  return {\n    keydown: a0\n  };\n};\n\nfunction DatePickerComponent_ng_template_9_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r8 = ɵngcc0.ɵɵgetCurrentView();\n\n    ɵngcc0.ɵɵelementStart(0, \"kendo-calendar\", 9, 10);\n    ɵngcc0.ɵɵlistener(\"valueChange\", function DatePickerComponent_ng_template_9_Template_kendo_calendar_valueChange_0_listener($event) {\n      ɵngcc0.ɵɵrestoreView(_r8);\n      const ctx_r7 = ɵngcc0.ɵɵnextContext();\n      return ctx_r7.handleChange(ctx_r7.mergeTime($event));\n    });\n    ɵngcc0.ɵɵelement(2, \"kendo-calendar-messages\", 11);\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵtemplate(3, DatePickerComponent_ng_template_9_ng_template_3_Template, 0, 0, \"ng-template\");\n  }\n\n  if (rf & 2) {\n    const ctx_r4 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵproperty(\"type\", ctx_r4.calendarType)(\"min\", ctx_r4.min)(\"max\", ctx_r4.max)(\"navigation\", ctx_r4.navigation)(\"animateNavigation\", ctx_r4.animateCalendarNavigation)(\"activeView\", ctx_r4.activeView)(\"bottomView\", ctx_r4.bottomView)(\"topView\", ctx_r4.topView)(\"weekNumber\", ctx_r4.weekNumber)(\"cellTemplate\", ctx_r4.cellTemplate)(\"monthCellTemplate\", ctx_r4.monthCellTemplate)(\"yearCellTemplate\", ctx_r4.yearCellTemplate)(\"decadeCellTemplate\", ctx_r4.decadeCellTemplate)(\"centuryCellTemplate\", ctx_r4.centuryCellTemplate)(\"weekNumberTemplate\", ctx_r4.weekNumberTemplate)(\"headerTitleTemplate\", ctx_r4.headerTitleTemplate)(\"navigationItemTemplate\", ctx_r4.navigationItemTemplate)(\"focusedDate\", ctx_r4.focusedDate)(\"value\", ctx_r4.value)(\"kendoEventsOutsideAngular\", ɵngcc0.ɵɵpureFunction1(25, _c28, ctx_r4.handleKeydown))(\"scope\", ctx_r4)(\"disabledDates\", ctx_r4.disabledDates);\n    ɵngcc0.ɵɵadvance(2);\n    ɵngcc0.ɵɵproperty(\"today\", ctx_r4.localization.get(\"today\"))(\"prevButtonTitle\", ctx_r4.localization.get(\"prevButtonTitle\"))(\"nextButtonTitle\", ctx_r4.localization.get(\"nextButtonTitle\"));\n  }\n}\n\nconst _c29 = function (a0, a1) {\n  return {\n    click: a0,\n    mousedown: a1\n  };\n};\n\nconst _c44 = function (a0, a1) {\n  return {\n    keydown: a0,\n    mousedown: a1\n  };\n};\n\nfunction TimePickerComponent_ng_template_7_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r7 = ɵngcc0.ɵɵgetCurrentView();\n\n    ɵngcc0.ɵɵelementStart(0, \"kendo-timeselector\", 9, 10);\n    ɵngcc0.ɵɵlistener(\"valueChange\", function TimePickerComponent_ng_template_7_Template_kendo_timeselector_valueChange_0_listener($event) {\n      ɵngcc0.ɵɵrestoreView(_r7);\n      const ctx_r6 = ɵngcc0.ɵɵnextContext();\n      return ctx_r6.handleChange($event);\n    })(\"valueReject\", function TimePickerComponent_ng_template_7_Template_kendo_timeselector_valueReject_0_listener() {\n      ɵngcc0.ɵɵrestoreView(_r7);\n      const ctx_r8 = ɵngcc0.ɵɵnextContext();\n      return ctx_r8.handleReject();\n    });\n    ɵngcc0.ɵɵelement(2, \"kendo-timeselector-messages\", 11);\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r3 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵproperty(\"cancelButton\", ctx_r3.cancelButton)(\"nowButton\", ctx_r3.nowButton)(\"format\", ctx_r3.format)(\"min\", ctx_r3.min)(\"max\", ctx_r3.max)(\"steps\", ctx_r3.steps)(\"value\", ctx_r3.value)(\"kendoEventsOutsideAngular\", ɵngcc0.ɵɵpureFunction2(15, _c44, ctx_r3.handleKeydown, ctx_r3.handleMousedown))(\"scope\", ctx_r3);\n    ɵngcc0.ɵɵadvance(2);\n    ɵngcc0.ɵɵproperty(\"acceptLabel\", ctx_r3.localization.get(\"acceptLabel\"))(\"accept\", ctx_r3.localization.get(\"accept\"))(\"cancelLabel\", ctx_r3.localization.get(\"cancelLabel\"))(\"cancel\", ctx_r3.localization.get(\"cancel\"))(\"nowLabel\", ctx_r3.localization.get(\"nowLabel\"))(\"now\", ctx_r3.localization.get(\"now\"));\n  }\n}\n\nfunction DateTimePickerComponent_ng_template_9_button_16_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"button\", 25);\n    ɵngcc0.ɵɵtext(1);\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r5 = ɵngcc0.ɵɵnextContext(2);\n    ɵngcc0.ɵɵproperty(\"kendoEventsOutsideAngular\", ɵngcc0.ɵɵpureFunction1(5, _c3, ctx_r5.handleCancel))(\"scope\", ctx_r5);\n    ɵngcc0.ɵɵattribute(\"title\", ctx_r5.localization.get(\"cancelLabel\"))(\"aria-label\", ctx_r5.localization.get(\"cancelLabel\"));\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵtextInterpolate1(\" \", ctx_r5.localization.get(\"cancel\"), \" \");\n  }\n}\n\nconst _c73 = function (a0, a1) {\n  return {\n    mousedown: a0,\n    keydown: a1\n  };\n};\n\nconst _c74 = function (a0, a1) {\n  return {\n    focusin: a0,\n    focusout: a1\n  };\n};\n\nconst _c75 = function (a0, a1) {\n  return {\n    click: a0,\n    keydown: a1\n  };\n};\n\nconst _c76 = function (a0) {\n  return {\n    transitionend: a0\n  };\n};\n\nconst _c77 = function (a0, a1, a2) {\n  return {\n    keydown: a0,\n    focusin: a1,\n    focusout: a2\n  };\n};\n\nfunction DateTimePickerComponent_ng_template_9_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r7 = ɵngcc0.ɵɵgetCurrentView();\n\n    ɵngcc0.ɵɵelementStart(0, \"div\", 9);\n    ɵngcc0.ɵɵelementStart(1, \"div\", 10);\n    ɵngcc0.ɵɵelementStart(2, \"div\", 11);\n    ɵngcc0.ɵɵelementStart(3, \"button\", 12);\n    ɵngcc0.ɵɵtext(4);\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵelementStart(5, \"button\", 13);\n    ɵngcc0.ɵɵtext(6);\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵelementStart(7, \"div\", 14, 15);\n    ɵngcc0.ɵɵelementStart(9, \"div\", 16);\n    ɵngcc0.ɵɵelementStart(10, \"kendo-calendar\", 17);\n    ɵngcc0.ɵɵlistener(\"valueChange\", function DateTimePickerComponent_ng_template_9_Template_kendo_calendar_valueChange_10_listener($event) {\n      ɵngcc0.ɵɵrestoreView(_r7);\n      const ctx_r6 = ɵngcc0.ɵɵnextContext();\n      return ctx_r6.calendarValue = $event;\n    })(\"valueChange\", function DateTimePickerComponent_ng_template_9_Template_kendo_calendar_valueChange_10_listener() {\n      ɵngcc0.ɵɵrestoreView(_r7);\n      const ctx_r8 = ɵngcc0.ɵɵnextContext();\n      return ctx_r8.handleCalendarValueChange();\n    });\n    ɵngcc0.ɵɵelement(11, \"kendo-calendar-messages\", 18);\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵelementStart(12, \"div\", 19);\n    ɵngcc0.ɵɵelementStart(13, \"kendo-timeselector\", 20);\n    ɵngcc0.ɵɵelement(14, \"kendo-timeselector-messages\", 21);\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵelementStart(15, \"div\", 22);\n    ɵngcc0.ɵɵtemplate(16, DateTimePickerComponent_ng_template_9_button_16_Template, 2, 7, \"button\", 23);\n    ɵngcc0.ɵɵelementStart(17, \"button\", 24);\n    ɵngcc0.ɵɵtext(18);\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const _r4 = ɵngcc0.ɵɵreference(8);\n\n    const ctx_r3 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵclassMapInterpolate1(\"k-datetime-wrap k-\", ctx_r3.activeTab, \"-tab\");\n    ɵngcc0.ɵɵproperty(\"kendoEventsOutsideAngular\", ɵngcc0.ɵɵpureFunction2(62, _c73, ctx_r3.preventMouseDown, ctx_r3.handleKeyDown))(\"scope\", ctx_r3);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"kendoEventsOutsideAngular\", ɵngcc0.ɵɵpureFunction2(65, _c74, ctx_r3.handleFocus, ctx_r3.handleBlur))(\"scope\", ctx_r3);\n    ɵngcc0.ɵɵadvance(2);\n    ɵngcc0.ɵɵclassProp(\"k-state-active\", ctx_r3.activeTab === \"date\");\n    ɵngcc0.ɵɵproperty(\"kendoEventsOutsideAngular\", ɵngcc0.ɵɵpureFunction2(68, _c75, ctx_r3.changeActiveTab.bind(ctx_r3, \"date\"), ctx_r3.handleBackTabOut))(\"scope\", ctx_r3);\n    ɵngcc0.ɵɵattribute(\"title\", ctx_r3.localization.get(\"dateTabLabel\"))(\"aria-label\", ctx_r3.localization.get(\"dateTabLabel\"));\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵtextInterpolate1(\" \", ctx_r3.localization.get(\"dateTab\"), \" \");\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵclassProp(\"k-state-active\", ctx_r3.activeTab === \"time\");\n    ɵngcc0.ɵɵproperty(\"kendoEventsOutsideAngular\", ɵngcc0.ɵɵpureFunction1(71, _c3, ctx_r3.changeActiveTab.bind(ctx_r3, \"time\")));\n    ɵngcc0.ɵɵattribute(\"title\", ctx_r3.localization.get(\"timeTabLabel\"))(\"aria-label\", ctx_r3.localization.get(\"timeTabLabel\"));\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵtextInterpolate1(\" \", ctx_r3.localization.get(\"timeTab\"), \" \");\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵstyleProp(\"transition\", ctx_r3.tabSwitchTransition);\n    ɵngcc0.ɵɵproperty(\"kendoEventsOutsideAngular\", ɵngcc0.ɵɵpureFunction1(73, _c76, ctx_r3.handleTabChangeTransitionEnd.bind(ctx_r3, _r4)));\n    ɵngcc0.ɵɵadvance(3);\n    ɵngcc0.ɵɵproperty(\"value\", ctx_r3.calendarValue)(\"type\", ctx_r3.calendarType)(\"min\", ctx_r3.calendarMin)(\"max\", ctx_r3.calendarMax)(\"focusedDate\", ctx_r3.focusedDate)(\"weekNumber\", ctx_r3.weekNumber)(\"navigation\", false)(\"animateNavigation\", ctx_r3.animateCalendarNavigation)(\"cellTemplate\", ctx_r3.cellTemplate)(\"monthCellTemplate\", ctx_r3.monthCellTemplate)(\"yearCellTemplate\", ctx_r3.yearCellTemplate)(\"decadeCellTemplate\", ctx_r3.decadeCellTemplate)(\"centuryCellTemplate\", ctx_r3.centuryCellTemplate)(\"weekNumberTemplate\", ctx_r3.weekNumberTemplate)(\"headerTitleTemplate\", ctx_r3.headerTitleTemplate)(\"disabled\", ctx_r3.disableCalendar)(\"disabledDates\", ctx_r3.disabledDates);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"today\", ctx_r3.localization.get(\"today\"))(\"prevButtonTitle\", ctx_r3.localization.get(\"prevButtonTitle\"))(\"nextButtonTitle\", ctx_r3.localization.get(\"nextButtonTitle\"));\n    ɵngcc0.ɵɵadvance(2);\n    ɵngcc0.ɵɵproperty(\"value\", ctx_r3.value)(\"format\", ctx_r3.timeSelectorFormat)(\"min\", ctx_r3.timeSelectorMin)(\"max\", ctx_r3.timeSelectorMax)(\"setButton\", false)(\"cancelButton\", false)(\"steps\", ctx_r3.steps)(\"disabled\", ctx_r3.disableTimeSelector);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"now\", ctx_r3.localization.get(\"now\"))(\"nowLabel\", ctx_r3.localization.get(\"nowLabel\"));\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"kendoEventsOutsideAngular\", ɵngcc0.ɵɵpureFunction3(75, _c77, ctx_r3.handleTabOut, ctx_r3.handleFocus, ctx_r3.handleBlur))(\"scope\", ctx_r3);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngIf\", ctx_r3.cancelButton);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"disabled\", !ctx_r3.calendarValue)(\"kendoEventsOutsideAngular\", ɵngcc0.ɵɵpureFunction1(79, _c3, ctx_r3.handleAccept))(\"scope\", ctx_r3);\n    ɵngcc0.ɵɵattribute(\"title\", ctx_r3.localization.get(\"acceptLabel\"))(\"aria-label\", ctx_r3.localization.get(\"acceptLabel\"));\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵtextInterpolate1(\" \", ctx_r3.localization.get(\"accept\"), \" \");\n  }\n}\n\nconst _c78 = function (a0, a1) {\n  return {\n    mousedown: a0,\n    click: a1\n  };\n};\n\nfunction HorizontalViewListComponent_ng_template_0_caption_1_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"caption\", 7);\n    ɵngcc0.ɵɵtext(1);\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const date_r5 = ɵngcc0.ɵɵnextContext().date;\n    const ctx_r7 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵproperty(\"ngClass\", ctx_r7.getCaptionClass());\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵtextInterpolate(ctx_r7.getCaptionTitle(date_r5));\n  }\n}\n\nfunction HorizontalViewListComponent_ng_template_0_thead_2_th_2_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"th\", 11);\n    ɵngcc0.ɵɵtext(1);\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const name_r11 = ctx.$implicit;\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵtextInterpolate(name_r11);\n  }\n}\n\nfunction HorizontalViewListComponent_ng_template_0_thead_2_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"thead\", 8);\n    ɵngcc0.ɵɵelementStart(1, \"tr\", 9);\n    ɵngcc0.ɵɵtemplate(2, HorizontalViewListComponent_ng_template_0_thead_2_th_2_Template, 2, 1, \"th\", 10);\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r8 = ɵngcc0.ɵɵnextContext(2);\n    ɵngcc0.ɵɵadvance(2);\n    ɵngcc0.ɵɵproperty(\"ngForOf\", ctx_r8.weekNames);\n  }\n}\n\nfunction HorizontalViewListComponent_ng_template_0_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r13 = ɵngcc0.ɵɵgetCurrentView();\n\n    ɵngcc0.ɵɵelementStart(0, \"table\", 3);\n    ɵngcc0.ɵɵtemplate(1, HorizontalViewListComponent_ng_template_0_caption_1_Template, 2, 2, \"caption\", 4);\n    ɵngcc0.ɵɵtemplate(2, HorizontalViewListComponent_ng_template_0_thead_2_Template, 3, 1, \"thead\", 5);\n    ɵngcc0.ɵɵelementStart(3, \"tbody\", 6);\n    ɵngcc0.ɵɵlistener(\"cellClick\", function HorizontalViewListComponent_ng_template_0_Template_tbody_cellClick_3_listener($event) {\n      ɵngcc0.ɵɵrestoreView(_r13);\n      const ctx_r12 = ɵngcc0.ɵɵnextContext();\n      return ctx_r12.cellClick.emit($event);\n    })(\"weekNumberCellClick\", function HorizontalViewListComponent_ng_template_0_Template_tbody_weekNumberCellClick_3_listener($event) {\n      ɵngcc0.ɵɵrestoreView(_r13);\n      const ctx_r14 = ɵngcc0.ɵɵnextContext();\n      return ctx_r14.weekNumberCellClick.emit($event);\n    })(\"cellEnter\", function HorizontalViewListComponent_ng_template_0_Template_tbody_cellEnter_3_listener($event) {\n      ɵngcc0.ɵɵrestoreView(_r13);\n      const ctx_r15 = ɵngcc0.ɵɵnextContext();\n      return ctx_r15.cellEnter.emit($event);\n    })(\"cellLeave\", function HorizontalViewListComponent_ng_template_0_Template_tbody_cellLeave_3_listener($event) {\n      ɵngcc0.ɵɵrestoreView(_r13);\n      const ctx_r16 = ɵngcc0.ɵɵnextContext();\n      return ctx_r16.cellLeave.emit($event);\n    });\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const date_r5 = ctx.date;\n    const class_r6 = ctx.className;\n    const ctx_r1 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵproperty(\"ngClass\", class_r6);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngIf\", ctx_r1.showViewHeader);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngIf\", ctx_r1.isMonthView());\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"activeView\", ctx_r1.activeView)(\"isActive\", ctx_r1.isActive)(\"min\", ctx_r1.min)(\"max\", ctx_r1.max)(\"cellUID\", ctx_r1.cellUID)(\"focusedDate\", ctx_r1.focusedDate)(\"selectedDates\", ctx_r1.selectedDates)(\"selectionRange\", ctx_r1.selectionRange)(\"activeRangeEnd\", ctx_r1.activeRangeEnd)(\"weekNumber\", ctx_r1.weekNumber)(\"templateRef\", ctx_r1.cellTemplateRef)(\"weekNumberTemplateRef\", ctx_r1.weekNumberTemplateRef)(\"viewDate\", date_r5);\n  }\n}\n\nfunction HorizontalViewListComponent_2_ng_template_0_Template(rf, ctx) {}\n\nconst _c79 = function (a0) {\n  return {\n    date: a0,\n    className: \"k-pointer-events-none\"\n  };\n};\n\nfunction HorizontalViewListComponent_2_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵtemplate(0, HorizontalViewListComponent_2_ng_template_0_Template, 0, 0, \"ng-template\", 12);\n  }\n\n  if (rf & 2) {\n    const ctx_r2 = ɵngcc0.ɵɵnextContext();\n\n    const _r0 = ɵngcc0.ɵɵreference(1);\n\n    ɵngcc0.ɵɵproperty(\"ngTemplateOutlet\", _r0)(\"ngTemplateOutletContext\", ɵngcc0.ɵɵpureFunction1(2, _c79, ctx_r2.nextAnimationDate));\n  }\n}\n\nfunction HorizontalViewListComponent_3_ng_template_0_Template(rf, ctx) {}\n\nconst _c80 = function (a0) {\n  return {\n    date: a0\n  };\n};\n\nfunction HorizontalViewListComponent_3_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵtemplate(0, HorizontalViewListComponent_3_ng_template_0_Template, 0, 0, \"ng-template\", 12);\n  }\n\n  if (rf & 2) {\n    const date_r18 = ctx.$implicit;\n    ɵngcc0.ɵɵnextContext();\n\n    const _r0 = ɵngcc0.ɵɵreference(1);\n\n    ɵngcc0.ɵɵproperty(\"ngTemplateOutlet\", _r0)(\"ngTemplateOutletContext\", ɵngcc0.ɵɵpureFunction1(2, _c80, date_r18));\n  }\n}\n\nfunction HorizontalViewListComponent_4_ng_template_0_Template(rf, ctx) {}\n\nfunction HorizontalViewListComponent_4_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵtemplate(0, HorizontalViewListComponent_4_ng_template_0_Template, 0, 0, \"ng-template\", 12);\n  }\n\n  if (rf & 2) {\n    const ctx_r4 = ɵngcc0.ɵɵnextContext();\n\n    const _r0 = ɵngcc0.ɵɵreference(1);\n\n    ɵngcc0.ɵɵproperty(\"ngTemplateOutlet\", _r0)(\"ngTemplateOutletContext\", ɵngcc0.ɵɵpureFunction1(2, _c79, ctx_r4.prevAnimationDate));\n  }\n}\n\nconst _c87 = [\"defaultTemplate\"];\n\nfunction DateRangePopupComponent_ng_template_2_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelement(0, \"kendo-multiviewcalendar\", 2);\n  }\n}\n\nfunction DateRangeComponent_kendo_daterange_popup_1_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelement(0, \"kendo-daterange-popup\");\n  }\n}\n\nfunction HeaderComponent_ng_template_1_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵtext(0);\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵtextInterpolate(ctx_r0.title);\n  }\n}\n\nfunction HeaderComponent_ng_template_2_Template(rf, ctx) {}\n\nfunction HeaderComponent_button_5_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r5 = ɵngcc0.ɵɵgetCurrentView();\n\n    ɵngcc0.ɵɵelementStart(0, \"button\", 8);\n    ɵngcc0.ɵɵlistener(\"click\", function HeaderComponent_button_5_Template_button_click_0_listener() {\n      ɵngcc0.ɵɵrestoreView(_r5);\n      const ctx_r4 = ɵngcc0.ɵɵnextContext();\n      return ctx_r4.prevButtonClick.emit();\n    });\n    ɵngcc0.ɵɵelement(1, \"span\", 9);\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r2 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵproperty(\"disabled\", ctx_r2.isPrevDisabled)(\"title\", ctx_r2.prevButtonTitle);\n    ɵngcc0.ɵɵattribute(\"aria-disabled\", ctx_r2.isPrevDisabled);\n  }\n}\n\nfunction HeaderComponent_button_8_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r7 = ɵngcc0.ɵɵgetCurrentView();\n\n    ɵngcc0.ɵɵelementStart(0, \"button\", 10);\n    ɵngcc0.ɵɵlistener(\"click\", function HeaderComponent_button_8_Template_button_click_0_listener() {\n      ɵngcc0.ɵɵrestoreView(_r7);\n      const ctx_r6 = ɵngcc0.ɵɵnextContext();\n      return ctx_r6.nextButtonClick.emit();\n    });\n    ɵngcc0.ɵɵelement(1, \"span\", 11);\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r3 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵproperty(\"disabled\", ctx_r3.isNextDisabled)(\"title\", ctx_r3.nextButtonTitle);\n    ɵngcc0.ɵɵattribute(\"aria-disabled\", ctx_r3.isNextDisabled);\n  }\n}\n\nconst _c88 = [\"kendoCalendarView\", \"\"];\n\nfunction ViewComponent_ng_template_0_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"td\", 3);\n    ɵngcc0.ɵɵtext(1, \"\\u00A0\");\n    ɵngcc0.ɵɵelementEnd();\n  }\n}\n\nfunction ViewComponent_tr_2_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"tr\", 4);\n    ɵngcc0.ɵɵelementStart(1, \"th\", 5);\n    ɵngcc0.ɵɵtext(2);\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r2 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"colSpan\", ctx_r2.colSpan);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵtextInterpolate(ctx_r2.title);\n  }\n}\n\nfunction ViewComponent_tr_3_ng_template_1_td_0_ng_template_1_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵtext(0);\n  }\n\n  if (rf & 2) {\n    const row_r4 = ɵngcc0.ɵɵnextContext(3).$implicit;\n    const ctx_r9 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵtextInterpolate1(\" \", ctx_r9.getWeekNumber(ctx_r9.firstDate(row_r4)), \" \");\n  }\n}\n\nfunction ViewComponent_tr_3_ng_template_1_td_0_ng_template_2_Template(rf, ctx) {}\n\nconst _c89 = function (a0, a1) {\n  return {\n    $implicit: a0,\n    cellContext: a1\n  };\n};\n\nfunction ViewComponent_tr_3_ng_template_1_td_0_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"td\", 9);\n    ɵngcc0.ɵɵtemplate(1, ViewComponent_tr_3_ng_template_1_td_0_ng_template_1_Template, 1, 1, \"ng-template\", 6);\n    ɵngcc0.ɵɵtemplate(2, ViewComponent_tr_3_ng_template_1_td_0_ng_template_2_Template, 0, 0, \"ng-template\", 10);\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const row_r4 = ɵngcc0.ɵɵnextContext(2).$implicit;\n    const ctx_r8 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵproperty(\"kendoEventsOutsideAngular\", ɵngcc0.ɵɵpureFunction1(5, _c3, ctx_r8.handleWeekNumberClick.bind(ctx_r8, row_r4)));\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngIf\", !ctx_r8.weekNumberTemplateRef);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngIf\", ctx_r8.weekNumberTemplateRef)(\"ngTemplateOutlet\", ctx_r8.weekNumberTemplateRef)(\"ngTemplateOutletContext\", ɵngcc0.ɵɵpureFunction2(7, _c89, ctx_r8.firstDate(row_r4), ctx_r8.getWeekNumberContext(row_r4)));\n  }\n}\n\nfunction ViewComponent_tr_3_ng_template_1_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵtemplate(0, ViewComponent_tr_3_ng_template_1_td_0_Template, 3, 10, \"td\", 8);\n  }\n\n  if (rf & 2) {\n    const row_r4 = ɵngcc0.ɵɵnextContext().$implicit;\n    const ctx_r6 = ɵngcc0.ɵɵnextContext();\n\n    const _r0 = ɵngcc0.ɵɵreference(1);\n\n    ɵngcc0.ɵɵproperty(\"ngIf\", ctx_r6.firstDate(row_r4))(\"ngIfElse\", _r0);\n  }\n}\n\nfunction ViewComponent_tr_3_ng_container_2_td_1_ng_template_2_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵtext(0);\n  }\n\n  if (rf & 2) {\n    const cell_r14 = ɵngcc0.ɵɵnextContext(2).$implicit;\n    ɵngcc0.ɵɵtextInterpolate(cell_r14.formattedValue);\n  }\n}\n\nfunction ViewComponent_tr_3_ng_container_2_td_1_3_ng_template_0_Template(rf, ctx) {}\n\nfunction ViewComponent_tr_3_ng_container_2_td_1_3_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵtemplate(0, ViewComponent_tr_3_ng_container_2_td_1_3_ng_template_0_Template, 0, 0, \"ng-template\", 15);\n  }\n\n  if (rf & 2) {\n    const cell_r14 = ɵngcc0.ɵɵnextContext(2).$implicit;\n    const ctx_r18 = ɵngcc0.ɵɵnextContext(2);\n    ɵngcc0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r18.templateRef)(\"ngTemplateOutletContext\", ɵngcc0.ɵɵpureFunction2(2, _c89, cell_r14.value, cell_r14));\n  }\n}\n\nfunction ViewComponent_tr_3_ng_container_2_td_1_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"td\", 12);\n    ɵngcc0.ɵɵelementStart(1, \"span\", 13);\n    ɵngcc0.ɵɵtemplate(2, ViewComponent_tr_3_ng_container_2_td_1_ng_template_2_Template, 1, 1, \"ng-template\", 6);\n    ɵngcc0.ɵɵtemplate(3, ViewComponent_tr_3_ng_container_2_td_1_3_Template, 1, 5, undefined, 14);\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r22 = ɵngcc0.ɵɵnextContext();\n    const cell_r14 = ctx_r22.$implicit;\n    const cellIndex_r15 = ctx_r22.index;\n    const rowIndex_r5 = ɵngcc0.ɵɵnextContext().index;\n    const ctx_r16 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵproperty(\"ngClass\", ctx_r16.getStyles(cell_r14))(\"title\", cell_r14.title);\n    ɵngcc0.ɵɵattribute(\"id\", cell_r14.id)(\"data-cell-index\", ctx_r16.tableCellIndex(rowIndex_r5, cellIndex_r15))(\"aria-selected\", cell_r14.isSelected || cell_r14.isRangeStart || cell_r14.isRangeMid || cell_r14.isRangeEnd)(\"aria-disabled\", cell_r14.isDisabled);\n    ɵngcc0.ɵɵadvance(2);\n    ɵngcc0.ɵɵproperty(\"ngIf\", !ctx_r16.templateRef);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngIf\", ctx_r16.templateRef);\n  }\n}\n\nfunction ViewComponent_tr_3_ng_container_2_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementContainerStart(0);\n    ɵngcc0.ɵɵtemplate(1, ViewComponent_tr_3_ng_container_2_td_1_Template, 4, 8, \"td\", 11);\n    ɵngcc0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const cell_r14 = ctx.$implicit;\n    const ctx_r7 = ɵngcc0.ɵɵnextContext(2);\n\n    const _r0 = ɵngcc0.ɵɵreference(1);\n\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngIf\", ctx_r7.shouldRenderCellContent(cell_r14))(\"ngIfElse\", _r0);\n  }\n}\n\nfunction ViewComponent_tr_3_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"tr\", 4);\n    ɵngcc0.ɵɵtemplate(1, ViewComponent_tr_3_ng_template_1_Template, 1, 2, \"ng-template\", 6);\n    ɵngcc0.ɵɵtemplate(2, ViewComponent_tr_3_ng_container_2_Template, 2, 2, \"ng-container\", 7);\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const row_r4 = ctx.$implicit;\n    const ctx_r3 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngIf\", ctx_r3.weekNumber);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"kForOf\", row_r4);\n  }\n}\n\nfunction TimeListComponent_li_2_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"li\", 3);\n    ɵngcc0.ɵɵelementStart(1, \"span\");\n    ɵngcc0.ɵɵtext(2);\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const item_r1 = ctx.$implicit;\n    const index_r2 = ctx.index;\n    ɵngcc0.ɵɵattribute(\"data-timelist-item-index\", index_r2);\n    ɵngcc0.ɵɵadvance(2);\n    ɵngcc0.ɵɵtextInterpolate(item_r1.text);\n  }\n}\n\nconst _c90 = [\"accept\"];\nconst _c91 = [\"cancel\"];\nconst _c92 = [\"now\"];\nconst _c93 = [\"listWrapper\"];\n\nconst _c106 = function (a0, a1, a2) {\n  return {\n    click: a0,\n    focus: a1,\n    blur: a2\n  };\n};\n\nfunction TimeSelectorComponent_button_4_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"button\", 8, 9);\n    ɵngcc0.ɵɵtext(2);\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵproperty(\"kendoEventsOutsideAngular\", ɵngcc0.ɵɵpureFunction3(6, _c106, ctx_r0.handleNow, ctx_r0.handleFocus, ctx_r0.handleBlur))(\"scope\", ctx_r0)(\"disabled\", ctx_r0.disabled);\n    ɵngcc0.ɵɵattribute(\"title\", ctx_r0.localization.get(\"nowLabel\"))(\"aria-label\", ctx_r0.localization.get(\"nowLabel\"));\n    ɵngcc0.ɵɵadvance(2);\n    ɵngcc0.ɵɵtextInterpolate(ctx_r0.localization.get(\"now\"));\n  }\n}\n\nconst _c107 = function (a0, a1) {\n  return {\n    focus: a0,\n    blur: a1\n  };\n};\n\nfunction TimeSelectorComponent_ng_template_7_div_0_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r10 = ɵngcc0.ɵɵgetCurrentView();\n\n    ɵngcc0.ɵɵelementStart(0, \"div\", 12, 13);\n    ɵngcc0.ɵɵelementStart(2, \"span\", 2);\n    ɵngcc0.ɵɵtext(3);\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵelementStart(4, \"kendo-timelist\", 14);\n    ɵngcc0.ɵɵlistener(\"valueChange\", function TimeSelectorComponent_ng_template_7_div_0_Template_kendo_timelist_valueChange_4_listener($event) {\n      ɵngcc0.ɵɵrestoreView(_r10);\n      const ctx_r9 = ɵngcc0.ɵɵnextContext(2);\n      return ctx_r9.current = $event;\n    });\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r11 = ɵngcc0.ɵɵnextContext();\n    const part_r4 = ctx_r11.$implicit;\n    const idx_r5 = ctx_r11.index;\n    const ctx_r6 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵadvance(3);\n    ɵngcc0.ɵɵtextInterpolate(ctx_r6.intl.dateFieldName(part_r4));\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"min\", ctx_r6.min)(\"max\", ctx_r6.max)(\"part\", part_r4)(\"step\", ctx_r6.partStep(part_r4))(\"disabled\", ctx_r6.disabled)(\"value\", ctx_r6.current)(\"kendoEventsOutsideAngular\", ɵngcc0.ɵɵpureFunction2(10, _c107, ctx_r6.handleListFocus, ctx_r6.handleBlur))(\"scope\", ctx_r6);\n    ɵngcc0.ɵɵattribute(\"data-timelist-index\", idx_r5);\n  }\n}\n\nfunction TimeSelectorComponent_ng_template_7_div_1_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"div\", 15);\n    ɵngcc0.ɵɵtext(1);\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const part_r4 = ɵngcc0.ɵɵnextContext().$implicit;\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵtextInterpolate1(\" \", part_r4.pattern, \" \");\n  }\n}\n\nfunction TimeSelectorComponent_ng_template_7_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵtemplate(0, TimeSelectorComponent_ng_template_7_div_0_Template, 5, 13, \"div\", 10);\n    ɵngcc0.ɵɵtemplate(1, TimeSelectorComponent_ng_template_7_div_1_Template, 2, 1, \"div\", 11);\n  }\n\n  if (rf & 2) {\n    const part_r4 = ctx.$implicit;\n    ɵngcc0.ɵɵproperty(\"ngIf\", part_r4.type !== \"literal\");\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngIf\", part_r4.type === \"literal\");\n  }\n}\n\nfunction TimeSelectorComponent_div_8_button_1_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"button\", 19, 20);\n    ɵngcc0.ɵɵtext(2);\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r13 = ɵngcc0.ɵɵnextContext(2);\n    ɵngcc0.ɵɵproperty(\"kendoEventsOutsideAngular\", ɵngcc0.ɵɵpureFunction3(6, _c106, ctx_r13.handleReject, ctx_r13.handleFocus, ctx_r13.handleBlur))(\"scope\", ctx_r13)(\"disabled\", ctx_r13.disabled);\n    ɵngcc0.ɵɵattribute(\"title\", ctx_r13.localization.get(\"cancelLabel\"))(\"aria-label\", ctx_r13.localization.get(\"cancelLabel\"));\n    ɵngcc0.ɵɵadvance(2);\n    ɵngcc0.ɵɵtextInterpolate(ctx_r13.localization.get(\"cancel\"));\n  }\n}\n\nfunction TimeSelectorComponent_div_8_button_2_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"button\", 21, 22);\n    ɵngcc0.ɵɵtext(2);\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r14 = ɵngcc0.ɵɵnextContext(2);\n    ɵngcc0.ɵɵproperty(\"kendoEventsOutsideAngular\", ɵngcc0.ɵɵpureFunction3(6, _c106, ctx_r14.handleAccept, ctx_r14.handleFocus, ctx_r14.handleBlur))(\"scope\", ctx_r14)(\"disabled\", ctx_r14.disabled);\n    ɵngcc0.ɵɵattribute(\"title\", ctx_r14.localization.get(\"acceptLabel\"))(\"aria-label\", ctx_r14.localization.get(\"acceptLabel\"));\n    ɵngcc0.ɵɵadvance(2);\n    ɵngcc0.ɵɵtextInterpolate(ctx_r14.localization.get(\"accept\"));\n  }\n}\n\nfunction TimeSelectorComponent_div_8_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"div\", 16);\n    ɵngcc0.ɵɵtemplate(1, TimeSelectorComponent_div_8_button_1_Template, 3, 10, \"button\", 17);\n    ɵngcc0.ɵɵtemplate(2, TimeSelectorComponent_div_8_button_2_Template, 3, 10, \"button\", 18);\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r2 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngIf\", ctx_r2.cancelButton);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngIf\", ctx_r2.setButton);\n  }\n}\n\nconst packageMetadata = {\n  name: '@progress/kendo-angular-dateinputs',\n  productName: 'Kendo UI for Angular',\n  productCodes: ['KENDOUIANGULAR', 'KENDOUICOMPLETE'],\n  publishDate: 1631623618,\n  version: '',\n  licensingDocsUrl: 'https://www.telerik.com/kendo-angular-ui/my-license/?utm_medium=product&utm_source=kendoangular&utm_campaign=kendo-ui-angular-purchase-license-keys-warning'\n};\n/**\n * @hidden\n */\n\nvar Action = /*#__PURE__*/(() => {\n  (function (Action) {\n    Action[Action[\"Left\"] = 0] = \"Left\";\n    Action[Action[\"Right\"] = 1] = \"Right\";\n    Action[Action[\"Up\"] = 2] = \"Up\";\n    Action[Action[\"Down\"] = 3] = \"Down\";\n    Action[Action[\"PrevView\"] = 4] = \"PrevView\";\n    Action[Action[\"NextView\"] = 5] = \"NextView\";\n    Action[Action[\"FirstInView\"] = 6] = \"FirstInView\";\n    Action[Action[\"LastInView\"] = 7] = \"LastInView\";\n    Action[Action[\"LowerView\"] = 8] = \"LowerView\";\n    Action[Action[\"UpperView\"] = 9] = \"UpperView\";\n  })(Action || (Action = {}));\n\n  return Action;\n})();\n\n/**\n * @hidden\n */\nconst EMPTY_SELECTIONRANGE = {\n  start: null,\n  end: null\n};\n/**\n * @hidden\n */\n\nconst MIDNIGHT_DATE = new Date(1980, 0, 1);\n/**\n * @hidden\n */\n\nconst MIN_DATE = new Date(1900, 0, 1);\n/**\n * @hidden\n */\n\nconst MAX_DATE = new Date(2099, 11, 31);\n/**\n * @hidden\n */\n\nconst MIN_TIME = new Date(1980, 0, 1);\n/**\n * @hidden\n */\n\nconst MAX_TIME = new Date(1980, 0, 1, 23, 59, 59);\n/**\n * @hidden\n */\n\nconst requiresZoneOnBlur = ngControl => ngControl && (!ngControl.touched || ngControl.control && ngControl.control.updateOn === 'blur');\n/**\n * @hidden\n */\n\n\nconst preventDefault = args => args.preventDefault();\n/**\n * @hidden\n */\n\n\nconst currentFocusTarget = blurArgs => blurArgs.relatedTarget || document.activeElement;\n/**\n * @hidden\n */\n\n\nconst isPresent = value => value !== undefined && value !== null;\n/**\n * @hidden\n *\n * If the provided parameter is an array with at least one item\n * and all items in the array are numbers, returns `true.\n */\n\n\nconst isNumberArray = value => Array.isArray(value) && value.length > 0 && value.every(item => typeof item === 'number');\n/**\n * @hidden\n *\n * If the provided parameter is an array with at least one item\n * and all items in the array are dates, returns `true`.\n */\n\n\nconst isDateArray = value => Array.isArray(value) && value.length > 0 && value.every(item => item instanceof Date);\n/* tslint:disable:no-bitwise max-line-length */\n\n\nconst isSet = value => value !== null && value !== undefined;\n\nconst setter = method => (date, value) => {\n  const clone = cloneDate(date);\n  clone[method](value);\n  return clone;\n};\n/**\n * @hidden\n */\n\n\nconst setTime = (origin, candidate) => {\n  const date = cloneDate(origin);\n  date.setHours(candidate.getHours(), candidate.getMinutes(), candidate.getSeconds(), candidate.getMilliseconds());\n  return date;\n};\n\nconst normalizeTimes = (candidate, min, max) => ({\n  candidateValue: setTime(MIDNIGHT_DATE, candidate),\n  maxValue: addDays(setTime(MIDNIGHT_DATE, max), min.getHours() < max.getHours() || min.getHours() === max.getHours() && min.getMinutes() < max.getMinutes() ? 0 : 1),\n  minValue: setTime(MIDNIGHT_DATE, min)\n});\n/**\n * @hidden\n */\n\n\nconst setYears = setter('setFullYear');\n/**\n * @hidden\n */\n\nconst setHours = setter('setHours');\n/**\n * @hidden\n */\n\nconst setMinutes = setter('setMinutes');\n/**\n * @hidden\n */\n\nconst setSeconds = setter('setSeconds');\n/**\n * @hidden\n */\n\nconst setMilliseconds = setter('setMilliseconds');\n/**\n * @hidden\n */\n\nconst range = (start, end, step = 1) => {\n  const result = [];\n\n  for (let i = start; i < end; i = i + step) {\n    result.push(i);\n  }\n\n  return result;\n};\n/**\n * @hidden\n */\n\n\nconst isInRange = (candidate, min, max) => !candidate || !(min && min > candidate || max && max < candidate);\n/**\n * @hidden\n */\n\n\nconst isInTimeRange = (candidate, min, max) => {\n  if (!candidate || !min || !max) {\n    return true;\n  }\n\n  const {\n    candidateValue,\n    minValue,\n    maxValue\n  } = normalizeTimes(candidate, min, max);\n  return minValue <= candidateValue && candidateValue <= maxValue;\n};\n/**\n * @hidden\n */\n\n\nconst isValidRange = (min, max) => !isSet(min) || !isSet(max) || min <= max;\n/**\n * @hidden\n */\n\n\nconst dateInRange = (candidate, min, max) => {\n  if (!candidate) {\n    return candidate;\n  }\n\n  if (min && candidate < min) {\n    return cloneDate(min);\n  }\n\n  if (max && candidate > max) {\n    return cloneDate(max);\n  }\n\n  return candidate;\n};\n/**\n * @hidden\n */\n\n\nconst timeInRange = (candidate, min, max) => {\n  if (!candidate || !min || !max) {\n    return candidate;\n  }\n\n  const {\n    candidateValue,\n    minValue,\n    maxValue\n  } = normalizeTimes(candidate, min, max);\n\n  if (candidateValue < minValue) {\n    return setTime(candidate, min);\n  }\n\n  if (candidateValue > maxValue) {\n    return setTime(candidate, max);\n  }\n\n  return candidate;\n};\n/**\n * @hidden\n */\n\n\nconst getNow = () => new Date();\n/**\n * @hidden\n */\n\n\nconst getToday = () => getDate(new Date());\n/**\n * @hidden\n */\n\n\nconst noop = _ => {}; // tslint:disable-line:no-empty\n\n/**\n * @hidden\n */\n\n\nconst isWindowAvailable = () => {\n  return typeof window !== 'undefined';\n};\n/**\n * @hidden\n */\n\n\nconst stringifyClassObject = classes => {\n  const pushToAcc = (acc, cls) => classes[cls] ? acc.concat(cls) : acc;\n\n  return Object.keys(classes).reduce(pushToAcc, []).join(' ');\n};\n/**\n * @hidden\n */\n\n\nconst shiftWeekNames = (names, offset) => names.slice(offset).concat(names.slice(0, offset));\n/**\n * @hidden\n */\n\n\nconst approximateStringMatching = (oldTextOrigin, oldFormat, newTextOrigin, caret) => {\n  // Remove the right part of the cursor.\n  //oldFormat = oldFormat.substring(0, caret + oldText.length - newText.length);\n  const oldIndex = caret + oldTextOrigin.length - newTextOrigin.length;\n  const oldTextSeparator = oldTextOrigin[oldIndex];\n  const oldText = oldTextOrigin.substring(0, caret + oldTextOrigin.length - newTextOrigin.length);\n  const newText = newTextOrigin.substring(0, caret);\n  const diff = []; // Handle typing a single character over the same selection.\n\n  if (oldText === newText && caret > 0) {\n    diff.push([oldFormat[caret - 1], newText[caret - 1]]);\n    return diff;\n  }\n\n  if (oldText.indexOf(newText) === 0 && (newText.length === 0 || oldFormat[newText.length - 1] !== oldFormat[newText.length])) {\n    // Handle Delete/Backspace.\n    let deletedSymbol = \"\"; //XXX:\n    // Whole text is replaced with a same char\n    // Nasty patch required to keep the selection in the first segment\n\n    if (newText.length === 1) {\n      diff.push([oldFormat[0], newText[0]]);\n    }\n\n    for (let i = newText.length; i < oldText.length; i++) {\n      if (oldFormat[i] !== deletedSymbol && oldFormat[i] !== \"_\") {\n        deletedSymbol = oldFormat[i];\n        diff.push([deletedSymbol, \"\"]);\n      }\n    }\n\n    return diff;\n  } // Handle inserting text (the new text is longer than the previous one).\n  // Handle typing over a literal as well.\n\n\n  if (newText.indexOf(oldText) === 0 || oldFormat[caret - 1] === \"_\") {\n    let symbol = oldFormat[0];\n\n    for (let i = Math.max(0, oldText.length - 1); i < oldFormat.length; i++) {\n      if (oldFormat[i] !== \"_\") {\n        symbol = oldFormat[i];\n        break;\n      }\n    }\n\n    return [[symbol, newText[caret - 1]]];\n  } // Handle entering a space or a separator, for navigation to the next item.\n\n\n  if (newText[newText.length - 1] === \" \" || newText[newText.length - 1] === oldTextSeparator && oldFormat[oldIndex] === '_') {\n    return [[oldFormat[caret - 1], \"_\"]];\n  } // Handle typing over a correctly selected part.\n\n\n  return [[oldFormat[caret - 1], newText[caret - 1]]];\n};\n/**\n * @hidden\n */\n\n\nconst domContainerFactory = type => (children, classes = \"\", styles = {}) => {\n  const container = document.createElement(type);\n  container.className = classes;\n  Object.keys(styles).map(key => container.style[key] = styles[key]);\n\n  if (typeof children === 'string') {\n    container.innerHTML = children || '';\n  } else {\n    (children || []).forEach(child => child && container.appendChild(child));\n  }\n\n  return container;\n};\n/**\n * @hidden\n */\n\n\nconst hasChange = (changes, field) => changes[field] !== undefined;\n/**\n * @hidden\n */\n\n\nconst hasExistingValue = (changes, field) => changes[field] && changes[field].currentValue !== undefined && changes[field].currentValue !== null;\n/**\n * @hidden\n */\n\n\nconst last = (list = []) => list && list[list.length - 1];\n/**\n * @hidden\n */\n\n\nconst isInSelectionRange = (value, selectionRange) => {\n  const {\n    start,\n    end\n  } = selectionRange || EMPTY_SELECTIONRANGE;\n\n  if (!start || !end) {\n    return false;\n  }\n\n  return start < value && value < end;\n};\n/**\n * @hidden\n */\n\n\nconst either = (value1, value2) => value1 || value2;\n/**\n * @hidden\n */\n\n\nconst clampRange = value => ({\n  start: value,\n  end: value\n});\n/**\n * @hidden\n */\n\n\nconst isEqualRange = (initial, updated) => {\n  const {\n    start: initialStart,\n    end: initialEnd\n  } = initial || EMPTY_SELECTIONRANGE;\n  const {\n    start: updatedStart,\n    end: updatedEnd\n  } = updated || EMPTY_SELECTIONRANGE;\n  return isEqual(initialStart, updatedStart) && isEqual(initialEnd, updatedEnd);\n};\n/**\n * @hidden\n */\n\n\nconst areDatesEqual = (first, second) => {\n  first = first || [];\n  second = second || [];\n  return first.length === second.length && first.every((date, index) => isEqual(date, second[index]));\n};\n/**\n * @hidden\n */\n\n\nconst sortDates = dates => {\n  return dates.filter(date => isPresent(date)).sort((a, b) => a.getTime() - b.getTime());\n};\n/**\n * @hidden\n *\n * Creates a new date based on the date information from the specified date portion\n * and the time information from the time portion.\n * If a parameter is not provided, returns `null`.\n */\n\n\nconst mergeDateAndTime = (date, time) => {\n  if (!(date && time)) {\n    return null;\n  }\n\n  return new Date(date.getFullYear(), date.getMonth(), date.getDate(), time.getHours(), time.getMinutes(), time.getSeconds(), time.getMilliseconds());\n};\n/**\n * @hidden\n */\n\n\nconst lastMillisecondOfDate = date => {\n  if (!date) {\n    return null;\n  }\n\n  return new Date(date.getFullYear(), date.getMonth(), date.getDate(), 23, 59, 59, 999);\n};\n/**\n * @hidden\n *\n * Returns an array with dates ranging between and including the specified start and\n * end dates that are evaluated as disabled.\n */\n\n\nconst disabledDatesInRange = (start, end, isDateDisabled) => {\n  if (!(start && end && isDateDisabled) || start > end) {\n    return [];\n  }\n\n  const dates = [];\n  let current = start;\n\n  while (current <= end) {\n    if (isDateDisabled(current)) {\n      dates.push(current);\n    }\n\n    current = addDays(current, 1);\n  }\n\n  return dates;\n};\n/**\n * @hidden\n *\n * Crops the last two digits from the year of the provided date value.\n */\n\n\nconst cropTwoDigitYear = date => {\n  if (!isPresent(date) || isNaN(date.getTime())) {\n    return 0;\n  }\n\n  return Number(date.getFullYear().toString().slice(-2));\n};\n/**\n * @hidden\n *\n * Used when resetting millisecond segment value in the DateInput\n */\n\n\nconst msPaddingFromFormat = format => {\n  return Array(format.match(/S+(\\1)/)[0].length).join(\"0\");\n};\n/**\n * @hidden\n */\n\n\nconst millisecondDigitsInFormat = format => {\n  const result = format && format.match(/S+(\\1)/);\n  return result ? result[0].length : 0;\n};\n/**\n * @hidden\n */\n\n\nconst millisecondStepFor = digits => {\n  return Math.pow(10, 3 - digits);\n};\n\nconst EMPTY_DATA = [[]];\nconst CELLS_LENGTH = 4;\nconst ROWS_LENGTH = 3;\nconst ACTIONS = {\n  [Action.Left]: date => addDecades(date, -1),\n  [Action.Up]: date => addDecades(date, -5),\n  [Action.Right]: date => addDecades(date, 1),\n  [Action.Down]: date => addDecades(date, 5),\n  [Action.PrevView]: date => addCenturies(date, -1),\n  [Action.NextView]: date => addCenturies(date, 1),\n  [Action.FirstInView]: date => firstDecadeOfCentury(date),\n  [Action.LastInView]: date => lastDecadeOfCentury(date)\n};\n/**\n * @hidden\n */\n\nlet CenturyViewService = /*#__PURE__*/(() => {\n  let CenturyViewService = class CenturyViewService {\n    /**\n     * @hidden\n     */\n    constructor() {\n      this.dateRange = (start, end) => {\n        if (!isPresent(start) || !isPresent(end)) {\n          return [];\n        }\n\n        const result = [];\n        let current = start;\n\n        while (current <= end) {\n          result.push(current);\n          current = addDecades(current, 1);\n        }\n\n        return result;\n      };\n    }\n\n    addToDate(min, skip) {\n      return addCenturies(min, skip);\n    }\n\n    datesList(start, count) {\n      return range(0, count).map(i => addCenturies(start, i));\n    }\n\n    data(options) {\n      const {\n        cellUID,\n        focusedDate,\n        isActiveView,\n        max,\n        min,\n        selectedDates,\n        selectionRange = EMPTY_SELECTIONRANGE,\n        viewDate\n      } = options;\n\n      if (!viewDate) {\n        return EMPTY_DATA;\n      }\n\n      const cells = range(0, CELLS_LENGTH);\n      const firstDate = firstDecadeOfCentury(viewDate);\n      const lastDate = lastDecadeOfCentury(viewDate);\n      const today = getToday();\n      return range(0, ROWS_LENGTH).map(rowOffset => {\n        const baseDate = addDecades(firstDate, rowOffset * CELLS_LENGTH);\n        return cells.map(cellOffset => {\n          const cellDate = this.normalize(addDecades(baseDate, cellOffset), min, max);\n          const nextCentury = cellDate.getFullYear() > lastDate.getFullYear();\n\n          if (!this.isInRange(cellDate, min, max) || nextCentury) {\n            return null;\n          }\n\n          const isRangeStart = this.isEqual(cellDate, selectionRange.start);\n          const isRangeEnd = this.isEqual(cellDate, selectionRange.end);\n          const isInMiddle = !isRangeStart && !isRangeEnd;\n          const isRangeMid = isInMiddle && isInSelectionRange(cellDate, selectionRange);\n          return {\n            formattedValue: this.value(cellDate),\n            id: `${cellUID}${cellDate.getTime()}`,\n            isFocused: this.isEqual(cellDate, focusedDate),\n            isSelected: isActiveView && selectedDates.some(date => this.isEqual(cellDate, date)),\n            isWeekend: false,\n            isRangeStart: isRangeStart,\n            isRangeMid: isRangeMid,\n            isRangeEnd: isRangeEnd,\n            isRangeSplitEnd: isRangeMid && this.isEqual(cellDate, lastDate),\n            isRangeSplitStart: isRangeMid && this.isEqual(cellDate, firstDate),\n            isToday: this.isEqual(cellDate, today),\n            title: this.cellTitle(cellDate),\n            value: cellDate\n          };\n        });\n      });\n    }\n\n    isEqual(candidate, expected) {\n      if (!candidate || !expected) {\n        return false;\n      }\n\n      return firstYearOfDecade(candidate).getFullYear() === firstYearOfDecade(expected).getFullYear();\n    }\n\n    isInArray(date, dates) {\n      if (!dates.length) {\n        return false;\n      }\n\n      const year = date.getFullYear();\n      return dates[0].getFullYear() <= year && year <= dates[dates.length - 1].getFullYear() + 99;\n    }\n\n    isInRange(candidate, min, max) {\n      const year = firstYearOfDecade(candidate).getFullYear();\n      const aboveMin = !min || firstYearOfDecade(min).getFullYear() <= year;\n      const belowMax = !max || year <= firstYearOfDecade(max).getFullYear();\n      return aboveMin && belowMax;\n    }\n\n    beginningOfPeriod(date) {\n      if (!date) {\n        return date;\n      }\n\n      const firstYear = firstYearOfDecade(firstDecadeOfCentury(date));\n      return createDate(firstYear.getFullYear(), 0, 1);\n    }\n\n    isRangeStart(value) {\n      return value.getFullYear() % 1000 === 0;\n    }\n\n    move(value, action) {\n      const modifier = ACTIONS[action];\n\n      if (!modifier) {\n        return value;\n      }\n\n      return modifier(value);\n    }\n\n    cellTitle(value) {\n      return firstYearOfDecade(value).getFullYear().toString();\n    }\n\n    navigationTitle(value) {\n      return value ? firstDecadeOfCentury(value).getFullYear().toString() : '';\n    }\n\n    title(value) {\n      if (!value) {\n        return '';\n      }\n\n      return `${firstDecadeOfCentury(value).getFullYear()} - ${lastDecadeOfCentury(value).getFullYear()}`;\n    }\n\n    rowLength() {\n      return CELLS_LENGTH;\n    }\n\n    skip(value, min) {\n      return durationInCenturies(min, value);\n    }\n\n    total(min, max) {\n      return durationInCenturies(min, max) + 1;\n    }\n\n    value(current) {\n      return current ? firstYearOfDecade(current).getFullYear().toString() : '';\n    }\n\n    viewDate(date, max, viewsCount = 1) {\n      const viewsInRange = this.total(date, max);\n\n      if (viewsInRange < viewsCount) {\n        const centuriesToSubtract = viewsCount - viewsInRange;\n        return addCenturies(date, -1 * centuriesToSubtract);\n      }\n\n      return date;\n    }\n\n    normalize(cellDate, min, max) {\n      if (cellDate < min && this.isEqual(cellDate, min)) {\n        return cloneDate(min);\n      }\n\n      if (cellDate > max && this.isEqual(cellDate, max)) {\n        return cloneDate(max);\n      }\n\n      return cellDate;\n    }\n\n  };\n\n  CenturyViewService.ɵfac = function CenturyViewService_Factory(t) {\n    return new (t || CenturyViewService)();\n  };\n\n  CenturyViewService.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: CenturyViewService,\n    factory: function (t) {\n      return CenturyViewService.ɵfac(t);\n    }\n  });\n  return CenturyViewService;\n})();\nconst EMPTY_DATA$1 = [[]];\nconst CELLS_LENGTH$1 = 4;\nconst ROWS_LENGTH$1 = 3;\nconst ACTIONS$1 = {\n  [Action.Left]: date => addYears(date, -1),\n  [Action.Up]: date => addYears(date, -5),\n  [Action.Right]: date => addYears(date, 1),\n  [Action.Down]: date => addYears(date, 5),\n  [Action.PrevView]: date => addDecades(date, -1),\n  [Action.NextView]: date => addDecades(date, 1),\n  [Action.FirstInView]: date => firstYearOfDecade(date),\n  [Action.LastInView]: date => lastYearOfDecade(date)\n};\n/**\n * @hidden\n */\n\nlet DecadeViewService = /*#__PURE__*/(() => {\n  let DecadeViewService = class DecadeViewService {\n    /**\n     * @hidden\n     */\n    constructor() {\n      this.dateRange = (start, end) => {\n        if (!isPresent(start) || !isPresent(end)) {\n          return [];\n        }\n\n        const result = [];\n        let current = start;\n\n        while (current <= end) {\n          result.push(current);\n          current = addYears(current, 1);\n        }\n\n        return result;\n      };\n    }\n\n    addToDate(min, skip) {\n      return addDecades(min, skip);\n    }\n\n    datesList(start, count) {\n      return range(0, count).map(i => addDecades(start, i));\n    }\n\n    data(options) {\n      const {\n        cellUID,\n        focusedDate,\n        isActiveView,\n        max,\n        min,\n        selectedDates,\n        selectionRange = EMPTY_SELECTIONRANGE,\n        viewDate\n      } = options;\n\n      if (!viewDate) {\n        return EMPTY_DATA$1;\n      }\n\n      const cells = range(0, CELLS_LENGTH$1);\n      const firstDate = firstYearOfDecade(viewDate);\n      const lastDate = lastYearOfDecade(viewDate);\n      const today = getToday();\n      return range(0, ROWS_LENGTH$1).map(rowOffset => {\n        const baseDate = addYears(firstDate, rowOffset * CELLS_LENGTH$1);\n        return cells.map(cellOffset => {\n          const cellDate = this.normalize(addYears(baseDate, cellOffset), min, max);\n          const nextDecade = cellDate.getFullYear() > lastDate.getFullYear();\n\n          if (!this.isInRange(cellDate, min, max) || nextDecade) {\n            return null;\n          }\n\n          const isRangeStart = this.isEqual(cellDate, selectionRange.start);\n          const isRangeEnd = this.isEqual(cellDate, selectionRange.end);\n          const isInMiddle = !isRangeStart && !isRangeEnd;\n          const isRangeMid = isInMiddle && isInSelectionRange(cellDate, selectionRange);\n          return {\n            formattedValue: this.value(cellDate),\n            id: `${cellUID}${cellDate.getTime()}`,\n            isFocused: this.isEqual(cellDate, focusedDate),\n            isSelected: isActiveView && selectedDates.some(date => this.isEqual(cellDate, date)),\n            isWeekend: false,\n            isRangeStart: isRangeStart,\n            isRangeMid: isRangeMid,\n            isRangeEnd: isRangeEnd,\n            isRangeSplitEnd: isRangeMid && this.isEqual(cellDate, lastDate),\n            isRangeSplitStart: isRangeMid && this.isEqual(cellDate, firstDate),\n            isToday: this.isEqual(cellDate, today),\n            title: this.cellTitle(cellDate),\n            value: cellDate\n          };\n        });\n      });\n    }\n\n    isEqual(candidate, expected) {\n      if (!candidate || !expected) {\n        return false;\n      }\n\n      return candidate.getFullYear() === expected.getFullYear();\n    }\n\n    isInArray(date, dates) {\n      if (!dates.length) {\n        return false;\n      }\n\n      const year = date.getFullYear();\n      return dates[0].getFullYear() <= year && year <= dates[dates.length - 1].getFullYear() + 9;\n    }\n\n    isInRange(candidate, min, max) {\n      const year = candidate.getFullYear();\n      const aboveMin = !min || min.getFullYear() <= year;\n      const belowMax = !max || year <= max.getFullYear();\n      return aboveMin && belowMax;\n    }\n\n    beginningOfPeriod(date) {\n      if (!date) {\n        return date;\n      }\n\n      const firstYear = firstYearOfDecade(date);\n      return createDate(firstYear.getFullYear(), 0, 1);\n    }\n\n    isRangeStart(value) {\n      return value.getFullYear() % 100 === 0;\n    }\n\n    move(value, action) {\n      const modifier = ACTIONS$1[action];\n\n      if (!modifier) {\n        return value;\n      }\n\n      return modifier(value);\n    }\n\n    cellTitle(value) {\n      return value.getFullYear().toString();\n    }\n\n    navigationTitle(value) {\n      return value ? firstYearOfDecade(value).getFullYear().toString() : '';\n    }\n\n    title(value) {\n      if (!value) {\n        return '';\n      }\n\n      return `${firstYearOfDecade(value).getFullYear()} - ${lastYearOfDecade(value).getFullYear()}`;\n    }\n\n    rowLength() {\n      return CELLS_LENGTH$1;\n    }\n\n    skip(value, min) {\n      return durationInDecades(min, value);\n    }\n\n    total(min, max) {\n      return durationInDecades(min, max) + 1;\n    }\n\n    value(current) {\n      return current ? current.getFullYear().toString() : '';\n    }\n\n    viewDate(date, max, viewsCount = 1) {\n      const viewsInRange = this.total(date, max);\n\n      if (viewsInRange < viewsCount) {\n        const decadesToSubtract = viewsCount - viewsInRange;\n        return addDecades(date, -1 * decadesToSubtract);\n      }\n\n      return date;\n    }\n\n    normalize(cellDate, min, max) {\n      if (cellDate < min && this.isEqual(cellDate, min)) {\n        return cloneDate(min);\n      }\n\n      if (cellDate > max && this.isEqual(cellDate, max)) {\n        return cloneDate(max);\n      }\n\n      return cellDate;\n    }\n\n  };\n\n  DecadeViewService.ɵfac = function DecadeViewService_Factory(t) {\n    return new (t || DecadeViewService)();\n  };\n\n  DecadeViewService.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: DecadeViewService,\n    factory: function (t) {\n      return DecadeViewService.ɵfac(t);\n    }\n  });\n  return DecadeViewService;\n})();\nconst EMPTY_DATA$2 = [[]];\nconst CELLS_LENGTH$2 = 7;\nconst ROWS_LENGTH$2 = 6;\nconst ACTIONS$2 = {\n  [Action.Left]: date => addDays(date, -1),\n  [Action.Up]: date => addWeeks(date, -1),\n  [Action.Right]: date => addDays(date, 1),\n  [Action.Down]: date => addWeeks(date, 1),\n  [Action.PrevView]: date => addMonths(date, -1),\n  [Action.NextView]: date => addMonths(date, 1),\n  [Action.FirstInView]: date => firstDayOfMonth(date),\n  [Action.LastInView]: date => lastDayOfMonth(date)\n};\n/**\n * @hidden\n */\n\nlet MonthViewService = /*#__PURE__*/(() => {\n  let MonthViewService = class MonthViewService {\n    constructor(_intlService) {\n      this._intlService = _intlService;\n\n      this.dateRange = (start, end) => {\n        if (!isPresent(start) || !isPresent(end)) {\n          return [];\n        }\n\n        const result = [];\n        let current = start;\n\n        while (current <= end) {\n          result.push(current);\n          current = addDays(current, 1);\n        }\n\n        return result;\n      };\n    }\n\n    addToDate(min, skip) {\n      return addMonths(min, skip);\n    }\n\n    datesList(start, count) {\n      return range(0, count).map(i => addMonths(start, i));\n    }\n\n    data(options) {\n      const {\n        cellUID,\n        focusedDate,\n        isActiveView,\n        max,\n        min,\n        selectedDates,\n        selectionRange = EMPTY_SELECTIONRANGE,\n        viewDate,\n        isDateDisabled = () => false\n      } = options;\n\n      if (!viewDate) {\n        return EMPTY_DATA$2;\n      }\n\n      const firstMonthDate = firstDayOfMonth(viewDate);\n      const firstMonthDay = getDate(firstMonthDate);\n      const lastMonthDate = lastDayOfMonth(viewDate);\n      const lastMonthDay = getDate(lastMonthDate);\n      const backward = -1;\n      const date = dayOfWeek(firstMonthDate, this._intlService.firstDay(), backward);\n      const cells = range(0, CELLS_LENGTH$2);\n      const today = getToday();\n      return range(0, ROWS_LENGTH$2).map(rowOffset => {\n        const baseDate = addDays(date, rowOffset * CELLS_LENGTH$2);\n        return cells.map(cellOffset => {\n          const cellDate = this.normalize(addDays(baseDate, cellOffset), min, max);\n          const cellDay = getDate(cellDate);\n          const otherMonth = cellDay < firstMonthDay || cellDay > lastMonthDay;\n          const outOfRange = cellDate < min || cellDate > max;\n\n          if (outOfRange) {\n            return null;\n          }\n\n          const isRangeStart = this.isEqual(cellDate, selectionRange.start);\n          const isRangeEnd = this.isEqual(cellDate, selectionRange.end);\n          const isInMiddle = !isRangeStart && !isRangeEnd;\n          const isRangeMid = isInMiddle && isInSelectionRange(cellDate, selectionRange);\n          return {\n            formattedValue: this.value(cellDate),\n            id: `${cellUID}${cellDate.getTime()}`,\n            isFocused: this.isEqual(cellDate, focusedDate),\n            isSelected: isActiveView && selectedDates.some(date => this.isEqual(cellDate, date)),\n            isWeekend: this.isWeekend(cellDate),\n            isRangeStart: isRangeStart,\n            isRangeMid: isRangeMid,\n            isRangeEnd: isRangeEnd,\n            isRangeSplitStart: isRangeMid && this.isEqual(cellDate, firstMonthDate),\n            isRangeSplitEnd: isRangeMid && this.isEqual(cellDate, lastMonthDate),\n            isToday: this.isEqual(cellDate, today),\n            title: this.cellTitle(cellDate),\n            value: cellDate,\n            isDisabled: isDateDisabled(cellDate),\n            isOtherMonth: otherMonth\n          };\n        });\n      });\n    }\n\n    isEqual(candidate, expected) {\n      if (!candidate || !expected) {\n        return false;\n      }\n\n      return getDate(candidate).getTime() === getDate(expected).getTime();\n    }\n\n    isInArray(date, dates) {\n      if (dates.length === 0) {\n        return false;\n      }\n\n      const lowerBound = this.beginningOfPeriod(dates[0]);\n      const upperBound = this.beginningOfPeriod(addMonths(dates[dates.length - 1], 1));\n      return lowerBound <= date && date < upperBound;\n    }\n\n    isInRange(candidate, min, max) {\n      const value = getDate(candidate);\n      const aboveMin = !min || getDate(min) <= value;\n      const belowMax = !max || value <= getDate(max);\n      return aboveMin && belowMax;\n    }\n\n    beginningOfPeriod(date) {\n      if (!date) {\n        return date;\n      }\n\n      return createDate(date.getFullYear(), date.getMonth(), 1);\n    }\n\n    isRangeStart(value) {\n      return !value.getMonth();\n    }\n\n    move(value, action) {\n      const modifier = ACTIONS$2[action];\n\n      if (!modifier) {\n        return value;\n      }\n\n      return modifier(value);\n    }\n\n    cellTitle(value) {\n      return this._intlService.formatDate(value, 'D');\n    }\n\n    navigationTitle(value) {\n      if (!value) {\n        return '';\n      }\n\n      return this.isRangeStart(value) ? value.getFullYear().toString() : this.abbrMonthNames()[value.getMonth()];\n    }\n\n    title(current) {\n      return `${this.wideMonthNames()[current.getMonth()]} ${current.getFullYear()}`;\n    }\n\n    rowLength(options = {}) {\n      return CELLS_LENGTH$2 + (options.prependCell ? 1 : 0);\n    }\n\n    skip(value, min) {\n      return durationInMonths(min, value);\n    }\n\n    total(min, max) {\n      return durationInMonths(min, max) + 1;\n    }\n\n    value(current) {\n      return current ? current.getDate().toString() : \"\";\n    }\n\n    viewDate(date, max, viewsCount = 1) {\n      const viewsInRange = this.total(date, max);\n\n      if (viewsInRange < viewsCount) {\n        const monthsToSubtract = viewsCount - viewsInRange;\n        return addMonths(date, -1 * monthsToSubtract);\n      }\n\n      return date;\n    }\n\n    isWeekend(date) {\n      const {\n        start,\n        end\n      } = this._intlService.weekendRange();\n\n      const day = date.getDay();\n\n      if (end < start) {\n        return day <= end || start <= day;\n      }\n\n      return start <= day && day <= end;\n    }\n\n    abbrMonthNames() {\n      return this._intlService.dateFormatNames({\n        nameType: 'abbreviated',\n        type: 'months'\n      });\n    }\n\n    normalize(cellDate, min, max) {\n      if (cellDate < min && this.isEqual(cellDate, min)) {\n        return cloneDate(min);\n      }\n\n      if (cellDate > max && this.isEqual(cellDate, max)) {\n        return cloneDate(max);\n      }\n\n      return cellDate;\n    }\n\n    wideMonthNames() {\n      return this._intlService.dateFormatNames({\n        nameType: 'wide',\n        type: 'months'\n      });\n    }\n\n  };\n\n  MonthViewService.ɵfac = function MonthViewService_Factory(t) {\n    return new (t || MonthViewService)(ɵngcc0.ɵɵinject(ɵngcc1.IntlService));\n  };\n\n  MonthViewService.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: MonthViewService,\n    factory: function (t) {\n      return MonthViewService.ɵfac(t);\n    }\n  });\n  MonthViewService = __decorate([__metadata(\"design:paramtypes\", [IntlService])], MonthViewService);\n  return MonthViewService;\n})();\nconst EMPTY_DATA$3 = [[]];\nconst CELLS_LENGTH$3 = 4;\nconst ROWS_LENGTH$3 = 3;\n\nconst upStep = month => {\n  if (month > 4) {\n    return -5;\n  }\n\n  if (month < 2) {\n    return -2;\n  }\n\n  return -7;\n};\n\nconst downStep = month => {\n  if (month < 7) {\n    return 5;\n  }\n\n  if (month < 10) {\n    return 7;\n  }\n\n  return 2;\n};\n\nconst ACTIONS$3 = {\n  [Action.Left]: date => addMonths(date, -1),\n  [Action.Up]: date => addMonths(date, upStep(date.getMonth())),\n  [Action.Right]: date => addMonths(date, 1),\n  [Action.Down]: date => addMonths(date, downStep(date.getMonth())),\n  [Action.PrevView]: date => addYears(date, -1),\n  [Action.NextView]: date => addYears(date, 1),\n  [Action.FirstInView]: date => firstMonthOfYear(date),\n  [Action.LastInView]: date => lastMonthOfYear(date)\n};\n/**\n * @hidden\n */\n\nlet YearViewService = /*#__PURE__*/(() => {\n  let YearViewService = class YearViewService {\n    constructor(_intlService) {\n      this._intlService = _intlService;\n\n      this.dateRange = (start, end) => {\n        if (!isPresent(start) || !isPresent(end)) {\n          return [];\n        }\n\n        const result = [];\n        let current = start;\n\n        while (current <= end) {\n          result.push(current);\n          current = addMonths(current, 1);\n        }\n\n        return result;\n      };\n    }\n\n    addToDate(min, skip) {\n      return addYears(min, skip);\n    }\n\n    datesList(start, count) {\n      return range(0, count).map(i => addYears(start, i));\n    }\n\n    data(options) {\n      const {\n        cellUID,\n        focusedDate,\n        isActiveView,\n        max,\n        min,\n        selectedDates,\n        selectionRange = EMPTY_SELECTIONRANGE,\n        viewDate\n      } = options;\n\n      if (!viewDate) {\n        return EMPTY_DATA$3;\n      }\n\n      const months = this.abbrMonthNames();\n      const firstDate = firstMonthOfYear(viewDate);\n      const lastDate = lastMonthOfYear(viewDate);\n      const currentYear = firstDate.getFullYear();\n      const cells = range(0, CELLS_LENGTH$3);\n      const today = getToday();\n      return range(0, ROWS_LENGTH$3).map(rowOffset => {\n        const baseDate = addMonths(firstDate, rowOffset * CELLS_LENGTH$3);\n        return cells.map(cellOffset => {\n          const cellDate = this.normalize(addMonths(baseDate, cellOffset), min, max);\n          const changedYear = currentYear < cellDate.getFullYear();\n\n          if (!this.isInRange(cellDate, min, max) || changedYear) {\n            return null;\n          }\n\n          const isRangeStart = this.isEqual(cellDate, selectionRange.start);\n          const isRangeEnd = this.isEqual(cellDate, selectionRange.end);\n          const isInMiddle = !isRangeStart && !isRangeEnd;\n          const isRangeMid = isInMiddle && isInSelectionRange(cellDate, selectionRange);\n          return {\n            formattedValue: months[cellDate.getMonth()],\n            id: `${cellUID}${cellDate.getTime()}`,\n            isFocused: this.isEqual(cellDate, focusedDate),\n            isSelected: isActiveView && selectedDates.some(date => this.isEqual(cellDate, date)),\n            isWeekend: false,\n            isRangeStart: isRangeStart,\n            isRangeMid: isRangeMid,\n            isRangeEnd: isRangeEnd,\n            isRangeSplitEnd: isRangeMid && this.isEqual(cellDate, lastDate),\n            isRangeSplitStart: isRangeMid && this.isEqual(cellDate, firstDate),\n            isToday: this.isEqual(cellDate, today),\n            title: this.cellTitle(cellDate),\n            value: cellDate\n          };\n        });\n      });\n    }\n\n    isEqual(candidate, expected) {\n      if (!candidate || !expected) {\n        return false;\n      }\n\n      return candidate.getFullYear() === expected.getFullYear() && candidate.getMonth() === expected.getMonth();\n    }\n\n    isInArray(date, dates) {\n      if (!dates.length) {\n        return false;\n      }\n\n      const year = date.getFullYear();\n      return dates[0].getFullYear() <= year && year <= dates[dates.length - 1].getFullYear();\n    }\n\n    isInRange(candidate, min, max) {\n      const candidateValue = createDate(candidate.getFullYear(), candidate.getMonth(), 1);\n      const aboveMin = !min || createDate(min.getFullYear(), min.getMonth(), 1) <= candidateValue;\n      const belowMax = !max || candidateValue <= createDate(max.getFullYear(), max.getMonth(), 1);\n      return aboveMin && belowMax;\n    }\n\n    beginningOfPeriod(date) {\n      if (!date) {\n        return date;\n      }\n\n      return createDate(date.getFullYear(), 0, 1);\n    }\n\n    isRangeStart(value) {\n      return value.getFullYear() % 10 === 0;\n    }\n\n    move(value, action) {\n      const modifier = ACTIONS$3[action];\n\n      if (!modifier) {\n        return value;\n      }\n\n      return modifier(value);\n    }\n\n    cellTitle(value) {\n      return `${value.getFullYear()} ${this.value(value)}`;\n    }\n\n    navigationTitle(value) {\n      return this.title(value);\n    }\n\n    title(current) {\n      return current ? current.getFullYear().toString() : '';\n    }\n\n    rowLength() {\n      return CELLS_LENGTH$3;\n    }\n\n    skip(value, min) {\n      return durationInYears(min, value);\n    }\n\n    total(min, max) {\n      return durationInYears(min, max) + 1;\n    }\n\n    value(current) {\n      return current ? this.abbrMonthNames()[current.getMonth()] : '';\n    }\n\n    viewDate(date, max, viewsCount = 1) {\n      const viewsInRange = this.total(date, max);\n\n      if (viewsInRange < viewsCount) {\n        const yearsToSubtract = viewsCount - viewsInRange;\n        return addYears(date, -1 * yearsToSubtract);\n      }\n\n      return date;\n    }\n\n    abbrMonthNames() {\n      return this._intlService.dateFormatNames({\n        nameType: 'abbreviated',\n        type: 'months'\n      });\n    }\n\n    normalize(cellDate, min, max) {\n      if (cellDate < min && this.isEqual(cellDate, min)) {\n        return cloneDate(min);\n      }\n\n      if (cellDate > max && this.isEqual(cellDate, max)) {\n        return cloneDate(max);\n      }\n\n      return cellDate;\n    }\n\n  };\n\n  YearViewService.ɵfac = function YearViewService_Factory(t) {\n    return new (t || YearViewService)(ɵngcc0.ɵɵinject(ɵngcc1.IntlService));\n  };\n\n  YearViewService.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: YearViewService,\n    factory: function (t) {\n      return YearViewService.ɵfac(t);\n    }\n  });\n  YearViewService = __decorate([__metadata(\"design:paramtypes\", [IntlService])], YearViewService);\n  /**\n   * @hidden\n   *\n   * The Enum which defines all possible Calendar view types.\n   */\n\n  return YearViewService;\n})();\nvar CalendarViewEnum = /*#__PURE__*/(() => {\n  (function (CalendarViewEnum) {\n    CalendarViewEnum[CalendarViewEnum[\"month\"] = 0] = \"month\";\n    CalendarViewEnum[CalendarViewEnum[\"year\"] = 1] = \"year\";\n    CalendarViewEnum[CalendarViewEnum[\"decade\"] = 2] = \"decade\";\n    CalendarViewEnum[CalendarViewEnum[\"century\"] = 3] = \"century\";\n  })(CalendarViewEnum || (CalendarViewEnum = {}));\n\n  return CalendarViewEnum;\n})();\nconst services = {\n  [CalendarViewEnum.month]: MonthViewService,\n  [CalendarViewEnum.year]: YearViewService,\n  [CalendarViewEnum.decade]: DecadeViewService,\n  [CalendarViewEnum.century]: CenturyViewService\n};\n\nconst viewOffset = (view, offset) => {\n  const candidate = CalendarViewEnum[CalendarViewEnum[view + offset]];\n  return candidate !== undefined ? candidate : view;\n};\n/**\n * @hidden\n */\n\n\nlet BusViewService = /*#__PURE__*/(() => {\n  let BusViewService = class BusViewService {\n    constructor(injector) {\n      this.injector = injector;\n      this.viewChanged = new EventEmitter();\n      this.bottom = CalendarViewEnum.month;\n      this.top = CalendarViewEnum.century;\n    }\n\n    configure(bottom, top) {\n      this.bottom = bottom;\n      this.top = top;\n    }\n\n    service(view) {\n      const serviceType = services[view];\n      return serviceType ? this.injector.get(serviceType) : null;\n    }\n\n    moveDown(view) {\n      this.move(view, -1);\n    }\n\n    moveUp(view) {\n      this.move(view, 1);\n    }\n\n    moveToBottom(activeView) {\n      if (activeView === this.bottom) {\n        return;\n      }\n\n      this.viewChanged.emit({\n        view: this.bottom\n      });\n    }\n\n    canMoveDown(view) {\n      return this.bottom < view;\n    }\n\n    canMoveUp(view) {\n      return view < this.top;\n    }\n\n    clamp(view) {\n      if (view < this.bottom) {\n        return this.bottom;\n      }\n\n      if (view > this.top) {\n        return this.top;\n      }\n\n      return view;\n    }\n\n    move(view, offset) {\n      const candidate = this.clamp(viewOffset(view, offset));\n\n      if (candidate === view) {\n        return;\n      }\n\n      this.viewChanged.emit({\n        view: candidate\n      });\n    }\n\n  };\n\n  BusViewService.ɵfac = function BusViewService_Factory(t) {\n    return new (t || BusViewService)(ɵngcc0.ɵɵinject(ɵngcc0.Injector));\n  };\n\n  BusViewService.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: BusViewService,\n    factory: function (t) {\n      return BusViewService.ɵfac(t);\n    }\n  });\n  BusViewService = __decorate([__metadata(\"design:paramtypes\", [Injector])], BusViewService);\n  return BusViewService;\n})();\nconst div = domContainerFactory('div');\nconst ul = domContainerFactory('ul');\nconst li = domContainerFactory('li');\nconst td = domContainerFactory('td');\nconst th = domContainerFactory('th');\nconst tr = domContainerFactory('tr');\nconst tbody = domContainerFactory('tbody');\nconst thead = domContainerFactory('thead');\nconst table = domContainerFactory('table');\n\nconst monthHeader = () => div(`\n            <span class=\"k-button k-flat k-title k-calendar-title\">March 2017</span>\n            <span class=\"k-spacer\"></span>\n            <span class=\"k-calendar-nav k-hstack\">\n                <span class=\"k-today k-nav-today\">TODAY</span>\n            </span>\n        `, 'k-calendar-header k-hstack');\n\nconst monthWeekHeader = () => table([thead([tr([th('MO', 'k-calendar-th')], 'k-calendar-tr')], 'k-calendar-thead')], 'k-calendar-weekdays k-calendar-table');\n\nconst repeat = (count, mapper) => new Array(count).fill('1').map(mapper);\n\nconst content = (rows, cells = 1) => table([tbody([tr([th('1', 'k-calendar-th')], 'k-calendar-tr')].concat(repeat(rows, () => tr(repeat(cells, c => td(`<span class=\"k-link\">${c}</span>`, 'k-calendar-td')), 'k-calendar-tr'))), 'k-calendar-tbody')], 'k-calendar-table');\n\nconst scrollable = children => div(children, 'k-flex k-content k-calendar-content k-scrollable');\n\nconst view = (contentElement, className, renderWeekHeader) => div([monthHeader(), renderWeekHeader ? monthWeekHeader() : null, scrollable([contentElement, contentElement])], className, {\n  left: '-10000px',\n  position: 'absolute'\n});\n\nconst ɵ6 = () => {\n  let navElement;\n  return () => {\n    if (!isDocumentAvailable) {\n      return null;\n    }\n\n    if (!navElement) {\n      navElement = div([scrollable([ul([li('<span>FEB</span>')])])], 'k-calendar-navigation', {\n        left: '0px',\n        position: 'absolute'\n      });\n    }\n\n    return navElement;\n  };\n};\n\nconst navigationList = ɵ6();\n\nconst viewFactory = ({\n  cells,\n  rows\n}, className, renderWeekHeader) => {\n  let viewElement;\n  return () => {\n    if (!isDocumentAvailable) {\n      return null;\n    }\n\n    if (!viewElement) {\n      viewElement = view(content(rows, cells), className, renderWeekHeader);\n    }\n\n    return viewElement;\n  };\n};\n\nconst getScrollable = element => element.querySelector('.k-scrollable');\n\nconst horizontal = element => {\n  const scrollableElement = getScrollable(element);\n  scrollableElement.classList.add('k-scrollable-horizontal');\n  return element;\n};\n\nconst monthView = viewFactory({\n  cells: 7,\n  rows: 6\n}, 'k-vstack k-calendar-view k-calendar-monthview', true);\nconst yearView = viewFactory({\n  cells: 4,\n  rows: 3\n}, 'k-vstack k-calendar-view k-calendar-yearview', false);\nconst decadeView = viewFactory({\n  cells: 4,\n  rows: 3\n}, 'k-vstack k-calendar-view k-calendar-decadeview', false);\n\nconst horzMonthView = () => horizontal(monthView());\n\nconst horzYearView = () => horizontal(yearView());\n\nconst horzDecadeView = () => horizontal(decadeView());\n\nconst height = element => parseFloat(window.getComputedStyle(element).height) || element.offsetHeight;\n\nconst width = element => {\n  const styles = window.getComputedStyle(element);\n  const computed = parseFloat(styles.width) + parseFloat(styles.paddingLeft) + parseFloat(styles.paddingRight);\n  return computed || element.offsetWidth;\n};\n\nconst getBody = element => element.querySelector('tbody');\n/**\n * @hidden\n */\n\n\nlet CalendarDOMService = /*#__PURE__*/(() => {\n  let CalendarDOMService = class CalendarDOMService {\n    ensureHeights() {\n      if (this.calendarHeight !== undefined) {\n        return;\n      }\n\n      this.calculateHeights();\n    }\n\n    calculateHeights(container) {\n      if (!isDocumentAvailable()) {\n        return;\n      }\n\n      this.hostContainer = container;\n      this.batch(monthView(), contentElement => {\n        const viewElement = getBody(contentElement);\n        this.calendarHeight = height(contentElement);\n        this.monthViewHeight = height(viewElement);\n        this.headerHeight = height(viewElement.children[0]);\n        this.scrollableContentHeight = height(getScrollable(contentElement));\n      });\n      this.batch(horzMonthView(), contentElement => {\n        const viewElement = getBody(contentElement);\n        this.calendarWidth = width(contentElement);\n        this.monthViewWidth = width(viewElement);\n        this.scrollableContentWidth = width(getScrollable(contentElement));\n      });\n      this.batch(yearView(), contentElement => {\n        this.yearViewHeight = height(getBody(contentElement));\n        this.scrollableYearContentHeight = height(getScrollable(contentElement));\n      });\n      this.batch(horzYearView(), contentElement => {\n        this.yearViewWidth = width(getBody(contentElement));\n      });\n      this.batch(decadeView(), contentElement => {\n        this.decadeViewHeight = height(getBody(contentElement));\n        this.centuryViewHeight = this.decadeViewHeight;\n      });\n      this.batch(horzDecadeView(), contentElement => {\n        this.decadeViewWidth = width(getBody(contentElement));\n        this.centuryViewWidth = this.decadeViewWidth;\n      });\n      this.batch(navigationList(), contentElement => {\n        this.navigationItemHeight = height(contentElement.querySelector('li'));\n      });\n    }\n\n    viewHeight(viewType) {\n      return this.viewDimension(viewType, 'height');\n    }\n\n    viewWidth(viewType) {\n      return this.viewDimension(viewType, 'width');\n    }\n\n    viewDimension(viewType, dimension) {\n      const viewProp = dimension === 'height' ? 'ViewHeight' : 'ViewWidth';\n\n      switch (viewType) {\n        case CalendarViewEnum.month:\n          return this[`month${viewProp}`];\n\n        case CalendarViewEnum.year:\n          return this[`year${viewProp}`];\n\n        case CalendarViewEnum.decade:\n          return this[`decade${viewProp}`];\n\n        case CalendarViewEnum.century:\n          return this[`century${viewProp}`];\n\n        default:\n          return 1;\n      }\n    }\n\n    batch(contentElement, action) {\n      if (!isPresent(this.hostContainer)) {\n        return;\n      }\n\n      const hostClone = this.hostContainer.cloneNode();\n      document.body.appendChild(hostClone);\n\n      try {\n        const appendedContent = hostClone.appendChild(contentElement);\n        action(appendedContent);\n      } catch (error) {\n        throw error;\n      } finally {\n        document.body.removeChild(hostClone);\n      }\n    }\n\n  };\n\n  CalendarDOMService.ɵfac = function CalendarDOMService_Factory(t) {\n    return new (t || CalendarDOMService)();\n  };\n\n  CalendarDOMService.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: CalendarDOMService,\n    factory: function (t) {\n      return CalendarDOMService.ɵfac(t);\n    }\n  });\n  /**\n   * @hidden\n   */\n\n  return CalendarDOMService;\n})();\n\nconst update = (arr, idx, value) => [...arr.slice(0, idx + 1), ...arr.slice(idx + 1).map(x => x + value)];\n/**\n * @hidden\n */\n\n\nclass RowHeightService {\n  constructor(total = 0, rowHeight, detailRowHeight) {\n    this.total = total;\n    this.rowHeight = rowHeight;\n    this.detailRowHeight = detailRowHeight;\n    this.offsets = [];\n    this.heights = [];\n    let agg = 0;\n\n    for (let idx = 0; idx < total; idx++) {\n      this.offsets.push(agg);\n      agg += rowHeight;\n      this.heights.push(rowHeight);\n    }\n  }\n\n  height(rowIndex) {\n    return this.heights[rowIndex];\n  }\n\n  expandDetail(rowIndex) {\n    if (this.height(rowIndex) === this.rowHeight) {\n      this.updateRowHeight(rowIndex, this.detailRowHeight);\n    }\n  }\n\n  collapseDetail(rowIndex) {\n    if (this.height(rowIndex) > this.rowHeight) {\n      this.updateRowHeight(rowIndex, this.detailRowHeight * -1);\n    }\n  }\n\n  index(position) {\n    if (position < 0) {\n      return undefined;\n    }\n\n    const result = this.offsets.reduce((prev, current, idx) => {\n      if (prev !== undefined) {\n        return prev;\n      } else if (current === position) {\n        return idx;\n      } else if (current > position) {\n        return idx - 1;\n      }\n\n      return undefined;\n    }, undefined); // tslint:disable-line:align\n\n    return result === undefined ? this.total - 1 : result;\n  }\n\n  offset(rowIndex) {\n    return this.offsets[rowIndex];\n  }\n\n  totalHeight() {\n    return this.heights.reduce((prev, curr) => prev + curr, 0);\n  }\n\n  updateRowHeight(rowIndex, value) {\n    this.heights[rowIndex] += value;\n    this.offsets = update(this.offsets, rowIndex, value);\n  }\n\n}\n\nconst normalize = x => Math.max(x, 0);\n/**\n * @hidden\n */\n\n\nclass ScrollAction {\n  constructor(offset) {\n    this.offset = offset;\n  }\n\n}\n/**\n * @hidden\n */\n\n\nclass PageAction {\n  constructor(skip) {\n    this.skip = skip;\n  }\n\n}\n/**\n * @hidden\n */\n\n\nclass ScrollerService {\n  constructor(scrollObservable) {\n    this.scrollObservable = scrollObservable;\n    this.firstLoaded = 0;\n    this.bottomOffset = 0;\n    this.topOffset = 0;\n  }\n\n  create(rowHeightService, skip, take, total, topOffset = 0, bottomOffset = 0, direction = 'vertical') {\n    this.rowHeightService = rowHeightService;\n    this.firstLoaded = skip;\n    this.lastLoaded = skip + take;\n    this.take = take;\n    this.total = total;\n    this.lastScroll = 0;\n    this.topOffset = topOffset;\n    this.bottomOffset = bottomOffset;\n    this.direction = direction;\n    const subject = new ReplaySubject(2);\n    const offsetBufferRows = this.rowsForHeight(topOffset);\n    const skipWithOffset = normalize(skip - offsetBufferRows);\n    subject.next(new ScrollAction(this.rowOffset(skipWithOffset)));\n\n    if (offsetBufferRows) {\n      subject.next(new PageAction(skipWithOffset));\n    }\n\n    this.subscription = new Observable(observer => {\n      this.unsubscribe();\n      this.scrollSubscription = this.scrollObservable.subscribe(x => this.onScroll(x, observer));\n    }).subscribe(x => subject.next(x));\n    return subject;\n  }\n\n  destroy() {\n    this.unsubscribe();\n\n    if (this.subscription) {\n      this.subscription.unsubscribe();\n    }\n  }\n\n  onScroll({\n    scrollLeft,\n    scrollTop,\n    offsetHeight,\n    offsetWidth\n  }, observer) {\n    const scrollPosition = this.direction === 'vertical' ? scrollTop : scrollLeft;\n    const offsetSize = this.direction === 'vertical' ? offsetHeight : offsetWidth;\n\n    if (this.lastScroll === scrollPosition) {\n      return;\n    }\n\n    const up = this.lastScroll >= scrollPosition;\n    this.lastScroll = scrollPosition;\n    const firstItemIndex = this.rowHeightService.index(normalize(scrollPosition - this.topOffset));\n    const lastItemIndex = this.rowHeightService.index(normalize(scrollPosition + offsetSize - this.bottomOffset));\n\n    if (!up && lastItemIndex >= this.lastLoaded && this.lastLoaded < this.total) {\n      this.firstLoaded = firstItemIndex;\n      observer.next(new ScrollAction(this.rowOffset(firstItemIndex)));\n      this.lastLoaded = Math.min(this.firstLoaded + this.take, this.total);\n      observer.next(new PageAction(this.firstLoaded));\n    }\n\n    if (up && firstItemIndex <= this.firstLoaded) {\n      const nonVisibleBuffer = Math.floor(this.take * 0.3);\n      this.firstLoaded = normalize(firstItemIndex - nonVisibleBuffer);\n      observer.next(new ScrollAction(this.rowOffset(this.firstLoaded)));\n      this.lastLoaded = Math.min(this.firstLoaded + this.take, this.total);\n      observer.next(new PageAction(this.firstLoaded));\n    }\n  }\n\n  rowOffset(index) {\n    return this.rowHeightService.offset(index) + this.topOffset;\n  }\n\n  rowsForHeight(height) {\n    return Math.ceil(height / this.rowHeightService.height(0));\n  }\n\n  unsubscribe() {\n    if (this.scrollSubscription) {\n      this.scrollSubscription.unsubscribe();\n      this.scrollSubscription = null;\n    }\n  }\n\n}\n/**\n * @hidden\n */\n\n\nconst SCROLLER_FACTORY_TOKEN = new InjectionToken('dateinputs-scroll-service-factory');\n/**\n * @hidden\n */\n\nfunction DEFAULT_SCROLLER_FACTORY(observable) {\n  return new ScrollerService(observable);\n}\n/**\n * @hidden\n */\n\n\nvar ScrollDirection = /*#__PURE__*/(() => {\n  (function (ScrollDirection) {\n    ScrollDirection[ScrollDirection[\"Backward\"] = 0] = \"Backward\";\n    ScrollDirection[ScrollDirection[\"Forward\"] = 1] = \"Forward\";\n  })(ScrollDirection || (ScrollDirection = {}));\n\n  return ScrollDirection;\n})();\nconst FRAME_DURATION = 17;\nconst scrollModifiers = {\n  [ScrollDirection.Forward]: step => value => value + step,\n  [ScrollDirection.Backward]: step => value => value - step\n};\nconst scrollNormalizers = {\n  [ScrollDirection.Forward]: end => value => Math.min(value, end),\n  [ScrollDirection.Backward]: end => value => Math.max(value, end)\n};\nconst scrollValidators = {\n  [ScrollDirection.Forward]: end => start => start < end,\n  [ScrollDirection.Backward]: end => start => start > end\n};\n\nconst differenceToScroll = (scrollTop, staticOffset, maxScrollDifference) => {\n  return Math.min(Math.abs(staticOffset - scrollTop), maxScrollDifference);\n};\n/**\n * @hidden\n */\n\n\nlet VirtualizationComponent = /*#__PURE__*/(() => {\n  let VirtualizationComponent = class VirtualizationComponent {\n    constructor(scrollerFactory, container, renderer, zone) {\n      this.container = container;\n      this.renderer = renderer;\n      this.zone = zone;\n      this.direction = 'vertical';\n      this.itemHeight = 1;\n      this.itemWidth = 1;\n      this.topOffset = 0;\n      this.bottomOffset = 0;\n      this.maxScrollDifference = 100;\n      this.scrollOffsetSize = 0;\n      this.scrollDuration = 150;\n      this.activeIndexChange = new EventEmitter();\n      this.pageChange = new EventEmitter();\n      this.scrollChange = new EventEmitter();\n      this.wrapperClasses = true;\n      this.resolvedPromise = Promise.resolve(null);\n      this.dispatcher = new Subject();\n      this.scroller = scrollerFactory(this.dispatcher);\n    }\n\n    get horizontalClass() {\n      return this.direction === 'horizontal';\n    }\n\n    get totalVertexLength() {\n      const value = `${this.totalSize}px`;\n      return this.direction === 'vertical' ? {\n        height: value\n      } : {\n        width: value\n      };\n    }\n\n    get containerOffsetSize() {\n      return this.getContainerProperty(this.direction === 'vertical' ? 'offsetHeight' : 'offsetWidth');\n    }\n\n    get containerScrollSize() {\n      return this.getContainerProperty(this.direction === 'vertical' ? 'scrollHeight' : 'scrollWidth');\n    }\n\n    get containerScrollPosition() {\n      return this.getContainerProperty(this.direction === 'vertical' ? 'scrollTop' : 'scrollLeft');\n    }\n\n    ngOnChanges(changes) {\n      if (changes.direction || changes.take || changes.total) {\n        this.initServices();\n        this.totalSize = this.rowHeightService.totalHeight() + this.bottomOffset;\n      }\n    }\n\n    ngOnInit() {\n      if (!this.rowHeightService) {\n        this.rowHeightService = this.createRowHeightService();\n      }\n    }\n\n    ngAfterViewInit() {\n      this.zone.runOutsideAngular(() => {\n        this.containerScrollSubscription = this.scroll$().pipe(map(event => event.target)).subscribe(t => {\n          this.dispatcher.next(t);\n          this.emitActiveIndex();\n        });\n      });\n    }\n\n    ngOnDestroy() {\n      if (this.containerScrollSubscription) {\n        this.containerScrollSubscription.unsubscribe();\n      }\n\n      if (this.scrollSubscription) {\n        this.scrollSubscription.unsubscribe();\n      }\n\n      if (this.animationSubscription) {\n        this.animationSubscription.unsubscribe();\n      }\n    }\n\n    getContainerProperty(propertyName) {\n      return this.container.nativeElement[propertyName];\n    }\n\n    activeIndex() {\n      return this.itemIndex(Math.ceil(this.containerScrollPosition)); //handle subpixeling\n    }\n\n    itemIndex(offset) {\n      return this.rowHeightService.index(offset);\n    }\n\n    itemOffset(index) {\n      return this.rowHeightService.offset(index);\n    }\n\n    isIndexVisible(index) {\n      if (!this.rowHeightService) {\n        return false;\n      }\n\n      const containerTop = this.containerScrollPosition;\n      const containerBottom = containerTop + this.containerOffsetSize;\n      const top = this.rowHeightService.offset(index);\n      const bottom = top + this.rowHeightService.height(index);\n      return top >= containerTop && bottom <= containerBottom;\n    }\n\n    isListScrolled(index) {\n      return this.containerScrollPosition !== this.rowHeightService.offset(index);\n    }\n\n    scrollTo(value) {\n      const scrollProperty = this.direction === \"vertical\" ? 'scrollTop' : 'scrollLeft';\n      this.renderer.setProperty(this.container.nativeElement, scrollProperty, value);\n    }\n\n    scrollToIndex(index) {\n      //XXX: scrolling with tick is required to prevent list jump in Chrome.\n      //Original issue: focus first day in the month and press LEFT arrow.\n      //Notice how the view jumps on every day change.\n      //\n      this.zone.runOutsideAngular(() => {\n        this.resolvedPromise.then(() => {\n          this.scrollTo(this.rowHeightService.offset(index));\n        });\n      });\n    }\n\n    scrollToBottom() {\n      this.scrollTo(this.totalSize);\n    }\n\n    animateToIndex(index) {\n      if (this.animationSubscription) {\n        this.animationSubscription.unsubscribe();\n      }\n\n      const indexOffset = this.rowHeightService.offset(index);\n      const direction = this.getContainerScrollDirection(indexOffset);\n      const {\n        start,\n        end\n      } = this.scrollRange(indexOffset, direction);\n\n      if (start === end) {\n        return;\n      }\n\n      const step = this.scrollStep(start, end);\n      const modifyScroll = scrollModifiers[direction](step);\n      const normalizeScroll = scrollNormalizers[direction](end);\n      const isScrollValid = scrollValidators[direction](modifyScroll(end));\n      this.zone.runOutsideAngular(() => {\n        this.animationSubscription = combineLatest(of(start), interval(0, animationFrameScheduler)).pipe(map(stream => stream[0]), scan(modifyScroll), takeWhile(isScrollValid), map(normalizeScroll)).subscribe(x => this.scrollTo(x));\n      });\n    }\n\n    scrollRange(indexOffset, direction) {\n      const containerScroll = this.containerScrollPosition;\n\n      if (parseInt(indexOffset, 10) === parseInt(containerScroll, 10)) {\n        return {\n          start: indexOffset,\n          end: indexOffset\n        };\n      }\n\n      const maxScroll = this.containerMaxScroll();\n      const sign = direction === ScrollDirection.Backward ? 1 : -1;\n      const difference = differenceToScroll(containerScroll, indexOffset, this.maxScrollDifference);\n      const end = Math.min(indexOffset, maxScroll);\n      const start = Math.min(Math.max(end + sign * difference, 0), maxScroll);\n      return {\n        start,\n        end\n      };\n    }\n\n    scrollStep(start, end) {\n      return Math.abs(end - start) / (this.scrollDuration / FRAME_DURATION);\n    }\n\n    scroll$() {\n      return isDocumentAvailable() ? fromEvent(this.container.nativeElement, 'scroll') : EMPTY;\n    }\n\n    initServices() {\n      this.rowHeightService = this.createRowHeightService();\n\n      if (this.scrollSubscription) {\n        this.scrollSubscription.unsubscribe();\n      }\n\n      this.scrollSubscription = this.scroller.create(this.rowHeightService, this.skip, this.take, this.total, this.topOffset, this.scrollOffsetSize, this.direction).subscribe(x => {\n        if (x instanceof PageAction) {\n          this.pageChange.emit(x);\n        } else {\n          this.scrollChange.emit(x);\n        }\n      });\n    }\n\n    createRowHeightService() {\n      const dimension = this.direction === 'vertical' ? this.itemHeight : this.itemWidth;\n      return new RowHeightService(this.total, dimension, 0);\n    }\n\n    emitActiveIndex() {\n      const index = this.rowHeightService.index(this.containerScrollPosition - this.topOffset);\n\n      if (this.lastActiveIndex !== index) {\n        this.lastActiveIndex = index;\n        this.activeIndexChange.emit(index);\n      }\n    }\n\n    containerMaxScroll() {\n      return this.containerScrollSize - this.containerOffsetSize;\n    }\n\n    getContainerScrollDirection(indexOffset) {\n      return indexOffset < this.containerScrollPosition ? ScrollDirection.Backward : ScrollDirection.Forward;\n    }\n\n  };\n\n  VirtualizationComponent.ɵfac = function VirtualizationComponent_Factory(t) {\n    return new (t || VirtualizationComponent)(ɵngcc0.ɵɵdirectiveInject(SCROLLER_FACTORY_TOKEN), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone));\n  };\n\n  VirtualizationComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: VirtualizationComponent,\n    selectors: [[\"kendo-virtualization\"]],\n    hostVars: 10,\n    hostBindings: function VirtualizationComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        ɵngcc0.ɵɵclassProp(\"k-flex\", ctx.wrapperClasses)(\"k-content\", ctx.wrapperClasses)(\"k-calendar-content\", ctx.wrapperClasses)(\"k-scrollable\", ctx.wrapperClasses)(\"k-scrollable-horizontal\", ctx.horizontalClass);\n      }\n    },\n    inputs: {\n      direction: \"direction\",\n      itemHeight: \"itemHeight\",\n      itemWidth: \"itemWidth\",\n      topOffset: \"topOffset\",\n      bottomOffset: \"bottomOffset\",\n      maxScrollDifference: \"maxScrollDifference\",\n      scrollOffsetSize: \"scrollOffsetSize\",\n      scrollDuration: \"scrollDuration\",\n      skip: \"skip\",\n      take: \"take\",\n      total: \"total\"\n    },\n    outputs: {\n      activeIndexChange: \"activeIndexChange\",\n      pageChange: \"pageChange\",\n      scrollChange: \"scrollChange\"\n    },\n    features: [ɵngcc0.ɵɵProvidersFeature([{\n      provide: SCROLLER_FACTORY_TOKEN,\n      useValue: DEFAULT_SCROLLER_FACTORY\n    }]), ɵngcc0.ɵɵNgOnChangesFeature],\n    ngContentSelectors: _c0,\n    decls: 2,\n    vars: 3,\n    consts: [[1, \"k-scrollable-placeholder\", 3, \"ngStyle\"]],\n    template: function VirtualizationComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵprojection(0);\n        ɵngcc0.ɵɵelement(1, \"div\", 0);\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵclassProp(\"k-scrollable-horizontal-placeholder\", ctx.direction === \"horizontal\");\n        ɵngcc0.ɵɵproperty(\"ngStyle\", ctx.totalVertexLength);\n      }\n    },\n    directives: [ɵngcc2.NgStyle],\n    encapsulation: 2\n  });\n\n  __decorate([Input(), __metadata(\"design:type\", String)], VirtualizationComponent.prototype, \"direction\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", Number)], VirtualizationComponent.prototype, \"itemHeight\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", Number)], VirtualizationComponent.prototype, \"itemWidth\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", Number)], VirtualizationComponent.prototype, \"topOffset\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", Number)], VirtualizationComponent.prototype, \"bottomOffset\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", Number)], VirtualizationComponent.prototype, \"maxScrollDifference\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", Number)], VirtualizationComponent.prototype, \"scrollOffsetSize\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", Number)], VirtualizationComponent.prototype, \"scrollDuration\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", Number)], VirtualizationComponent.prototype, \"skip\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", Number)], VirtualizationComponent.prototype, \"take\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", Number)], VirtualizationComponent.prototype, \"total\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], VirtualizationComponent.prototype, \"activeIndexChange\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], VirtualizationComponent.prototype, \"pageChange\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], VirtualizationComponent.prototype, \"scrollChange\", void 0);\n\n  __decorate([HostBinding('class.k-flex'), HostBinding('class.k-content'), HostBinding('class.k-calendar-content'), HostBinding('class.k-scrollable'), __metadata(\"design:type\", Boolean)], VirtualizationComponent.prototype, \"wrapperClasses\", void 0);\n\n  __decorate([HostBinding('class.k-scrollable-horizontal'), __metadata(\"design:type\", Boolean), __metadata(\"design:paramtypes\", [])], VirtualizationComponent.prototype, \"horizontalClass\", null);\n\n  VirtualizationComponent = __decorate([__param(0, Inject(SCROLLER_FACTORY_TOKEN)), __metadata(\"design:paramtypes\", [Object, ElementRef, Renderer2, NgZone])], VirtualizationComponent);\n  /**\n   * @hidden\n   */\n\n  return VirtualizationComponent;\n})();\n\nconst closestInScope = (node, predicate, scope) => {\n  while (node && node !== scope && !predicate(node)) {\n    node = node.parentNode;\n  }\n\n  if (node !== scope) {\n    return node;\n  }\n};\n/**\n * @hidden\n */\n\n\nconst closest = (node, predicate) => {\n  while (node && !predicate(node)) {\n    node = node.parentNode;\n  }\n\n  return node;\n};\n\nconst ITEMS_COUNT = 30;\n/**\n * @hidden\n */\n\nlet NavigationComponent = /*#__PURE__*/(() => {\n  let NavigationComponent = class NavigationComponent {\n    constructor(bus, dom, intl, cdr, renderer) {\n      this.bus = bus;\n      this.dom = dom;\n      this.intl = intl;\n      this.cdr = cdr;\n      this.renderer = renderer;\n      this.min = new Date(MIN_DATE);\n      this.max = new Date(MAX_DATE);\n      this.focusedDate = new Date();\n      this.valueChange = new EventEmitter();\n      this.pageChange = new EventEmitter();\n      this.dates = [];\n      this.take = ITEMS_COUNT;\n      this.indexToScroll = -1;\n    }\n\n    get getComponentClass() {\n      return true;\n    }\n\n    ngOnInit() {\n      this.dom.ensureHeights();\n      const calendarHeight = this.dom.calendarHeight;\n      this.itemHeight = this.dom.navigationItemHeight;\n      this.maxViewHeight = this.dom.monthViewHeight;\n      this.topOffset = (calendarHeight - this.itemHeight) / 2;\n      this.bottomOffset = calendarHeight - this.itemHeight;\n      this.intlSubscription = this.intl.changes.subscribe(this.intlChange.bind(this));\n    }\n\n    ngOnChanges(changes) {\n      this.service = this.bus.service(this.activeView);\n\n      if (!this.service) {\n        return;\n      }\n\n      this.activeViewValue = CalendarViewEnum[this.activeView];\n      const viewDate = dateInRange(this.focusedDate, this.min, this.max);\n      const total = this.service.total(this.min, this.max);\n      const totalChanged = this.total && this.total !== total;\n      this.skip = this.service.skip(viewDate, this.min);\n      this.total = total;\n\n      if (totalChanged || !this.service.isInArray(viewDate, this.dates)) {\n        this.dates = this.service.datesList(viewDate, this.getTake(this.skip));\n      }\n\n      if (!!changes.focusedDate || totalChanged) {\n        this.indexToScroll = this.service.skip(this.focusedDate, this.min);\n      }\n    }\n\n    ngOnDestroy() {\n      if (this.intlSubscription) {\n        this.intlSubscription.unsubscribe();\n      }\n    }\n\n    ngAfterViewInit() {\n      if (this.indexToScroll === -1) {\n        return;\n      }\n\n      this.virtualization.scrollToIndex(this.indexToScroll);\n      this.indexToScroll = -1;\n    }\n\n    ngAfterViewChecked() {\n      if (this.indexToScroll === -1) {\n        return;\n      }\n\n      this.virtualization.scrollToIndex(this.indexToScroll);\n      this.indexToScroll = -1;\n    }\n\n    onPageChange({\n      skip\n    }) {\n      this.dates = this.service.datesList(this.service.addToDate(this.min, skip), this.getTake(skip));\n      this.pageChange.emit();\n    }\n\n    scrollChange({\n      offset\n    }) {\n      const el = this.list.nativeElement;\n      const translate = `translateY(${offset}px)`;\n      this.renderer.setStyle(el, 'transform', translate);\n      this.renderer.setStyle(el, '-ms-transform', translate);\n    }\n\n    handleDateChange(args) {\n      const item = closestInScope(args.target, node => node.hasAttribute('data-date-index'), this.list.nativeElement);\n\n      if (item) {\n        const index = parseInt(item.getAttribute('data-date-index'), 10);\n        const candidate = this.dates[index];\n        this.valueChange.emit(cloneDate(candidate));\n      }\n    }\n\n    getTake(skip) {\n      return Math.min(this.total - skip, this.take);\n    }\n\n    intlChange() {\n      if (this.activeView === CalendarViewEnum.month) {\n        this.cdr.markForCheck();\n      }\n    }\n\n  };\n\n  NavigationComponent.ɵfac = function NavigationComponent_Factory(t) {\n    return new (t || NavigationComponent)(ɵngcc0.ɵɵdirectiveInject(BusViewService), ɵngcc0.ɵɵdirectiveInject(CalendarDOMService), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.IntlService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2));\n  };\n\n  NavigationComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: NavigationComponent,\n    selectors: [[\"kendo-calendar-navigation\"]],\n    viewQuery: function NavigationComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵviewQuery(VirtualizationComponent, 5);\n        ɵngcc0.ɵɵviewQuery(_c1, 7);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.virtualization = _t.first);\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.list = _t.first);\n      }\n    },\n    hostVars: 2,\n    hostBindings: function NavigationComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        ɵngcc0.ɵɵclassProp(\"k-calendar-navigation\", ctx.getComponentClass);\n      }\n    },\n    inputs: {\n      min: \"min\",\n      max: \"max\",\n      focusedDate: \"focusedDate\",\n      activeView: \"activeView\",\n      templateRef: \"templateRef\"\n    },\n    outputs: {\n      valueChange: \"valueChange\",\n      pageChange: \"pageChange\"\n    },\n    features: [ɵngcc0.ɵɵNgOnChangesFeature],\n    decls: 5,\n    vars: 12,\n    consts: [[1, \"k-calendar-navigation-highlight\"], [3, \"skip\", \"take\", \"total\", \"itemHeight\", \"topOffset\", \"bottomOffset\", \"maxScrollDifference\", \"pageChange\", \"scrollChange\"], [1, \"k-reset\", 3, \"kendoEventsOutsideAngular\", \"scope\"], [\"list\", \"\"], [4, \"kFor\", \"kForOf\"], [3, \"ngIf\"], [3, \"ngIf\", \"ngTemplateOutlet\", \"ngTemplateOutletContext\"]],\n    template: function NavigationComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵelement(0, \"span\", 0);\n        ɵngcc0.ɵɵelementStart(1, \"kendo-virtualization\", 1);\n        ɵngcc0.ɵɵlistener(\"pageChange\", function NavigationComponent_Template_kendo_virtualization_pageChange_1_listener($event) {\n          return ctx.onPageChange($event);\n        })(\"scrollChange\", function NavigationComponent_Template_kendo_virtualization_scrollChange_1_listener($event) {\n          return ctx.scrollChange($event);\n        });\n        ɵngcc0.ɵɵelementStart(2, \"ul\", 2, 3);\n        ɵngcc0.ɵɵtemplate(4, NavigationComponent_li_4_Template, 4, 11, \"li\", 4);\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"skip\", ctx.skip)(\"take\", ctx.take)(\"total\", ctx.total)(\"itemHeight\", ctx.itemHeight)(\"topOffset\", ctx.topOffset)(\"bottomOffset\", ctx.bottomOffset)(\"maxScrollDifference\", ctx.maxViewHeight);\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"kendoEventsOutsideAngular\", ɵngcc0.ɵɵpureFunction1(10, _c3, ctx.handleDateChange))(\"scope\", ctx);\n        ɵngcc0.ɵɵadvance(2);\n        ɵngcc0.ɵɵproperty(\"kForOf\", ctx.dates);\n      }\n    },\n    directives: function () {\n      return [VirtualizationComponent, ɵngcc3.EventsOutsideAngularDirective, KForOf, ɵngcc2.NgIf, ɵngcc2.NgTemplateOutlet];\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n\n  __decorate([Input(), __metadata(\"design:type\", Number)], NavigationComponent.prototype, \"activeView\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", Date)], NavigationComponent.prototype, \"min\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", Date)], NavigationComponent.prototype, \"max\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", Date)], NavigationComponent.prototype, \"focusedDate\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", TemplateRef)], NavigationComponent.prototype, \"templateRef\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], NavigationComponent.prototype, \"valueChange\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], NavigationComponent.prototype, \"pageChange\", void 0);\n\n  __decorate([ViewChild(VirtualizationComponent, {\n    static: false\n  }), __metadata(\"design:type\", VirtualizationComponent)], NavigationComponent.prototype, \"virtualization\", void 0);\n\n  __decorate([ViewChild('list', {\n    static: true\n  }), __metadata(\"design:type\", ElementRef)], NavigationComponent.prototype, \"list\", void 0);\n\n  __decorate([HostBinding(\"class.k-calendar-navigation\"), __metadata(\"design:type\", Boolean), __metadata(\"design:paramtypes\", [])], NavigationComponent.prototype, \"getComponentClass\", null);\n\n  NavigationComponent = __decorate([__metadata(\"design:paramtypes\", [BusViewService, CalendarDOMService, IntlService, ChangeDetectorRef, Renderer2])], NavigationComponent);\n  return NavigationComponent;\n})();\nconst VIEWS_COUNT = 5;\n\nconst isEqualMonthYear = (date1, date2) => date1 && date2 && date1.getFullYear() === date2.getFullYear() && date1.getMonth() === date2.getMonth();\n/**\n * @hidden\n */\n\n\nlet ViewListComponent = /*#__PURE__*/(() => {\n  let ViewListComponent = class ViewListComponent {\n    constructor(bus, cdr, intl, dom, renderer) {\n      this.bus = bus;\n      this.cdr = cdr;\n      this.intl = intl;\n      this.dom = dom;\n      this.renderer = renderer;\n      this.isActive = true;\n      this.min = new Date(MIN_DATE);\n      this.max = new Date(MAX_DATE);\n      this.selectedDates = [];\n      this.cellClick = new EventEmitter();\n      this.weekNumberCellClick = new EventEmitter();\n      this.activeDateChange = new EventEmitter();\n      this.todayButtonClick = new EventEmitter();\n      this.pageChange = new EventEmitter();\n      this.getComponentClass = true;\n      this.dates = [];\n      this.cols = [];\n      this.weekNames = [];\n      this.take = VIEWS_COUNT;\n      this.animateToIndex = true;\n      this.indexToScroll = -1;\n      this.minViewsToRender = 1;\n    }\n\n    get weekNumber() {\n      return this.showWeekNumbers && this.isMonthView();\n    }\n\n    set weekNumber(showWeekNumbers) {\n      this.showWeekNumbers = showWeekNumbers;\n    }\n\n    get getComponentMonthClass() {\n      return this.activeView === CalendarViewEnum.month;\n    }\n\n    get getComponentYearClass() {\n      return this.activeView === CalendarViewEnum.year;\n    }\n\n    get getComponentDecadeClass() {\n      return this.activeView === CalendarViewEnum.decade;\n    }\n\n    get getComponentCenturyClass() {\n      return this.activeView === CalendarViewEnum.century;\n    }\n\n    ngOnInit() {\n      this.weekNames = this.getWeekNames();\n      this.bottomOffset = this.getBottomOffset();\n      this.viewOffset = -1 * this.dom.headerHeight;\n      this.viewHeight = this.dom.viewHeight(this.activeView);\n      this.intlSubscription = this.intl.changes.subscribe(this.intlChange.bind(this));\n    }\n\n    ngOnChanges(changes) {\n      this.service = this.bus.service(this.activeView);\n\n      if (!this.service) {\n        return;\n      }\n\n      this.cols = new Array(this.service.rowLength({\n        prependCell: this.weekNumber\n      })).fill('');\n      this.colWidth = Math.round(100 / this.cols.length);\n      this.weekNames = hasChange(changes, 'weekNumber') && this.weekNumber ? this.getWeekNames() : this.weekNames;\n      const activeViewChanged = hasChange(changes, 'activeView');\n      const focusedDate = this.focusedDate;\n      const viewDate = dateInRange(this.service.viewDate(focusedDate, this.max, this.minViewsToRender), this.min, this.max);\n      const total = this.service.total(this.min, this.max);\n      const totalChanged = this.total && this.total !== total;\n      const generateDates = totalChanged || !this.service.isInArray(focusedDate, this.dates);\n      this.skip = this.service.skip(viewDate, this.min);\n      this.total = total;\n      this.animateToIndex = !activeViewChanged;\n      this.bottomOffset = this.getBottomOffset();\n      this.viewHeight = this.dom.viewHeight(this.activeView);\n\n      if (generateDates) {\n        this.dates = this.service.datesList(viewDate, this.getTake(this.skip));\n      }\n\n      if (!isEqualMonthYear(this.activeDate, focusedDate)) {\n        this.activeDate = cloneDate(focusedDate);\n      }\n\n      const updateIndex = hasChange(changes, 'focusedDate') || activeViewChanged;\n\n      if (generateDates || updateIndex || this.virtualization.isIndexVisible(this.skip)) {\n        this.indexToScroll = this.service.skip(focusedDate, this.min);\n      }\n    }\n\n    ngOnDestroy() {\n      if (this.intlSubscription) {\n        this.intlSubscription.unsubscribe();\n      }\n    }\n\n    ngAfterViewInit() {\n      if (this.indexToScroll === -1) {\n        return;\n      }\n\n      this.virtualization.scrollToIndex(this.indexToScroll);\n      this.indexToScroll = -1;\n    }\n\n    ngAfterViewChecked() {\n      if (this.indexToScroll === -1) {\n        return;\n      }\n\n      this.virtualization[this.animateToIndex ? 'animateToIndex' : 'scrollToIndex'](this.indexToScroll);\n      this.animateToIndex = true;\n      this.indexToScroll = -1;\n    }\n\n    onPageChange({\n      skip\n    }) {\n      this.dates = this.service.datesList(this.service.addToDate(this.min, skip), this.getTake(skip));\n      this.pageChange.emit();\n    }\n\n    scrollChange({\n      offset\n    }) {\n      const el = this.list.nativeElement;\n      const translate = `translateY(${offset}px)`;\n      this.renderer.setStyle(el, 'transform', translate);\n      this.renderer.setStyle(el, '-ms-transform', translate);\n    }\n\n    setActiveDate(index) {\n      const candidate = this.service.addToDate(this.min, index);\n      this.activeDate = candidate;\n      this.activeDateChange.emit(candidate);\n      this.cdr.detectChanges();\n    }\n\n    isMonthView() {\n      return this.activeView === CalendarViewEnum.month;\n    }\n\n    isScrolled() {\n      return this.virtualization.isListScrolled(this.service.skip(this.focusedDate, this.min));\n    }\n\n    getBottomOffset() {\n      return this.getScrollableHeight() - this.dom.viewHeight(this.activeView);\n    }\n\n    getScrollableHeight() {\n      return this.activeView === CalendarViewEnum.month ? this.dom.scrollableContentHeight : this.dom.scrollableYearContentHeight;\n    }\n\n    getTake(skip) {\n      return Math.min(this.total - skip, this.take);\n    }\n\n    getWeekNames() {\n      const weekNames = shiftWeekNames(this.intl.dateFormatNames({\n        nameType: 'short',\n        type: 'days'\n      }), this.intl.firstDay());\n      return this.weekNumber ? [''].concat(weekNames) : weekNames;\n    }\n\n    intlChange() {\n      this.weekNames = this.getWeekNames();\n\n      if (this.isMonthView()) {\n        this.cdr.markForCheck();\n      }\n    }\n\n  };\n\n  ViewListComponent.ɵfac = function ViewListComponent_Factory(t) {\n    return new (t || ViewListComponent)(ɵngcc0.ɵɵdirectiveInject(BusViewService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.IntlService), ɵngcc0.ɵɵdirectiveInject(CalendarDOMService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2));\n  };\n\n  ViewListComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: ViewListComponent,\n    selectors: [[\"kendo-calendar-viewlist\"]],\n    viewQuery: function ViewListComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵviewQuery(VirtualizationComponent, 5);\n        ɵngcc0.ɵɵviewQuery(_c1, 7);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.virtualization = _t.first);\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.list = _t.first);\n      }\n    },\n    hostVars: 12,\n    hostBindings: function ViewListComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        ɵngcc0.ɵɵclassProp(\"k-vstack\", ctx.getComponentClass)(\"k-calendar-view\", ctx.getComponentClass)(\"k-calendar-monthview\", ctx.getComponentMonthClass)(\"k-calendar-yearview\", ctx.getComponentYearClass)(\"k-calendar-decadeview\", ctx.getComponentDecadeClass)(\"k-calendar-centuryview\", ctx.getComponentCenturyClass);\n      }\n    },\n    inputs: {\n      isActive: \"isActive\",\n      min: \"min\",\n      max: \"max\",\n      selectedDates: \"selectedDates\",\n      weekNumber: \"weekNumber\",\n      cellTemplateRef: \"cellTemplateRef\",\n      weekNumberTemplateRef: \"weekNumberTemplateRef\",\n      headerTitleTemplateRef: \"headerTitleTemplateRef\",\n      activeView: \"activeView\",\n      cellUID: \"cellUID\",\n      focusedDate: \"focusedDate\"\n    },\n    outputs: {\n      cellClick: \"cellClick\",\n      weekNumberCellClick: \"weekNumberCellClick\",\n      activeDateChange: \"activeDateChange\",\n      todayButtonClick: \"todayButtonClick\",\n      pageChange: \"pageChange\"\n    },\n    features: [ɵngcc0.ɵɵNgOnChangesFeature],\n    decls: 8,\n    vars: 17,\n    consts: [[3, \"currentDate\", \"min\", \"max\", \"activeView\", \"templateRef\", \"todayButtonClick\"], [\"class\", \"k-calendar-weekdays k-calendar-table\", \"style\", \"table-layout: auto;\", 4, \"ngIf\"], [3, \"tabindex\", \"skip\", \"take\", \"total\", \"itemHeight\", \"topOffset\", \"bottomOffset\", \"scrollOffsetSize\", \"maxScrollDifference\", \"pageChange\", \"scrollChange\", \"activeIndexChange\"], [1, \"k-calendar-table\"], [\"list\", \"\"], [4, \"ngFor\", \"ngForOf\"], [\"class\", \"k-calendar-tbody\", \"kendoCalendarView\", \"\", \"role\", \"rowgroup\", 3, \"activeView\", \"isActive\", \"min\", \"max\", \"cellUID\", \"focusedDate\", \"selectedDates\", \"weekNumber\", \"templateRef\", \"weekNumberTemplateRef\", \"viewDate\", \"cellClick\", \"weekNumberCellClick\", 4, \"kFor\", \"kForOf\"], [1, \"k-calendar-weekdays\", \"k-calendar-table\", 2, \"table-layout\", \"auto\"], [1, \"k-calendar-thead\"], [1, \"k-calendar-tr\"], [\"class\", \"k-calendar-th\", 3, \"width\", 4, \"ngFor\", \"ngForOf\"], [1, \"k-calendar-th\"], [\"kendoCalendarView\", \"\", \"role\", \"rowgroup\", 1, \"k-calendar-tbody\", 3, \"activeView\", \"isActive\", \"min\", \"max\", \"cellUID\", \"focusedDate\", \"selectedDates\", \"weekNumber\", \"templateRef\", \"weekNumberTemplateRef\", \"viewDate\", \"cellClick\", \"weekNumberCellClick\"]],\n    template: function ViewListComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵelementStart(0, \"kendo-calendar-header\", 0);\n        ɵngcc0.ɵɵlistener(\"todayButtonClick\", function ViewListComponent_Template_kendo_calendar_header_todayButtonClick_0_listener($event) {\n          return ctx.todayButtonClick.emit($event);\n        });\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵtemplate(1, ViewListComponent_table_1_Template, 4, 1, \"table\", 1);\n        ɵngcc0.ɵɵelementStart(2, \"kendo-virtualization\", 2);\n        ɵngcc0.ɵɵlistener(\"pageChange\", function ViewListComponent_Template_kendo_virtualization_pageChange_2_listener($event) {\n          return ctx.onPageChange($event);\n        })(\"scrollChange\", function ViewListComponent_Template_kendo_virtualization_scrollChange_2_listener($event) {\n          return ctx.scrollChange($event);\n        })(\"activeIndexChange\", function ViewListComponent_Template_kendo_virtualization_activeIndexChange_2_listener($event) {\n          return ctx.setActiveDate($event);\n        });\n        ɵngcc0.ɵɵelementStart(3, \"table\", 3, 4);\n        ɵngcc0.ɵɵelementStart(5, \"colgroup\");\n        ɵngcc0.ɵɵtemplate(6, ViewListComponent_col_6_Template, 1, 0, \"col\", 5);\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵtemplate(7, ViewListComponent_tbody_7_Template, 1, 11, \"tbody\", 6);\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵproperty(\"currentDate\", ctx.activeDate)(\"min\", ctx.min)(\"max\", ctx.max)(\"activeView\", ctx.activeView)(\"templateRef\", ctx.headerTitleTemplateRef);\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngIf\", ctx.isMonthView());\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"tabindex\", -1)(\"skip\", ctx.skip)(\"take\", ctx.take)(\"total\", ctx.total)(\"itemHeight\", ctx.viewHeight)(\"topOffset\", ctx.viewOffset)(\"bottomOffset\", ctx.bottomOffset)(\"scrollOffsetSize\", ctx.viewOffset)(\"maxScrollDifference\", ctx.viewHeight);\n        ɵngcc0.ɵɵadvance(4);\n        ɵngcc0.ɵɵproperty(\"ngForOf\", ctx.cols);\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"kForOf\", ctx.dates);\n      }\n    },\n    directives: function () {\n      return [HeaderComponent, ɵngcc2.NgIf, VirtualizationComponent, ɵngcc2.NgForOf, KForOf, ViewComponent];\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n\n  __decorate([Input(), __metadata(\"design:type\", TemplateRef)], ViewListComponent.prototype, \"cellTemplateRef\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", TemplateRef)], ViewListComponent.prototype, \"weekNumberTemplateRef\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", TemplateRef)], ViewListComponent.prototype, \"headerTitleTemplateRef\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", Number)], ViewListComponent.prototype, \"activeView\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", String)], ViewListComponent.prototype, \"cellUID\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", Date)], ViewListComponent.prototype, \"focusedDate\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", Boolean)], ViewListComponent.prototype, \"isActive\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", Date)], ViewListComponent.prototype, \"min\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", Date)], ViewListComponent.prototype, \"max\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", Array)], ViewListComponent.prototype, \"selectedDates\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", Boolean), __metadata(\"design:paramtypes\", [Boolean])], ViewListComponent.prototype, \"weekNumber\", null);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], ViewListComponent.prototype, \"cellClick\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], ViewListComponent.prototype, \"weekNumberCellClick\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], ViewListComponent.prototype, \"activeDateChange\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], ViewListComponent.prototype, \"todayButtonClick\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], ViewListComponent.prototype, \"pageChange\", void 0);\n\n  __decorate([ViewChild(VirtualizationComponent, {\n    static: false\n  }), __metadata(\"design:type\", VirtualizationComponent)], ViewListComponent.prototype, \"virtualization\", void 0);\n\n  __decorate([ViewChild('list', {\n    static: true\n  }), __metadata(\"design:type\", ElementRef)], ViewListComponent.prototype, \"list\", void 0);\n\n  __decorate([HostBinding(\"class.k-vstack\"), HostBinding(\"class.k-calendar-view\"), __metadata(\"design:type\", Boolean)], ViewListComponent.prototype, \"getComponentClass\", void 0);\n\n  __decorate([HostBinding(\"class.k-calendar-monthview\"), __metadata(\"design:type\", Boolean), __metadata(\"design:paramtypes\", [])], ViewListComponent.prototype, \"getComponentMonthClass\", null);\n\n  __decorate([HostBinding(\"class.k-calendar-yearview\"), __metadata(\"design:type\", Boolean), __metadata(\"design:paramtypes\", [])], ViewListComponent.prototype, \"getComponentYearClass\", null);\n\n  __decorate([HostBinding(\"class.k-calendar-decadeview\"), __metadata(\"design:type\", Boolean), __metadata(\"design:paramtypes\", [])], ViewListComponent.prototype, \"getComponentDecadeClass\", null);\n\n  __decorate([HostBinding(\"class.k-calendar-centuryview\"), __metadata(\"design:type\", Boolean), __metadata(\"design:paramtypes\", [])], ViewListComponent.prototype, \"getComponentCenturyClass\", null);\n\n  ViewListComponent = __decorate([__metadata(\"design:paramtypes\", [BusViewService, ChangeDetectorRef, IntlService, CalendarDOMService, Renderer2])], ViewListComponent);\n  return ViewListComponent;\n})();\nconst KEY_TO_ACTION = {\n  '33': Action.PrevView,\n  '34': Action.NextView,\n  '35': Action.LastInView,\n  '36': Action.FirstInView,\n  '37': Action.Left,\n  '38': Action.Up,\n  '39': Action.Right,\n  '40': Action.Down,\n  'meta+38': Action.UpperView,\n  'meta+40': Action.LowerView\n};\n/**\n * @hidden\n */\n\nlet NavigationService = /*#__PURE__*/(() => {\n  let NavigationService = class NavigationService {\n    constructor(bus) {\n      this.bus = bus;\n    }\n\n    action(event) {\n      const action = `${event.ctrlKey || event.metaKey ? 'meta+' : ''}${event.keyCode}`;\n      return KEY_TO_ACTION[action];\n    }\n\n    move(value, action, activeView) {\n      const service = this.bus.service(activeView);\n\n      if (!service) {\n        return value;\n      }\n\n      if (action === Action.UpperView && this.bus.canMoveUp(activeView)) {\n        this.bus.moveUp(activeView);\n        return value;\n      }\n\n      if (action === Action.LowerView && this.bus.canMoveDown(activeView)) {\n        this.bus.moveDown(activeView);\n        return value;\n      }\n\n      return service.move(value, action);\n    }\n\n  };\n\n  NavigationService.ɵfac = function NavigationService_Factory(t) {\n    return new (t || NavigationService)(ɵngcc0.ɵɵinject(BusViewService));\n  };\n\n  NavigationService.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: NavigationService,\n    factory: function (t) {\n      return NavigationService.ɵfac(t);\n    }\n  });\n  NavigationService = __decorate([__metadata(\"design:paramtypes\", [BusViewService])], NavigationService);\n  return NavigationService;\n})();\n\nconst noop$1 = () => false;\n\nconst DISABLED_DATES_DOC_LINK = 'https://www.telerik.com/kendo-angular-ui/components/dateinputs/calendar/disabled-dates/';\n/**\n * @hidden\n */\n\nlet DisabledDatesService = /*#__PURE__*/(() => {\n  let DisabledDatesService = class DisabledDatesService {\n    /**\n     * @hidden\n     */\n    constructor() {\n      /**\n       * Emits every time the `isDateDisabled` method changes.\n       */\n      this.changes = new Subject();\n      /**\n       * Based on the user-defined `disabledDates` input evaluates if the date is disabled.\n       * If not set, returns `false`.\n       */\n\n      this.isDateDisabled = noop$1;\n    }\n    /**\n     * Configures the `isDateDisabled` function.\n     *\n     * * If a function is provided, uses it as-is and passes each date to it for evaluation.\n     * The time part is set to `midnight`.\n     * * If a `Date[]` is provided, creates a function that checks the targeted date against\n     * the listed dates and, if the targeted date is listed, marks it as disabled.\n     * * If a `Day[]` is provided, creates a function that evaluates the provided days of the\n     * week as disabled.\n     */\n\n\n    initialize(disabledDates) {\n      if (typeof disabledDates === 'function') {\n        this.isDateDisabled = date => disabledDates(getDate(date));\n      } else if (isNumberArray(disabledDates)) {\n        const disabledWeekDays = new Set(disabledDates);\n\n        this.isDateDisabled = date => disabledWeekDays.has(date.getDay());\n      } else if (isDateArray(disabledDates)) {\n        const normalizedDisabledDates = new Set(disabledDates.map(date => getDate(date).getTime()));\n\n        this.isDateDisabled = date => normalizedDisabledDates.has(getDate(date).getTime());\n      } else {\n        this.isDateDisabled = noop$1;\n        this.notifyInvalidInput(disabledDates);\n      }\n\n      this.notifyServiceChange();\n    }\n\n    notifyInvalidInput(disabledDates) {\n      if (isPresent(disabledDates) && isDevMode()) {\n        throw new Error(`The 'disabledDates' value should be a function, a Day array or a Date array. Check ${DISABLED_DATES_DOC_LINK} for more information.`);\n      }\n    }\n\n    notifyServiceChange() {\n      this.changes.next();\n    }\n\n  };\n\n  DisabledDatesService.ɵfac = function DisabledDatesService_Factory(t) {\n    return new (t || DisabledDatesService)();\n  };\n\n  DisabledDatesService.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: DisabledDatesService,\n    factory: function (t) {\n      return DisabledDatesService.ɵfac(t);\n    }\n  });\n  /**\n   * @hidden\n   */\n\n  return DisabledDatesService;\n})();\nlet SelectionService = /*#__PURE__*/(() => {\n  let SelectionService = class SelectionService {\n    constructor(bus) {\n      this.bus = bus;\n    }\n\n    performSelection(args) {\n      let {\n        date,\n        modifiers,\n        selectionMode,\n        activeViewEnum,\n        rangePivot\n      } = args;\n      let selectedDates = args.selectedDates.slice();\n\n      if (selectionMode === 'multiple') {\n        if (modifiers.ctrlKey || modifiers.metaKey) {\n          if (this.isDateSelected(selectedDates, date)) {\n            selectedDates = selectedDates.filter(item => !isEqual(item, date));\n          } else {\n            selectedDates.push(date);\n          }\n\n          rangePivot = date;\n        } else if (modifiers.shiftKey) {\n          const [start, end] = sortDates([rangePivot || date, date]);\n          selectedDates = this.bus.service(activeViewEnum).dateRange(start, end);\n          rangePivot = date > selectedDates[0] ? selectedDates[0] : last(selectedDates);\n        } else {\n          selectedDates = [date];\n          rangePivot = date;\n        }\n      } else {\n        selectedDates = [date];\n        rangePivot = date;\n      }\n\n      return {\n        selectedDates,\n        rangePivot\n      };\n    }\n\n    isDateSelected(selectedDates, date) {\n      return selectedDates.some(item => isEqual(item, date));\n    }\n\n  };\n\n  SelectionService.ɵfac = function SelectionService_Factory(t) {\n    return new (t || SelectionService)(ɵngcc0.ɵɵinject(BusViewService));\n  };\n\n  SelectionService.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: SelectionService,\n    factory: function (t) {\n      return SelectionService.ɵfac(t);\n    }\n  });\n  SelectionService = __decorate([__metadata(\"design:paramtypes\", [BusViewService])], SelectionService);\n  return SelectionService;\n})();\n\nconst divideByMagnitude = magnitude => x => Math.floor(x / magnitude);\n\nconst powerByMagnitude = magnitude => x => x * magnitude;\n/**\n * @hidden\n */\n\n\nlet ScrollSyncService = /*#__PURE__*/(() => {\n  let ScrollSyncService = class ScrollSyncService {\n    constructor(dom, zone) {\n      this.dom = dom;\n      this.zone = zone;\n    }\n\n    configure(activeView) {\n      const magnitude = Math.max(this.dom.viewHeight(activeView) / this.dom.navigationItemHeight, 1);\n      this.divideByMagnitude = divideByMagnitude(magnitude);\n      this.powerByMagnitude = powerByMagnitude(magnitude);\n    }\n\n    sync(navigator, view) {\n      this.unsubscribe();\n\n      if (!navigator || !view) {\n        return;\n      }\n\n      this.navigator = navigator;\n      this.view = view;\n      this.zone.runOutsideAngular(() => {\n        let navScrolled, monthScrolled;\n        this.navSubscription = navigator.scroll$().subscribe(e => {\n          if (monthScrolled) {\n            monthScrolled = false;\n            return;\n          }\n\n          navScrolled = true;\n          this.scrollSiblingOf(e.target);\n        });\n        this.viewSubscription = view.scroll$().subscribe(e => {\n          if (navScrolled) {\n            navScrolled = false;\n            return;\n          }\n\n          monthScrolled = true;\n          this.scrollSiblingOf(e.target);\n        });\n      });\n    }\n\n    scrollSiblingOf(scrolledElement) {\n      const component = this.siblingComponent(scrolledElement);\n      const scrollTop = this.calculateScroll(component, scrolledElement.scrollTop);\n      component.scrollTo(scrollTop);\n    }\n\n    siblingComponent(scrollableElement) {\n      return this.navigator.container.nativeElement === scrollableElement ? this.view : this.navigator;\n    }\n\n    calculateScroll(component, scrollTop) {\n      const modifier = component === this.navigator ? this.divideByMagnitude : this.powerByMagnitude;\n      return modifier(scrollTop);\n    }\n\n    destroy() {\n      this.unsubscribe();\n    }\n\n    unsubscribe() {\n      if (this.navSubscription) {\n        this.navSubscription.unsubscribe();\n      }\n\n      if (this.viewSubscription) {\n        this.viewSubscription.unsubscribe();\n      }\n    }\n\n  };\n\n  ScrollSyncService.ɵfac = function ScrollSyncService_Factory(t) {\n    return new (t || ScrollSyncService)(ɵngcc0.ɵɵinject(CalendarDOMService), ɵngcc0.ɵɵinject(ɵngcc0.NgZone));\n  };\n\n  ScrollSyncService.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: ScrollSyncService,\n    factory: function (t) {\n      return ScrollSyncService.ɵfac(t);\n    }\n  });\n  ScrollSyncService = __decorate([__metadata(\"design:paramtypes\", [CalendarDOMService, NgZone])], ScrollSyncService);\n  /**\n   * Used for rendering the cell content of the Calendar. To define the cell template, nest an `<ng-template>` tag\n   * with the `kendoCalendarCellTemplate` directive inside the component tag. The template context is set to the\n   * current component. To get a reference to the current date, use the `let-date` directive. To provide more details\n   * about the current cell, get a reference to the current `cellContext` by using the `let-cellContext` directive.\n   *\n   * For more examples, refer to the article on [templates]({% slug templates_calendar %}).\n   *\n   * > `kendoCalendarCellTemplate` is equivalent to\n   * > [`kendoCalendarMonthCellTemplate`]({% slug api_dateinputs_monthcelltemplatedirective %}).\n   *\n   * @example\n   * ```ts\n   * _@Component({\n   * selector: 'my-app',\n   * styles: ['.custom { color: red; }'],\n   * template: `\n   *  <kendo-calendar>\n   *    <ng-template kendoCalendarCellTemplate let-date>\n   *      <span class=\"custom\">{{date.getDate()}}</span>\n   *    </ng-template>\n   *  </kendo-calendar>\n   * `\n   * })\n   * export class AppComponent { }\n   * ```\n   */\n\n  return ScrollSyncService;\n})();\nlet CellTemplateDirective = /*#__PURE__*/(() => {\n  let CellTemplateDirective = class CellTemplateDirective {\n    constructor(templateRef) {\n      this.templateRef = templateRef;\n    }\n\n  };\n\n  CellTemplateDirective.ɵfac = function CellTemplateDirective_Factory(t) {\n    return new (t || CellTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef));\n  };\n\n  CellTemplateDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: CellTemplateDirective,\n    selectors: [[\"\", \"kendoCalendarCellTemplate\", \"\"]]\n  });\n  CellTemplateDirective = __decorate([__metadata(\"design:paramtypes\", [TemplateRef])], CellTemplateDirective);\n  /**\n   * Used for rendering the month cell content of the Calendar. To define the month cell template, nest an `<ng-template>` tag\n   * with the `kendoCalendarMonthCellTemplate` directive inside the component tag. The template context is set to the current\n   * component. To get a reference to the current date, use the `let-date` directive. To provide more details about the current\n   * month cell, get a reference to the current `cellContext` by using the `let-cellContext` directive.\n   *\n   * For more examples, refer to the article on [templates]({% slug templates_calendar %}).\n   *\n   * @example\n   * ```ts\n   * _@Component({\n   * selector: 'my-app',\n   * styles: ['.custom { color: red; }'],\n   * template: `\n   *  <kendo-calendar>\n   *    <ng-template kendoCalendarMonthCellTemplate let-context=\"cellContext\">\n   *      <span class=\"custom\">{{context.formattedValue}}</span>\n   *    </ng-template>\n   *  </kendo-calendar>\n   * `\n   * })\n   * export class AppComponent { }\n   * ```\n   */\n\n  return CellTemplateDirective;\n})();\nlet MonthCellTemplateDirective = /*#__PURE__*/(() => {\n  let MonthCellTemplateDirective = class MonthCellTemplateDirective {\n    constructor(templateRef) {\n      this.templateRef = templateRef;\n    }\n\n  };\n\n  MonthCellTemplateDirective.ɵfac = function MonthCellTemplateDirective_Factory(t) {\n    return new (t || MonthCellTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef));\n  };\n\n  MonthCellTemplateDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: MonthCellTemplateDirective,\n    selectors: [[\"\", \"kendoCalendarMonthCellTemplate\", \"\"]]\n  });\n  MonthCellTemplateDirective = __decorate([__metadata(\"design:paramtypes\", [TemplateRef])], MonthCellTemplateDirective);\n  /**\n   * Used for rendering the year cell content of the Calendar. To define the year cell template, nest an\n   * `<ng-template>` tag with the `kendoCalendarYearCellTemplate` directive inside the component tag.\n   * The template context is set to the current component. To get a reference to the current date, use\n   * the `let-date` directive. To provide more details about the current year cell, get a reference to the\n   * current `cellContext` by using the `let-cellContext` directive.\n   *\n   * For more examples, refer to the article on [templates]({% slug templates_calendar %}).\n   *\n   * @example\n   * ```ts\n   * _@Component({\n   * selector: 'my-app',\n   * styles: ['.custom { color: red; }'],\n   * template: `\n   *  <kendo-calendar [activeView]=\"activeView\">\n   *    <ng-template kendoCalendarYearCellTemplate let-context=\"cellContext\">\n   *      <span class=\"custom\">{{context.formattedValue}}</span>\n   *    </ng-template>\n   *  </kendo-calendar>\n   * `\n   * })\n   * export class AppComponent {\n   *  public activeView: CalendarView = 'year';\n   * }\n   * ```\n   */\n\n  return MonthCellTemplateDirective;\n})();\nlet YearCellTemplateDirective = /*#__PURE__*/(() => {\n  let YearCellTemplateDirective = class YearCellTemplateDirective {\n    constructor(templateRef) {\n      this.templateRef = templateRef;\n    }\n\n  };\n\n  YearCellTemplateDirective.ɵfac = function YearCellTemplateDirective_Factory(t) {\n    return new (t || YearCellTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef));\n  };\n\n  YearCellTemplateDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: YearCellTemplateDirective,\n    selectors: [[\"\", \"kendoCalendarYearCellTemplate\", \"\"]]\n  });\n  YearCellTemplateDirective = __decorate([__metadata(\"design:paramtypes\", [TemplateRef])], YearCellTemplateDirective);\n  /**\n   * Used for rendering the decade cell content of the Calendar. To define the decade cell template, nest an `<ng-template>`\n   * tag with the `kendoCalendarDecadeCellTemplate` directive inside the component tag. The template context is set to the\n   * current component. To get a reference to the current date, use the `let-date` directive. To provide more details about\n   * the current decade cell, get a reference to the current `cellContext` by using the `let-cellContext` directive.\n   *\n   * For more examples, refer to the article on [templates]({% slug templates_calendar %}).\n   *\n   * @example\n   * ```ts\n   * _@Component({\n   * selector: 'my-app',\n   * styles: ['.custom { color: red; }'],\n   * template: `\n   *  <kendo-calendar [activeView]=\"activeView\">\n   *    <ng-template kendoCalendarDecadeCellTemplate let-context=\"cellContext\">\n   *      <span class=\"custom\">{{context.formattedValue}}</span>\n   *    </ng-template>\n   *  </kendo-calendar>\n   * `\n   * })\n   * export class AppComponent {\n   *  public activeView: CalendarView = 'decade';\n   * }\n   * ```\n   */\n\n  return YearCellTemplateDirective;\n})();\nlet DecadeCellTemplateDirective = /*#__PURE__*/(() => {\n  let DecadeCellTemplateDirective = class DecadeCellTemplateDirective {\n    constructor(templateRef) {\n      this.templateRef = templateRef;\n    }\n\n  };\n\n  DecadeCellTemplateDirective.ɵfac = function DecadeCellTemplateDirective_Factory(t) {\n    return new (t || DecadeCellTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef));\n  };\n\n  DecadeCellTemplateDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: DecadeCellTemplateDirective,\n    selectors: [[\"\", \"kendoCalendarDecadeCellTemplate\", \"\"]]\n  });\n  DecadeCellTemplateDirective = __decorate([__metadata(\"design:paramtypes\", [TemplateRef])], DecadeCellTemplateDirective);\n  /**\n   * Used for rendering the century cell content of the Calendar. To define the century cell template, nest an `<ng-template>`\n   * tag with the `kendoCalendarCenturyCellTemplate` directive inside the component tag. The template context is set to the\n   * current component. To get a reference to the current date, use the `let-date` directive. To provide more details about\n   * the current century cell, get a reference to the current `cellContext` by using the `let-cellContext` directive.\n   *\n   * For more examples, refer to the article on [templates]({% slug templates_calendar %}).\n   *\n   * @example\n   * ```ts\n   * _@Component({\n   * selector: 'my-app',\n   * styles: ['.custom { color: red; }'],\n   * template: `\n   *  <kendo-calendar [activeView]=\"activeView\">\n   *    <ng-template kendoCalendarCenturyCellTemplate let-context=\"cellContext\">\n   *      <span class=\"custom\">{{context.formattedValue}}</span>\n   *    </ng-template>\n   *  </kendo-calendar>\n   * `\n   * })\n   * export class AppComponent {\n   *  public activeView: CalendarView = 'century';\n   * }\n   * ```\n   */\n\n  return DecadeCellTemplateDirective;\n})();\nlet CenturyCellTemplateDirective = /*#__PURE__*/(() => {\n  let CenturyCellTemplateDirective = class CenturyCellTemplateDirective {\n    constructor(templateRef) {\n      this.templateRef = templateRef;\n    }\n\n  };\n\n  CenturyCellTemplateDirective.ɵfac = function CenturyCellTemplateDirective_Factory(t) {\n    return new (t || CenturyCellTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef));\n  };\n\n  CenturyCellTemplateDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: CenturyCellTemplateDirective,\n    selectors: [[\"\", \"kendoCalendarCenturyCellTemplate\", \"\"]]\n  });\n  CenturyCellTemplateDirective = __decorate([__metadata(\"design:paramtypes\", [TemplateRef])], CenturyCellTemplateDirective);\n  /**\n   * Used for rendering the week number cell content in the month view of the Calendar. To define the month week number cell template,\n   * nest an `<ng-template>` tag with the `kendoCalendarWeekNumberCellTemplate` directive inside the component tag. The template\n   * context is set to the current component. To get a reference to the current date, use the `let-date` directive. To provide more\n   * details about the current week number cell, get a reference to the current `cellContext` by using the `let-cellContext` directive.\n   *\n   * For more examples, refer to the article on [templates]({% slug templates_calendar %}).\n   *\n   * @example\n   * ```ts\n   * _@Component({\n   * selector: 'my-app',\n   * styles: ['.custom { color: red; }'],\n   * template: `\n   *  <kendo-calendar [weekNumber]=\"true\">\n   *    <ng-template kendoCalendarWeekNumberCellTemplate let-context=\"cellContext\">\n   *      <span class=\"custom\">{{context.formattedValue}}</span>\n   *    </ng-template>\n   *  </kendo-calendar>\n   * `\n   * })\n   * export class AppComponent { }\n   * ```\n   */\n\n  return CenturyCellTemplateDirective;\n})();\nlet WeekNumberCellTemplateDirective = /*#__PURE__*/(() => {\n  let WeekNumberCellTemplateDirective = class WeekNumberCellTemplateDirective {\n    constructor(templateRef) {\n      this.templateRef = templateRef;\n    }\n\n  };\n\n  WeekNumberCellTemplateDirective.ɵfac = function WeekNumberCellTemplateDirective_Factory(t) {\n    return new (t || WeekNumberCellTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef));\n  };\n\n  WeekNumberCellTemplateDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: WeekNumberCellTemplateDirective,\n    selectors: [[\"\", \"kendoCalendarWeekNumberCellTemplate\", \"\"]]\n  });\n  WeekNumberCellTemplateDirective = __decorate([__metadata(\"design:paramtypes\", [TemplateRef])], WeekNumberCellTemplateDirective);\n  /**\n   * Used for rendering the header title of the Calendar. To define the header title template, nest an `<ng-template>` tag\n   * with the `kendoCalendarHeaderTitleTemplate` directive inside the component tag. The template context is set to the\n   * current component. To get a reference to the current title, use the `let-title` directive. To provide more details about\n   * the current title, get a reference to the current `date` by using the `let-date` directive or get a reference to the\n   * current active view  by using the `let-activeView` directive.\n   *\n   * For more examples, refer to the article on [templates]({% slug templates_calendar %}).\n   *\n   * @example\n   * ```ts\n   * _@Component({\n   * selector: 'my-app',\n   * styles: ['.custom { color: red; }'],\n   * template: `\n   *  <kendo-calendar>\n   *    <ng-template kendoCalendarHeaderTitleTemplate let-title>\n   *      <span class=\"custom\">{{title}}</span>\n   *    </ng-template>\n   *  </kendo-calendar>\n   * `\n   * })\n   * export class AppComponent { }\n   * ```\n   */\n\n  return WeekNumberCellTemplateDirective;\n})();\nlet HeaderTitleTemplateDirective = /*#__PURE__*/(() => {\n  let HeaderTitleTemplateDirective = class HeaderTitleTemplateDirective {\n    constructor(templateRef) {\n      this.templateRef = templateRef;\n    }\n\n  };\n\n  HeaderTitleTemplateDirective.ɵfac = function HeaderTitleTemplateDirective_Factory(t) {\n    return new (t || HeaderTitleTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef));\n  };\n\n  HeaderTitleTemplateDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: HeaderTitleTemplateDirective,\n    selectors: [[\"\", \"kendoCalendarHeaderTitleTemplate\", \"\"]]\n  });\n  HeaderTitleTemplateDirective = __decorate([__metadata(\"design:paramtypes\", [TemplateRef])], HeaderTitleTemplateDirective);\n  /**\n   * Used for rendering the navigation item of the Calendar. To define the navigation item template, nest an `<ng-template>`\n   * tag with the `kendoCalendarNavigationItemTemplate` directive inside the component tag. The template context is set to the\n   * current component. To get a reference to the current item value, use the `let-title` directive. To provide more details\n   * about the current title, get a reference to the current `date` by using the `let-date='date'` directive or get a reference\n   * to the current active view by using the `let-activeView='activeView'` directive.\n   *\n   * For more examples, refer to the article on [templates]({% slug templates_calendar %}).\n   *\n   * @example\n   * ```ts\n   * _@Component({\n   * selector: 'my-app',\n   * styles: ['.custom { color: red; }'],\n   * template: `\n   *  <kendo-calendar>\n   *    <ng-template kendoCalendarNavigationItemTemplate let-title>\n   *      <span class=\"custom\">{{title}}</span>\n   *    </ng-template>\n   *  </kendo-calendar>\n   * `\n   * })\n   * export class AppComponent { }\n   * ```\n   */\n\n  return HeaderTitleTemplateDirective;\n})();\nlet NavigationItemTemplateDirective = /*#__PURE__*/(() => {\n  let NavigationItemTemplateDirective = class NavigationItemTemplateDirective {\n    constructor(templateRef) {\n      this.templateRef = templateRef;\n    }\n\n  };\n\n  NavigationItemTemplateDirective.ɵfac = function NavigationItemTemplateDirective_Factory(t) {\n    return new (t || NavigationItemTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef));\n  };\n\n  NavigationItemTemplateDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: NavigationItemTemplateDirective,\n    selectors: [[\"\", \"kendoCalendarNavigationItemTemplate\", \"\"]]\n  });\n  NavigationItemTemplateDirective = __decorate([__metadata(\"design:paramtypes\", [TemplateRef])], NavigationItemTemplateDirective);\n  /**\n   * @hidden\n   */\n\n  return NavigationItemTemplateDirective;\n})();\nlet PickerService = /*#__PURE__*/(() => {\n  class PickerService {\n    constructor() {\n      this.onFocus = new EventEmitter();\n      this.onBlur = new EventEmitter();\n      this.sameDateSelected = new EventEmitter();\n      this.dateCompletenessChange = new EventEmitter();\n    }\n\n  }\n\n  PickerService.ɵfac = function PickerService_Factory(t) {\n    return new (t || PickerService)();\n  };\n\n  PickerService.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: PickerService,\n    factory: PickerService.ɵfac\n  });\n  /**\n   * @hidden\n   */\n\n  return PickerService;\n})();\n\nconst minValidator = minValue => {\n  return control => {\n    const err = {\n      minError: {\n        minValue: minValue,\n        value: control.value\n      }\n    };\n\n    if (!minValue || !control.value) {\n      return null;\n    }\n\n    return control.value < minValue ? err : null;\n  };\n};\n/**\n * @hidden\n */\n\n\nconst maxValidator = maxValue => {\n  return control => {\n    const err = {\n      maxError: {\n        maxValue: maxValue,\n        value: control.value\n      }\n    };\n\n    if (!maxValue || !control.value) {\n      return null;\n    }\n\n    return control.value > maxValue ? err : null;\n  };\n};\n\nconst BOTTOM_VIEW_DOC_LINK = 'http://www.telerik.com/kendo-angular-ui/components/dateinputs/api/CalendarComponent/#toc-bottomview';\nconst TOP_VIEW_DOC_LINK = 'http://www.telerik.com/kendo-angular-ui/components/dateinputs/api/CalendarComponent/#toc-topview';\nconst MIN_DOC_LINK = 'http://www.telerik.com/kendo-angular-ui/components/dateinputs/api/CalendarComponent/#toc-min';\nconst MAX_DOC_LINK = 'http://www.telerik.com/kendo-angular-ui/components/dateinputs/api/CalendarComponent/#toc-max';\nconst VALUE_DOC_LINK = 'http://www.telerik.com/kendo-angular-ui/components/dateinputs/calendar/#toc-using-with-json';\n\nconst virtualizationProp = x => x ? x.virtualization : null;\n/**\n * @hidden\n */\n\n\nconst CALENDAR_VALUE_ACCESSOR = {\n  multi: true,\n  provide: NG_VALUE_ACCESSOR,\n  useExisting: forwardRef(() => CalendarComponent) //tslint:disable-line:no-use-before-declare\n\n};\n/**\n * @hidden\n */\n\nconst CALENDAR_RANGE_VALIDATORS = {\n  multi: true,\n  provide: NG_VALIDATORS,\n  useExisting: forwardRef(() => CalendarComponent) //tslint:disable-line:no-use-before-declare\n\n};\n/**\n * @hidden\n */\n\nconst KENDO_INPUT_PROVIDER = {\n  provide: KendoInput,\n  useExisting: forwardRef(() => CalendarComponent) //tslint:disable-line:no-use-before-declare\n\n};\n/**\n * Represents the [Kendo UI Calendar component for Angular]({% slug overview_calendar %}#toc-basic-usage).\n *\n * @example\n * ```ts\n * _@Component({\n * selector: 'my-app',\n * template: `\n *  <kendo-calendar></kendo-calendar>\n * `\n * })\n * export class AppComponent { }\n * ```\n */\n\nlet CalendarComponent = /*#__PURE__*/(() => {\n  let CalendarComponent = class CalendarComponent {\n    constructor(bus, dom, element, navigator, renderer, cdr, ngZone, injector, scrollSyncService, disabledDatesService, localization, selectionService, pickerService) {\n      this.bus = bus;\n      this.dom = dom;\n      this.element = element;\n      this.navigator = navigator;\n      this.renderer = renderer;\n      this.cdr = cdr;\n      this.ngZone = ngZone;\n      this.injector = injector;\n      this.scrollSyncService = scrollSyncService;\n      this.disabledDatesService = disabledDatesService;\n      this.localization = localization;\n      this.selectionService = selectionService;\n      this.pickerService = pickerService;\n      /**\n       * @hidden\n       */\n\n      this.id = guid();\n      /**\n       * Determines whether the built-in min or max validators are enforced when validating a form.\n       */\n\n      this.rangeValidation = false;\n      /**\n       * Sets the Calendar selection mode\n       * ([see example]({% slug multiple_selection_calendar %})).\n       *\n       * The available values are:\n       * * `single` (default)\n       * * `multiple`\n       */\n\n      this.selection = 'single';\n      /**\n       * Sets or gets the `disabled` property of the Calendar and\n       * determines whether the component is active\n       * ([see example]({% slug disabled_calendar %})).\n       */\n\n      this.disabled = false;\n      /**\n       * Sets or gets the `tabindex` property of the Calendar. Based on the\n       * [HTML `tabindex`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) behavior,\n       * it determines whether the component is focusable.\n       */\n\n      this.tabindex = 0;\n      /**\n       * Sets or gets the `navigation` property of the Calendar\n       * and determines whether the navigation side-bar will be displayed\n       * ([see example]({% slug sidebar_calendar %})).\n       * Applies to the [`infinite`]({% slug api_dateinputs_calendarcomponent %}#toc-type) Calendar only.\n       */\n\n      this.navigation = true;\n      /**\n       * Defines the active view that the Calendar initially renders\n       * ([see example]({% slug activeview_calendar %})).\n       * By default, the active view is `month`.\n       *\n       * > You have to set `activeView` within the `topView`-`bottomView` range.\n       */\n\n      this.activeView = CalendarViewEnum[CalendarViewEnum.month];\n      /**\n       * Defines the bottommost view to which the user can navigate\n       * ([see example]({% slug dates_calendar %}#toc-partial-dates)).\n       */\n\n      this.bottomView = CalendarViewEnum[CalendarViewEnum.month];\n      /**\n       * Defines the topmost view to which the user can navigate\n       * ([see example]({% slug sidebar_calendar %}#toc-partial-dates)).\n       */\n\n      this.topView = CalendarViewEnum[CalendarViewEnum.century];\n      /**\n       * Determines whether to enable animation when navigating to previous/next view.\n       * Applies to the [`classic`]({% slug api_dateinputs_calendarcomponent %}#toc-type) Calendar only.\n       *\n       * > This feature uses the [Web Animations API](https://developer.mozilla.org/en-US/docs/Web/API/Web_Animations_API). In order to run the animation in browsers that do not support it, you need the `web-animations-js` polyfill.\n       *\n       * @default false\n       */\n\n      this.animateNavigation = false;\n      /**\n       * Determines whether to display a week number column in the `month` view\n       * ([see example]({% slug weeknumcolumn_calendar %})).\n       */\n\n      this.weekNumber = false;\n      /**\n       * Fires when the active view is changed\n       * ([more information and example]({% slug overview_calendar %}#toc-events)).\n       */\n\n      this.activeViewChange = new EventEmitter();\n      /**\n       * Fires when the active view date is changed\n       * ([more information and example]({% slug overview_calendar %}#toc-events)).\n       * Applies to the [`infinite`]({% slug api_dateinputs_calendarcomponent %}#toc-type) Calendar only.\n       */\n\n      this.activeViewDateChange = new EventEmitter();\n      /**\n       * Fires when the value is changed\n       * ([more information and example]({% slug overview_calendar %}#toc-events)).\n       */\n\n      this.valueChange = new EventEmitter();\n      this.isActive = false;\n      this.cellUID = guid();\n      this.selectedDates = [];\n      this._min = new Date(MIN_DATE);\n      this._max = new Date(MAX_DATE);\n      this._focusedDate = getToday();\n      this.onControlChange = noop;\n      this.onControlTouched = noop;\n      this.onValidatorChange = noop;\n      this.minValidateFn = noop;\n      this.maxValidateFn = noop;\n      this.syncNavigation = true;\n      this._type = 'infinite';\n      this.domEvents = [];\n      this.resolvedPromise = Promise.resolve(null);\n      this.destroyed = false;\n      validatePackage(packageMetadata);\n      this.setClasses(element.nativeElement);\n\n      if (this.pickerService) {\n        this.pickerService.calendar = this;\n      }\n    }\n    /**\n     * Sets or gets the `focusedDate` property of the Calendar and\n     * defines the focused date of the component\n     * ([see example]({% slug dates_calendar %}#toc-focused-dates)).\n     *\n     * > If the Calendar is out of the min or max range, it normalizes the defined `focusedDate`.\n     */\n\n\n    set focusedDate(focusedDate) {\n      this._focusedDate = focusedDate || getToday();\n      this.setAriaActivedescendant();\n    }\n\n    get focusedDate() {\n      return this._focusedDate;\n    }\n    /**\n     * Sets or gets the `min` property of the Calendar and\n     * defines the minimum allowed date value\n     * ([see example]({% slug dateranges_calendar %})).\n     * By default, the `min` value is `1900-1-1`.\n     */\n\n\n    set min(min) {\n      this._min = min || new Date(MIN_DATE);\n    }\n\n    get min() {\n      return this._min;\n    }\n    /**\n     * Sets or gets the `max` property of the Calendar and\n     * defines the maximum allowed date value\n     * ([see example]({% slug dateranges_calendar %})).\n     * By default, the `max` value is `2099-12-31`.\n     */\n\n\n    set max(max) {\n      this._max = max || new Date(MAX_DATE);\n    }\n\n    get max() {\n      return this._max;\n    }\n    /**\n     * Sets or gets the `value` property of the Calendar and defines the selected value of the component.\n     *\n     * > The `value` has to be a valid\n     * [JavaScript `Date`](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Date)\n     * instance when in `single` selection mode or an array of valid JavaScript Date instances when in `multiple` selection mode.\n     */\n\n\n    get value() {\n      return this._value;\n    }\n\n    set value(candidate) {\n      this.verifyValue(candidate);\n      this._value = Array.isArray(candidate) ? candidate.filter(date => isPresent(date)).map(element => cloneDate(element)) : cloneDate(candidate);\n      const selection = [].concat(candidate).filter(date => isPresent(date)).map(date => cloneDate(date));\n\n      if (!areDatesEqual(selection, this.selectedDates)) {\n        const lastSelected = last(selection);\n        this.rangePivot = cloneDate(lastSelected);\n        this.focusedDate = cloneDate(lastSelected) || this.focusedDate;\n        this.selectedDates = selection;\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    set tabIndex(tabIndex) {\n      this.tabindex = tabIndex;\n    }\n\n    get tabIndex() {\n      return this.tabindex;\n    }\n    /**\n     * Sets the dates of the Calendar that will be disabled\n     * ([see example]({% slug disabled_dates_calendar %})).\n     */\n\n\n    set disabledDates(value) {\n      this.disabledDatesService.initialize(value);\n    }\n    /**\n     * Specifies the Calendar type.\n     *\n     * The possible values are:\n     * - `infinite` (default)\n     * - `classic`\n     *\n     */\n\n\n    set type(type) {\n      this.renderer.removeClass(this.element.nativeElement, `k-calendar-${this.type}`);\n      this.renderer.addClass(this.element.nativeElement, `k-calendar-${type}`);\n      this._type = type;\n    }\n\n    get type() {\n      return this._type;\n    }\n    /**\n     * @hidden\n     */\n\n\n    set cellTemplateRef(template) {\n      this.cellTemplate = template;\n    }\n    /**\n     * @hidden\n     */\n\n\n    set monthCellTemplateRef(template) {\n      this.monthCellTemplate = template;\n    }\n    /**\n     * @hidden\n     */\n\n\n    set yearCellTemplateRef(template) {\n      this.yearCellTemplate = template;\n    }\n    /**\n     * @hidden\n     */\n\n\n    set decadeCellTemplateRef(template) {\n      this.decadeCellTemplate = template;\n    }\n    /**\n     * @hidden\n     */\n\n\n    set centuryCellTemplateRef(template) {\n      this.centuryCellTemplate = template;\n    }\n    /**\n     * @hidden\n     */\n\n\n    set weekNumberTemplateRef(template) {\n      this.weekNumberTemplate = template;\n    }\n    /**\n     * @hidden\n     */\n\n\n    set headerTitleTemplateRef(template) {\n      this.headerTitleTemplate = template;\n    }\n    /**\n     * @hidden\n     */\n\n\n    set navigationItemTemplateRef(template) {\n      this.navigationItemTemplate = template;\n    }\n\n    get activeViewEnum() {\n      const activeView = CalendarViewEnum[this.activeView];\n      return activeView < this.bottomViewEnum ? this.bottomViewEnum : activeView;\n    }\n\n    get bottomViewEnum() {\n      return CalendarViewEnum[this.bottomView];\n    }\n\n    get topViewEnum() {\n      return CalendarViewEnum[this.topView];\n    }\n\n    get widgetId() {\n      return this.id;\n    }\n\n    get widgetRole() {\n      return 'grid';\n    }\n\n    get calendarTabIndex() {\n      return this.disabled ? undefined : this.tabIndex;\n    }\n\n    get ariaDisabled() {\n      return this.disabled;\n    }\n\n    ngOnInit() {\n      this.dom.calculateHeights(this.element.nativeElement);\n      this.scrollSyncService.configure(this.activeViewEnum);\n      this.localizationChangeSubscription = this.localization.changes.subscribe(() => this.cdr.markForCheck());\n      this.viewChangeSubscription = this.bus.viewChanged.subscribe(({\n        view\n      }) => this.handleActiveViewChange(CalendarViewEnum[view]));\n      this.control = this.injector.get(NgControl, null);\n\n      if (this.element) {\n        this.ngZone.runOutsideAngular(() => {\n          this.bindEvents();\n        });\n      }\n    }\n\n    ngOnChanges(changes) {\n      this.verifyChanges();\n      this.bus.configure(this.bottomViewEnum, this.topViewEnum);\n      this.scrollSyncService.configure(this.activeViewEnum);\n\n      if (hasExistingValue(changes, 'focusedDate')) {\n        const focusedDate = changes.focusedDate.currentValue;\n        this.focusedDate = dateInRange(focusedDate, this.min, this.max);\n      }\n\n      if (changes.navigation) {\n        this.syncNavigation = true;\n      }\n\n      if (changes.min || changes.max || changes.rangeValidation) {\n        this.minValidateFn = this.rangeValidation ? minValidator(this.min) : noop;\n        this.maxValidateFn = this.rangeValidation ? maxValidator(this.max) : noop;\n        this.onValidatorChange();\n      }\n    }\n\n    ngAfterViewInit() {\n      this.setAriaActivedescendant();\n    }\n\n    ngAfterViewChecked() {\n      if (!this.syncNavigation) {\n        return;\n      }\n\n      this.syncNavigation = false;\n      this.scrollSyncService.sync(virtualizationProp(this.navigationView), virtualizationProp(this.monthView));\n    }\n\n    ngOnDestroy() {\n      this.scrollSyncService.destroy();\n      this.viewChangeSubscription.unsubscribe();\n      this.domEvents.forEach(unbindCallback => unbindCallback());\n\n      if (this.pickerService) {\n        this.pickerService.calendar = null;\n      }\n\n      if (this.pageChangeSubscription) {\n        this.pageChangeSubscription.unsubscribe();\n      }\n\n      if (this.localizationChangeSubscription) {\n        this.localizationChangeSubscription.unsubscribe();\n      }\n\n      this.destroyed = true;\n    }\n    /**\n     * @hidden\n     */\n\n\n    onResize() {\n      this.focusedDate = new Date(this.focusedDate);\n      this.cdr.detectChanges();\n    }\n    /**\n     * Focuses the host element of the Calendar.\n     *\n     * @example\n     * ```ts\n     * _@Component({\n     * selector: 'my-app',\n     * template: `\n     *  <button (click)=\"calendar.focus()\">Focus calendar</button>\n     *  <kendo-calendar #calendar></kendo-calendar>\n     * `\n     * })\n     * export class AppComponent { }\n     * ```\n     */\n\n\n    focus() {\n      if (!this.element) {\n        return;\n      }\n\n      this.element.nativeElement.focus();\n    }\n    /**\n     * Blurs the Calendar component.\n     */\n\n\n    blur() {\n      if (!this.element) {\n        return;\n      }\n\n      this.element.nativeElement.blur();\n    }\n    /**\n     * @hidden\n     */\n\n\n    containsElement(element) {\n      return Boolean(closest(element, node => node === this.element.nativeElement));\n    }\n    /**\n     * @hidden\n     */\n\n\n    handleNavigation(candidate) {\n      if (this.disabled) {\n        return;\n      }\n\n      const focusTarget = candidate ? new Date(cloneDate(candidate).setDate(1)) : this.focusedDate;\n      this.focusedDate = dateInRange(focusTarget, this.min, this.max);\n      this.detectChanges();\n    }\n    /**\n     * @hidden\n     */\n\n\n    onPageChange() {\n      if (!NgZone.isInAngularZone()) {\n        if (this.pageChangeSubscription) {\n          this.pageChangeSubscription.unsubscribe();\n        }\n\n        this.pageChangeSubscription = from(this.resolvedPromise).subscribe(() => {\n          this.detectChanges(); // requires zone if templates\n        });\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    handleMultiViewCalendarValueChange(date, focusedDate) {\n      const selectedDates = Array.isArray(date) ? date : [date];\n      this.handleDateChange({\n        selectedDates,\n        focusedDate\n      });\n    }\n    /**\n     * @hidden\n     */\n\n\n    handleDateChange(args) {\n      const selectedDates = Array.isArray(args.selectedDates) ? args.selectedDates : [args.selectedDates];\n      const canNavigateDown = this.bus.canMoveDown(this.activeViewEnum);\n      const availableDates = selectedDates.filter(date => !this.disabledDatesService.isDateDisabled(date));\n      this.focusedDate = args.focusedDate || this.focusedDate;\n\n      if (this.disabled) {\n        return;\n      }\n\n      if (!canNavigateDown && areDatesEqual(availableDates, this.selectedDates)) {\n        this.emitSameDate();\n        return;\n      }\n\n      if (canNavigateDown) {\n        this.bus.moveDown(this.activeViewEnum);\n        return;\n      }\n\n      if (this.disabledDatesService.isDateDisabled(this.focusedDate)) {\n        return;\n      }\n\n      this.ngZone.run(() => {\n        this.selectedDates = availableDates.map(date => cloneDate(date));\n        this.value = this.parseSelectionToValue(availableDates);\n        this.onControlChange(this.parseSelectionToValue(availableDates));\n        this.valueChange.emit(this.parseSelectionToValue(availableDates));\n        this.cdr.markForCheck();\n      });\n    }\n    /**\n     * @hidden\n     */\n\n\n    writeValue(candidate) {\n      this.verifyValue(candidate);\n      this.value = candidate;\n      this.cdr.markForCheck();\n    }\n    /**\n     * @hidden\n     */\n\n\n    registerOnChange(fn) {\n      this.onControlChange = fn;\n    }\n    /**\n     * @hidden\n     */\n\n\n    registerOnTouched(fn) {\n      this.onControlTouched = fn;\n    }\n    /**\n     * @hidden\n     */\n\n\n    setDisabledState(isDisabled) {\n      this.disabled = isDisabled;\n      this.cdr.markForCheck();\n    }\n    /**\n     * @hidden\n     */\n\n\n    validate(control) {\n      return this.minValidateFn(control) || this.maxValidateFn(control);\n    }\n    /**\n     * @hidden\n     */\n\n\n    registerOnValidatorChange(fn) {\n      this.onValidatorChange = fn;\n    }\n    /**\n     * @hidden\n     */\n\n\n    activeCellTemplate() {\n      switch (this.activeViewEnum) {\n        case CalendarViewEnum.month:\n          return this.monthCellTemplate || this.cellTemplate;\n\n        case CalendarViewEnum.year:\n          return this.yearCellTemplate;\n\n        case CalendarViewEnum.decade:\n          return this.decadeCellTemplate;\n\n        case CalendarViewEnum.century:\n          return this.centuryCellTemplate;\n\n        default:\n          return null;\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    emitEvent(emitter, args) {\n      if (hasObservers(emitter)) {\n        this.ngZone.run(() => {\n          emitter.emit(args);\n        });\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    handleActiveViewChange(view) {\n      this.activeView = view;\n      this.emitEvent(this.activeViewChange, view);\n\n      if (this.type === 'infinite') {\n        this.scrollSyncService.configure(this.activeViewEnum);\n      }\n\n      this.detectChanges(); // requires zone if templates\n    }\n\n    handleCellClick({\n      date,\n      modifiers\n    }) {\n      this.performSelection(date, modifiers);\n    }\n    /**\n     * @hidden\n     */\n\n\n    handleWeekNumberClick(dates) {\n      if (this.selection === 'single') {\n        return;\n      }\n\n      this.ngZone.run(() => {\n        this.handleDateChange({\n          selectedDates: dates,\n          focusedDate: last(dates)\n        });\n      });\n    }\n\n    setClasses(element) {\n      this.renderer.addClass(element, 'k-widget');\n      this.renderer.addClass(element, 'k-calendar');\n      this.renderer.addClass(element, `k-calendar-${this.type}`);\n    }\n\n    verifyChanges() {\n      if (!isDevMode()) {\n        return;\n      }\n\n      if (this.min > this.max) {\n        throw new Error(`The max value should be bigger than the min. See ${MIN_DOC_LINK} and ${MAX_DOC_LINK}.`);\n      }\n\n      if (this.bottomViewEnum > this.topViewEnum) {\n        throw new Error(`The topView should be greater than bottomView. See ${BOTTOM_VIEW_DOC_LINK} and ${TOP_VIEW_DOC_LINK}.`);\n      }\n    }\n\n    verifyValue(candidate) {\n      if (!isDevMode()) {\n        return;\n      }\n\n      if (this.selection === 'single' && candidate && !(candidate instanceof Date)) {\n        throw new Error(`The 'value' should be a valid JavaScript Date instance. Check ${VALUE_DOC_LINK} for possible resolution.`);\n      } else if (this.selection === 'multiple' && candidate && Array.isArray(candidate)) {\n        const onlyDates = candidate.every(value => value instanceof Date);\n\n        if (!onlyDates) {\n          throw new Error(`The 'value' should be an array of valid JavaScript Date instances. Check ${VALUE_DOC_LINK} for possible resolution.`);\n        }\n      }\n    }\n\n    bindEvents() {\n      const element = this.element.nativeElement;\n      this.domEvents.push(this.renderer.listen(element, 'blur', this.handleBlur.bind(this)), this.renderer.listen(element, 'focus', this.handleFocus.bind(this)), this.renderer.listen(element, 'mousedown', preventDefault), this.renderer.listen(element, 'click', this.handleComponentClick.bind(this)), this.renderer.listen(element, 'keydown', this.handleKeydown.bind(this)));\n    }\n\n    emitBlur(args) {\n      if (this.pickerService) {\n        this.pickerService.onBlur.emit(args);\n      }\n    }\n\n    emitFocus() {\n      if (this.pickerService) {\n        this.pickerService.onFocus.emit();\n      }\n    }\n\n    handleBlur(args) {\n      this.isActive = false; // the injector can get the NgControl instance of the parent component (for example, the DateTimePicker)\n      // and enters the zone for no reason because the parent component is still untouched\n\n      if (!this.pickerService && requiresZoneOnBlur(this.control)) {\n        this.ngZone.run(() => {\n          this.onControlTouched();\n          this.emitBlur(args);\n          this.cdr.markForCheck();\n        });\n      } else {\n        this.emitBlur(args);\n        this.detectChanges();\n      }\n    }\n\n    handleFocus() {\n      this.isActive = true;\n\n      if (!NgZone.isInAngularZone()) {\n        this.detectChanges();\n      }\n\n      this.emitFocus();\n    }\n\n    handleComponentClick() {\n      if (!this.isActive) {\n        if (this.type === 'infinite' && this.monthView.isScrolled()) {\n          this.focusedDate = cloneDate(this.focusedDate); //XXX: forces change detect\n\n          this.detectChanges();\n        }\n\n        this.focus();\n      }\n    }\n\n    handleKeydown(args) {\n      // reserve the alt + arrow key commands for the picker\n      const arrowKeyPressed = [Keys.ArrowUp, Keys.ArrowRight, Keys.ArrowDown, Keys.ArrowLeft].indexOf(args.keyCode) !== -1;\n\n      if (isPresent(this.pickerService) && arrowKeyPressed && args.altKey) {\n        return;\n      }\n\n      const candidate = dateInRange(this.navigator.move(this.focusedDate, this.navigator.action(args), this.activeViewEnum), this.min, this.max);\n\n      if (!isEqual(this.focusedDate, candidate)) {\n        this.focusedDate = candidate;\n        this.detectChanges();\n        args.preventDefault();\n      }\n\n      if (args.keyCode === Keys.Enter) {\n        this.performSelection(this.focusedDate, args);\n      }\n    }\n\n    detectChanges() {\n      if (!this.destroyed) {\n        this.cdr.detectChanges();\n      }\n    }\n\n    emitSameDate() {\n      if (this.pickerService) {\n        this.pickerService.sameDateSelected.emit();\n      }\n    }\n\n    setAriaActivedescendant() {\n      if (!isPresent(this.element)) {\n        return;\n      }\n\n      const focusedCellId = this.cellUID + this.focusedDate.getTime();\n      this.renderer.setAttribute(this.element.nativeElement, 'aria-activedescendant', focusedCellId);\n    }\n\n    parseSelectionToValue(selection) {\n      selection = selection || [];\n      return this.selection === 'single' ? cloneDate(last(selection)) : selection.map(date => cloneDate(date));\n    }\n\n    performSelection(date, selectionModifiers) {\n      const selection = this.selectionService.performSelection({\n        date: date,\n        modifiers: selectionModifiers,\n        selectionMode: this.selection,\n        activeViewEnum: this.activeViewEnum,\n        rangePivot: this.rangePivot,\n        selectedDates: this.selectedDates\n      });\n      this.rangePivot = selection.rangePivot;\n      this.handleDateChange({\n        selectedDates: selection.selectedDates,\n        focusedDate: date\n      });\n    }\n\n  };\n\n  CalendarComponent.ɵfac = function CalendarComponent_Factory(t) {\n    return new (t || CalendarComponent)(ɵngcc0.ɵɵdirectiveInject(BusViewService), ɵngcc0.ɵɵdirectiveInject(CalendarDOMService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(NavigationService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Injector), ɵngcc0.ɵɵdirectiveInject(ScrollSyncService), ɵngcc0.ɵɵdirectiveInject(DisabledDatesService), ɵngcc0.ɵɵdirectiveInject(ɵngcc4.LocalizationService), ɵngcc0.ɵɵdirectiveInject(SelectionService), ɵngcc0.ɵɵdirectiveInject(PickerService, 8));\n  };\n\n  CalendarComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: CalendarComponent,\n    selectors: [[\"kendo-calendar\"]],\n    contentQueries: function CalendarComponent_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵcontentQuery(dirIndex, CellTemplateDirective, 7);\n        ɵngcc0.ɵɵcontentQuery(dirIndex, MonthCellTemplateDirective, 7);\n        ɵngcc0.ɵɵcontentQuery(dirIndex, YearCellTemplateDirective, 7);\n        ɵngcc0.ɵɵcontentQuery(dirIndex, DecadeCellTemplateDirective, 7);\n        ɵngcc0.ɵɵcontentQuery(dirIndex, CenturyCellTemplateDirective, 7);\n        ɵngcc0.ɵɵcontentQuery(dirIndex, WeekNumberCellTemplateDirective, 7);\n        ɵngcc0.ɵɵcontentQuery(dirIndex, HeaderTitleTemplateDirective, 7);\n        ɵngcc0.ɵɵcontentQuery(dirIndex, NavigationItemTemplateDirective, 7);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.cellTemplate = _t.first);\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.monthCellTemplate = _t.first);\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.yearCellTemplate = _t.first);\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.decadeCellTemplate = _t.first);\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.centuryCellTemplate = _t.first);\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.weekNumberTemplate = _t.first);\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.headerTitleTemplate = _t.first);\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.navigationItemTemplate = _t.first);\n      }\n    },\n    viewQuery: function CalendarComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵviewQuery(NavigationComponent, 5);\n        ɵngcc0.ɵɵviewQuery(ViewListComponent, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.navigationView = _t.first);\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.monthView = _t.first);\n      }\n    },\n    hostVars: 8,\n    hostBindings: function CalendarComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        ɵngcc0.ɵɵattribute(\"id\", ctx.widgetId)(\"role\", ctx.widgetRole)(\"tabindex\", ctx.calendarTabIndex)(\"aria-disabled\", ctx.ariaDisabled);\n        ɵngcc0.ɵɵclassProp(\"k-week-number\", ctx.weekNumber)(\"k-state-disabled\", ctx.ariaDisabled);\n      }\n    },\n    inputs: {\n      id: \"id\",\n      rangeValidation: \"rangeValidation\",\n      selection: \"selection\",\n      disabled: \"disabled\",\n      tabindex: \"tabindex\",\n      navigation: \"navigation\",\n      activeView: \"activeView\",\n      bottomView: \"bottomView\",\n      topView: \"topView\",\n      animateNavigation: \"animateNavigation\",\n      weekNumber: \"weekNumber\",\n      focusedDate: \"focusedDate\",\n      min: \"min\",\n      max: \"max\",\n      value: \"value\",\n      tabIndex: \"tabIndex\",\n      disabledDates: \"disabledDates\",\n      type: \"type\",\n      cellTemplateRef: [\"cellTemplate\", \"cellTemplateRef\"],\n      monthCellTemplateRef: [\"monthCellTemplate\", \"monthCellTemplateRef\"],\n      yearCellTemplateRef: [\"yearCellTemplate\", \"yearCellTemplateRef\"],\n      decadeCellTemplateRef: [\"decadeCellTemplate\", \"decadeCellTemplateRef\"],\n      centuryCellTemplateRef: [\"centuryCellTemplate\", \"centuryCellTemplateRef\"],\n      weekNumberTemplateRef: [\"weekNumberTemplate\", \"weekNumberTemplateRef\"],\n      headerTitleTemplateRef: [\"headerTitleTemplate\", \"headerTitleTemplateRef\"],\n      navigationItemTemplateRef: [\"navigationItemTemplate\", \"navigationItemTemplateRef\"]\n    },\n    outputs: {\n      activeViewChange: \"activeViewChange\",\n      activeViewDateChange: \"activeViewDateChange\",\n      valueChange: \"valueChange\"\n    },\n    exportAs: [\"kendo-calendar\"],\n    features: [ɵngcc0.ɵɵProvidersFeature([BusViewService, CALENDAR_VALUE_ACCESSOR, CALENDAR_RANGE_VALIDATORS, KENDO_INPUT_PROVIDER, LocalizationService, DisabledDatesService, {\n      provide: L10N_PREFIX,\n      useValue: 'kendo.calendar'\n    }, NavigationService, ScrollSyncService, SelectionService]), ɵngcc0.ɵɵNgOnChangesFeature],\n    decls: 3,\n    vars: 2,\n    consts: function () {\n      let i18n_4;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The label for the today button in the calendar header\n         * @meaning kendo.calendar.today\n         */\n        const MSG_EXTERNAL_4715594042078324085$$DIST_FESM2015_INDEX_JS_5 = goog.getMsg(\"Today\");\n        i18n_4 = MSG_EXTERNAL_4715594042078324085$$DIST_FESM2015_INDEX_JS_5;\n      } else {\n        i18n_4 = $localize`:kendo.calendar.today|The label for the today button in the calendar header␟7a8b7961a5c754397897f39a824bdec621719040␟4715594042078324085:Today`;\n      }\n\n      let i18n_6;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The title of the previous button in the Classic calendar\n         * @meaning kendo.calendar.prevButtonTitle\n         */\n        const MSG_EXTERNAL_9114031309296786030$$DIST_FESM2015_INDEX_JS_7 = goog.getMsg(\"Navigate to previous view\");\n        i18n_6 = MSG_EXTERNAL_9114031309296786030$$DIST_FESM2015_INDEX_JS_7;\n      } else {\n        i18n_6 = $localize`:kendo.calendar.prevButtonTitle|The title of the previous button in the Classic calendar␟031715cd6a995d5dd1f62365cfe1b9e6226ca185␟9114031309296786030:Navigate to previous view`;\n      }\n\n      let i18n_8;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The title of the next button in the Classic calendar\n         * @meaning kendo.calendar.nextButtonTitle\n         */\n        const MSG_EXTERNAL_7248948899360601102$$DIST_FESM2015_INDEX_JS_9 = goog.getMsg(\"Navigate to next view\");\n        i18n_8 = MSG_EXTERNAL_7248948899360601102$$DIST_FESM2015_INDEX_JS_9;\n      } else {\n        i18n_8 = $localize`:kendo.calendar.nextButtonTitle|The title of the next button in the Classic calendar␟cd8c0952c72306cccf0973c8fd1957ef9da1f569␟7248948899360601102:Navigate to next view`;\n      }\n\n      return [[\"kendoCalendarLocalizedMessages\", \"\", \"today\", i18n_4, \"prevButtonTitle\", i18n_6, \"nextButtonTitle\", i18n_8], [4, \"ngIf\"], [3, \"activeView\", \"focusedDate\", \"min\", \"max\", \"templateRef\", \"valueChange\", \"pageChange\", 4, \"ngIf\"], [3, \"activeView\", \"isActive\", \"cellTemplateRef\", \"headerTitleTemplateRef\", \"weekNumberTemplateRef\", \"cellUID\", \"min\", \"max\", \"focusedDate\", \"weekNumber\", \"selectedDates\", \"todayButtonClick\", \"cellClick\", \"weekNumberCellClick\", \"activeDateChange\", \"pageChange\"], [3, \"resize\"], [3, \"activeView\", \"focusedDate\", \"min\", \"max\", \"templateRef\", \"valueChange\", \"pageChange\"], [3, \"views\", \"min\", \"max\", \"isActive\", \"activeView\", \"bottomView\", \"topView\", \"weekNumber\", \"animateNavigation\", \"cellTemplate\", \"monthCellTemplate\", \"yearCellTemplate\", \"decadeCellTemplate\", \"centuryCellTemplate\", \"headerTitleTemplate\", \"weekNumberTemplate\", \"focusedDate\", \"selection\", \"value\", \"disabledDates\", \"activeViewChange\", \"valueChange\"], [\"multiviewcalendar\", \"\"], [3, \"today\", \"prevButtonTitle\", \"nextButtonTitle\"]];\n    },\n    template: function CalendarComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵelementContainer(0, 0);\n        ɵngcc0.ɵɵtemplate(1, CalendarComponent_ng_container_1_Template, 4, 12, \"ng-container\", 1);\n        ɵngcc0.ɵɵtemplate(2, CalendarComponent_ng_container_2_Template, 4, 23, \"ng-container\", 1);\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngIf\", ctx.type === \"infinite\");\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngIf\", ctx.type === \"classic\");\n      }\n    },\n    directives: function () {\n      return [CalendarLocalizedMessagesDirective, ɵngcc2.NgIf, ViewListComponent, ɵngcc3.ResizeSensorComponent, NavigationComponent, MultiViewCalendarComponent, MultiViewCalendarCustomMessagesComponent];\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n\n  __decorate([Input(), __metadata(\"design:type\", String)], CalendarComponent.prototype, \"id\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", Date), __metadata(\"design:paramtypes\", [Date])], CalendarComponent.prototype, \"focusedDate\", null);\n\n  __decorate([Input(), __metadata(\"design:type\", Date), __metadata(\"design:paramtypes\", [Date])], CalendarComponent.prototype, \"min\", null);\n\n  __decorate([Input(), __metadata(\"design:type\", Date), __metadata(\"design:paramtypes\", [Date])], CalendarComponent.prototype, \"max\", null);\n\n  __decorate([Input(), __metadata(\"design:type\", Boolean)], CalendarComponent.prototype, \"rangeValidation\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", String)], CalendarComponent.prototype, \"selection\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", Object), __metadata(\"design:paramtypes\", [Object])], CalendarComponent.prototype, \"value\", null);\n\n  __decorate([Input(), __metadata(\"design:type\", Boolean)], CalendarComponent.prototype, \"disabled\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", Number)], CalendarComponent.prototype, \"tabindex\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", Number), __metadata(\"design:paramtypes\", [Number])], CalendarComponent.prototype, \"tabIndex\", null);\n\n  __decorate([Input(), __metadata(\"design:type\", Object), __metadata(\"design:paramtypes\", [Object])], CalendarComponent.prototype, \"disabledDates\", null);\n\n  __decorate([Input(), __metadata(\"design:type\", Boolean)], CalendarComponent.prototype, \"navigation\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", String)], CalendarComponent.prototype, \"activeView\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", String)], CalendarComponent.prototype, \"bottomView\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", String)], CalendarComponent.prototype, \"topView\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", String), __metadata(\"design:paramtypes\", [String])], CalendarComponent.prototype, \"type\", null);\n\n  __decorate([Input(), __metadata(\"design:type\", Boolean)], CalendarComponent.prototype, \"animateNavigation\", void 0);\n\n  __decorate([Input(), HostBinding('class.k-week-number'), __metadata(\"design:type\", Boolean)], CalendarComponent.prototype, \"weekNumber\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], CalendarComponent.prototype, \"activeViewChange\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], CalendarComponent.prototype, \"activeViewDateChange\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], CalendarComponent.prototype, \"valueChange\", void 0);\n\n  __decorate([ContentChild(CellTemplateDirective, {\n    static: true\n  }), __metadata(\"design:type\", CellTemplateDirective)], CalendarComponent.prototype, \"cellTemplate\", void 0);\n\n  __decorate([Input('cellTemplate'), __metadata(\"design:type\", CellTemplateDirective), __metadata(\"design:paramtypes\", [CellTemplateDirective])], CalendarComponent.prototype, \"cellTemplateRef\", null);\n\n  __decorate([ContentChild(MonthCellTemplateDirective, {\n    static: true\n  }), __metadata(\"design:type\", MonthCellTemplateDirective)], CalendarComponent.prototype, \"monthCellTemplate\", void 0);\n\n  __decorate([Input('monthCellTemplate'), __metadata(\"design:type\", MonthCellTemplateDirective), __metadata(\"design:paramtypes\", [MonthCellTemplateDirective])], CalendarComponent.prototype, \"monthCellTemplateRef\", null);\n\n  __decorate([ContentChild(YearCellTemplateDirective, {\n    static: true\n  }), __metadata(\"design:type\", YearCellTemplateDirective)], CalendarComponent.prototype, \"yearCellTemplate\", void 0);\n\n  __decorate([Input('yearCellTemplate'), __metadata(\"design:type\", YearCellTemplateDirective), __metadata(\"design:paramtypes\", [YearCellTemplateDirective])], CalendarComponent.prototype, \"yearCellTemplateRef\", null);\n\n  __decorate([ContentChild(DecadeCellTemplateDirective, {\n    static: true\n  }), __metadata(\"design:type\", DecadeCellTemplateDirective)], CalendarComponent.prototype, \"decadeCellTemplate\", void 0);\n\n  __decorate([Input('decadeCellTemplate'), __metadata(\"design:type\", DecadeCellTemplateDirective), __metadata(\"design:paramtypes\", [DecadeCellTemplateDirective])], CalendarComponent.prototype, \"decadeCellTemplateRef\", null);\n\n  __decorate([ContentChild(CenturyCellTemplateDirective, {\n    static: true\n  }), __metadata(\"design:type\", CenturyCellTemplateDirective)], CalendarComponent.prototype, \"centuryCellTemplate\", void 0);\n\n  __decorate([Input('centuryCellTemplate'), __metadata(\"design:type\", CenturyCellTemplateDirective), __metadata(\"design:paramtypes\", [CenturyCellTemplateDirective])], CalendarComponent.prototype, \"centuryCellTemplateRef\", null);\n\n  __decorate([ContentChild(WeekNumberCellTemplateDirective, {\n    static: true\n  }), __metadata(\"design:type\", WeekNumberCellTemplateDirective)], CalendarComponent.prototype, \"weekNumberTemplate\", void 0);\n\n  __decorate([Input('weekNumberTemplate'), __metadata(\"design:type\", WeekNumberCellTemplateDirective), __metadata(\"design:paramtypes\", [WeekNumberCellTemplateDirective])], CalendarComponent.prototype, \"weekNumberTemplateRef\", null);\n\n  __decorate([ContentChild(HeaderTitleTemplateDirective, {\n    static: true\n  }), __metadata(\"design:type\", HeaderTitleTemplateDirective)], CalendarComponent.prototype, \"headerTitleTemplate\", void 0);\n\n  __decorate([Input('headerTitleTemplate'), __metadata(\"design:type\", HeaderTitleTemplateDirective), __metadata(\"design:paramtypes\", [HeaderTitleTemplateDirective])], CalendarComponent.prototype, \"headerTitleTemplateRef\", null);\n\n  __decorate([ContentChild(NavigationItemTemplateDirective, {\n    static: true\n  }), __metadata(\"design:type\", NavigationItemTemplateDirective)], CalendarComponent.prototype, \"navigationItemTemplate\", void 0);\n\n  __decorate([Input('navigationItemTemplate'), __metadata(\"design:type\", NavigationItemTemplateDirective), __metadata(\"design:paramtypes\", [NavigationItemTemplateDirective])], CalendarComponent.prototype, \"navigationItemTemplateRef\", null);\n\n  __decorate([ViewChild(NavigationComponent, {\n    static: false\n  }), __metadata(\"design:type\", NavigationComponent)], CalendarComponent.prototype, \"navigationView\", void 0);\n\n  __decorate([ViewChild(ViewListComponent, {\n    static: false\n  }), __metadata(\"design:type\", ViewListComponent)], CalendarComponent.prototype, \"monthView\", void 0);\n\n  __decorate([HostBinding('attr.id'), __metadata(\"design:type\", String), __metadata(\"design:paramtypes\", [])], CalendarComponent.prototype, \"widgetId\", null);\n\n  __decorate([HostBinding('attr.role'), __metadata(\"design:type\", String), __metadata(\"design:paramtypes\", [])], CalendarComponent.prototype, \"widgetRole\", null);\n\n  __decorate([HostBinding('attr.tabindex'), __metadata(\"design:type\", Number), __metadata(\"design:paramtypes\", [])], CalendarComponent.prototype, \"calendarTabIndex\", null);\n\n  __decorate([HostBinding('attr.aria-disabled'), HostBinding('class.k-state-disabled'), __metadata(\"design:type\", Boolean), __metadata(\"design:paramtypes\", [])], CalendarComponent.prototype, \"ariaDisabled\", null);\n\n  CalendarComponent = __decorate([__param(12, Optional()), __metadata(\"design:paramtypes\", [BusViewService, CalendarDOMService, ElementRef, NavigationService, Renderer2, ChangeDetectorRef, NgZone, Injector, ScrollSyncService, DisabledDatesService, LocalizationService, SelectionService, PickerService])], CalendarComponent);\n  /**\n   * @hidden\n   */\n\n  return CalendarComponent;\n})();\n\nconst incompleteDateValidator = () => {\n  return (control, incomplete) => {\n    if (!isPresent(control.value) && incomplete) {\n      return {\n        incompleteDate: true\n      };\n    } else {\n      return null;\n    }\n  };\n};\n/**\n * @hidden\n */\n\n\nvar Arrow = /*#__PURE__*/(() => {\n  (function (Arrow) {\n    Arrow[Arrow[\"Up\"] = 0] = \"Up\";\n    Arrow[Arrow[\"Down\"] = 1] = \"Down\";\n    Arrow[Arrow[\"None\"] = 2] = \"None\";\n  })(Arrow || (Arrow = {}));\n\n  return Arrow;\n})();\nvar DateInputComponent_1;\nconst MIN_DOC_LINK$1 = 'http://www.telerik.com/kendo-angular-ui/components/dateinputs/api/DateInputComponent/#toc-min';\nconst MAX_DOC_LINK$1 = 'http://www.telerik.com/kendo-angular-ui/components/dateinputs/api/DateInputComponent/#toc-max';\nconst VALUE_DOC_LINK$1 = 'http://www.telerik.com/kendo-angular-ui/components/dateinputs/dateinput/#toc-using-with-json';\nconst DATE_PART_REGEXP = /year|month|<day>/;\nconst TIME_PART_REGEXP = /hour|minute|second|millisecond/;\nconst SHORT_PATTERN_LENGTH_REGEXP = /d|M|H|h|m|s/;\nconst TWO_DIGIT_YEAR_MAX = 68;\nconst PREVIOUS_CENTURY_BASE = 1900;\nconst CURRENT_CENTURY_BASE = 2000;\nconst DEFAULT_FORMAT = 'd';\n\nconst padZero = length => new Array(Math.max(length, 0)).fill('0').join('');\n\nconst unpadZero = value => value.replace(/^0*/, '');\n\nclass Mask {\n  constructor() {\n    this.symbols = \"\";\n  }\n\n}\n\nclass KendoDate {\n  constructor(intl, formatPlaceholder, format, value, twoDigitYearMax = TWO_DIGIT_YEAR_MAX) {\n    this.intl = intl;\n    this.formatPlaceholder = formatPlaceholder;\n    this.format = format;\n    this.twoDigitYearMax = twoDigitYearMax;\n    this.year = true;\n    this.month = true;\n    this.date = true;\n    this.hours = true;\n    this.minutes = true;\n    this.seconds = true;\n    this.milliseconds = true;\n    this.leadingZero = null;\n    this.monthNames = null;\n    this.typedMonthPart = \"\";\n    this.value = getDate(new Date());\n    this.knownParts = \"adHhmMsSEy\";\n    this.symbols = {\n      \"E\": \"E\",\n      \"H\": \"H\",\n      \"M\": \"M\",\n      \"a\": \"a\",\n      \"d\": \"d\",\n      \"h\": \"h\",\n      \"m\": \"m\",\n      \"s\": \"s\",\n      \"S\": \"S\",\n      \"y\": \"y\"\n    };\n    validatePackage(packageMetadata);\n    this.monthNames = this.allFormatedMonths();\n    this.dayPeriods = this.allDayPeriods();\n\n    if (!value) {\n      this.value = getDate(new Date());\n      const sampleFormat = this.dateFormatString(this.value, this.format).symbols;\n\n      for (let i = 0; i < sampleFormat.length; i++) {\n        this.setExisting(sampleFormat[i], false);\n      }\n    } else {\n      this.value = cloneDate(value);\n    }\n  }\n\n  hasValue() {\n    const pred = (a, p) => a || p.type !== 'literal' && p.type !== 'dayperiod' && this.getExisting(p.pattern[0]);\n\n    return this.intl.splitDateFormat(this.format).reduce(pred, false);\n  }\n\n  shouldNormalizeCentury() {\n    return this.intl.splitDateFormat(this.format).some(part => part.pattern === 'yy');\n  }\n\n  getDateObject() {\n    for (let i = 0; i < this.knownParts.length; i++) {\n      if (!this.getExisting(this.knownParts[i])) {\n        return null;\n      }\n    }\n\n    return cloneDate(this.value);\n  }\n\n  getTextAndFormat(format) {\n    return this.merge(this.intl.formatDate(this.value, format), this.dateFormatString(this.value, format));\n  }\n\n  getExisting(symbol) {\n    switch (symbol) {\n      case \"y\":\n        return this.year;\n\n      case \"M\":\n      case \"L\":\n        return this.month;\n\n      case \"d\":\n        return this.date;\n\n      case \"E\":\n        return this.date && this.month && this.year;\n\n      case \"h\":\n      case \"H\":\n        return this.hours;\n\n      case \"m\":\n        return this.minutes;\n\n      case \"s\":\n        return this.seconds;\n\n      case \"S\":\n        return this.milliseconds;\n\n      default:\n        return true;\n    }\n  }\n\n  setExisting(symbol, value) {\n    switch (symbol) {\n      case \"y\":\n        this.year = value;\n\n        if (value === false) {\n          this.value.setFullYear(2000);\n        }\n\n        break;\n      //allow 2/29 dates\n\n      case \"M\":\n        this.month = value;\n\n        if (value === false) {\n          this.value.setMonth(0);\n        }\n\n        break;\n      //make sure you can type 31 at day part\n\n      case \"d\":\n        this.date = value;\n        break;\n\n      case \"h\":\n      case \"H\":\n        this.hours = value;\n        break;\n\n      case \"m\":\n        this.minutes = value;\n        break;\n\n      case \"s\":\n        this.seconds = value;\n        break;\n\n      case \"S\":\n        this.milliseconds = value;\n        break;\n\n      default:\n        return;\n    }\n  }\n\n  modifyPart(symbol, offset) {\n    let newValue = cloneDate(this.value);\n\n    switch (symbol) {\n      case \"y\":\n        newValue.setFullYear(newValue.getFullYear() + offset);\n        break;\n\n      case \"M\":\n        newValue = addMonths(this.value, offset);\n        break;\n\n      case \"d\":\n      case \"E\":\n        newValue.setDate(newValue.getDate() + offset);\n        break;\n\n      case \"h\":\n      case \"H\":\n        newValue.setHours(newValue.getHours() + offset);\n        break;\n\n      case \"m\":\n        newValue.setMinutes(newValue.getMinutes() + offset);\n        break;\n\n      case \"s\":\n        newValue.setSeconds(newValue.getSeconds() + offset);\n        break;\n\n      case \"S\":\n        newValue.setMilliseconds(newValue.getMilliseconds() + offset);\n        break;\n\n      case \"a\":\n        newValue.setHours(newValue.getHours() + 12 * offset);\n        break;\n\n      default:\n        break;\n    }\n\n    if (this.shouldNormalizeCentury()) {\n      newValue = this.normalizeCentury(newValue);\n    }\n\n    if (newValue.getFullYear() > 0) {\n      this.setExisting(symbol, true);\n      this.value = newValue;\n    }\n  }\n\n  parsePart(symbol, currentChar, resetSegmentValue) {\n    if (!currentChar) {\n      this.resetLeadingZero();\n      this.setExisting(symbol, false);\n      return {\n        value: null,\n        switchToNext: false\n      };\n    }\n\n    let baseDate = this.intl.formatDate(this.value, this.format);\n    let dateParts = this.dateFormatString(this.value, this.format);\n    let baseFormat = dateParts.symbols;\n    let replaced = false;\n    let prefix = \"\";\n    let current = \"\";\n    let suffix = \"\";\n\n    for (let i = 0; i < baseDate.length; i++) {\n      if (baseFormat[i] === symbol) {\n        current += this.getExisting(symbol) ? baseDate[i] : \"0\";\n        replaced = true;\n      } else if (!replaced) {\n        prefix += baseDate[i];\n      } else {\n        suffix += baseDate[i];\n      }\n    }\n\n    let currentMaxLength = current.length - 3;\n    let parsedDate = null;\n    const month = this.matchMonth(currentChar);\n    const dayPeriod = this.matchDayPeriod(currentChar, symbol);\n    const isZeroCurrentChar = currentChar === '0';\n    const leadingZero = (this.leadingZero || {})[symbol] || 0;\n\n    if (isZeroCurrentChar) {\n      let valueNumber = parseInt(resetSegmentValue ? currentChar : current + currentChar, 10);\n\n      if (valueNumber === 0 && !this.isAbbrMonth(dateParts.partMap, symbol)) {\n        this.incrementLeadingZero(symbol);\n      }\n    } else {\n      this.resetLeadingZero();\n    }\n\n    for (let i = Math.max(0, currentMaxLength); i <= current.length; i++) {\n      let middle = resetSegmentValue ? currentChar : current.substring(i) + currentChar;\n\n      if (symbol === \"S\" && resetSegmentValue) {\n        // The \"S\" parser in intl parses \"1\" as 100ms in order to handle ISOString dates correctly, so to get 1ms, we need to pass \"001\"\n        const padding = msPaddingFromFormat(baseFormat);\n        middle = padding + middle;\n      }\n\n      let middleNumber = parseInt(middle, 10);\n      parsedDate = this.intl.parseDate(prefix + middle + suffix, this.format);\n\n      if (!parsedDate && !isNaN(middleNumber) && !isNaN(parseInt(currentChar, 10))) {\n        if (symbol === 'M' && !month) {\n          const monthNumber = middleNumber - 1;\n\n          if (monthNumber > -1 && monthNumber < 12) {\n            parsedDate = cloneDate(this.value);\n            parsedDate.setMonth(monthNumber);\n\n            if (parsedDate.getMonth() !== monthNumber) {\n              parsedDate = lastDayOfMonth(addMonths(parsedDate, -1));\n            }\n          }\n        }\n\n        if (symbol === 'y') {\n          parsedDate = createDate(parseInt(middle, 10), this.month ? this.value.getMonth() : 0, this.date ? this.value.getDate() : 1, this.hours ? this.value.getHours() : 0, this.minutes ? this.value.getMinutes() : 0, this.seconds ? this.value.getSeconds() : 0, this.milliseconds ? this.value.getMilliseconds() : 0);\n\n          if (this.date && parsedDate.getDate() !== this.value.getDate()) {\n            parsedDate = lastDayOfMonth(addMonths(parsedDate, -1));\n          }\n        }\n      }\n\n      if (parsedDate) {\n        //move to next segment if the part will overflow with next char\n        //when start from empty date (01, then 010), padded zeros should be trimmed\n        const patternValue = this.partPattern(dateParts.partMap, symbol).pattern;\n        const peekDate = this.intl.parseDate(`${prefix}${this.peek(middle, patternValue)}${suffix}`, this.format);\n        const patternLength = this.patternLength(patternValue) || patternValue.length;\n        const patternSatisfied = leadingZero + (unpadZero(middle) || currentChar).length >= patternLength;\n        const switchToNext = peekDate === null || patternSatisfied;\n\n        if (this.shouldNormalizeCentury()) {\n          parsedDate = this.normalizeCentury(parsedDate);\n        }\n\n        this.value = parsedDate;\n        this.setExisting(symbol, true);\n        return {\n          value: this.value,\n          switchToNext: switchToNext\n        };\n      }\n    }\n\n    if (month) {\n      parsedDate = this.intl.parseDate(prefix + month + suffix, this.format);\n\n      if (parsedDate) {\n        this.value = parsedDate;\n        this.setExisting(symbol, true);\n        return {\n          value: this.value,\n          switchToNext: false\n        };\n      }\n    }\n\n    if (dayPeriod) {\n      parsedDate = this.intl.parseDate(prefix + dayPeriod + suffix, this.format);\n\n      if (parsedDate) {\n        this.value = parsedDate;\n        return {\n          value: this.value,\n          switchToNext: true\n        };\n      }\n    }\n\n    if (isZeroCurrentChar) {\n      this.setExisting(symbol, false);\n    }\n\n    return {\n      value: null,\n      switchToNext: false\n    };\n  }\n\n  resetLeadingZero() {\n    const hasLeadingZero = this.leadingZero !== null;\n    this.setLeadingZero(null);\n    return hasLeadingZero;\n  }\n\n  setLeadingZero(leadingZero) {\n    this.leadingZero = leadingZero;\n  }\n\n  normalizeCentury(date) {\n    if (!isPresent(date)) {\n      return date;\n    }\n\n    const twoDigitYear = cropTwoDigitYear(date);\n    const centuryBase = this.getNormalizedCenturyBase(twoDigitYear);\n    const normalizedDate = setYears(date, centuryBase + twoDigitYear);\n    return normalizedDate;\n  }\n\n  incrementLeadingZero(symbol) {\n    const leadingZero = this.leadingZero || {};\n    leadingZero[symbol] = (leadingZero[symbol] || 0) + 1;\n    this.leadingZero = leadingZero;\n  }\n\n  isAbbrMonth(parts, symbol) {\n    const pattern = this.partPattern(parts, symbol);\n    return pattern.type === 'month' && pattern.names;\n  }\n\n  partPattern(parts, symbol) {\n    return parts.filter(part => part.pattern.indexOf(symbol) !== -1)[0];\n  }\n\n  peek(value, pattern) {\n    const peekValue = unpadZero(value) + '0';\n    return padZero(pattern.length - peekValue.length) + peekValue;\n  }\n\n  matchMonth(typedChar) {\n    this.typedMonthPart += typedChar.toLowerCase();\n\n    if (!this.monthNames) {\n      return \"\";\n    }\n\n    while (this.typedMonthPart.length > 0) {\n      for (let i = 0; i < this.monthNames.length; i++) {\n        if (this.monthNames[i].toLowerCase().indexOf(this.typedMonthPart) === 0) {\n          return this.monthNames[i];\n        }\n      }\n\n      const monthAsNum = parseInt(this.typedMonthPart, 10);\n\n      if (monthAsNum >= 1 && monthAsNum <= 12 && monthAsNum.toString() === this.typedMonthPart\n      /*ensure they exact match*/\n      ) {\n        return this.monthNames[monthAsNum - 1];\n      }\n\n      this.typedMonthPart = this.typedMonthPart.substring(1, this.typedMonthPart.length);\n    }\n\n    return \"\";\n  }\n\n  matchDayPeriod(typedChar, symbol) {\n    const lowerChart = String(typedChar).toLowerCase();\n\n    if (symbol === 'a' && this.dayPeriods) {\n      if (this.dayPeriods.am.toLowerCase().startsWith(lowerChart)) {\n        return this.dayPeriods.am;\n      } else if (this.dayPeriods.pm.toLowerCase().startsWith(lowerChart)) {\n        return this.dayPeriods.pm;\n      }\n    }\n\n    return '';\n  }\n\n  allFormatedMonths() {\n    const dateFormatParts = this.intl.splitDateFormat(this.format);\n\n    for (let i = 0; i < dateFormatParts.length; i++) {\n      if (dateFormatParts[i].type === \"month\" && dateFormatParts[i].names) {\n        return this.intl.dateFormatNames(dateFormatParts[i].names);\n      }\n    }\n\n    return null;\n  }\n\n  allDayPeriods() {\n    const dateFormatParts = this.intl.splitDateFormat(this.format);\n\n    for (let i = 0; i < dateFormatParts.length; i++) {\n      if (dateFormatParts[i].type === \"dayperiod\" && dateFormatParts[i].names) {\n        return this.intl.dateFormatNames(dateFormatParts[i].names);\n      }\n    }\n\n    return null;\n  }\n\n  patternLength(pattern) {\n    if (pattern[0] === 'y') {\n      return 4;\n    }\n\n    if (SHORT_PATTERN_LENGTH_REGEXP.test(pattern)) {\n      return 2;\n    }\n\n    return 0;\n  } //TODO: REMOVE!\n\n\n  dateFormatString(date, format) {\n    const dateFormatParts = this.intl.splitDateFormat(format);\n    const parts = [];\n    const partMap = [];\n\n    for (let i = 0; i < dateFormatParts.length; i++) {\n      let partLength = this.intl.formatDate(date, {\n        pattern: dateFormatParts[i].pattern\n      }).length;\n\n      while (partLength > 0) {\n        parts.push(this.symbols[dateFormatParts[i].pattern[0]] || \"_\");\n        partMap.push(dateFormatParts[i]);\n        partLength--;\n      }\n    }\n\n    const returnValue = new Mask();\n    returnValue.symbols = parts.join(\"\");\n    returnValue.partMap = partMap;\n    return returnValue;\n  }\n\n  merge(text, mask) {\n    // Important: right to left.\n    let resultText = \"\";\n    let resultFormat = \"\";\n    let format = mask.symbols;\n\n    for (let r = format.length - 1; r >= 0; r--) {\n      if (this.knownParts.indexOf(format[r]) === -1 || this.getExisting(format[r])) {\n        resultText = text[r] + resultText;\n        resultFormat = format[r] + resultFormat;\n      } else {\n        const currentSymbol = format[r];\n\n        while (r >= 0 && currentSymbol === format[r]) {\n          r--;\n        }\n\n        r++;\n\n        if (this.leadingZero && this.leadingZero[currentSymbol]) {\n          resultText = '0' + resultText;\n        } else {\n          resultText = this.dateFieldName(mask.partMap[r]) + resultText;\n        }\n\n        while (resultFormat.length < resultText.length) {\n          resultFormat = format[r] + resultFormat;\n        }\n      }\n    }\n\n    return [resultText, resultFormat];\n  }\n\n  dateFieldName(part) {\n    const formatPlaceholder = this.formatPlaceholder || 'wide';\n\n    if (formatPlaceholder[part.type]) {\n      return formatPlaceholder[part.type];\n    }\n\n    if (formatPlaceholder === 'formatPattern') {\n      return part.pattern;\n    }\n\n    return this.intl.dateFieldName(Object.assign(part, {\n      nameType: formatPlaceholder\n    }));\n  }\n\n  getNormalizedCenturyBase(twoDigitYear) {\n    return twoDigitYear > this.twoDigitYearMax ? PREVIOUS_CENTURY_BASE : CURRENT_CENTURY_BASE;\n  }\n\n}\n/**\n * Represents the [Kendo UI DateInput component for Angular]({% slug overview_dateinput %}#toc-basic-usage).\n */\n\n\nlet DateInputComponent = DateInputComponent_1 = class DateInputComponent {\n  constructor(cdr, intl, renderer, element, ngZone, injector, localization, pickerService) {\n    this.cdr = cdr;\n    this.intl = intl;\n    this.renderer = renderer;\n    this.element = element;\n    this.ngZone = ngZone;\n    this.injector = injector;\n    this.localization = localization;\n    this.pickerService = pickerService;\n    /**\n     * @hidden\n     */\n\n    this.focusableId = `k-${guid()}`;\n    /**\n     * Sets or gets the `disabled` property of the DateInput and\n     * determines whether the component is active\n     * ([see example]({% slug disabled_dateinput %})).\n     */\n\n    this.disabled = false;\n    /**\n     * Sets or gets the read-only state of the DateInput\n     * ([see example]({% slug readonly_dateinput %})).\n     */\n\n    this.readonly = false;\n    /**\n     * Sets the title of the input element of the DateInput.\n     */\n\n    this.title = \"\";\n    /**\n     * Sets or gets the `tabIndex` property of the DateInput.\n     * .\n     */\n\n    this.tabindex = 0;\n    /**\n     * @hidden\n     */\n\n    this.role = 'spinbutton';\n    /**\n     * @hidden\n     */\n\n    this.ariaReadOnly = false;\n    /**\n     * Specifies the date format that is used to display the input value\n     * ([see example]({% slug formats_dateinput %})).\n     *\n     * Format value options:\n     * - `string` - Provide a `string` if a single format is going to be used regardless whether the input is focused or blurred.\n     * - [`FormatSettings`]({% slug api_dateinputs_formatsettings %}) - To display different formats when the component is focused or blurred, provide a settings object with specified `inputFormat` and `displayFormat` values.\n     */\n\n    this.format = DEFAULT_FORMAT;\n    /**\n     * Specifies the hint the DateInput displays when its value is `null`.\n     * For more information, refer to the article on\n     * [placeholders]({% slug placeholders_dateinput %}).\n     *\n     * @example\n     * ```ts\n     * _@Component({\n     * selector: 'my-app',\n     * template: `\n     *  <kendo-dateinput placeholder=\"Enter birth date...\"></kendo-dateinput>\n     * `\n     * })\n     * export class AppComponent { }\n     * ```\n     */\n\n    this.placeholder = null;\n    /**\n     * Configures the incremental steps of the DateInput.\n     * For more information, refer to the article on\n     * [incremental steps]({% slug incrementalsteps_dateinput %}).\n     *\n     * @example\n     * ```ts\n     * _@Component({\n     * selector: 'my-app',\n     * template: `\n     *  <kendo-dateinput [steps]=\"steps\"></kendo-dateinput>\n     * `\n     * })\n     * export class AppComponent {\n     *   public steps = { year: 10, month: 1, day: 5 };\n     * }\n     * ```\n     */\n\n    this.steps = {};\n    /**\n     * Determines whether the built-in min or max validators are to be enforced when a form is being validated.\n     */\n\n    this.rangeValidation = true;\n    /**\n     * @hidden\n     * Based on the min and max values, specifies whether the value will be auto-corrected while typing.\n     */\n\n    this.autoCorrect = false;\n    /**\n     * Determines whether the built-in validation for incomplete dates is to be enforced when a form is being validated.\n     */\n\n    this.incompleteDateValidation = false;\n    /**\n     * The maximum year to assume to be from the current century when typing two-digit year value\n     * ([see example]({% slug formats_dateinput %}#toc-two-digit-year-format)).\n     *\n     * The default value is 68, indicating that typing any value less than 69\n     * will be assumed to be 20xx, while 69 and larger will be assumed to be 19xx.\n     */\n\n    this.twoDigitYearMax = TWO_DIGIT_YEAR_MAX;\n    /**\n     * Specifies whether the **Up** and **Down** spin buttons will be rendered.\n     * For more information, refer to the article on\n     * [spinner buttons]({% slug spinbuttons_dateinput %}).\n     */\n\n    this.spinners = false;\n    /**\n     * @hidden\n     */\n\n    this.isPopupOpen = false;\n    /**\n     * @hidden\n     */\n\n    this.hasPopup = false;\n    /**\n     * Fires each time the user selects a new value.\n     * For more information, refer to the section on\n     * [events]({% slug overview_dateinput %}#toc-events).\n     */\n\n    this.valueChange = new EventEmitter();\n    /**\n     * @hidden\n     * Fires each time the user selects a new value.\n     * For more information, refer to the section on\n     * [events]({% slug overview_dateinput %}#toc-events).\n     */\n\n    this.valueUpdate = new EventEmitter();\n    /**\n     * Fires each time the user focuses the input element.\n     * For more information, refer to the section on\n     * [events]({% slug overview_dateinput %}#toc-events).\n     *\n     * > To wire the event programmatically, use the `onFocus` property.\n     *\n     * @example\n     * ```ts\n     * _@Component({\n     * selector: 'my-app',\n     * template: `\n     *  <kendo-dateinput (focus)=\"handleFocus()\"></kendo-dateinput>\n     * `\n     * })\n     * export class AppComponent {\n     *   public handleFocus(): void {\n     *      console.log(\"Component is focused\");\n     *   }\n     * }\n     * ```\n     *\n     */\n\n    this.onFocus = new EventEmitter(); //tslint:disable-line:no-output-rename\n\n    /**\n     * Fires each time the input element gets blurred.\n     * For more information, refer to the section on\n     * [events]({% slug overview_dateinput %}#toc-events).\n     *\n     * > To wire the event programmatically, use the `onBlur` property.\n     *\n     * @example\n     * ```ts\n     * _@Component({\n     * selector: 'my-app',\n     * template: `\n     *  <kendo-dateinput (blur)=\"handleBlur()\"></kendo-dateinput>\n     * `\n     * })\n     * export class AppComponent {\n     *   public handleBlur(): void {\n     *      console.log(\"Component is blurred\");\n     *   }\n     * }\n     * ```\n     *\n     */\n\n    this.onBlur = new EventEmitter(); //tslint:disable-line:no-output-rename\n\n    this.arrow = Arrow;\n    this.arrowDirection = Arrow.None;\n    this.formatSections = {\n      date: false,\n      time: false\n    };\n    this.hasMousedown = false;\n    this.focusedPriorToMousedown = false;\n    /**\n     * @hidden\n     */\n\n    this.isDateIncomplete = false;\n    this.currentValue = \"\";\n    this.currentFormat = \"\";\n    this.backspace = false;\n    this.resetSegmentValue = true;\n    this.minValidator = noop;\n    this.maxValidator = noop;\n    this.incompleteValidator = noop;\n    this._value = null;\n    this._active = false;\n    this.kendoDate = null;\n    this.paste = false;\n    this.domEvents = [];\n    this.onControlChange = noop;\n    this.onControlTouched = noop;\n    this.onValidatorChange = noop;\n    this.symbolsMap = this.dateSymbolMap();\n    this.updateFormatSections();\n\n    if (this.pickerService) {\n      this.pickerService.input = this;\n    }\n  }\n  /**\n   * @hidden\n   */\n\n\n  set tabIndex(tabIndex) {\n    this.tabindex = tabIndex;\n  }\n\n  get tabIndex() {\n    return this.tabindex;\n  }\n  /**\n   * Specifies the value of the DateInput component.\n   *\n   * > The `value` has to be a valid [JavaScript `Date`](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Date) instance.\n   */\n\n\n  set value(value) {\n    this.verifyValue(value);\n\n    if (this.autoCorrect && !isInRange(value, this.min, this.max)) {\n      return;\n    }\n\n    this._value = cloneDate(value);\n    this.valueUpdate.emit(cloneDate(value));\n  }\n\n  get value() {\n    return this._value;\n  }\n\n  get wrapperClass() {\n    return true;\n  }\n\n  get disabledClass() {\n    return this.disabled;\n  }\n\n  get inputElement() {\n    return this.dateInput ? this.dateInput.nativeElement : null;\n  }\n\n  get inputValue() {\n    return (this.inputElement || {}).value || '';\n  }\n\n  get isActive() {\n    return this._active;\n  }\n\n  set isActive(value) {\n    this._active = value;\n\n    if (!this.wrap) {\n      return;\n    }\n\n    if (!isPresent(this.pickerService)) {\n      const element = this.wrap.nativeElement;\n\n      if (value) {\n        this.renderer.addClass(element, 'k-state-focused');\n      } else {\n        this.renderer.removeClass(element, 'k-state-focused');\n      }\n    }\n  }\n\n  get inputFormat() {\n    if (!this.format) {\n      return DEFAULT_FORMAT;\n    }\n\n    if (typeof this.format === 'string') {\n      return this.format;\n    } else {\n      return this.format.inputFormat;\n    }\n  }\n\n  get displayFormat() {\n    if (!this.format) {\n      return DEFAULT_FORMAT;\n    }\n\n    if (typeof this.format === 'string') {\n      return this.format;\n    } else {\n      return this.format.displayFormat;\n    }\n  }\n  /**\n   * @hidden\n   * Used by the TextBoxContainer to determine if the component is empty\n   */\n\n\n  isEmpty() {\n    return !this.currentValue || !String(this.currentValue).trim();\n  }\n  /**\n   * @hidden\n   */\n\n\n  containsElement(element) {\n    return Boolean(closest(element, node => node === this.element.nativeElement));\n  }\n  /**\n   * @hidden\n   */\n\n\n  ngOnChanges(changes) {\n    this.verifyRange();\n\n    if (changes.min || changes.max || changes.rangeValidation || changes.incompleteDateValidation) {\n      this.minValidator = this.rangeValidation ? minValidator(this.min) : noop;\n      this.maxValidator = this.rangeValidation ? maxValidator(this.max) : noop;\n      this.incompleteValidator = this.incompleteDateValidation ? incompleteDateValidator() : noop;\n      this.onValidatorChange();\n    }\n\n    if (changes.format) {\n      this.symbolsMap = this.dateSymbolMap();\n      this.updateFormatSections();\n    }\n\n    const isEqualToKendoDate = this.kendoDate && isEqual(this.value, this.kendoDate.getDateObject());\n\n    if (changes.format || !isEqualToKendoDate || changes.placeholder) {\n      this.kendoDate = this.getKendoDate(this.value);\n      this.updateElementValue(this.isActive);\n    }\n  }\n\n  ngOnDestroy() {\n    if (this.intlSubscription) {\n      this.intlSubscription.unsubscribe();\n    }\n\n    if (this.pickerService) {\n      this.pickerService.input = null;\n    }\n\n    this.domEvents.forEach(unbindCallback => unbindCallback());\n  }\n  /**\n   * @hidden\n   */\n\n\n  validate(control) {\n    return this.minValidator(control) || this.maxValidator(control) || this.incompleteValidator(control, this.isDateIncomplete);\n  }\n  /**\n   * @hidden\n   */\n\n\n  registerOnValidatorChange(fn) {\n    this.onValidatorChange = fn;\n  }\n  /**\n   * @hidden\n   */\n\n\n  ngOnInit() {\n    this.kendoDate = this.getKendoDate(this.value);\n    this.updateElementValue();\n    this.intlSubscription = this.intl.changes.subscribe(this.intlChange.bind(this));\n    this.ngControl = this.injector.get(NgControl, null);\n\n    if (this.element) {\n      this.renderer.removeAttribute(this.element.nativeElement, 'tabindex');\n      this.ngZone.runOutsideAngular(() => {\n        this.bindEvents();\n      });\n    }\n  }\n  /**\n   * @hidden\n   */\n\n\n  setDisabledState(isDisabled) {\n    this.disabled = isDisabled;\n    this.cdr.markForCheck();\n  } //ngModel binding\n\n  /**\n   * @hidden\n   */\n\n\n  writeValue(value) {\n    this.verifyValue(value);\n    this.kendoDate = this.getKendoDate(value);\n    this.value = cloneDate(value);\n    this.updateElementValue(this.isActive);\n  }\n  /**\n   * @hidden\n   */\n\n\n  triggerChange() {\n    const value = this.kendoDate.getDateObject();\n\n    if (+value !== +this.value) {\n      this.value = cloneDate(value);\n      this.notify();\n    }\n  }\n  /**\n   * @hidden\n   */\n\n\n  notify() {\n    this.ngZone.run(() => {\n      this.onControlChange(cloneDate(this.value));\n      this.valueChange.emit(cloneDate(this.value));\n    });\n  }\n  /**\n   * @hidden\n   */\n\n\n  registerOnChange(fn) {\n    this.onControlChange = fn;\n  }\n  /**\n   * @hidden\n   */\n\n\n  registerOnTouched(fn) {\n    this.onControlTouched = fn;\n  }\n  /**\n   * Focuses the DateInput component.\n   *\n   * @example\n   * ```ts\n   * _@Component({\n   * selector: 'my-app',\n   * template: `\n   *  <button (click)=\"dateinput.focus()\">Focus date input</button>\n   *  <kendo-dateinput #dateinput></kendo-dateinput>\n   * `\n   * })\n   * export class AppComponent { }\n   * ```\n   */\n\n\n  focus() {\n    const input = this.inputElement;\n\n    if (input) {\n      input.focus();\n      this.selectDateSegment(this.currentFormat[0]);\n    }\n  }\n  /**\n   * Blurs the DateInput component.\n   */\n\n\n  blur() {\n    const input = this.inputElement;\n\n    if (input) {\n      input.blur();\n    }\n  }\n  /**\n   * @hidden\n   */\n\n\n  handleButtonClick(offset) {\n    this.arrowDirection = Arrow.None;\n    this.modifyDateSegmentValue(offset);\n  }\n  /**\n   * @hidden\n   */\n\n\n  modifyDateSegmentValue(offset) {\n    const caret = this.caret();\n    const symbol = this.currentFormat[caret[0]];\n    let step = (this.steps || {})[this.symbolsMap[symbol]] || 1;\n\n    if (symbol === \"S\" && !this.steps.millisecond) {\n      const msDigits = millisecondDigitsInFormat(this.inputFormat);\n      step = millisecondStepFor(msDigits);\n    }\n\n    this.kendoDate.modifyPart(symbol, offset * step);\n    this.putDateInRange();\n    this.updateElementValue(this.isActive);\n    this.triggerChange();\n    this.selectDateSegment(symbol);\n    this.updateIncompleteValidationStatus();\n  }\n  /**\n   * @hidden\n   */\n\n\n  switchDateSegment(offset) {\n    const caret = this.caret();\n\n    if (this.kendoDate.resetLeadingZero()) {\n      this.updateElementValue(this.isActive);\n    }\n\n    if (caret[0] < caret[1] && this.currentFormat[caret[0]] !== this.currentFormat[caret[1] - 1]) {\n      this.selectNearestSegment(offset > 0 ? caret[0] : caret[1] - 1);\n      this.resetSegmentValue = true;\n      return true;\n    }\n\n    const previousFormatSymbol = this.currentFormat[caret[0]];\n    let a = caret[0] + offset;\n\n    while (a > 0 && a < this.currentFormat.length) {\n      if (this.currentFormat[a] !== previousFormatSymbol && this.currentFormat[a] !== \"_\") {\n        break;\n      }\n\n      a += offset;\n    }\n\n    if (this.currentFormat[a] === \"_\") {\n      //there is not known symbol found\n      return false;\n    }\n\n    let b = a;\n\n    while (b >= 0 && b < this.currentFormat.length) {\n      if (this.currentFormat[b] !== this.currentFormat[a]) {\n        break;\n      }\n\n      b += offset;\n    }\n\n    if (a > b && (b + 1 !== caret[0] || a + 1 !== caret[1])) {\n      this.caret(b + 1, a + 1);\n      this.resetSegmentValue = true;\n      return true;\n    } else if (a < b && (a !== caret[0] || b !== caret[1])) {\n      this.caret(a, b);\n      this.resetSegmentValue = true;\n      return true;\n    }\n\n    return false;\n  }\n  /**\n   * @hidden\n   */\n\n\n  selectDateSegment(symbol) {\n    let begin = -1;\n    let end = 0;\n\n    for (let i = 0; i < this.currentFormat.length; i++) {\n      if (this.currentFormat[i] === symbol) {\n        end = i + 1;\n\n        if (begin === -1) {\n          begin = i;\n        }\n      }\n    }\n\n    if (begin < 0) {\n      begin = 0;\n    }\n\n    this.caret(0, 0);\n    this.caret(begin, end);\n  }\n  /**\n   * @hidden\n   */\n\n\n  handleClick() {\n    this.hasMousedown = false;\n\n    if (this.isActive) {\n      const selectionPresent = this.inputElement.selectionStart !== this.inputElement.selectionEnd;\n      const placeholderToggled = isPresent(this.placeholder) && !this.kendoDate.hasValue() && !this.focusedPriorToMousedown; // focus first segment if the user hasn't selected something during mousedown and if the placeholder was just toggled\n\n      const selectFirstSegment = !selectionPresent && placeholderToggled;\n      const index = selectFirstSegment ? 0 : this.caret()[0];\n      this.selectNearestSegment(index);\n    }\n  }\n  /**\n   * @hidden\n   */\n\n\n  handleDragAndDrop(args) {\n    args.preventDefault();\n  }\n  /**\n   * @hidden\n   */\n\n\n  handleMousedown() {\n    this.hasMousedown = true;\n    this.focusedPriorToMousedown = this.isActive;\n  }\n  /**\n   * @hidden\n   */\n\n\n  handleFocus(args) {\n    this.isActive = true;\n    this.updateElementValue();\n\n    if (!this.hasMousedown) {\n      this.caret(0, this.inputValue.length);\n    }\n\n    this.hasMousedown = false;\n\n    if (hasObservers(this.onFocus)) {\n      this.ngZone.run(() => {\n        this.emitFocus(args);\n      });\n    } else {\n      this.emitFocus(args);\n    }\n  }\n  /**\n   * @hidden\n   */\n\n\n  handleBlur(args) {\n    this.isActive = false;\n    this.resetSegmentValue = true;\n    this.kendoDate.resetLeadingZero();\n    this.updateElementValue();\n\n    if (hasObservers(this.onBlur) || requiresZoneOnBlur(this.ngControl)) {\n      this.ngZone.run(() => {\n        this.onControlTouched();\n        this.emitBlur(args);\n        this.cdr.markForCheck();\n      });\n    } else {\n      this.emitBlur(args);\n    }\n  }\n\n  getKendoDate(value) {\n    const {\n      leadingZero\n    } = this.kendoDate || {} || null;\n    const kendoDate = new KendoDate(this.intl, this.formatPlaceholder, this.inputFormat, value, this.twoDigitYearMax);\n    kendoDate.setLeadingZero(this.isActive ? leadingZero : null);\n    return kendoDate;\n  }\n\n  dateSymbolMap() {\n    const reducer = (map$$1, part) => {\n      map$$1[part.pattern[0]] = part.type;\n      return map$$1;\n    };\n\n    return this.intl.splitDateFormat(this.inputFormat).reduce(reducer, {});\n  }\n\n  updateElementValue(isActive) {\n    const start = this.caret()[0]; //XXX: get caret position before input is updated\n\n    const format = this.isActive ? this.inputFormat : this.displayFormat;\n    const texts = this.kendoDate.getTextAndFormat(format);\n    const showPlaceholder = !this.isActive && isPresent(this.placeholder) && !this.kendoDate.hasValue();\n    const input = this.inputElement;\n    this.currentFormat = texts[1];\n    this.currentValue = !showPlaceholder ? texts[0] : '';\n    this.renderer.setProperty(input, \"value\", this.currentValue);\n\n    if (input.placeholder !== this.placeholder) {\n      this.renderer.setProperty(input, \"placeholder\", this.placeholder);\n    }\n\n    if (isActive) {\n      this.selectNearestSegment(start);\n    }\n  }\n\n  caret(start, end = start) {\n    const isPosition = start !== undefined;\n    let returnValue = [start, start];\n    const element = this.inputElement;\n\n    if (isPosition && (this.disabled || this.readonly)) {\n      return undefined;\n    }\n\n    try {\n      if (element.selectionStart !== undefined) {\n        if (isPosition) {\n          if (isDocumentAvailable() && document.activeElement !== element) {\n            element.focus();\n          }\n\n          element.setSelectionRange(start, end);\n        }\n\n        returnValue = [element.selectionStart, element.selectionEnd];\n      }\n    } catch (e) {\n      returnValue = [];\n    }\n\n    return returnValue;\n  }\n\n  selectNearestSegment(index) {\n    // Finds the nearest (in both directions) known part.\n    for (let i = index, j = index - 1; i < this.currentFormat.length || j >= 0; i++, j--) {\n      if (i < this.currentFormat.length && this.currentFormat[i] !== \"_\") {\n        this.selectDateSegment(this.currentFormat[i]);\n        return;\n      }\n\n      if (j >= 0 && this.currentFormat[j] !== \"_\") {\n        this.selectDateSegment(this.currentFormat[j]);\n        return;\n      }\n    }\n  }\n\n  verifyRange() {\n    if (!isDevMode()) {\n      return;\n    }\n\n    if (!isValidRange(this.min, this.max)) {\n      throw new Error(`The max value should be bigger than the min. See ${MIN_DOC_LINK$1} and ${MAX_DOC_LINK$1}.`);\n    }\n  }\n\n  verifyValue(value) {\n    if (!isDevMode()) {\n      return;\n    }\n\n    if (value && !(value instanceof Date)) {\n      throw new Error(`The 'value' should be a valid JavaScript Date instance. Check ${VALUE_DOC_LINK$1} for possible resolution.`);\n    }\n  }\n\n  putDateInRange() {\n    const currentDate = this.kendoDate.getDateObject();\n    const candidate = dateInRange(currentDate, this.min, this.max);\n\n    if (this.autoCorrect && !isEqual(currentDate, candidate)) {\n      this.kendoDate = this.getKendoDate(candidate);\n    }\n  }\n\n  updateFormatSections() {\n    this.formatSections = this.intl.splitDateFormat(this.inputFormat).reduce(({\n      date,\n      time\n    }, p) => {\n      return {\n        date: date || DATE_PART_REGEXP.test(p.type),\n        time: time || TIME_PART_REGEXP.test(p.type)\n      };\n    }, {\n      date: false,\n      time: false\n    });\n  }\n\n  intlChange() {\n    this.updateFormatSections();\n    this.kendoDate = this.getKendoDate(this.value);\n    this.updateElementValue(this.isActive);\n  }\n\n  updateOnPaste() {\n    let value = this.intl.parseDate(this.inputValue, this.inputFormat) || this.value;\n\n    if (isPresent(value) && this.kendoDate.shouldNormalizeCentury()) {\n      value = this.kendoDate.normalizeCentury(value);\n    }\n\n    const notify = +value !== +this.value;\n    this.writeValue(value);\n\n    if (notify) {\n      this.notify();\n    }\n  }\n\n  bindEvents() {\n    const element = this.element.nativeElement;\n    const mousewheelHandler = this.handleMouseWheel.bind(this);\n    this.domEvents.push(this.renderer.listen(element, 'DOMMouseScroll', mousewheelHandler), this.renderer.listen(element, 'mousewheel', mousewheelHandler), this.renderer.listen(element, 'keydown', this.handleKeydown.bind(this)), this.renderer.listen(element, 'paste', this.handlePaste.bind(this)), this.renderer.listen(element, 'input', this.handleInput.bind(this)));\n  }\n\n  handleMouseWheel(event) {\n    if (this.disabled || this.readonly || !this.isActive) {\n      return;\n    }\n    /* tslint:disable-next-line:deprecation */\n\n\n    event = window.event || event;\n\n    if (event.shiftKey) {\n      this.switchDateSegment((event.wheelDelta || -event.detail) > 0 ? -1 : 1);\n    } else {\n      this.modifyDateSegmentValue((event.wheelDelta || -event.detail) > 0 ? 1 : -1);\n    }\n\n    event.returnValue = false;\n\n    if (event.preventDefault) {\n      event.preventDefault();\n    }\n\n    if (event.stopPropagation) {\n      event.stopPropagation();\n    }\n  }\n\n  handlePaste() {\n    this.paste = true;\n  }\n\n  handleKeydown(event) {\n    if (this.disabled || this.readonly || event.altKey || event.ctrlKey || event.metaKey) {\n      return;\n    }\n\n    if (event.keyCode === Keys.Tab) {\n      const moved = this.switchDateSegment(event.shiftKey ? -1 : 1);\n\n      if (moved) {\n        event.preventDefault();\n      }\n\n      return;\n    }\n\n    if (event.keyCode === Keys.Backspace) {\n      this.backspace = true;\n      return;\n    }\n\n    switch (event.keyCode) {\n      case Keys.ArrowDown:\n        this.modifyDateSegmentValue(-1);\n        break;\n\n      case Keys.ArrowUp:\n        this.modifyDateSegmentValue(1);\n        break;\n\n      case Keys.ArrowRight:\n        this.switchDateSegment(1);\n        break;\n\n      case Keys.ArrowLeft:\n        this.switchDateSegment(-1);\n        break;\n\n      case Keys.Home:\n        this.selectNearestSegment(0);\n        break;\n\n      case Keys.End:\n        this.selectNearestSegment(this.inputValue.length);\n        break;\n\n      default:\n        return;\n      //skip the preventDefault if we didn't handled the keyCode\n    }\n\n    event.preventDefault();\n  }\n\n  handleInput() {\n    if (this.disabled || this.readonly) {\n      return;\n    }\n\n    if (this.paste) {\n      this.updateOnPaste();\n      this.paste = false;\n      return;\n    }\n\n    const diff = approximateStringMatching(this.currentValue, this.currentFormat, this.inputValue, this.caret()[0]);\n    const navigationOnly = diff.length === 1 && diff[0][1] === \"_\";\n    let switchPart = false;\n\n    if (!navigationOnly) {\n      let parsedPart;\n\n      for (let i = 0; i < diff.length; i++) {\n        parsedPart = this.kendoDate.parsePart(diff[i][0], diff[i][1], this.resetSegmentValue);\n        switchPart = parsedPart.switchToNext;\n      }\n\n      const candidate = this.kendoDate.getDateObject();\n\n      if (this.value && candidate && !this.formatSections.date) {\n        this.kendoDate = this.getKendoDate(setTime(this.value, candidate));\n      }\n    }\n\n    this.resetSegmentValue = false;\n    this.putDateInRange();\n    this.updateElementValue(this.isActive);\n    this.triggerChange();\n    this.updateIncompleteValidationStatus();\n\n    if (diff.length && diff[0][0] !== \"_\") {\n      this.selectDateSegment(diff[0][0]);\n    }\n\n    if (switchPart || navigationOnly) {\n      this.switchDateSegment(1);\n    }\n\n    if (this.backspace) {\n      this.switchDateSegment(-1);\n    }\n\n    this.backspace = false;\n  }\n\n  emitFocus(args) {\n    this.onFocus.emit();\n\n    if (this.pickerService) {\n      this.pickerService.onFocus.emit(args);\n    }\n  }\n\n  emitBlur(args) {\n    this.onBlur.emit();\n\n    if (this.pickerService) {\n      this.pickerService.onBlur.emit(args);\n    }\n  }\n\n  updateIncompleteValidationStatus() {\n    const previousValue = this.isDateIncomplete;\n    this.isDateIncomplete = this.kendoDate.hasValue() && this.value === null;\n\n    if (previousValue === this.isDateIncomplete || !this.incompleteDateValidation) {\n      return;\n    }\n\n    if (isPresent(this.ngControl) && !isPresent(this.pickerService)) {\n      this.cdr.markForCheck();\n      this.ngZone.run(() => this.onValidatorChange());\n    } else if (isPresent(this.pickerService)) {\n      this.pickerService.dateCompletenessChange.emit();\n    }\n  }\n\n};\n\nDateInputComponent.ɵfac = function DateInputComponent_Factory(t) {\n  return new (t || DateInputComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.IntlService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Injector), ɵngcc0.ɵɵdirectiveInject(ɵngcc4.LocalizationService), ɵngcc0.ɵɵdirectiveInject(PickerService, 8));\n};\n\nDateInputComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n  type: DateInputComponent,\n  selectors: [[\"kendo-dateinput\"]],\n  viewQuery: function DateInputComponent_Query(rf, ctx) {\n    if (rf & 1) {\n      ɵngcc0.ɵɵviewQuery(_c10, 7);\n      ɵngcc0.ɵɵviewQuery(_c11, 5);\n    }\n\n    if (rf & 2) {\n      let _t;\n\n      ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.dateInput = _t.first);\n      ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.wrap = _t.first);\n    }\n  },\n  hostVars: 6,\n  hostBindings: function DateInputComponent_HostBindings(rf, ctx) {\n    if (rf & 2) {\n      ɵngcc0.ɵɵclassProp(\"k-widget\", ctx.wrapperClass)(\"k-dateinput\", ctx.wrapperClass)(\"k-state-disabled\", ctx.disabledClass);\n    }\n  },\n  inputs: {\n    focusableId: \"focusableId\",\n    disabled: \"disabled\",\n    readonly: \"readonly\",\n    title: \"title\",\n    tabindex: \"tabindex\",\n    role: \"role\",\n    ariaReadOnly: \"ariaReadOnly\",\n    format: \"format\",\n    placeholder: \"placeholder\",\n    steps: \"steps\",\n    rangeValidation: \"rangeValidation\",\n    autoCorrect: \"autoCorrect\",\n    incompleteDateValidation: \"incompleteDateValidation\",\n    twoDigitYearMax: \"twoDigitYearMax\",\n    spinners: \"spinners\",\n    isPopupOpen: \"isPopupOpen\",\n    hasPopup: \"hasPopup\",\n    tabIndex: \"tabIndex\",\n    value: \"value\",\n    formatPlaceholder: \"formatPlaceholder\",\n    max: \"max\",\n    min: \"min\"\n  },\n  outputs: {\n    valueChange: \"valueChange\",\n    valueUpdate: \"valueUpdate\",\n    onFocus: \"focus\",\n    onBlur: \"blur\"\n  },\n  exportAs: [\"kendo-dateinput\"],\n  features: [ɵngcc0.ɵɵProvidersFeature([{\n    provide: NG_VALUE_ACCESSOR,\n    useExisting: forwardRef(() => DateInputComponent_1),\n    multi: true\n  }, {\n    provide: NG_VALIDATORS,\n    useExisting: forwardRef(() => DateInputComponent_1),\n    multi: true\n  }, {\n    provide: L10N_PREFIX,\n    useValue: 'kendo.dateinput'\n  }, {\n    provide: KendoInput,\n    useExisting: forwardRef(() => DateInputComponent_1)\n  }, LocalizationService]), ɵngcc0.ɵɵNgOnChangesFeature],\n  decls: 6,\n  vars: 21,\n  consts: function () {\n    let i18n_12;\n\n    if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n      /**\n       * @desc The label for the **Increment** button in the DateInput\n       * @meaning kendo.dateinput.increment\n       */\n      const MSG_EXTERNAL_589112377451589685$$DIST_FESM2015_INDEX_JS_13 = goog.getMsg(\"Increase value\");\n      i18n_12 = MSG_EXTERNAL_589112377451589685$$DIST_FESM2015_INDEX_JS_13;\n    } else {\n      i18n_12 = $localize`:kendo.dateinput.increment|The label for the **Increment** button in the DateInput␟a55944f9de69e7cc86b91200fe96f980a947d704␟589112377451589685:Increase value`;\n    }\n\n    let i18n_14;\n\n    if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n      /**\n       * @desc The label for the **Decrement** button in the DateInput\n       * @meaning kendo.dateinput.decrement\n       */\n      const MSG_EXTERNAL_6980524091606682769$$DIST_FESM2015_INDEX_JS_15 = goog.getMsg(\"Decrease value\");\n      i18n_14 = MSG_EXTERNAL_6980524091606682769$$DIST_FESM2015_INDEX_JS_15;\n    } else {\n      i18n_14 = $localize`:kendo.dateinput.decrement|The label for the **Decrement** button in the DateInput␟0eded761107e6dad120997006a7f915bade9b15c␟6980524091606682769:Decrease value`;\n    }\n\n    return [[\"kendoDateInputLocalizedMessages\", \"\", \"increment\", i18n_12, \"decrement\", i18n_14], [1, \"k-dateinput-wrap\"], [\"wrap\", \"\"], [\"autocomplete\", \"off\", \"autocorrect\", \"off\", \"autocapitalize\", \"off\", \"spellcheck\", \"false\", 1, \"k-input\", 3, \"id\", \"title\", \"tabindex\", \"disabled\", \"readonly\", \"placeholder\", \"kendoEventsOutsideAngular\", \"scope\"], [\"dateInput\", \"\"], [\"class\", \"k-select\", 3, \"mousedown\", 4, \"ngIf\"], [1, \"k-select\", 3, \"mousedown\"], [1, \"k-link\", \"k-link-increase\", 3, \"title\", \"mousedown\", \"mouseleave\", \"click\"], [1, \"k-icon\", \"k-i-arrow-n\"], [1, \"k-link\", \"k-link-decrease\", 3, \"title\", \"click\", \"mousedown\", \"mouseleave\"], [1, \"k-icon\", \"k-i-arrow-s\"]];\n  },\n  template: function DateInputComponent_Template(rf, ctx) {\n    if (rf & 1) {\n      ɵngcc0.ɵɵelementContainer(0, 0);\n      ɵngcc0.ɵɵelementStart(1, \"span\", 1, 2);\n      ɵngcc0.ɵɵelement(3, \"input\", 3, 4);\n      ɵngcc0.ɵɵtemplate(5, DateInputComponent_span_5_Template, 5, 8, \"span\", 5);\n      ɵngcc0.ɵɵelementEnd();\n    }\n\n    if (rf & 2) {\n      ɵngcc0.ɵɵadvance(3);\n      ɵngcc0.ɵɵproperty(\"id\", ctx.focusableId)(\"title\", ctx.title)(\"tabindex\", ctx.tabindex)(\"disabled\", ctx.disabled)(\"readonly\", ctx.readonly)(\"placeholder\", ctx.placeholder)(\"kendoEventsOutsideAngular\", ɵngcc0.ɵɵpureFunction7(13, _c16, ctx.handleClick, ctx.handleFocus, ctx.handleMousedown, ctx.handleMousedown, ctx.handleDragAndDrop, ctx.handleDragAndDrop, ctx.handleBlur))(\"scope\", ctx);\n      ɵngcc0.ɵɵattribute(\"role\", ctx.role)(\"aria-readonly\", ctx.ariaReadOnly)(\"aria-expanded\", ctx.isPopupOpen)(\"aria-haspopup\", ctx.hasPopup);\n      ɵngcc0.ɵɵadvance(2);\n      ɵngcc0.ɵɵproperty(\"ngIf\", ctx.spinners);\n    }\n  },\n  directives: function () {\n    return [DateInputLocalizedMessagesDirective, ɵngcc3.EventsOutsideAngularDirective, ɵngcc2.NgIf];\n  },\n  encapsulation: 2,\n  changeDetection: 0\n});\n\n__decorate([Input(), __metadata(\"design:type\", String)], DateInputComponent.prototype, \"focusableId\", void 0);\n\n__decorate([Input(), __metadata(\"design:type\", Boolean)], DateInputComponent.prototype, \"disabled\", void 0);\n\n__decorate([Input(), __metadata(\"design:type\", Boolean)], DateInputComponent.prototype, \"readonly\", void 0);\n\n__decorate([Input(), __metadata(\"design:type\", String)], DateInputComponent.prototype, \"title\", void 0);\n\n__decorate([Input(), __metadata(\"design:type\", Number)], DateInputComponent.prototype, \"tabindex\", void 0);\n\n__decorate([Input(), __metadata(\"design:type\", String)], DateInputComponent.prototype, \"role\", void 0);\n\n__decorate([Input(), __metadata(\"design:type\", Boolean)], DateInputComponent.prototype, \"ariaReadOnly\", void 0);\n\n__decorate([Input(), __metadata(\"design:type\", Number), __metadata(\"design:paramtypes\", [Number])], DateInputComponent.prototype, \"tabIndex\", null);\n\n__decorate([Input(), __metadata(\"design:type\", Object)], DateInputComponent.prototype, \"format\", void 0);\n\n__decorate([Input(), __metadata(\"design:type\", Object)], DateInputComponent.prototype, \"formatPlaceholder\", void 0);\n\n__decorate([Input(), __metadata(\"design:type\", String)], DateInputComponent.prototype, \"placeholder\", void 0);\n\n__decorate([Input(), __metadata(\"design:type\", Object)], DateInputComponent.prototype, \"steps\", void 0);\n\n__decorate([Input(), __metadata(\"design:type\", Date)], DateInputComponent.prototype, \"max\", void 0);\n\n__decorate([Input(), __metadata(\"design:type\", Date)], DateInputComponent.prototype, \"min\", void 0);\n\n__decorate([Input(), __metadata(\"design:type\", Boolean)], DateInputComponent.prototype, \"rangeValidation\", void 0);\n\n__decorate([Input(), __metadata(\"design:type\", Boolean)], DateInputComponent.prototype, \"autoCorrect\", void 0);\n\n__decorate([Input(), __metadata(\"design:type\", Boolean)], DateInputComponent.prototype, \"incompleteDateValidation\", void 0);\n\n__decorate([Input(), __metadata(\"design:type\", Number)], DateInputComponent.prototype, \"twoDigitYearMax\", void 0);\n\n__decorate([Input(), __metadata(\"design:type\", Date), __metadata(\"design:paramtypes\", [Date])], DateInputComponent.prototype, \"value\", null);\n\n__decorate([Input(), __metadata(\"design:type\", Boolean)], DateInputComponent.prototype, \"spinners\", void 0);\n\n__decorate([Input(), __metadata(\"design:type\", Boolean)], DateInputComponent.prototype, \"isPopupOpen\", void 0);\n\n__decorate([Input(), __metadata(\"design:type\", Boolean)], DateInputComponent.prototype, \"hasPopup\", void 0);\n\n__decorate([Output(), __metadata(\"design:type\", EventEmitter)], DateInputComponent.prototype, \"valueChange\", void 0);\n\n__decorate([Output(), __metadata(\"design:type\", EventEmitter)], DateInputComponent.prototype, \"valueUpdate\", void 0);\n\n__decorate([Output('focus'), __metadata(\"design:type\", EventEmitter)], DateInputComponent.prototype, \"onFocus\", void 0);\n\n__decorate([Output('blur'), __metadata(\"design:type\", EventEmitter)], DateInputComponent.prototype, \"onBlur\", void 0);\n\n__decorate([ViewChild('dateInput', {\n  static: true\n}), __metadata(\"design:type\", ElementRef)], DateInputComponent.prototype, \"dateInput\", void 0);\n\n__decorate([ViewChild('wrap', {\n  static: false\n}), __metadata(\"design:type\", ElementRef)], DateInputComponent.prototype, \"wrap\", void 0);\n\n__decorate([HostBinding('class.k-widget'), HostBinding('class.k-dateinput'), __metadata(\"design:type\", Boolean), __metadata(\"design:paramtypes\", [])], DateInputComponent.prototype, \"wrapperClass\", null);\n\n__decorate([HostBinding('class.k-state-disabled'), __metadata(\"design:type\", Boolean), __metadata(\"design:paramtypes\", [])], DateInputComponent.prototype, \"disabledClass\", null);\n\nDateInputComponent = DateInputComponent_1 = __decorate([__param(7, Optional()), __metadata(\"design:paramtypes\", [ChangeDetectorRef, IntlService, Renderer2, ElementRef, NgZone, Injector, LocalizationService, PickerService])], DateInputComponent);\n/**\n * A preventable event instance which is triggered by the `open` and `close` events.\n */\n\nclass PreventableEvent {\n  constructor() {\n    this.prevented = false;\n  }\n  /**\n   * Prevents the default action for a specified event.\n   * In this way, the source component suppresses the built-in behavior that follows the event.\n   */\n\n\n  preventDefault() {\n    this.prevented = true;\n  }\n  /**\n   * If the event is prevented by any of its subscribers, returns `true`.\n   *\n   * @returns `true` if the default action was prevented. Otherwise, returns `false`.\n   */\n\n\n  isDefaultPrevented() {\n    return this.prevented;\n  }\n\n}\n/**\n * @hidden\n */\n\n\nconst TOUCH_ENABLED = new InjectionToken('dateinputs-touch-enabled');\n/**\n * @hidden\n */\n\nconst disabledDatesValidator = isDateDisabled => {\n  return control => {\n    if (!isDateDisabled || !control.value) {\n      return null;\n    }\n\n    const error = {\n      disabledDate: true\n    };\n    return isDateDisabled(control.value) ? error : null;\n  };\n};\n/* tslint:disable:max-line-length */\n\n\nvar DatePickerComponent_1;\nconst MIN_DOC_LINK$2 = 'http://www.telerik.com/kendo-angular-ui/components/dateinputs/api/DatePickerComponent/#toc-min';\nconst MAX_DOC_LINK$2 = 'http://www.telerik.com/kendo-angular-ui/components/dateinputs/api/DatePickerComponent/#toc-max';\nconst VALUE_DOC_LINK$2 = 'http://www.telerik.com/kendo-angular-ui/components/dateinputs/datepicker/#toc-using-with-json';\nconst DEFAULT_FORMAT$1 = 'd';\nconst TWO_DIGIT_YEAR_MAX$1 = 68;\n/**\n * Represents the [Kendo UI DatePicker component for Angular]({% slug overview_datepicker %}#toc-basic-usage).\n */\n\nlet DatePickerComponent = DatePickerComponent_1 = class DatePickerComponent {\n  constructor(zone, localization, cdr, popupService, element, renderer, injector, pickerService, disabledDatesService, touchEnabled$$1) {\n    this.zone = zone;\n    this.localization = localization;\n    this.cdr = cdr;\n    this.popupService = popupService;\n    this.element = element;\n    this.renderer = renderer;\n    this.injector = injector;\n    this.pickerService = pickerService;\n    this.disabledDatesService = disabledDatesService;\n    this.touchEnabled = touchEnabled$$1;\n    /**\n     * @hidden\n     */\n\n    this.focusableId = `k-${guid()}`;\n    /**\n     * Defines the active view that the Calendar initially renders\n     * ([see example]({% slug calendar_type_datepicker %}#toc-active-view)).\n     * By default, the active view is `month`.\n     *\n     * > You have to set `activeView` within the `topView`-`bottomView` range.\n     */\n\n    this.activeView = CalendarViewEnum[CalendarViewEnum.month];\n    /**\n     * Defines the bottommost Calendar view to which the user can navigate\n     * ([see example]({% slug calendar_type_datepicker %}#toc-focused-dates)).\n     */\n\n    this.bottomView = CalendarViewEnum[CalendarViewEnum.month];\n    /**\n     * Defines the topmost Calendar view to which the user can navigate\n     * ([see example]({% slug calendar_type_datepicker %}#toc-focused-dates)).\n     */\n\n    this.topView = CalendarViewEnum[CalendarViewEnum.century];\n    /**\n     * Specifies the Calendar type.\n     *\n     * The possible values are:\n     * - `infinite` (default)\n     * - `classic`\n     *\n     */\n\n    this.calendarType = 'infinite';\n    /**\n     * Determines whether to enable animation when navigating to previous/next Calendar view.\n     * Applies to the [`classic`]({% slug api_dateinputs_datepickercomponent %}#toc-calendartype) Calendar only.\n     *\n     * > This feature uses the [Web Animations API](https://developer.mozilla.org/en-US/docs/Web/API/Web_Animations_API). In order to run the animation in browsers that do not support it, you need the `web-animations-js` polyfill.\n     *\n     * @default false\n     */\n\n    this.animateCalendarNavigation = false;\n    /**\n     * Sets or gets the `disabled` property of the DatePicker and determines whether the component is active\n     * ([see example]({% slug disabled_datepicker %})).\n     */\n\n    this.disabled = false;\n    /**\n     * Sets the read-only state of the DatePicker\n     * ([see example]({% slug readonly_datepicker %}#toc-read-only-datepicker)).\n     */\n\n    this.readonly = false;\n    /**\n     * Sets the read-only state of the DatePicker input field\n     * ([see example]({% slug readonly_datepicker %}#toc-read-only-input)).\n     *\n     * > Note that if you set the [`readonly`]({% slug api_dateinputs_datepickercomponent %}#toc-readonly) property value to `true`,\n     * the input will be rendered in a read-only state regardless of the `readOnlyInput` value.\n     */\n\n    this.readOnlyInput = false;\n    /**\n     * Sets or gets the `navigation` property of the Calendar\n     * and determines whether the navigation side-bar is displayed.\n     * ([see example]({% slug sidebar_datepicker %})).\n     */\n\n    this.navigation = true;\n    /**\n     * Specifies the smallest valid date\n     * ([see example]({% slug dateranges_datepicker %})).\n     */\n\n    this.min = cloneDate(MIN_DATE);\n    /**\n     * Specifies the biggest valid date\n     * ([see example]({% slug dateranges_datepicker %})).\n     */\n\n    this.max = cloneDate(MAX_DATE);\n    /**\n     * Determines whether the built-in validation for incomplete dates is to be enforced when a form is being validated.\n     */\n\n    this.incompleteDateValidation = false;\n    /**\n     * Specifies the focused date of the Calendar component\n     * ([see example]({% slug calendar_type_datepicker %}#toc-focused-dates)).\n     */\n\n    this.focusedDate = null;\n    /**\n     * Specifies the date format that is used to display the input value\n     * ([see example]({% slug formats_datepicker %})).\n     *\n     * Format value options:\n     * - `string` - Provide a `string` if a single format is going to be used regardless whether the input is focused or blurred.\n     * - [`FormatSettings`]({% slug api_dateinputs_formatsettings %}) - To display different formats when the component is focused or blurred, provide a settings object with specified `inputFormat` and `displayFormat` values.\n     */\n\n    this.format = DEFAULT_FORMAT$1;\n    /**\n     * The maximum year to assume to be from the current century when typing two-digit year value\n     * ([see example]({% slug formats_datepicker %}#toc-two-digit-year-format)).\n     *\n     * The default value is 68, indicating that typing any value less than 69\n     * will be assumed to be 20xx, while 69 and larger will be assumed to be 19xx.\n     */\n\n    this.twoDigitYearMax = TWO_DIGIT_YEAR_MAX$1;\n    /**\n     * Specifies the hint the DatePicker displays when its value is `null`.\n     * ([more information and exaples]({% slug placeholders_datepicker %})).\n     *\n     * @example\n     * ```ts\n     * _@Component({\n     * selector: 'my-app',\n     * template: `\n     *  <kendo-datepicker placeholder=\"Enter birth date...\"></kendo-datepicker>\n     * `\n     * })\n     * export class AppComponent { }\n     * ```\n     */\n\n    this.placeholder = null;\n    /**\n     * Sets or gets the `tabindex` property of the DatePicker.\n     */\n\n    this.tabindex = 0;\n    /**\n     * Sets the title of the input element of the DatePicker.\n     */\n\n    this.title = \"\";\n    /**\n     * Determines whether the built-in min or max validators are enforced when validating a form.\n     */\n\n    this.rangeValidation = true;\n    /**\n     * Determines whether the built-in validator for disabled\n     * date ranges is enforced when validating a form\n     * ([see example]({% slug disabled_dates_datepicker %}#toc-validation)).\n     */\n\n    this.disabledDatesValidation = true;\n    /**\n     * Determines whether to display a week number column in the `month` view of the Calendar\n     * ([see example]({% slug calendar_type_datepicker %}#toc-week-number-column)).\n     */\n\n    this.weekNumber = false;\n    /**\n     * Fires each time the user selects a new value\n     * ([more information and example]({% slug overview_datepicker %}#toc-events)).\n     */\n\n    this.valueChange = new EventEmitter();\n    /**\n     * Fires each time the user focuses the input element\n     * ([more information and example]({% slug overview_datepicker %}#toc-events)).\n     *\n     * > To wire the event programmatically, use the `onFocus` property.\n     *\n     * @example\n     * ```ts\n     * _@Component({\n     * selector: 'my-app',\n     * template: `\n     *  <kendo-datepicker (focus)=\"handleFocus()\"></kendo-datepicker>\n     * `\n     * })\n     * export class AppComponent {\n     *   public handleFocus(): void {\n     *      console.log(\"Component is focused\");\n     *   }\n     * }\n     * ```\n     */\n\n    this.onFocus = new EventEmitter(); //tslint:disable-line:no-output-rename\n\n    /**\n     * Fires each time the input element gets blurred\n     * ([more information and example]({% slug overview_datepicker %}#toc-events)).\n     *\n     * > To wire the event programmatically, use the `onBlur` property.\n     *\n     * @example\n     * ```ts\n     * _@Component({\n     * selector: 'my-app',\n     * template: `\n     *  <kendo-datepicker (blur)=\"handleBlur()\"></kendo-datepicker>\n     * `\n     * })\n     * export class AppComponent {\n     *   public handleBlur(): void {\n     *      console.log(\"Component is blurred\");\n     *   }\n     * }\n     * ```\n     */\n\n    this.onBlur = new EventEmitter(); //tslint:disable-line:no-output-rename\n\n    /**\n     * Fires each time the popup is about to open.\n     * This event is preventable. If you cancel the event, the popup will remain closed\n     * ([more information and example]({% slug overview_datepicker %}#toc-events)).\n     */\n\n    this.open = new EventEmitter();\n    /**\n     * Fires each time the popup is about to close.\n     * This event is preventable. If you cancel the event, the popup will remain open\n     * ([more information and example]({% slug overview_datepicker %}#toc-events)).\n     */\n\n    this.close = new EventEmitter();\n    /**\n     * @hidden\n     */\n\n    this.wrapperClasses = true;\n    this.popupUID = guid();\n    this._popupSettings = {\n      animate: true\n    };\n    this._show = false;\n    this._value = null;\n    this._active = false;\n    this.onControlChange = noop;\n    this.onControlTouched = noop;\n    this.onValidatorChange = noop;\n    this.minValidateFn = noop;\n    this.maxValidateFn = noop;\n    this.disabledDatesValidateFn = noop;\n    this.incompleteValidator = noop;\n    this.resolvedPromise = Promise.resolve(null);\n    this.domEvents = [];\n    validatePackage(packageMetadata);\n    this.pickerSubscriptions = this.pickerService.onFocus.subscribe(this.handleFocus.bind(this));\n    this.pickerSubscriptions.add(this.pickerService.onBlur.subscribe(this.handleBlur.bind(this)));\n    this.pickerSubscriptions.add(this.pickerService.sameDateSelected.subscribe(this.handleSameSelection.bind(this)));\n    this.pickerSubscriptions.add(this.pickerService.dateCompletenessChange.subscribe(this.handleDateCompletenessChange.bind(this)));\n  }\n  /**\n   * @hidden\n   */\n\n\n  set cellTemplateRef(template) {\n    this.cellTemplate = template;\n  }\n  /**\n   * @hidden\n   */\n\n\n  set monthCellTemplateRef(template) {\n    this.monthCellTemplate = template;\n  }\n  /**\n   * @hidden\n   */\n\n\n  set yearCellTemplateRef(template) {\n    this.yearCellTemplate = template;\n  }\n  /**\n   * @hidden\n   */\n\n\n  set decadeCellTemplateRef(template) {\n    this.decadeCellTemplate = template;\n  }\n  /**\n   * @hidden\n   */\n\n\n  set centuryCellTemplateRef(template) {\n    this.centuryCellTemplate = template;\n  }\n  /**\n   * @hidden\n   */\n\n\n  set weekNumberTemplateRef(template) {\n    this.weekNumberTemplate = template;\n  }\n  /**\n   * @hidden\n   */\n\n\n  set headerTitleTemplateRef(template) {\n    this.headerTitleTemplate = template;\n  }\n  /**\n   * @hidden\n   */\n\n\n  set navigationItemTemplateRef(template) {\n    this.navigationItemTemplate = template;\n  }\n  /**\n   * Configures the popup options of the DatePicker.\n   *\n   * The available options are:\n   * - `animate: Boolean`&mdash;Controls the popup animation. By default, the open and close animations are enabled.\n   * - `appendTo: 'root' | 'component' | ViewContainerRef`&mdash;Controls the popup container. By default, the popup will be appended to the root component.\n   * - `popupClass: String`&mdash;Specifies a list of CSS classes that are used to style the popup.\n   */\n\n\n  set popupSettings(settings) {\n    this._popupSettings = Object.assign({}, {\n      animate: true\n    }, settings);\n  }\n\n  get popupSettings() {\n    return this._popupSettings;\n  }\n  /**\n   * Specifies the value of the DatePicker component.\n   *\n   * > The `value` has to be a valid\n   * [JavaScript `Date`](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Date) instance.\n   */\n\n\n  set value(value) {\n    this.verifyValue(value);\n    this._value = cloneDate(value);\n  }\n\n  get value() {\n    return this._value;\n  }\n  /**\n   * @hidden\n   */\n\n\n  set tabIndex(tabIndex) {\n    this.tabindex = tabIndex;\n  }\n\n  get tabIndex() {\n    return this.tabindex;\n  }\n  /**\n   * Sets the dates of the DatePicker that will be disabled\n   * ([see example]({% slug disabled_dates_datepicker %})).\n   */\n\n\n  set disabledDates(value) {\n    this._disabledDates = value;\n    this.disabledDatesService.initialize(value);\n  }\n\n  get disabledDates() {\n    return this._disabledDates;\n  }\n  /**\n   * @hidden\n   */\n\n\n  get disabledClass() {\n    return this.disabled;\n  }\n  /**\n   * @hidden\n   */\n\n\n  get inputRole() {\n    return this.readOnlyInput ? 'listbox' : 'spinbutton';\n  }\n\n  get isActive() {\n    return this._active;\n  }\n\n  set isActive(value) {\n    this._active = value;\n\n    if (!this.wrapper) {\n      return;\n    }\n\n    const element = this.wrapper.nativeElement;\n\n    if (value) {\n      this.renderer.addClass(element, 'k-state-focused');\n    } else {\n      this.renderer.removeClass(element, 'k-state-focused');\n    }\n  }\n\n  get show() {\n    return this._show;\n  }\n\n  set show(show) {\n    if (show && (this.disabled || this.readonly)) {\n      return;\n    }\n\n    const skipZone = !show && (!this._show || !hasObservers(this.close));\n\n    if (!skipZone) {\n      this.zone.run(() => {\n        this.togglePopup(show);\n      });\n    } else {\n      this.togglePopup(show);\n    }\n  }\n  /**\n   * @hidden\n   * Used by the TextBoxContainer to determine if the component is empty.\n   */\n\n\n  isEmpty() {\n    return !this.value && this.input.isEmpty();\n  }\n  /**\n   * @hidden\n   */\n\n\n  ngOnInit() {\n    this.localizationChangeSubscription = this.localization.changes.subscribe(() => this.cdr.markForCheck());\n    this.control = this.injector.get(NgControl, null);\n\n    if (this.element) {\n      this.renderer.removeAttribute(this.element.nativeElement, 'tabindex');\n      this.zone.runOutsideAngular(() => {\n        this.bindEvents();\n      });\n    }\n  }\n  /**\n   * @hidden\n   */\n\n\n  ngOnChanges(changes) {\n    this.verifySettings();\n\n    if (changes.min || changes.max || changes.rangeValidation || changes.disabledDatesValidation || changes.disabledDates || changes.incompleteDateValidation) {\n      this.minValidateFn = this.rangeValidation ? minValidator(this.min) : noop;\n      this.maxValidateFn = this.rangeValidation ? maxValidator(this.max) : noop;\n      this.disabledDatesValidateFn = this.disabledDatesValidation ? disabledDatesValidator(this.disabledDatesService.isDateDisabled) : noop;\n      this.incompleteValidator = this.incompleteDateValidation ? incompleteDateValidator() : noop;\n      this.onValidatorChange();\n    }\n  }\n  /**\n   * @hidden\n   */\n\n\n  ngOnDestroy() {\n    this.isActive = false;\n    this.show = false;\n\n    if (this.localizationChangeSubscription) {\n      this.localizationChangeSubscription.unsubscribe();\n    }\n\n    if (this.windowBlurSubscription) {\n      this.windowBlurSubscription.unsubscribe();\n    }\n\n    this.domEvents.forEach(unbindCallback => unbindCallback());\n    this.pickerSubscriptions.unsubscribe();\n  }\n  /**\n   * Returns the current open state of the popup.\n   */\n\n\n  get isOpen() {\n    return this.show;\n  }\n  /**\n   * @hidden\n   */\n\n\n  writeValue(value) {\n    this.verifyValue(value);\n    this.value = cloneDate(value);\n    this.cdr.markForCheck();\n\n    if (!value && this.input) {\n      this.input.placeholder = this.placeholder;\n      this.input.writeValue(value);\n    }\n  }\n  /**\n   * @hidden\n   */\n\n\n  registerOnChange(fn) {\n    this.onControlChange = fn;\n  }\n  /**\n   * @hidden\n   */\n\n\n  registerOnTouched(fn) {\n    this.onControlTouched = fn;\n  }\n  /**\n   * @hidden\n   */\n\n\n  setDisabledState(isDisabled) {\n    this.disabled = isDisabled;\n    this.cdr.markForCheck();\n  }\n  /**\n   * @hidden\n   */\n\n\n  validate(control) {\n    return this.minValidateFn(control) || this.maxValidateFn(control) || this.disabledDatesValidateFn(control) || this.incompleteValidator(control, this.input && this.input.isDateIncomplete);\n  }\n  /**\n   * @hidden\n   */\n\n\n  registerOnValidatorChange(fn) {\n    this.onValidatorChange = fn;\n  }\n  /**\n   * Focuses the DatePicker component.\n   *\n   * @example\n   * ```ts\n   * _@Component({\n   * selector: 'my-app',\n   * template: `\n   *  <button (click)=\"datepicker.focus()\">Focus date picker</button>\n   *  <kendo-datepicker #datepicker></kendo-datepicker>\n   * `\n   * })\n   * export class AppComponent { }\n   * ```\n   */\n\n\n  focus() {\n    this.input.focus();\n  }\n  /**\n   * Blurs the DatePicker component.\n   */\n\n\n  blur() {\n    (this.calendar || this.input)['blur'](); //tslint:disable-line:no-string-literal\n  }\n  /**\n   * Toggles the visibility of the popup. If you use the `toggle` method to show or hide the popup,\n   * the `open` and `close` events do not fire.\n   *\n   * @param show - The state of the popup.\n   */\n\n\n  toggle(show) {\n    if (this.disabled || this.readonly) {\n      return;\n    }\n\n    this.resolvedPromise.then(() => {\n      this._toggle(show === undefined ? !this.show : show);\n    });\n  }\n  /**\n   * @hidden\n   */\n\n\n  handleIconClick(event) {\n    if (this.disabled || this.readonly) {\n      return;\n    }\n\n    event.preventDefault();\n    this.focusInput(); //XXX: explicitly call the handleFocus handler here\n    //due to async IE focus event\n\n    this.handleFocus();\n    this.show = !this.show;\n    this.cdr.markForCheck();\n  }\n  /**\n   * @hidden\n   */\n\n\n  handleMousedown(args) {\n    args.preventDefault();\n  }\n  /**\n   * @hidden\n   */\n\n\n  handleChange(value) {\n    this.cdr.markForCheck();\n    this.focusInput();\n    this.value = value;\n    this.show = false;\n    this.onControlChange(cloneDate(value));\n    this.valueChange.emit(cloneDate(value));\n  }\n  /**\n   * @hidden\n   */\n\n\n  handleInputChange(value) {\n    this.handleChange(this.input.formatSections.time ? value : this.mergeTime(value));\n  }\n  /**\n   * @hidden\n   */\n\n\n  get popupClasses() {\n    return ['k-calendar-container', 'k-group', 'k-reset'].concat(this.popupSettings.popupClass || []);\n  }\n  /**\n   * @hidden\n   */\n\n\n  get appendTo() {\n    const {\n      appendTo\n    } = this.popupSettings;\n\n    if (!appendTo || appendTo === 'root') {\n      return undefined;\n    }\n\n    return appendTo === 'component' ? this.container : appendTo;\n  }\n\n  get input() {\n    return this.pickerService.input;\n  }\n\n  get calendar() {\n    return this.pickerService.calendar;\n  }\n  /**\n   * @hidden\n   */\n\n\n  mergeTime(value) {\n    return this.value && value ? setTime(value, this.value) : value;\n  }\n  /**\n   * @hidden\n   */\n\n\n  handleKeydown(e) {\n    const {\n      altKey,\n      keyCode\n    } = e;\n\n    if (keyCode === Keys.Escape) {\n      this.show = false;\n    }\n\n    if (altKey) {\n      if (keyCode === Keys.ArrowDown && !this.show) {\n        this.show = true;\n      }\n\n      if (keyCode === Keys.ArrowUp) {\n        this.show = false;\n      }\n    }\n\n    if (keyCode === Keys.Tab && this.show && this.calendar.isActive) {\n      this.input.focus();\n      this.show = false;\n    }\n  }\n\n  togglePopup(show) {\n    const event = new PreventableEvent();\n\n    if (!this._show && show) {\n      this.open.emit(event);\n    } else if (this._show && !show) {\n      this.close.emit(event);\n    }\n\n    if (event.isDefaultPrevented()) {\n      return;\n    }\n\n    this._toggle(show);\n\n    this.toggleFocus();\n  }\n\n  _toggle(show) {\n    if (show === this._show) {\n      return;\n    }\n\n    this._show = show;\n\n    if (show) {\n      const direction = this.localization.rtl ? 'right' : 'left';\n      this.popupRef = this.popupService.open({\n        anchor: this.wrapper,\n        anchorAlign: {\n          vertical: 'bottom',\n          horizontal: direction\n        },\n        animate: this.popupSettings.animate,\n        appendTo: this.appendTo,\n        content: this.popupTemplate,\n        popupAlign: {\n          vertical: 'top',\n          horizontal: direction\n        },\n        popupClass: this.popupClasses,\n        positionMode: 'absolute'\n      });\n      this.popupRef.popupElement.setAttribute('id', this.popupUID);\n      this.subscription = this.popupRef.popupAnchorViewportLeave.subscribe(() => this.show = false);\n    } else {\n      this.popupRef.close();\n      this.popupRef = null;\n      this.subscription.unsubscribe();\n    }\n  }\n\n  focusInput() {\n    if (this.touchEnabled) {\n      return;\n    }\n\n    this.input.focus();\n  }\n\n  toggleFocus() {\n    if (!this.isActive) {\n      return;\n    }\n\n    if (this.show) {\n      if (!this.calendar) {\n        this.cdr.detectChanges();\n      }\n\n      if (this.calendar) {\n        this.calendar.focus();\n      }\n    } else if (!this.touchEnabled) {\n      this.input.focus();\n    } else if (!this.input.isActive) {\n      this.handleBlur();\n    }\n  }\n\n  verifySettings() {\n    if (!isDevMode()) {\n      return;\n    }\n\n    if (!isValidRange(this.min, this.max)) {\n      throw new Error(`The max value should be bigger than the min. See ${MIN_DOC_LINK$2} and ${MAX_DOC_LINK$2}.`);\n    }\n  }\n\n  verifyValue(value) {\n    if (!isDevMode()) {\n      return;\n    }\n\n    if (value && !(value instanceof Date)) {\n      throw new Error(`The 'value' should be a valid JavaScript Date instance. Check ${VALUE_DOC_LINK$2} for possible resolution.`);\n    }\n  }\n\n  bindEvents() {\n    const element = this.element.nativeElement;\n    this.domEvents.push(this.renderer.listen(element, 'keydown', this.handleKeydown.bind(this)));\n\n    if (isWindowAvailable()) {\n      this.windowBlurSubscription = fromEvent(window, 'blur').subscribe(this.handleWindowBlur.bind(this));\n    }\n  }\n\n  handleFocus() {\n    if (this.isActive) {\n      return;\n    }\n\n    this.isActive = true;\n\n    if (hasObservers(this.onFocus)) {\n      this.zone.run(() => {\n        this.onFocus.emit();\n      });\n    }\n  }\n\n  handleWindowBlur() {\n    if (!this.isOpen) {\n      return;\n    }\n\n    this.show = false;\n  }\n\n  handleBlur(args) {\n    const currentTarget = args && currentFocusTarget(args);\n\n    if (currentTarget && (this.input.containsElement(currentTarget) || this.calendar && this.calendar.containsElement(currentTarget))) {\n      return;\n    }\n\n    if (hasObservers(this.onBlur) || this.show && hasObservers(this.close) || requiresZoneOnBlur(this.control)) {\n      this.zone.run(() => {\n        this.blurComponent();\n        this.cdr.markForCheck();\n      });\n    } else {\n      this.blurComponent();\n    }\n  }\n\n  blurComponent() {\n    this.isActive = false; // order is important ¯\\_(ツ)_/¯\n\n    this.show = false;\n    this.cdr.detectChanges();\n    this.onControlTouched();\n    this.onBlur.emit();\n  }\n\n  handleSameSelection() {\n    if (this.show) {\n      this.focusInput();\n      this.show = false;\n    }\n  }\n\n  handleDateCompletenessChange() {\n    this.cdr.markForCheck();\n    this.zone.run(() => this.onValidatorChange());\n  }\n\n};\n\nDatePickerComponent.ɵfac = function DatePickerComponent_Factory(t) {\n  return new (t || DatePickerComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc4.LocalizationService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc5.PopupService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Injector), ɵngcc0.ɵɵdirectiveInject(PickerService), ɵngcc0.ɵɵdirectiveInject(DisabledDatesService), ɵngcc0.ɵɵdirectiveInject(TOUCH_ENABLED, 8));\n};\n\nDatePickerComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n  type: DatePickerComponent,\n  selectors: [[\"kendo-datepicker\"]],\n  contentQueries: function DatePickerComponent_ContentQueries(rf, ctx, dirIndex) {\n    if (rf & 1) {\n      ɵngcc0.ɵɵcontentQuery(dirIndex, CellTemplateDirective, 5);\n      ɵngcc0.ɵɵcontentQuery(dirIndex, MonthCellTemplateDirective, 5);\n      ɵngcc0.ɵɵcontentQuery(dirIndex, YearCellTemplateDirective, 5);\n      ɵngcc0.ɵɵcontentQuery(dirIndex, DecadeCellTemplateDirective, 5);\n      ɵngcc0.ɵɵcontentQuery(dirIndex, CenturyCellTemplateDirective, 5);\n      ɵngcc0.ɵɵcontentQuery(dirIndex, WeekNumberCellTemplateDirective, 5);\n      ɵngcc0.ɵɵcontentQuery(dirIndex, HeaderTitleTemplateDirective, 5);\n      ɵngcc0.ɵɵcontentQuery(dirIndex, NavigationItemTemplateDirective, 5);\n    }\n\n    if (rf & 2) {\n      let _t;\n\n      ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.cellTemplate = _t.first);\n      ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.monthCellTemplate = _t.first);\n      ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.yearCellTemplate = _t.first);\n      ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.decadeCellTemplate = _t.first);\n      ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.centuryCellTemplate = _t.first);\n      ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.weekNumberTemplate = _t.first);\n      ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.headerTitleTemplate = _t.first);\n      ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.navigationItemTemplate = _t.first);\n    }\n  },\n  viewQuery: function DatePickerComponent_Query(rf, ctx) {\n    if (rf & 1) {\n      ɵngcc0.ɵɵviewQuery(_c17, 7, ViewContainerRef);\n      ɵngcc0.ɵɵviewQuery(_c18, 7);\n      ɵngcc0.ɵɵviewQuery(_c19, 5);\n    }\n\n    if (rf & 2) {\n      let _t;\n\n      ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.container = _t.first);\n      ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.popupTemplate = _t.first);\n      ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.wrapper = _t.first);\n    }\n  },\n  hostVars: 6,\n  hostBindings: function DatePickerComponent_HostBindings(rf, ctx) {\n    if (rf & 2) {\n      ɵngcc0.ɵɵclassProp(\"k-widget\", ctx.wrapperClasses)(\"k-datepicker\", ctx.wrapperClasses)(\"k-state-disabled\", ctx.disabledClass);\n    }\n  },\n  inputs: {\n    focusableId: \"focusableId\",\n    activeView: \"activeView\",\n    bottomView: \"bottomView\",\n    topView: \"topView\",\n    calendarType: \"calendarType\",\n    animateCalendarNavigation: \"animateCalendarNavigation\",\n    disabled: \"disabled\",\n    readonly: \"readonly\",\n    readOnlyInput: \"readOnlyInput\",\n    navigation: \"navigation\",\n    min: \"min\",\n    max: \"max\",\n    incompleteDateValidation: \"incompleteDateValidation\",\n    focusedDate: \"focusedDate\",\n    format: \"format\",\n    twoDigitYearMax: \"twoDigitYearMax\",\n    placeholder: \"placeholder\",\n    tabindex: \"tabindex\",\n    title: \"title\",\n    rangeValidation: \"rangeValidation\",\n    disabledDatesValidation: \"disabledDatesValidation\",\n    weekNumber: \"weekNumber\",\n    cellTemplateRef: [\"cellTemplate\", \"cellTemplateRef\"],\n    monthCellTemplateRef: [\"monthCellTemplate\", \"monthCellTemplateRef\"],\n    yearCellTemplateRef: [\"yearCellTemplate\", \"yearCellTemplateRef\"],\n    decadeCellTemplateRef: [\"decadeCellTemplate\", \"decadeCellTemplateRef\"],\n    centuryCellTemplateRef: [\"centuryCellTemplate\", \"centuryCellTemplateRef\"],\n    weekNumberTemplateRef: [\"weekNumberTemplate\", \"weekNumberTemplateRef\"],\n    headerTitleTemplateRef: [\"headerTitleTemplate\", \"headerTitleTemplateRef\"],\n    navigationItemTemplateRef: [\"navigationItemTemplate\", \"navigationItemTemplateRef\"],\n    popupSettings: \"popupSettings\",\n    value: \"value\",\n    tabIndex: \"tabIndex\",\n    disabledDates: \"disabledDates\",\n    formatPlaceholder: \"formatPlaceholder\"\n  },\n  outputs: {\n    valueChange: \"valueChange\",\n    onFocus: \"focus\",\n    onBlur: \"blur\",\n    open: \"open\",\n    close: \"close\"\n  },\n  exportAs: [\"kendo-datepicker\"],\n  features: [ɵngcc0.ɵɵProvidersFeature([{\n    provide: NG_VALUE_ACCESSOR,\n    useExisting: forwardRef(() => DatePickerComponent_1),\n    multi: true\n  }, {\n    provide: NG_VALIDATORS,\n    useExisting: forwardRef(() => DatePickerComponent_1),\n    multi: true\n  }, {\n    provide: KendoInput,\n    useExisting: forwardRef(() => DatePickerComponent_1)\n  }, LocalizationService, PickerService, DisabledDatesService, {\n    provide: L10N_PREFIX,\n    useValue: 'kendo.datepicker'\n  }]), ɵngcc0.ɵɵNgOnChangesFeature],\n  decls: 11,\n  vars: 26,\n  consts: function () {\n    let i18n_20;\n\n    if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n      /**\n       * @desc The label for the today button in the calendar header\n       * @meaning kendo.datepicker.today\n       */\n      const MSG_EXTERNAL_5799873230514803381$$DIST_FESM2015_INDEX_JS_21 = goog.getMsg(\"Today\");\n      i18n_20 = MSG_EXTERNAL_5799873230514803381$$DIST_FESM2015_INDEX_JS_21;\n    } else {\n      i18n_20 = $localize`:kendo.datepicker.today|The label for the today button in the calendar header␟c8af34428eb25c8f689f0c19a9300394b07b5be3␟5799873230514803381:Today`;\n    }\n\n    let i18n_22;\n\n    if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n      /**\n       * @desc The title of the toggle button in the datepicker component\n       * @meaning kendo.datepicker.toggle\n       */\n      const MSG_EXTERNAL_4817467473728423164$$DIST_FESM2015_INDEX_JS_23 = goog.getMsg(\"Toggle calendar\");\n      i18n_22 = MSG_EXTERNAL_4817467473728423164$$DIST_FESM2015_INDEX_JS_23;\n    } else {\n      i18n_22 = $localize`:kendo.datepicker.toggle|The title of the toggle button in the datepicker component␟f6c28c2d80dbe993c4b33f4dc4010364f41cc2ae␟4817467473728423164:Toggle calendar`;\n    }\n\n    let i18n_24;\n\n    if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n      /**\n       * @desc The title of the previous button in the Classic calendar\n       * @meaning kendo.datepicker.prevButtonTitle\n       */\n      const MSG_EXTERNAL_1741914107549506055$$DIST_FESM2015_INDEX_JS_25 = goog.getMsg(\"Navigate to previous view\");\n      i18n_24 = MSG_EXTERNAL_1741914107549506055$$DIST_FESM2015_INDEX_JS_25;\n    } else {\n      i18n_24 = $localize`:kendo.datepicker.prevButtonTitle|The title of the previous button in the Classic calendar␟b24bedd31916ff8439cd7e3c46cbdabea3409dd1␟1741914107549506055:Navigate to previous view`;\n    }\n\n    let i18n_26;\n\n    if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n      /**\n       * @desc The title of the next button in the Classic calendar\n       * @meaning kendo.datepicker.nextButtonTitle\n       */\n      const MSG_EXTERNAL_3363484587807059211$$DIST_FESM2015_INDEX_JS_27 = goog.getMsg(\"Navigate to next view\");\n      i18n_26 = MSG_EXTERNAL_3363484587807059211$$DIST_FESM2015_INDEX_JS_27;\n    } else {\n      i18n_26 = $localize`:kendo.datepicker.nextButtonTitle|The title of the next button in the Classic calendar␟2f0e2a91beb7149035e42bd0d6663e8903dc3852␟3363484587807059211:Navigate to next view`;\n    }\n\n    return [[\"kendoDatePickerLocalizedMessages\", \"\", \"today\", i18n_20, \"toggle\", i18n_22, \"prevButtonTitle\", i18n_24, \"nextButtonTitle\", i18n_26], [1, \"k-picker-wrap\"], [\"wrapper\", \"\"], [3, \"role\", \"focusableId\", \"hasPopup\", \"isPopupOpen\", \"disabled\", \"readonly\", \"ariaReadOnly\", \"tabindex\", \"title\", \"format\", \"twoDigitYearMax\", \"formatPlaceholder\", \"placeholder\", \"min\", \"max\", \"incompleteDateValidation\", \"value\", \"valueChange\"], [\"input\", \"\"], [\"role\", \"button\", 1, \"k-select\", 3, \"kendoEventsOutsideAngular\", \"scope\"], [1, \"k-icon\", \"k-i-calendar\"], [\"container\", \"\"], [\"popupTemplate\", \"\"], [3, \"type\", \"min\", \"max\", \"navigation\", \"animateNavigation\", \"activeView\", \"bottomView\", \"topView\", \"weekNumber\", \"cellTemplate\", \"monthCellTemplate\", \"yearCellTemplate\", \"decadeCellTemplate\", \"centuryCellTemplate\", \"weekNumberTemplate\", \"headerTitleTemplate\", \"navigationItemTemplate\", \"focusedDate\", \"value\", \"kendoEventsOutsideAngular\", \"scope\", \"disabledDates\", \"valueChange\"], [\"calendar\", \"\"], [3, \"today\", \"prevButtonTitle\", \"nextButtonTitle\"]];\n  },\n  template: function DatePickerComponent_Template(rf, ctx) {\n    if (rf & 1) {\n      ɵngcc0.ɵɵelementContainer(0, 0);\n      ɵngcc0.ɵɵelementStart(1, \"span\", 1, 2);\n      ɵngcc0.ɵɵelementStart(3, \"kendo-dateinput\", 3, 4);\n      ɵngcc0.ɵɵlistener(\"valueChange\", function DatePickerComponent_Template_kendo_dateinput_valueChange_3_listener($event) {\n        return ctx.handleInputChange($event);\n      });\n      ɵngcc0.ɵɵelementEnd();\n      ɵngcc0.ɵɵelementStart(5, \"span\", 5);\n      ɵngcc0.ɵɵelement(6, \"span\", 6);\n      ɵngcc0.ɵɵelementEnd();\n      ɵngcc0.ɵɵelementEnd();\n      ɵngcc0.ɵɵelementContainer(7, null, 7);\n      ɵngcc0.ɵɵtemplate(9, DatePickerComponent_ng_template_9_Template, 4, 27, \"ng-template\", null, 8, ɵngcc0.ɵɵtemplateRefExtractor);\n    }\n\n    if (rf & 2) {\n      ɵngcc0.ɵɵadvance(1);\n      ɵngcc0.ɵɵclassProp(\"k-state-disabled\", ctx.disabled);\n      ɵngcc0.ɵɵadvance(2);\n      ɵngcc0.ɵɵproperty(\"role\", ctx.inputRole)(\"focusableId\", ctx.focusableId)(\"hasPopup\", true)(\"isPopupOpen\", ctx.show)(\"disabled\", ctx.disabled)(\"readonly\", ctx.readonly || ctx.readOnlyInput)(\"ariaReadOnly\", ctx.readonly)(\"tabindex\", ctx.tabindex)(\"title\", ctx.title)(\"format\", ctx.format)(\"twoDigitYearMax\", ctx.twoDigitYearMax)(\"formatPlaceholder\", ctx.formatPlaceholder)(\"placeholder\", ctx.placeholder)(\"min\", ctx.min)(\"max\", ctx.max)(\"incompleteDateValidation\", ctx.incompleteDateValidation)(\"value\", ctx.value);\n      ɵngcc0.ɵɵadvance(2);\n      ɵngcc0.ɵɵproperty(\"kendoEventsOutsideAngular\", ɵngcc0.ɵɵpureFunction2(23, _c29, ctx.handleIconClick, ctx.handleMousedown))(\"scope\", ctx);\n      ɵngcc0.ɵɵattribute(\"title\", ctx.localization.get(\"toggle\"))(\"aria-label\", ctx.localization.get(\"toggle\"));\n    }\n  },\n  directives: function () {\n    return [DatePickerLocalizedMessagesDirective, DateInputComponent, ɵngcc3.EventsOutsideAngularDirective, CalendarComponent, CalendarCustomMessagesComponent];\n  },\n  encapsulation: 2,\n  changeDetection: 0\n});\n\n__decorate([ViewChild('container', {\n  read: ViewContainerRef,\n  static: true\n}), __metadata(\"design:type\", ViewContainerRef)], DatePickerComponent.prototype, \"container\", void 0);\n\n__decorate([ViewChild('popupTemplate', {\n  static: true\n}), __metadata(\"design:type\", TemplateRef)], DatePickerComponent.prototype, \"popupTemplate\", void 0);\n\n__decorate([ViewChild('wrapper', {\n  static: false\n}), __metadata(\"design:type\", ElementRef)], DatePickerComponent.prototype, \"wrapper\", void 0);\n\n__decorate([ContentChild(CellTemplateDirective, {\n  static: false\n}), __metadata(\"design:type\", CellTemplateDirective)], DatePickerComponent.prototype, \"cellTemplate\", void 0);\n\n__decorate([Input('cellTemplate'), __metadata(\"design:type\", CellTemplateDirective), __metadata(\"design:paramtypes\", [CellTemplateDirective])], DatePickerComponent.prototype, \"cellTemplateRef\", null);\n\n__decorate([ContentChild(MonthCellTemplateDirective, {\n  static: false\n}), __metadata(\"design:type\", MonthCellTemplateDirective)], DatePickerComponent.prototype, \"monthCellTemplate\", void 0);\n\n__decorate([Input('monthCellTemplate'), __metadata(\"design:type\", MonthCellTemplateDirective), __metadata(\"design:paramtypes\", [MonthCellTemplateDirective])], DatePickerComponent.prototype, \"monthCellTemplateRef\", null);\n\n__decorate([ContentChild(YearCellTemplateDirective, {\n  static: false\n}), __metadata(\"design:type\", YearCellTemplateDirective)], DatePickerComponent.prototype, \"yearCellTemplate\", void 0);\n\n__decorate([Input('yearCellTemplate'), __metadata(\"design:type\", YearCellTemplateDirective), __metadata(\"design:paramtypes\", [YearCellTemplateDirective])], DatePickerComponent.prototype, \"yearCellTemplateRef\", null);\n\n__decorate([ContentChild(DecadeCellTemplateDirective, {\n  static: false\n}), __metadata(\"design:type\", DecadeCellTemplateDirective)], DatePickerComponent.prototype, \"decadeCellTemplate\", void 0);\n\n__decorate([Input('decadeCellTemplate'), __metadata(\"design:type\", DecadeCellTemplateDirective), __metadata(\"design:paramtypes\", [DecadeCellTemplateDirective])], DatePickerComponent.prototype, \"decadeCellTemplateRef\", null);\n\n__decorate([ContentChild(CenturyCellTemplateDirective, {\n  static: false\n}), __metadata(\"design:type\", CenturyCellTemplateDirective)], DatePickerComponent.prototype, \"centuryCellTemplate\", void 0);\n\n__decorate([Input('centuryCellTemplate'), __metadata(\"design:type\", CenturyCellTemplateDirective), __metadata(\"design:paramtypes\", [CenturyCellTemplateDirective])], DatePickerComponent.prototype, \"centuryCellTemplateRef\", null);\n\n__decorate([ContentChild(WeekNumberCellTemplateDirective, {\n  static: false\n}), __metadata(\"design:type\", WeekNumberCellTemplateDirective)], DatePickerComponent.prototype, \"weekNumberTemplate\", void 0);\n\n__decorate([Input('weekNumberTemplate'), __metadata(\"design:type\", WeekNumberCellTemplateDirective), __metadata(\"design:paramtypes\", [WeekNumberCellTemplateDirective])], DatePickerComponent.prototype, \"weekNumberTemplateRef\", null);\n\n__decorate([ContentChild(HeaderTitleTemplateDirective, {\n  static: false\n}), __metadata(\"design:type\", HeaderTitleTemplateDirective)], DatePickerComponent.prototype, \"headerTitleTemplate\", void 0);\n\n__decorate([Input('headerTitleTemplate'), __metadata(\"design:type\", HeaderTitleTemplateDirective), __metadata(\"design:paramtypes\", [HeaderTitleTemplateDirective])], DatePickerComponent.prototype, \"headerTitleTemplateRef\", null);\n\n__decorate([ContentChild(NavigationItemTemplateDirective, {\n  static: false\n}), __metadata(\"design:type\", NavigationItemTemplateDirective)], DatePickerComponent.prototype, \"navigationItemTemplate\", void 0);\n\n__decorate([Input('navigationItemTemplate'), __metadata(\"design:type\", NavigationItemTemplateDirective), __metadata(\"design:paramtypes\", [NavigationItemTemplateDirective])], DatePickerComponent.prototype, \"navigationItemTemplateRef\", null);\n\n__decorate([Input(), __metadata(\"design:type\", String)], DatePickerComponent.prototype, \"focusableId\", void 0);\n\n__decorate([Input(), __metadata(\"design:type\", String)], DatePickerComponent.prototype, \"activeView\", void 0);\n\n__decorate([Input(), __metadata(\"design:type\", String)], DatePickerComponent.prototype, \"bottomView\", void 0);\n\n__decorate([Input(), __metadata(\"design:type\", String)], DatePickerComponent.prototype, \"topView\", void 0);\n\n__decorate([Input(), __metadata(\"design:type\", String)], DatePickerComponent.prototype, \"calendarType\", void 0);\n\n__decorate([Input(), __metadata(\"design:type\", Boolean)], DatePickerComponent.prototype, \"animateCalendarNavigation\", void 0);\n\n__decorate([Input(), __metadata(\"design:type\", Boolean)], DatePickerComponent.prototype, \"disabled\", void 0);\n\n__decorate([Input(), __metadata(\"design:type\", Boolean)], DatePickerComponent.prototype, \"readonly\", void 0);\n\n__decorate([Input(), __metadata(\"design:type\", Boolean)], DatePickerComponent.prototype, \"readOnlyInput\", void 0);\n\n__decorate([Input(), __metadata(\"design:type\", Object), __metadata(\"design:paramtypes\", [Object])], DatePickerComponent.prototype, \"popupSettings\", null);\n\n__decorate([Input(), __metadata(\"design:type\", Boolean)], DatePickerComponent.prototype, \"navigation\", void 0);\n\n__decorate([Input(), __metadata(\"design:type\", Date)], DatePickerComponent.prototype, \"min\", void 0);\n\n__decorate([Input(), __metadata(\"design:type\", Date)], DatePickerComponent.prototype, \"max\", void 0);\n\n__decorate([Input(), __metadata(\"design:type\", Boolean)], DatePickerComponent.prototype, \"incompleteDateValidation\", void 0);\n\n__decorate([Input(), __metadata(\"design:type\", Date)], DatePickerComponent.prototype, \"focusedDate\", void 0);\n\n__decorate([Input(), __metadata(\"design:type\", Date), __metadata(\"design:paramtypes\", [Date])], DatePickerComponent.prototype, \"value\", null);\n\n__decorate([Input(), __metadata(\"design:type\", Object)], DatePickerComponent.prototype, \"format\", void 0);\n\n__decorate([Input(), __metadata(\"design:type\", Number)], DatePickerComponent.prototype, \"twoDigitYearMax\", void 0);\n\n__decorate([Input(), __metadata(\"design:type\", Object)], DatePickerComponent.prototype, \"formatPlaceholder\", void 0);\n\n__decorate([Input(), __metadata(\"design:type\", String)], DatePickerComponent.prototype, \"placeholder\", void 0);\n\n__decorate([Input(), __metadata(\"design:type\", Number)], DatePickerComponent.prototype, \"tabindex\", void 0);\n\n__decorate([Input(), __metadata(\"design:type\", Number), __metadata(\"design:paramtypes\", [Number])], DatePickerComponent.prototype, \"tabIndex\", null);\n\n__decorate([Input(), __metadata(\"design:type\", Object), __metadata(\"design:paramtypes\", [Object])], DatePickerComponent.prototype, \"disabledDates\", null);\n\n__decorate([Input(), __metadata(\"design:type\", String)], DatePickerComponent.prototype, \"title\", void 0);\n\n__decorate([Input(), __metadata(\"design:type\", Boolean)], DatePickerComponent.prototype, \"rangeValidation\", void 0);\n\n__decorate([Input(), __metadata(\"design:type\", Boolean)], DatePickerComponent.prototype, \"disabledDatesValidation\", void 0);\n\n__decorate([Input(), __metadata(\"design:type\", Boolean)], DatePickerComponent.prototype, \"weekNumber\", void 0);\n\n__decorate([Output(), __metadata(\"design:type\", EventEmitter)], DatePickerComponent.prototype, \"valueChange\", void 0);\n\n__decorate([Output('focus'), __metadata(\"design:type\", EventEmitter)], DatePickerComponent.prototype, \"onFocus\", void 0);\n\n__decorate([Output('blur'), __metadata(\"design:type\", EventEmitter)], DatePickerComponent.prototype, \"onBlur\", void 0);\n\n__decorate([Output(), __metadata(\"design:type\", EventEmitter)], DatePickerComponent.prototype, \"open\", void 0);\n\n__decorate([Output(), __metadata(\"design:type\", EventEmitter)], DatePickerComponent.prototype, \"close\", void 0);\n\n__decorate([HostBinding('class.k-widget'), HostBinding('class.k-datepicker'), __metadata(\"design:type\", Boolean)], DatePickerComponent.prototype, \"wrapperClasses\", void 0);\n\n__decorate([HostBinding('class.k-state-disabled'), __metadata(\"design:type\", Boolean), __metadata(\"design:paramtypes\", [])], DatePickerComponent.prototype, \"disabledClass\", null);\n\nDatePickerComponent = DatePickerComponent_1 = __decorate([__param(9, Optional()), __param(9, Inject(TOUCH_ENABLED)), __metadata(\"design:paramtypes\", [NgZone, LocalizationService, ChangeDetectorRef, PopupService, ElementRef, Renderer2, Injector, PickerService, DisabledDatesService, Boolean])], DatePickerComponent);\n/**\n * @hidden\n */\n\nconst TIME_PART = {\n  dayperiod: 'dayperiod',\n  hour: 'hour',\n  millisecond: 'millisecond',\n  minute: 'minute',\n  second: 'second'\n};\n/**\n * @hidden\n */\n\nconst timeRangeValidator = (min, max) => {\n  return control => {\n    if (!min || !max || !control.value) {\n      return null;\n    }\n\n    const err = {\n      timeRangeError: {\n        maxValue: max,\n        minValue: min,\n        value: control.value\n      }\n    };\n    return isInTimeRange(control.value, min, max) ? null : err;\n  };\n};\n\nvar TimePickerComponent_1;\nconst VALUE_DOC_LINK$3 = 'https://www.telerik.com/kendo-angular-ui/components/dateinputs/timepicker/#toc-integration-with-json';\nconst INTL_DATE_FORMAT = 'https://github.com/telerik/kendo-intl/blob/master/docs/date-formatting/index.md';\nconst formatRegExp = new RegExp(`${TIME_PART.hour}|${TIME_PART.minute}|${TIME_PART.second}|${TIME_PART.millisecond}|${TIME_PART.dayperiod}|literal`);\n/**\n * Represents the [Kendo UI TimePicker component for Angular]({% slug overview_timepicker %}#toc-basic-usage).\n */\n\nlet TimePickerComponent = TimePickerComponent_1 = class TimePickerComponent {\n  constructor(zone, localization, cdr, popupService, element, renderer, injector, pickerService, intl, touchEnabled$$1) {\n    this.zone = zone;\n    this.localization = localization;\n    this.cdr = cdr;\n    this.popupService = popupService;\n    this.element = element;\n    this.renderer = renderer;\n    this.injector = injector;\n    this.pickerService = pickerService;\n    this.intl = intl;\n    this.touchEnabled = touchEnabled$$1;\n    /**\n     * @hidden\n     */\n\n    this.focusableId = `k-${guid()}`;\n    /**\n     * Sets or gets the `disabled` property of the TimePicker and\n     * determines whether the component is active\n     * ([see example]({% slug disabled_timepicker %})).\n     */\n\n    this.disabled = false;\n    /**\n     * Sets the read-only state of the TimePicker\n     * ([see example]({% slug readonly_timepicker %}#toc-read-only-timepicker)).\n     */\n\n    this.readonly = false;\n    /**\n     * Sets the read-only state of the TimePicker input field\n     * ([see example]({% slug readonly_timepicker %}#toc-read-only-input)).\n     *\n     * > Note that if you set the [`readonly`]({% slug api_dateinputs_timepickercomponent %}#toc-readonly) property value to `true`,\n     * the input will be rendered in a read-only state regardless of the `readOnlyInput` value.\n     */\n\n    this.readOnlyInput = false;\n    /**\n     * Specifies the time format that is used to display the input value\n     * ([see example]({% slug formats_timepicker %})).\n     */\n\n    this.format = 't';\n    /**\n     * Specifies the hint the TimePicker displays when its value is `null`.\n     * For more information, refer to the article on\n     * [placeholders]({% slug placeholders_timepicker %}).\n     *\n     * @example\n     * ```ts\n     * _@Component({\n     * selector: 'my-app',\n     * template: `\n     *  <kendo-timepicker placeholder=\"Enter start...\"></kendo-timepicker>\n     * `\n     * })\n     * export class AppComponent { }\n     * ```\n     */\n\n    this.placeholder = null;\n    /**\n     * Determines whether the built-in validation for incomplete dates is to be enforced when a form is being validated.\n     */\n\n    this.incompleteDateValidation = false;\n    /**\n     * Determines whether to display the **Cancel** button in the popup.\n     */\n\n    this.cancelButton = true;\n    /**\n     * Determines whether to display the **Now** button in the popup.\n     *\n     * > If the current time is out of range or the incremental step is greater than `1`, the **Now** button will be hidden.\n     */\n\n    this.nowButton = true;\n    /**\n     * Sets or gets the `tabindex` property of the TimePicker.\n     */\n\n    this.tabindex = 0;\n    /**\n     * Sets the title of the input element of the TimePicker.\n     */\n\n    this.title = \"\";\n    /**\n     * Determines whether the built-in min or max validators are enforced when a form is being validated.\n     */\n\n    this.rangeValidation = true;\n    /**\n     * Fires each time the user selects a new value.\n     * For more information, refer to the section on\n     * [events]({% slug overview_timepicker %}#toc-events).\n     */\n\n    this.valueChange = new EventEmitter();\n    /**\n     * Fires each time the user focuses the input element.\n     * For more information, refer to the section on\n     * [events]({% slug overview_timepicker %}#toc-events).\n     *\n     * > To wire the event programmatically, use the `onFocus` property.\n     *\n     * @example\n     * ```ts\n     * _@Component({\n     * selector: 'my-app',\n     * template: `\n     *  <kendo-timepicker (focus)=\"handleFocus()\"></kendo-timepicker>\n     * `\n     * })\n     * export class AppComponent {\n     *   public handleFocus(): void {\n     *      console.log(\"Component is focused\");\n     *   }\n     * }\n     * ```\n     */\n\n    this.onFocus = new EventEmitter(); //tslint:disable-line:no-output-rename\n\n    /**\n     * Fires each time the input element gets blurred.\n     * For more information, refer to the section on\n     * [events]({% slug overview_timepicker %}#toc-events).\n     *\n     * > To wire the event programmatically, use the `onBlur` property.\n     *\n     * @example\n     * ```ts\n     * _@Component({\n     * selector: 'my-app',\n     * template: `\n     *  <kendo-timepicker (blur)=\"handleBlur()\"></kendo-timepicker>\n     * `\n     * })\n     * export class AppComponent {\n     *   public handleBlur(): void {\n     *      console.log(\"Component is blurred\");\n     *   }\n     * }\n     * ```\n     */\n\n    this.onBlur = new EventEmitter(); //tslint:disable-line:no-output-rename\n\n    /**\n     * Fires each time the popup is about to open.\n     * This event is preventable. If you cancel the event, the popup will remain closed.\n     * For more information, refer to the section on\n     * [events]({% slug overview_timepicker %}#toc-events).\n     */\n\n    this.open = new EventEmitter();\n    /**\n     * Fires each time the popup is about to close.\n     * This event is preventable. If you cancel the event, the popup will remain open.\n     * For more information, refer to the section on\n     * [events]({% slug overview_timepicker %}#toc-events).\n     */\n\n    this.close = new EventEmitter();\n    /**\n     * @hidden\n     */\n\n    this.wrapperClasses = true;\n    this.popupUID = guid();\n    this.onControlChange = noop;\n    this.onControlTouched = noop;\n    this.onValidatorChange = noop;\n    this.resolvedPromise = Promise.resolve(null);\n    this.timeRangeValidateFn = noop;\n    this.incompleteValidator = noop;\n    this._min = cloneDate(MIN_TIME);\n    this._max = cloneDate(MAX_TIME);\n    this._popupSettings = {\n      animate: true\n    };\n    this._show = false;\n    this._steps = {};\n    this._value = null;\n    this._active = false;\n    this.domEvents = [];\n    validatePackage(packageMetadata);\n    this.pickerSubscriptions = this.pickerService.onFocus.subscribe(this.handleFocus.bind(this));\n    this.pickerSubscriptions.add(this.pickerService.onBlur.subscribe(this.handleBlur.bind(this)));\n    this.pickerSubscriptions.add(this.pickerService.dateCompletenessChange.subscribe(this.handleDateCompletenessChange.bind(this)));\n  }\n  /**\n   * Specifies the smallest valid time value\n   * ([see example]({% slug timeranges_timepicker %})).\n   */\n\n\n  set min(min) {\n    this._min = cloneDate(min || MIN_TIME);\n  }\n\n  get min() {\n    return this._min;\n  }\n  /**\n   * Specifies the biggest valid time value\n   * ([see example]({% slug timeranges_timepicker %})).\n   */\n\n\n  set max(max) {\n    this._max = cloneDate(max || MAX_TIME);\n  }\n\n  get max() {\n    return this._max;\n  }\n  /**\n   * Configures the incremental steps of the TimePicker.\n   * For more information, refer to the article on\n   * [incremental steps]({% slug incrementalsteps_timepicker %}).\n   *\n   * > If the incremental step is greater than `1`, the **Now** button will be hidden.\n   *\n   * @example\n   * ```ts\n   * _@Component({\n   * selector: 'my-app',\n   * template: `\n   *  <kendo-timepicker format=\"HH:mm:ss\" [steps]=\"steps\"></kendo-timepicker>\n   * `\n   * })\n   * class AppComponent {\n   *   public steps = { hour: 2, minute: 15, second: 15, millisecond: 10 };\n   * }\n   * ```\n   *\n   */\n\n\n  set steps(steps) {\n    this._steps = steps || {};\n  }\n\n  get steps() {\n    return this._steps;\n  }\n  /**\n   * Configures the popup of the TimePicker.\n   *\n   * The available options are:\n   * - `animate: Boolean`&mdash;Controls the popup animation. By default, the open and close animations are enabled.\n   * - `appendTo: 'root' | 'component' | ViewContainerRef`&mdash;Controls the popup container. By default, the popup will be appended to the root component.\n   * - `popupClass: String`&mdash;Specifies a list of CSS classes that are used to style the popup.\n   */\n\n\n  set popupSettings(settings) {\n    this._popupSettings = Object.assign({}, {\n      animate: true\n    }, settings);\n  }\n\n  get popupSettings() {\n    return this._popupSettings;\n  }\n  /**\n   * @hidden\n   */\n\n\n  set tabIndex(tabIndex) {\n    this.tabindex = tabIndex;\n  }\n\n  get tabIndex() {\n    return this.tabindex;\n  }\n  /**\n   * Specifies the value of the TimePicker component.\n   */\n\n\n  set value(value) {\n    this.verifyValue(value);\n    this._value = cloneDate(value);\n  }\n\n  get value() {\n    return this._value;\n  }\n  /**\n   * @hidden\n   */\n\n\n  get disabledClass() {\n    return this.disabled;\n  }\n  /**\n   * @hidden\n   */\n\n\n  get inputRole() {\n    return this.readOnlyInput ? 'listbox' : 'spinbutton';\n  }\n\n  get isActive() {\n    return this._active;\n  }\n\n  set isActive(value) {\n    this._active = value;\n\n    if (!this.wrapper) {\n      return;\n    }\n\n    const element = this.wrapper.nativeElement;\n\n    if (value) {\n      this.renderer.addClass(element, 'k-state-focused');\n    } else {\n      this.renderer.removeClass(element, 'k-state-focused');\n    }\n  }\n\n  get show() {\n    return this._show;\n  }\n\n  set show(show) {\n    if (show && (this.disabled || this.readonly)) {\n      return;\n    }\n\n    const skipZone = !show && (!this._show || !hasObservers(this.close));\n\n    if (!skipZone) {\n      this.zone.run(() => {\n        this.togglePopup(show);\n      });\n    } else {\n      this.togglePopup(show);\n    }\n  }\n\n  get input() {\n    return this.pickerService.input;\n  }\n\n  get timeSelector() {\n    return this.pickerService.timeSelector;\n  }\n  /**\n   * @hidden\n   * Used by the TextBoxContainer to determine if the component is empty\n   */\n\n\n  isEmpty() {\n    return !this.value && this.input.isEmpty();\n  }\n  /**\n   * @hidden\n   */\n\n\n  ngOnInit() {\n    this.localizationChangeSubscription = this.localization.changes.subscribe(() => this.cdr.markForCheck());\n    this.control = this.injector.get(NgControl, null);\n\n    if (this.element) {\n      this.renderer.removeAttribute(this.element.nativeElement, 'tabindex');\n      this.zone.runOutsideAngular(() => {\n        this.bindEvents();\n      });\n    }\n  }\n  /**\n   * @hidden\n   */\n\n\n  ngOnChanges(changes) {\n    if (changes.min || changes.max || changes.rangeValidation || changes.incompleteDateValidation) {\n      this.timeRangeValidateFn = this.rangeValidation ? timeRangeValidator(this.min, this.max) : noop;\n      this.incompleteValidator = this.incompleteDateValidation ? incompleteDateValidator() : noop;\n      this.onValidatorChange();\n    }\n\n    if (changes.format) {\n      this.verifyFormat();\n    }\n  }\n  /**\n   * @hidden\n   */\n\n\n  ngOnDestroy() {\n    this.isActive = false;\n    this.show = false;\n\n    if (this.localizationChangeSubscription) {\n      this.localizationChangeSubscription.unsubscribe();\n    }\n\n    if (this.windowBlurSubscription) {\n      this.windowBlurSubscription.unsubscribe();\n    }\n\n    this.domEvents.forEach(unbindCallback => unbindCallback());\n    this.pickerSubscriptions.unsubscribe();\n  }\n  /**\n   * @hidden\n   */\n\n\n  handleKeydown(event) {\n    const {\n      altKey,\n      keyCode\n    } = event;\n\n    if (keyCode === Keys.Escape) {\n      this.show = false;\n      return;\n    }\n\n    if (altKey) {\n      if (keyCode === Keys.ArrowUp) {\n        this.show = false;\n      }\n\n      if (keyCode === Keys.ArrowDown && !this.show) {\n        this.show = true;\n      }\n    }\n  }\n  /**\n   * @hidden\n   */\n\n\n  writeValue(value) {\n    this.verifyValue(value);\n    this.value = cloneDate(value);\n    this.cdr.markForCheck();\n\n    if (!value && this.input) {\n      this.input.placeholder = this.placeholder;\n      this.input.writeValue(value);\n    }\n  }\n  /**\n   * @hidden\n   */\n\n\n  registerOnChange(fn) {\n    this.onControlChange = fn;\n  }\n  /**\n   * @hidden\n   */\n\n\n  registerOnTouched(fn) {\n    this.onControlTouched = fn;\n  }\n  /**\n   * @hidden\n   */\n\n\n  setDisabledState(isDisabled) {\n    this.disabled = isDisabled;\n    this.cdr.markForCheck();\n  }\n  /**\n   * @hidden\n   */\n\n\n  validate(control) {\n    return this.timeRangeValidateFn(control) || this.incompleteValidator(control, this.input && this.input.isDateIncomplete);\n  }\n  /**\n   * @hidden\n   */\n\n\n  registerOnValidatorChange(fn) {\n    this.onValidatorChange = fn;\n  }\n  /**\n   * Focuses the TimePicker component.\n   *\n   * @example\n   * ```ts\n   * _@Component({\n   * selector: 'my-app',\n   * template: `\n   *  <button (click)=\"timepicker.focus()\">Focus time picker</button>\n   *  <kendo-timepicker #timepicker></kendo-timepicker>\n   * `\n   * })\n   * export class AppComponent { }\n   * ```\n   */\n\n\n  focus() {\n    this.input.focus();\n  }\n  /**\n   * Blurs the TimePicker component.\n   */\n\n\n  blur() {\n    (this.timeSelector || this.input)['blur'](); //tslint:disable-line:no-string-literal\n  }\n  /**\n   * Toggles the visibility of the popup. If you use the `toggle` method to show or hide the popup,\n   * the `open` and `close` events do not fire.\n   *\n   * @param show - The state of the popup.\n   */\n\n\n  toggle(show) {\n    if (this.disabled || this.readonly) {\n      return;\n    }\n\n    this.resolvedPromise.then(() => {\n      this._toggle(show === undefined ? !this.show : show);\n    });\n  }\n  /**\n   * Returns the current open state of the popup.\n   */\n\n\n  get isOpen() {\n    return this.show;\n  }\n  /**\n   * @hidden\n   */\n\n\n  get appendTo() {\n    const {\n      appendTo\n    } = this.popupSettings;\n\n    if (!appendTo || appendTo === 'root') {\n      return undefined;\n    }\n\n    return appendTo === 'component' ? this.container : appendTo;\n  }\n  /**\n   * @hidden\n   */\n\n\n  handleChange(value) {\n    if (isEqual(this.value, value)) {\n      this.focusInput();\n      this.show = false;\n      return;\n    }\n\n    this.value = cloneDate(value);\n    this.zone.run(() => {\n      this.focusInput();\n      this.show = false;\n      this.onControlChange(cloneDate(value));\n      this.valueChange.emit(cloneDate(value));\n    });\n  }\n  /**\n   * @hidden\n   */\n\n\n  handleReject() {\n    this.show = false;\n  }\n  /**\n   * @hidden\n   */\n\n\n  handleInputChange(value) {\n    const val = this.input.formatSections.date ? value : this.mergeTime(value);\n    this.handleChange(val);\n  }\n  /**\n   * @hidden\n   */\n\n\n  handleMousedown(args) {\n    args.preventDefault();\n  }\n  /**\n   * @hidden\n   */\n\n\n  handleIconClick(event) {\n    if (this.disabled || this.readonly) {\n      return;\n    }\n\n    event.preventDefault();\n    this.focusInput(); //XXX: explicit call handleFocus handler here\n    //due to async IE focus event\n\n    this.handleFocus();\n    this.show = !this.show;\n  }\n  /**\n   * @hidden\n   */\n\n\n  get popupClasses() {\n    return ['k-group', 'k-reset'].concat(this.popupSettings.popupClass || []);\n  }\n  /**\n   * @hidden\n   */\n\n\n  normalizeTime(date) {\n    return setTime(MIDNIGHT_DATE, date);\n  }\n  /**\n   * @hidden\n   */\n\n\n  mergeTime(value) {\n    return this.value && value ? setTime(this.value, value) : value;\n  }\n\n  togglePopup(show) {\n    const event = new PreventableEvent();\n\n    if (!this._show && show) {\n      this.open.emit(event);\n    } else if (this._show && !show) {\n      this.close.emit(event);\n    }\n\n    if (event.isDefaultPrevented()) {\n      return;\n    }\n\n    this._toggle(show);\n\n    this.toggleFocus();\n  }\n\n  _toggle(show) {\n    if (show === this.isOpen) {\n      return;\n    }\n\n    this._show = show;\n    this.cdr.markForCheck();\n\n    if (show) {\n      const direction = this.localization.rtl ? 'right' : 'left';\n      this.popupRef = this.popupService.open({\n        anchor: this.wrapper,\n        anchorAlign: {\n          vertical: 'bottom',\n          horizontal: direction\n        },\n        animate: this.popupSettings.animate,\n        appendTo: this.appendTo,\n        content: this.popupTemplate,\n        popupAlign: {\n          vertical: 'top',\n          horizontal: direction\n        },\n        popupClass: this.popupClasses,\n        positionMode: 'absolute'\n      });\n      this.popupRef.popupElement.setAttribute('id', this.popupUID);\n      this.popupRef.popupAnchorViewportLeave.subscribe(() => this.show = false);\n    } else {\n      this.popupRef.close();\n      this.popupRef = null;\n    }\n  }\n\n  focusInput() {\n    if (this.touchEnabled) {\n      return;\n    }\n\n    this.input.focus();\n  }\n\n  toggleFocus() {\n    if (!this.isActive) {\n      return;\n    }\n\n    if (this.show) {\n      if (!this.timeSelector) {\n        this.cdr.detectChanges();\n      }\n\n      if (this.isActive) {\n        this.timeSelector.focus();\n      }\n    } else if (!this.touchEnabled) {\n      this.input.focus();\n    } else if (!this.input.isActive) {\n      this.handleBlur();\n    }\n  }\n\n  verifyValue(value) {\n    if (!isDevMode()) {\n      return;\n    }\n\n    if (value && !(value instanceof Date)) {\n      throw new Error(`The 'value' should be a valid JavaScript Date instance. Check ${VALUE_DOC_LINK$3} for possible resolution.`);\n    }\n  }\n\n  verifyFormat() {\n    if (!isDevMode()) {\n      return;\n    }\n\n    const formatContainsDateParts = this.intl.splitDateFormat(this.format).some(part => !formatRegExp.test(part.type));\n\n    if (formatContainsDateParts) {\n      throw new Error(`Provided format is not supported. Supported specifiers are T|t|H|h|m|s|S|a. See ${INTL_DATE_FORMAT}`);\n    }\n  }\n\n  bindEvents() {\n    const element = this.element.nativeElement;\n    this.domEvents.push(this.renderer.listen(element, 'keydown', this.handleKeydown.bind(this)));\n\n    if (isWindowAvailable()) {\n      this.windowBlurSubscription = fromEvent(window, 'blur').subscribe(this.handleWindowBlur.bind(this));\n    }\n  }\n\n  handleWindowBlur() {\n    if (!this.isOpen) {\n      return;\n    }\n\n    this.show = false;\n  }\n\n  handleFocus() {\n    if (this.isActive) {\n      return;\n    }\n\n    this.isActive = true;\n\n    if (hasObservers(this.onFocus)) {\n      this.zone.run(() => {\n        this.onFocus.emit();\n      });\n    }\n  }\n\n  handleBlur(args) {\n    const currentTarget = args && currentFocusTarget(args);\n\n    if (currentTarget && (this.input.containsElement(currentTarget) || this.timeSelector && this.timeSelector.containsElement(currentTarget))) {\n      return;\n    }\n\n    if (hasObservers(this.onBlur) || this.show && hasObservers(this.close) || requiresZoneOnBlur(this.control)) {\n      this.zone.run(() => {\n        this.blurComponent();\n        this.cdr.markForCheck();\n      });\n    } else {\n      this.blurComponent();\n    }\n  }\n\n  blurComponent() {\n    this.isActive = false; // order is important ¯\\_(ツ)_/¯\n\n    this.show = false;\n    this.onControlTouched();\n    this.onBlur.emit();\n  }\n\n  handleDateCompletenessChange() {\n    this.cdr.markForCheck();\n    this.zone.run(() => this.onValidatorChange());\n  }\n\n};\n\nTimePickerComponent.ɵfac = function TimePickerComponent_Factory(t) {\n  return new (t || TimePickerComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc4.LocalizationService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc5.PopupService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Injector), ɵngcc0.ɵɵdirectiveInject(PickerService), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.IntlService), ɵngcc0.ɵɵdirectiveInject(TOUCH_ENABLED, 8));\n};\n\nTimePickerComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n  type: TimePickerComponent,\n  selectors: [[\"kendo-timepicker\"]],\n  viewQuery: function TimePickerComponent_Query(rf, ctx) {\n    if (rf & 1) {\n      ɵngcc0.ɵɵviewQuery(_c17, 5, ViewContainerRef);\n      ɵngcc0.ɵɵviewQuery(_c18, 5);\n      ɵngcc0.ɵɵviewQuery(_c19, 5);\n    }\n\n    if (rf & 2) {\n      let _t;\n\n      ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.container = _t.first);\n      ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.popupTemplate = _t.first);\n      ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.wrapper = _t.first);\n    }\n  },\n  hostVars: 6,\n  hostBindings: function TimePickerComponent_HostBindings(rf, ctx) {\n    if (rf & 2) {\n      ɵngcc0.ɵɵclassProp(\"k-widget\", ctx.wrapperClasses)(\"k-timepicker\", ctx.wrapperClasses)(\"k-state-disabled\", ctx.disabledClass);\n    }\n  },\n  inputs: {\n    focusableId: \"focusableId\",\n    disabled: \"disabled\",\n    readonly: \"readonly\",\n    readOnlyInput: \"readOnlyInput\",\n    format: \"format\",\n    placeholder: \"placeholder\",\n    incompleteDateValidation: \"incompleteDateValidation\",\n    cancelButton: \"cancelButton\",\n    nowButton: \"nowButton\",\n    tabindex: \"tabindex\",\n    title: \"title\",\n    rangeValidation: \"rangeValidation\",\n    min: \"min\",\n    max: \"max\",\n    steps: \"steps\",\n    popupSettings: \"popupSettings\",\n    tabIndex: \"tabIndex\",\n    value: \"value\",\n    formatPlaceholder: \"formatPlaceholder\"\n  },\n  outputs: {\n    valueChange: \"valueChange\",\n    onFocus: \"focus\",\n    onBlur: \"blur\",\n    open: \"open\",\n    close: \"close\"\n  },\n  exportAs: [\"kendo-timepicker\"],\n  features: [ɵngcc0.ɵɵProvidersFeature([{\n    provide: NG_VALUE_ACCESSOR,\n    useExisting: forwardRef(() => TimePickerComponent_1),\n    multi: true\n  }, {\n    provide: NG_VALIDATORS,\n    useExisting: forwardRef(() => TimePickerComponent_1),\n    multi: true\n  }, {\n    provide: KendoInput,\n    useExisting: forwardRef(() => TimePickerComponent_1)\n  }, LocalizationService, {\n    provide: L10N_PREFIX,\n    useValue: 'kendo.timepicker'\n  }, PickerService]), ɵngcc0.ɵɵNgOnChangesFeature],\n  decls: 11,\n  vars: 26,\n  consts: function () {\n    let i18n_30;\n\n    if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n      /**\n       * @desc The Accept button text in the timepicker component\n       * @meaning kendo.timepicker.accept\n       */\n      const MSG_EXTERNAL_7519663530416240229$$DIST_FESM2015_INDEX_JS_31 = goog.getMsg(\"Set\");\n      i18n_30 = MSG_EXTERNAL_7519663530416240229$$DIST_FESM2015_INDEX_JS_31;\n    } else {\n      i18n_30 = $localize`:kendo.timepicker.accept|The Accept button text in the timepicker component␟4c3bf42192220c7611c09ece1c5de14855139dd0␟7519663530416240229:Set`;\n    }\n\n    let i18n_32;\n\n    if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n      /**\n       * @desc The label for the Accept button in the timepicker component\n       * @meaning kendo.timepicker.acceptLabel\n       */\n      const MSG_EXTERNAL_4355879331538595758$$DIST_FESM2015_INDEX_JS_33 = goog.getMsg(\"Set time\");\n      i18n_32 = MSG_EXTERNAL_4355879331538595758$$DIST_FESM2015_INDEX_JS_33;\n    } else {\n      i18n_32 = $localize`:kendo.timepicker.acceptLabel|The label for the Accept button in the timepicker component␟93c2a9c3aa49f56e452c0aecbaabe3bb33fa4222␟4355879331538595758:Set time`;\n    }\n\n    let i18n_34;\n\n    if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n      /**\n       * @desc The Cancel button text in the timepicker component\n       * @meaning kendo.timepicker.cancel\n       */\n      const MSG_EXTERNAL_1086687567255473060$$DIST_FESM2015_INDEX_JS_35 = goog.getMsg(\"Cancel\");\n      i18n_34 = MSG_EXTERNAL_1086687567255473060$$DIST_FESM2015_INDEX_JS_35;\n    } else {\n      i18n_34 = $localize`:kendo.timepicker.cancel|The Cancel button text in the timepicker component␟132eefca16bd41d489b4647724b91e93793603aa␟1086687567255473060:Cancel`;\n    }\n\n    let i18n_36;\n\n    if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n      /**\n       * @desc The label for the Cancel button in the timepicker component\n       * @meaning kendo.timepicker.cancelLabel\n       */\n      const MSG_EXTERNAL_83621966901491941$$DIST_FESM2015_INDEX_JS_37 = goog.getMsg(\"Cancel changes\");\n      i18n_36 = MSG_EXTERNAL_83621966901491941$$DIST_FESM2015_INDEX_JS_37;\n    } else {\n      i18n_36 = $localize`:kendo.timepicker.cancelLabel|The label for the Cancel button in the timepicker component␟2cf6f4ca4470810944b4016c9b6f87943d3390ab␟83621966901491941:Cancel changes`;\n    }\n\n    let i18n_38;\n\n    if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n      /**\n       * @desc The Now button text in the timepicker component\n       * @meaning kendo.timepicker.now\n       */\n      const MSG_EXTERNAL_5912507758515138116$$DIST_FESM2015_INDEX_JS_39 = goog.getMsg(\"Now\");\n      i18n_38 = MSG_EXTERNAL_5912507758515138116$$DIST_FESM2015_INDEX_JS_39;\n    } else {\n      i18n_38 = $localize`:kendo.timepicker.now|The Now button text in the timepicker component␟bbc99bb74ae75a503bd813aad0c7253d3553e923␟5912507758515138116:Now`;\n    }\n\n    let i18n_40;\n\n    if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n      /**\n       * @desc The label for the Now button in the timepicker component\n       * @meaning kendo.timepicker.nowLabel\n       */\n      const MSG_EXTERNAL_371982627910576599$$DIST_FESM2015_INDEX_JS_41 = goog.getMsg(\"Select now\");\n      i18n_40 = MSG_EXTERNAL_371982627910576599$$DIST_FESM2015_INDEX_JS_41;\n    } else {\n      i18n_40 = $localize`:kendo.timepicker.nowLabel|The label for the Now button in the timepicker component␟df1a696f318275aa934e27850920889d494c2740␟371982627910576599:Select now`;\n    }\n\n    let i18n_42;\n\n    if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n      /**\n       * @desc The label for the toggle button in the timepicker component\n       * @meaning kendo.timepicker.toggle\n       */\n      const MSG_EXTERNAL_6938407659294495526$$DIST_FESM2015_INDEX_JS_43 = goog.getMsg(\"Toggle time list\");\n      i18n_42 = MSG_EXTERNAL_6938407659294495526$$DIST_FESM2015_INDEX_JS_43;\n    } else {\n      i18n_42 = $localize`:kendo.timepicker.toggle|The label for the toggle button in the timepicker component␟f2c196786ed2d3ecb2369750c36aac9a4053fb30␟6938407659294495526:Toggle time list`;\n    }\n\n    return [[\"kendoTimePickerLocalizedMessages\", \"\", \"accept\", i18n_30, \"acceptLabel\", i18n_32, \"cancel\", i18n_34, \"cancelLabel\", i18n_36, \"now\", i18n_38, \"nowLabel\", i18n_40, \"toggle\", i18n_42], [1, \"k-picker-wrap\"], [\"wrapper\", \"\"], [3, \"focusableId\", \"hasPopup\", \"isPopupOpen\", \"disabled\", \"readonly\", \"role\", \"ariaReadOnly\", \"format\", \"formatPlaceholder\", \"placeholder\", \"min\", \"max\", \"incompleteDateValidation\", \"steps\", \"tabindex\", \"title\", \"value\", \"valueChange\"], [\"input\", \"\"], [\"role\", \"button\", 1, \"k-select\", 3, \"kendoEventsOutsideAngular\", \"scope\"], [1, \"k-icon\", \"k-i-clock\"], [\"popupTemplate\", \"\"], [\"container\", \"\"], [3, \"cancelButton\", \"nowButton\", \"format\", \"min\", \"max\", \"steps\", \"value\", \"kendoEventsOutsideAngular\", \"scope\", \"valueChange\", \"valueReject\"], [\"timeSelector\", \"\"], [3, \"acceptLabel\", \"accept\", \"cancelLabel\", \"cancel\", \"nowLabel\", \"now\"]];\n  },\n  template: function TimePickerComponent_Template(rf, ctx) {\n    if (rf & 1) {\n      ɵngcc0.ɵɵelementContainer(0, 0);\n      ɵngcc0.ɵɵelementStart(1, \"span\", 1, 2);\n      ɵngcc0.ɵɵelementStart(3, \"kendo-dateinput\", 3, 4);\n      ɵngcc0.ɵɵlistener(\"valueChange\", function TimePickerComponent_Template_kendo_dateinput_valueChange_3_listener($event) {\n        return ctx.handleInputChange($event);\n      });\n      ɵngcc0.ɵɵelementEnd();\n      ɵngcc0.ɵɵelementStart(5, \"span\", 5);\n      ɵngcc0.ɵɵelement(6, \"span\", 6);\n      ɵngcc0.ɵɵelementEnd();\n      ɵngcc0.ɵɵtemplate(7, TimePickerComponent_ng_template_7_Template, 3, 18, \"ng-template\", null, 7, ɵngcc0.ɵɵtemplateRefExtractor);\n      ɵngcc0.ɵɵelementEnd();\n      ɵngcc0.ɵɵelementContainer(9, null, 8);\n    }\n\n    if (rf & 2) {\n      ɵngcc0.ɵɵadvance(1);\n      ɵngcc0.ɵɵclassProp(\"k-state-disabled\", ctx.disabled);\n      ɵngcc0.ɵɵadvance(2);\n      ɵngcc0.ɵɵproperty(\"focusableId\", ctx.focusableId)(\"hasPopup\", true)(\"isPopupOpen\", ctx.show)(\"disabled\", ctx.disabled)(\"readonly\", ctx.readonly || ctx.readOnlyInput)(\"role\", ctx.inputRole)(\"ariaReadOnly\", ctx.readonly)(\"format\", ctx.format)(\"formatPlaceholder\", ctx.formatPlaceholder)(\"placeholder\", ctx.placeholder)(\"min\", ctx.normalizeTime(ctx.min))(\"max\", ctx.normalizeTime(ctx.max))(\"incompleteDateValidation\", ctx.incompleteDateValidation)(\"steps\", ctx.steps)(\"tabindex\", !ctx.show ? ctx.tabindex : -1)(\"title\", ctx.title)(\"value\", ctx.value);\n      ɵngcc0.ɵɵadvance(2);\n      ɵngcc0.ɵɵproperty(\"kendoEventsOutsideAngular\", ɵngcc0.ɵɵpureFunction2(23, _c29, ctx.handleIconClick, ctx.handleMousedown))(\"scope\", ctx);\n      ɵngcc0.ɵɵattribute(\"title\", ctx.localization.get(\"toggle\"))(\"aria-label\", ctx.localization.get(\"toggle\"));\n    }\n  },\n  directives: function () {\n    return [TimePickerLocalizedMessagesDirective, DateInputComponent, ɵngcc3.EventsOutsideAngularDirective, TimeSelectorComponent, TimeSelectorCustomMessagesComponent];\n  },\n  encapsulation: 2,\n  changeDetection: 0\n});\n\n__decorate([ViewChild('container', {\n  read: ViewContainerRef,\n  static: false\n}), __metadata(\"design:type\", ViewContainerRef)], TimePickerComponent.prototype, \"container\", void 0);\n\n__decorate([ViewChild('popupTemplate', {\n  static: false\n}), __metadata(\"design:type\", TemplateRef)], TimePickerComponent.prototype, \"popupTemplate\", void 0);\n\n__decorate([ViewChild('wrapper', {\n  static: false\n}), __metadata(\"design:type\", ElementRef)], TimePickerComponent.prototype, \"wrapper\", void 0);\n\n__decorate([Input(), __metadata(\"design:type\", String)], TimePickerComponent.prototype, \"focusableId\", void 0);\n\n__decorate([Input(), __metadata(\"design:type\", Boolean)], TimePickerComponent.prototype, \"disabled\", void 0);\n\n__decorate([Input(), __metadata(\"design:type\", Boolean)], TimePickerComponent.prototype, \"readonly\", void 0);\n\n__decorate([Input(), __metadata(\"design:type\", Boolean)], TimePickerComponent.prototype, \"readOnlyInput\", void 0);\n\n__decorate([Input(), __metadata(\"design:type\", String)], TimePickerComponent.prototype, \"format\", void 0);\n\n__decorate([Input(), __metadata(\"design:type\", Object)], TimePickerComponent.prototype, \"formatPlaceholder\", void 0);\n\n__decorate([Input(), __metadata(\"design:type\", String)], TimePickerComponent.prototype, \"placeholder\", void 0);\n\n__decorate([Input(), __metadata(\"design:type\", Date), __metadata(\"design:paramtypes\", [Date])], TimePickerComponent.prototype, \"min\", null);\n\n__decorate([Input(), __metadata(\"design:type\", Date), __metadata(\"design:paramtypes\", [Date])], TimePickerComponent.prototype, \"max\", null);\n\n__decorate([Input(), __metadata(\"design:type\", Boolean)], TimePickerComponent.prototype, \"incompleteDateValidation\", void 0);\n\n__decorate([Input(), __metadata(\"design:type\", Boolean)], TimePickerComponent.prototype, \"cancelButton\", void 0);\n\n__decorate([Input(), __metadata(\"design:type\", Boolean)], TimePickerComponent.prototype, \"nowButton\", void 0);\n\n__decorate([Input(), __metadata(\"design:type\", Object), __metadata(\"design:paramtypes\", [Object])], TimePickerComponent.prototype, \"steps\", null);\n\n__decorate([Input(), __metadata(\"design:type\", Object), __metadata(\"design:paramtypes\", [Object])], TimePickerComponent.prototype, \"popupSettings\", null);\n\n__decorate([Input(), __metadata(\"design:type\", Number)], TimePickerComponent.prototype, \"tabindex\", void 0);\n\n__decorate([Input(), __metadata(\"design:type\", Number), __metadata(\"design:paramtypes\", [Number])], TimePickerComponent.prototype, \"tabIndex\", null);\n\n__decorate([Input(), __metadata(\"design:type\", String)], TimePickerComponent.prototype, \"title\", void 0);\n\n__decorate([Input(), __metadata(\"design:type\", Boolean)], TimePickerComponent.prototype, \"rangeValidation\", void 0);\n\n__decorate([Input(), __metadata(\"design:type\", Date), __metadata(\"design:paramtypes\", [Date])], TimePickerComponent.prototype, \"value\", null);\n\n__decorate([Output(), __metadata(\"design:type\", EventEmitter)], TimePickerComponent.prototype, \"valueChange\", void 0);\n\n__decorate([Output('focus'), __metadata(\"design:type\", EventEmitter)], TimePickerComponent.prototype, \"onFocus\", void 0);\n\n__decorate([Output('blur'), __metadata(\"design:type\", EventEmitter)], TimePickerComponent.prototype, \"onBlur\", void 0);\n\n__decorate([Output(), __metadata(\"design:type\", EventEmitter)], TimePickerComponent.prototype, \"open\", void 0);\n\n__decorate([Output(), __metadata(\"design:type\", EventEmitter)], TimePickerComponent.prototype, \"close\", void 0);\n\n__decorate([HostBinding('class.k-widget'), HostBinding('class.k-timepicker'), __metadata(\"design:type\", Boolean)], TimePickerComponent.prototype, \"wrapperClasses\", void 0);\n\n__decorate([HostBinding('class.k-state-disabled'), __metadata(\"design:type\", Boolean), __metadata(\"design:paramtypes\", [])], TimePickerComponent.prototype, \"disabledClass\", null);\n\nTimePickerComponent = TimePickerComponent_1 = __decorate([__param(9, Optional()), __param(9, Inject(TOUCH_ENABLED)), __metadata(\"design:paramtypes\", [NgZone, LocalizationService, ChangeDetectorRef, PopupService, ElementRef, Renderer2, Injector, PickerService, IntlService, Boolean])], TimePickerComponent);\nvar DateTimePickerComponent_1;\nconst timeFormatRegExp = new RegExp(`${TIME_PART.hour}|${TIME_PART.minute}|${TIME_PART.second}|${TIME_PART.dayperiod}|literal`);\nconst VALUE_DOC_LINK$4 = 'https://www.telerik.com/kendo-angular-ui/components/dateinputs/datetimepicker/integration-with-json/';\nconst MIN_MAX_DOC_LINK = 'https://www.telerik.com/kendo-angular-ui/components/dateinputs/datetimepicker/date-time-limits/';\nconst DEFAULT_ACTIVE_TAB = 'date';\nconst DEFAULT_DATEINPUT_FORMAT = 'g';\nconst DEFAULT_TIMESELECTOR_FORMAT = 't';\nconst TWO_DIGIT_YEAR_MAX$2 = 68;\n/**\n * Represents the [Kendo UI DateTimePicker component for Angular]({% slug overview_datetimepicker %}).\n */\n\nlet DateTimePickerComponent = DateTimePickerComponent_1 = class DateTimePickerComponent {\n  constructor(popupService, intl, cdr, pickerService, ngZone, host, touchEnabled$$1, localization, disabledDatesService, renderer) {\n    this.popupService = popupService;\n    this.intl = intl;\n    this.cdr = cdr;\n    this.pickerService = pickerService;\n    this.ngZone = ngZone;\n    this.host = host;\n    this.touchEnabled = touchEnabled$$1;\n    this.localization = localization;\n    this.disabledDatesService = disabledDatesService;\n    this.renderer = renderer;\n    /**\n     * @hidden\n     */\n\n    this.hostClasses = true;\n    /**\n     * The maximum year to assume to be from the current century when typing two-digit year value\n     * ([see example]({% slug formats_datetimepicker %}#toc-two-digit-year-format)).\n     *\n     * The default value is 68, indicating that typing any value less than 69\n     * will be assumed to be 20xx, while 69 and larger will be assumed to be 19xx.\n     */\n\n    this.twoDigitYearMax = TWO_DIGIT_YEAR_MAX$2;\n    /**\n     * @hidden\n     */\n\n    this.focusableId = `k-${guid()}`;\n    /**\n     * Sets the title of the input element of the DateTimePicker.\n     */\n\n    this.title = '';\n    /**\n     * Sets or gets the `disabled` property of the DateTimePicker and determines whether the component is active\n     * ([see example]({% slug disabled_datetimepicker %})).\n     */\n\n    this.disabled = false;\n    /**\n     * Sets the read-only state of the DateTimePicker\n     * ([see example]({% slug readonly_datetimepicker %}#toc-read-only-datetimepicker)).\n     */\n\n    this.readonly = false;\n    /**\n     * Sets the read-only state of the DateTimePicker input field\n     * ([see example]({% slug readonly_datetimepicker %}#toc-read-only-input)).\n     *\n     * > Note that if you set the [`readonly`]({% slug api_dateinputs_datetimepickercomponent %}#toc-readonly) property value to `true`,\n     * the input will be rendered in a read-only state regardless of the `readOnlyInput` value.\n     */\n\n    this.readOnlyInput = false;\n    /**\n     * Determines whether to display the **Cancel** button in the popup\n     * ([see example]({% slug datetimepicker_popup_options %}#toc-toggling-the-cancel-button)).\n     */\n\n    this.cancelButton = true;\n    /**\n     * Configures the incremental steps of the DateInput and the popup component of the TimePicker\n     * ([see example]({% slug incrementalsteps_datetimepicker %})).\n     */\n\n    this.steps = {};\n    /**\n     * Specifies the Calendar type.\n     *\n     * The possible values are:\n     * - `infinite` (default)\n     * - `classic`\n     *\n     */\n\n    this.calendarType = 'infinite';\n    /**\n     * Determines whether to enable animation when navigating to previous/next Calendar view.\n     * Applies to the [`classic`]({% slug api_dateinputs_datetimepickercomponent %}#toc-calendartype) Calendar only.\n     *\n     * > This feature uses the [Web Animations API](https://developer.mozilla.org/en-US/docs/Web/API/Web_Animations_API). In order to run the animation in browsers that do not support it, you need the `web-animations-js` polyfill.\n     *\n     * @default false\n     */\n\n    this.animateCalendarNavigation = false;\n    /**\n     * Determines whether to display a week number column in the `month` view of the popup Calendar\n     * ([see example]({% slug datetimepicker_calendar_options %}#toc-week-number-column)).\n     */\n\n    this.weekNumber = false;\n    /**\n     * Determines whether the built-in min or max validators are enforced when validating a form\n     * ([see example]({% slug dateranges_datetimepicker %}#toc-prevent-invalid-input)).\n     */\n\n    this.rangeValidation = true;\n    /**\n     * Determines whether the built-in validator for disabled\n     * date ranges is enforced when validating a form\n     * ([see example]({% slug disabled_dates_datetimepicker %}#toc-validation)).\n     */\n\n    this.disabledDatesValidation = true;\n    /**\n     * Determines whether the built-in validation for incomplete dates is to be enforced when a form is being validated.\n     */\n\n    this.incompleteDateValidation = false;\n    /**\n     * Fires each time the user selects a new value.\n     * ([more information and example]({% slug overview_datetimepicker %}#toc-methods-and-events)).\n     */\n\n    this.valueChange = new EventEmitter();\n    /**\n     * Fires each time the popup is about to open.\n     * This event is preventable. If you cancel the event by setting `event.preventDefault()`, the popup will remain closed.\n     * ([more information and example]({% slug overview_datetimepicker %}#toc-methods-and-events)).\n     */\n\n    this.open = new EventEmitter();\n    /**\n     * Fires each time the popup is about to close.\n     * This event is preventable. If you cancel the event by setting `event.preventDefault()`, the popup will remain open.\n     * ([more information and example]({% slug overview_datetimepicker %}#toc-methods-and-events)).\n     */\n\n    this.close = new EventEmitter();\n    /**\n     * Fires each time the user focuses the component.\n     * ([more information and example]({% slug overview_datetimepicker %}#toc-methods-and-events)).\n     */\n\n    this.onFocus = new EventEmitter();\n    /**\n     * Fires each time the user blurs the component.\n     * ([more information and example]({% slug overview_datetimepicker %}#toc-methods-and-events)).\n     */\n\n    this.onBlur = new EventEmitter();\n    /**\n     * @hidden\n     *\n     * Controls whether the Calendar or the TimeSelector will be displayed.\n     */\n\n    this.activeTab = DEFAULT_ACTIVE_TAB;\n    /**\n     * @hidden\n     *\n     * Specifies the stripped time-related format that is used in the TimeSelector.\n     * Updates each time the `format` property value changes.\n     */\n\n    this.timeSelectorFormat = DEFAULT_TIMESELECTOR_FORMAT;\n    /**\n     * @hidden\n     */\n\n    this.timeSelectorMin = cloneDate(MIN_TIME);\n    /**\n     * @hidden\n     */\n\n    this.timeSelectorMax = cloneDate(MAX_TIME);\n    /**\n     * @hidden\n     */\n\n    this.calendarValue = null;\n    /**\n     * @hidden\n     */\n\n    this.calendarMin = cloneDate(MIN_DATE);\n    /**\n     * @hidden\n     */\n\n    this.calendarMax = lastMillisecondOfDate(MAX_DATE);\n    this._popupSettings = {\n      animate: true\n    };\n    this._value = null;\n    this._format = DEFAULT_DATEINPUT_FORMAT;\n    this._tabindex = 0;\n    this._defaultTab = DEFAULT_ACTIVE_TAB;\n    this._min = mergeDateAndTime(MIN_DATE, MIN_TIME);\n    this._max = mergeDateAndTime(MAX_DATE, MAX_TIME);\n    this._isActive = false;\n    this.onControlTouched = noop;\n    this.onControlChange = noop;\n    this.onValidatorChange = noop;\n    this.minValidateFn = noop;\n    this.maxValidateFn = noop;\n    this.disabledDatesValidateFn = noop;\n    this.incompleteValidator = noop;\n    this.subscriptions = new Subscription();\n    validatePackage(packageMetadata);\n  }\n  /**\n   * @hidden\n   */\n\n\n  get input() {\n    return this.pickerService.input;\n  }\n  /**\n   * @hidden\n   */\n\n\n  get calendar() {\n    return this.pickerService.calendar;\n  }\n  /**\n   * @hidden\n   */\n\n\n  get timeSelector() {\n    return this.pickerService.timeSelector;\n  }\n  /**\n   * Specifies the value of the DateTimePicker component.\n   *\n   * > The `value` has to be a valid [JavaScript `Date`](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Date) instance.\n   */\n\n\n  set value(value) {\n    this.verifyValue(value);\n    this._value = cloneDate(value);\n    this.setCalendarValue(value);\n    this.cdr.markForCheck();\n  }\n\n  get value() {\n    return this._value;\n  }\n  /**\n   * Specifies the date format for displaying the input value\n   * ([see example]({% slug formats_datetimepicker %}))\n   *\n   * Format value options:\n   * - `string` - Provide a `string` if a single format is going to be used regardless whether the input is focused or blurred.\n   * - [`FormatSettings`]({% slug api_dateinputs_formatsettings %}) - To display different formats when the component is focused or blurred, provide a settings object with specified `inputFormat` and `displayFormat` values.\n   *\n   * > If a [`FormatSettings`]({% slug api_dateinputs_formatsettings %}) object is provided, the `displayFormat` value will be used for the popup TimePicker.\n   */\n\n\n  set format(format) {\n    this._format = format;\n    const displayFormat = this.getDisplayFormat(format);\n    this.timeSelectorFormat = this.getTimeSelectorFormat(displayFormat);\n  }\n\n  get format() {\n    return this._format;\n  }\n  /**\n   * Specifies the [`tabindex`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the DateTimePicker.\n   */\n\n\n  set tabindex(value) {\n    const tabindex = Number(value);\n    const defaultValue = 0;\n    this._tabindex = !isNaN(tabindex) ? tabindex : defaultValue;\n  }\n\n  get tabindex() {\n    return this.disabled ? -1 : this._tabindex;\n  }\n  /**\n   * Sets the dates of the DateTimePicker that will be disabled\n   * ([see example]({% slug disabled_dates_datetimepicker %})).\n   */\n\n\n  set disabledDates(value) {\n    this._disabledDates = value;\n    this.disabledDatesService.initialize(value);\n  }\n\n  get disabledDates() {\n    return this._disabledDates;\n  }\n  /**\n   * Configures the popup settings of the DateTimePicker\n   * ([see example]({% slug datetimepicker_popup_options %}#toc-customizing-the-popup)).\n   *\n   * The available options are:\n   * - `animate: Boolean`&mdash;Controls the popup animation. By default, the open and close animations are enabled.\n   * - `appendTo: 'root' | 'component' | ViewContainerRef`&mdash;Controls the popup container. By default, the popup will be appended to the root component.\n   * - `popupClass: String`&mdash;Specifies a list of CSS classes that are used to style the popup.\n   */\n\n\n  set popupSettings(settings) {\n    this._popupSettings = Object.assign({}, {\n      animate: true\n    }, settings);\n  }\n\n  get popupSettings() {\n    return this._popupSettings;\n  }\n  /**\n   * Specifies the smallest valid date.\n   * The Calendar will not display dates before this value.\n   * If the `min` value of the Calendar is selected, the TimePicker will not display\n   * time entries before the specified time portion of this value\n   * ([see example]({% slug dateranges_datetimepicker %})).\n   */\n\n\n  set min(value) {\n    if (!isPresent(value)) {\n      return;\n    }\n\n    this._min = cloneDate(value);\n    this.calendarMin = getDate(value);\n  }\n\n  get min() {\n    return this._min;\n  }\n  /**\n   * Specifies the biggest valid date.\n   * The Calendar will not display dates after this value.\n   * If the `max` value of the Calendar is selected, the TimePicker will not display\n   * time entries after the specified time portion of this value\n   * ([see example]({% slug dateranges_datetimepicker %})).\n   */\n\n\n  set max(value) {\n    if (!isPresent(value)) {\n      return;\n    }\n\n    this._max = cloneDate(value);\n    this.calendarMax = lastMillisecondOfDate(value);\n  }\n\n  get max() {\n    return this._max;\n  }\n  /**\n   * Indicates whether the component is currently open.\n   */\n\n\n  get isOpen() {\n    return isPresent(this.popupRef);\n  }\n  /**\n   * Indicates whether the component or its popup content is focused.\n   */\n\n\n  get isActive() {\n    return this._isActive;\n  }\n\n  set isActive(value) {\n    if (value) {\n      this.renderer.addClass(this.wrapper.nativeElement, 'k-state-focused');\n    } else {\n      this.renderer.removeClass(this.wrapper.nativeElement, 'k-state-focused');\n    }\n\n    this._isActive = value;\n  }\n  /**\n   * Sets the active tab on opening the popup\n   * ([see example]({% slug datetimepicker_popup_options %}#toc-setting-the-default-tab)).\n   */\n\n\n  set defaultTab(tab) {\n    this._defaultTab = tab || DEFAULT_ACTIVE_TAB;\n    this.activeTab = this.defaultTab;\n  }\n\n  get defaultTab() {\n    return this._defaultTab;\n  }\n  /**\n   * @hidden\n   */\n\n\n  get tabSwitchTransition() {\n    /*\n     When the popup is opening, disables the set transition in the themes. When `defaultTab` is set to `time`,\n     the popup opens with an active **Time** tab and the animation of the initial transition is undesired.\n     Setting the inline transition style to `none` overrides the set animation in the themes.\n     Setting the inline transition style to `null` does not apply any inline styles or override the themes CSS.\n    */\n    return this.isOpen ? null : 'none';\n  }\n  /**\n   * @hidden\n   *\n   * Indicates whether the Calendar will be disabled.\n   * The inactive tab component gets disabled and becomes inaccessible on tab click.\n   */\n\n\n  get disableCalendar() {\n    return this.activeTab !== 'date' && !this.calendar.isActive;\n  }\n  /**\n   * @hidden\n   */\n\n\n  get inputRole() {\n    return this.readOnlyInput ? 'listbox' : 'spinbutton';\n  }\n  /**\n   * @hidden\n   *\n   * Indicates whether the TimeSelector will be disabled.\n   * The inactive tab component gets disabled and becomes inaccessible on tab click.\n   */\n\n\n  get disableTimeSelector() {\n    return this.activeTab !== 'time' && !this.timeSelector.isActive;\n  }\n\n  get activeTabComponent() {\n    if (!this.isOpen) {\n      return;\n    }\n\n    if (!(isPresent(this.calendar) || isPresent(this.timeSelector))) {\n      this.cdr.detectChanges();\n    }\n\n    return this.activeTab === 'date' ? this.calendar : this.timeSelector;\n  }\n\n  get appendTo() {\n    const {\n      appendTo\n    } = this.popupSettings;\n\n    if (!isPresent(appendTo) || appendTo === 'root') {\n      return undefined;\n    }\n\n    return appendTo === 'component' ? this.container : appendTo;\n  }\n\n  ngOnInit() {\n    this.subscriptions.add(this.pickerService.onFocus // detect popup changes to disable the inactive view mark-up when the popup is open\n    .pipe(tap(this.detectPopupChanges.bind(this))).subscribe(this.handleFocus.bind(this)));\n    this.subscriptions.add(this.pickerService.onBlur.subscribe(this.handleBlur.bind(this)));\n    this.subscriptions.add(this.pickerService.sameDateSelected.subscribe(this.handleCalendarValueChange.bind(this)));\n    this.subscriptions.add(this.localization.changes.subscribe(() => this.cdr.markForCheck()));\n    this.subscriptions.add(this.pickerService.dateCompletenessChange.subscribe(this.handleDateCompletenessChange.bind(this)));\n\n    if (isWindowAvailable()) {\n      this.subscriptions.add(this.ngZone.runOutsideAngular(() => fromEvent(window, 'blur').subscribe(this.handleCancel.bind(this))));\n    }\n  }\n\n  ngOnChanges(changes) {\n    if (isPresent(changes.min) || isPresent(changes.max)) {\n      this.verifyMinMaxRange();\n    }\n\n    if (changes.min || changes.max || changes.rangeValidation || changes.disabledDatesValidation || changes.disabledDates || changes.incompleteDateValidation) {\n      this.minValidateFn = this.rangeValidation ? minValidator(this.min) : noop;\n      this.maxValidateFn = this.rangeValidation ? maxValidator(this.max) : noop;\n      this.disabledDatesValidateFn = this.disabledDatesValidation ? disabledDatesValidator(this.disabledDatesService.isDateDisabled) : noop;\n      this.incompleteValidator = this.incompleteDateValidation ? incompleteDateValidator() : noop;\n      this.onValidatorChange();\n    }\n  }\n\n  ngOnDestroy() {\n    if (this.isOpen) {\n      this.closePopup();\n    }\n\n    this.subscriptions.unsubscribe();\n  }\n  /**\n   * * If the popup is closed, focuses the DateTimePicker input.\n   * * If the popup is open, the focus is moved to its content.\n   */\n\n\n  focus() {\n    if (this.disabled) {\n      return;\n    }\n\n    if (this.isOpen) {\n      this.activeTabComponent.focus();\n    } else {\n      this.input.focus();\n    }\n  }\n  /**\n   * Blurs the DateTimePicker.\n   */\n\n\n  blur() {\n    if (this.isOpen && this.activeTabComponent.isActive) {\n      this.activeTabComponent.blur();\n    } else {\n      this.input.blur();\n    }\n  }\n  /**\n   * Toggles the visibility of the popup. If you use the `toggle` method to show or hide the popup,\n   * the `open` and `close` events do not fire.\n   * ([more information and example]({% slug overview_datetimepicker %}#toc-methods-and-events)).\n   *\n   * @param show - The state of the popup.\n   */\n\n\n  toggle(show) {\n    if (this.disabled || this.readonly || show === this.isOpen) {\n      return;\n    }\n\n    const shouldOpen = isPresent(show) ? show : !this.isOpen;\n\n    if (shouldOpen) {\n      this.openPopup();\n    } else {\n      this.closePopup(); // Changes the tab and the calendar or clock icon to the designated default.\n\n      if (this.activeTab !== this.defaultTab) {\n        this.activeTab = this.defaultTab;\n        this.cdr.detectChanges();\n      }\n    }\n  }\n  /**\n   * @hidden\n   */\n\n\n  writeValue(value) {\n    this.value = value;\n  }\n  /**\n   * @hidden\n   */\n\n\n  registerOnChange(fn) {\n    this.onControlChange = fn;\n  }\n  /**\n   * @hidden\n   */\n\n\n  registerOnTouched(fn) {\n    this.onControlTouched = fn;\n  }\n  /**\n   * @hidden\n   */\n\n\n  setDisabledState(disabled) {\n    this.disabled = disabled;\n    this.cdr.markForCheck();\n  }\n  /**\n   * @hidden\n   */\n\n\n  validate(control) {\n    return this.minValidateFn(control) || this.maxValidateFn(control) || this.disabledDatesValidateFn(control) || this.incompleteValidator(control, this.input && this.input.isDateIncomplete);\n  }\n  /**\n   * @hidden\n   */\n\n\n  registerOnValidatorChange(fn) {\n    this.onValidatorChange = fn;\n  }\n  /**\n   * @hidden\n   *\n   * Used by the TextBoxContainer to determine if the floating label will render in the input.\n   */\n\n\n  isEmpty() {\n    return !isPresent(this.value) && this.input.isEmpty();\n  }\n  /**\n   * @hidden\n   */\n\n\n  handleIconClick(event) {\n    if (this.disabled || this.readonly) {\n      return;\n    } // prevents the event default to evade focusing the DateInput input when placed inside a label (FF/IE/Edge)\n\n\n    event.preventDefault();\n    const runInZone = !this.isOpen || hasObservers(this.close);\n    this.run(runInZone, () => {\n      const shouldOpen = !this.isOpen; // handle focus first to maintain correct event order `focus` => `open`\n\n      this.handleFocus();\n      this.togglePopup(shouldOpen);\n      this.switchFocus();\n    });\n  }\n  /**\n   * @hidden\n   */\n\n\n  handleFocus() {\n    if (this.isActive) {\n      return;\n    }\n\n    this.isActive = true;\n\n    if (hasObservers(this.onFocus)) {\n      this.ngZone.run(() => this.onFocus.emit());\n    }\n  }\n  /**\n   * @hidden\n   */\n\n\n  handleBlur(event) {\n    if (!this.isActive || this.focusTargetInComponent(event)) {\n      return;\n    }\n\n    this.isActive = false;\n    const isNgControlUntouched = this.host.nativeElement.classList.contains('ng-untouched');\n    const runInZone = isNgControlUntouched || hasObservers(this.onBlur) || this.isOpen && hasObservers(this.close);\n    this.run(runInZone, () => {\n      this.onBlur.emit();\n      this.onControlTouched();\n      this.togglePopup(false);\n      this.cdr.markForCheck();\n    });\n  }\n  /**\n   * @hidden\n   */\n\n\n  changeActiveTab(tab) {\n    if (!this.isOpen || this.activeTab === tab) {\n      return;\n    } // persists the Tcurrent value of the TimeSelector when switching between tabs\n\n\n    if (!isEqual(this.timeSelector.value, this.timeSelector.current)) {\n      this.timeSelector.handleAccept();\n    }\n\n    this.activeTab = tab;\n    this.cdr.detectChanges();\n    this.detectPopupChanges();\n  }\n  /**\n   * @hidden\n   */\n\n\n  handleTabChangeTransitionEnd(dateTimeSelector, event) {\n    // handle only the .k-datetime-selector element transition, ignore any child element transitions\n    if (event.target !== dateTimeSelector) {\n      return;\n    }\n\n    this.activeTabComponent.focus();\n  }\n  /**\n   * @hidden\n   */\n\n\n  handleAccept() {\n    if (!this.isOpen) {\n      return;\n    }\n\n    const candidate = mergeDateAndTime(this.calendar.value, this.timeSelector.current);\n    const valueChangePresent = !isEqual(this.value, candidate);\n    const runInZone = valueChangePresent || hasObservers(this.close);\n    this.run(runInZone, () => {\n      this.handleValueChange(candidate);\n      this.togglePopup(false);\n    });\n  }\n  /**\n   * @hidden\n   */\n\n\n  handleCancel() {\n    if (!this.isOpen) {\n      return;\n    }\n\n    const runInZone = hasObservers(this.close);\n    this.run(runInZone, () => this.togglePopup(false));\n  }\n  /**\n   * @hidden\n   */\n\n\n  handleInputValueChange(value) {\n    this.handleValueChange(value);\n\n    if (this.isOpen) {\n      this.togglePopup(false);\n    }\n  }\n  /**\n   * @hidden\n   */\n\n\n  handleCalendarValueChange() {\n    this.setTimeSelectorMinMax(this.calendar.value);\n    this.changeActiveTab('time');\n  }\n  /**\n   * @hidden\n   */\n\n\n  handleKeyDown(event) {\n    if (this.disabled || this.readonly) {\n      return;\n    }\n\n    const {\n      keyCode,\n      altKey\n    } = event;\n\n    switch (keyCode) {\n      case altKey && Keys.ArrowUp:\n      case Keys.Escape:\n        this.handleCancel();\n        break;\n\n      case !this.isOpen && altKey && Keys.ArrowDown:\n        this.ngZone.run(() => this.togglePopup(true));\n        break;\n\n      case altKey && Keys.ArrowRight:\n        this.changeActiveTab('time');\n        break;\n\n      case altKey && Keys.ArrowLeft:\n        this.changeActiveTab('date');\n        break;\n\n      case this.isOpen && this.timeSelector.isActive && isPresent(this.calendarValue) && Keys.Enter:\n        this.handleAccept();\n        break;\n\n      default:\n        return;\n    }\n\n    event.preventDefault();\n  }\n  /**\n   * @hidden\n   */\n\n\n  handleTabOut(event) {\n    const {\n      keyCode,\n      shiftKey,\n      target\n    } = event; // if no focusable next sibling elements exist in the controls sections, the user is tabbing out of the popup\n\n    const focusableSiblingAvailable = isPresent(target.nextElementSibling) && !target.nextElementSibling.disabled;\n\n    if (keyCode === Keys.Tab && !shiftKey && !focusableSiblingAvailable) {\n      this.input.focus();\n      this.handleCancel();\n    }\n  }\n  /**\n   * @hidden\n   */\n\n\n  handleBackTabOut(event) {\n    const {\n      keyCode,\n      shiftKey\n    } = event;\n\n    if (keyCode === Keys.Tab && shiftKey) {\n      this.input.focus();\n    }\n  }\n  /**\n   * @hidden\n   *\n   * Prevents the diversion of the focus from the currently active element in the component.\n   */\n\n\n  preventMouseDown(event) {\n    event.preventDefault();\n  }\n\n  verifyValue(value) {\n    if (!isDevMode()) {\n      return;\n    }\n\n    if (isPresent(value) && !(value instanceof Date)) {\n      throw new Error(`The 'value' should be a valid JavaScript Date instance. Check ${VALUE_DOC_LINK$4} for possible resolution.`);\n    }\n  }\n\n  verifyMinMaxRange() {\n    if (!isDevMode()) {\n      return;\n    }\n\n    if (!isValidRange(this.min, this.max)) {\n      throw new Error(`The max value should be bigger than the min. See ${MIN_MAX_DOC_LINK}.`);\n    }\n  }\n  /**\n   * Extracts the time slots and the literals that are not preceded by date parts\n   * and concatenates the resulting parts into a string.\n   * If the provided format value does not contain any time parts,\n   * returns the designated format of the default popup component of the TimePicker.\n   */\n\n\n  getTimeSelectorFormat(format) {\n    const timeSelectorFormat = this.intl.splitDateFormat(format).filter(this.timeFormatPartFilter).reduce((format, part) => format += part.pattern, '');\n    return timeSelectorFormat || DEFAULT_TIMESELECTOR_FORMAT;\n  }\n  /**\n   * Extracts the `displayFormat` from the provided `string | FormatSettings` value.\n   * Fallbacks to the default input value, if a falsy value param is passed.\n   */\n\n\n  getDisplayFormat(format) {\n    if (!format) {\n      return DEFAULT_DATEINPUT_FORMAT;\n    }\n\n    if (typeof format === 'string') {\n      return format;\n    } else {\n      return format.displayFormat;\n    }\n  }\n  /**\n   * The filter expression that filters out all format parts\n   * except for `hour`, `minute`, `second`, `dayperiod`, and specific literals.\n   * Literals will be left only if they are not preceded by date parts.\n   */\n\n\n  timeFormatPartFilter(part, index, parts) {\n    const previousPart = index >= 1 && parts[index - 1];\n\n    if (previousPart && part.type === 'literal') {\n      return timeFormatRegExp.test(previousPart.type);\n    }\n\n    return timeFormatRegExp.test(part.type);\n  }\n\n  togglePopup(open) {\n    if (open === this.isOpen) {\n      return;\n    }\n\n    const event = new PreventableEvent();\n    open ? this.open.emit(event) : this.close.emit(event);\n\n    if (event.isDefaultPrevented()) {\n      return;\n    }\n\n    this.toggle(open);\n    this.switchFocus();\n  }\n\n  switchFocus() {\n    if (!this.isActive) {\n      return;\n    }\n\n    if (this.isOpen) {\n      this.activeTabComponent.focus();\n    } else if (!this.touchEnabled) {\n      this.input.focus();\n    } else if (!this.input.isActive) {\n      this.handleBlur();\n    }\n  }\n\n  openPopup() {\n    this.setCalendarValue(this.value);\n    this.setTimeSelectorMinMax(this.value);\n    const direction = this.localization.rtl ? 'right' : 'left';\n    this.popupRef = this.popupService.open({\n      anchor: this.wrapper,\n      content: this.popupTemplate,\n      positionMode: 'absolute',\n      animate: this.popupSettings.animate,\n      appendTo: this.appendTo,\n      popupClass: `k-datetime-container ${this.popupSettings.popupClass || ''}`,\n      anchorAlign: {\n        vertical: 'bottom',\n        horizontal: direction\n      },\n      popupAlign: {\n        vertical: 'top',\n        horizontal: direction\n      }\n    });\n    this.popupRef.popupAnchorViewportLeave.subscribe(() => this.handleCancel());\n  }\n\n  closePopup() {\n    if (!this.isOpen) {\n      return;\n    }\n\n    this.popupRef.close();\n    this.popupRef = null;\n  }\n\n  handleValueChange(value) {\n    if (isEqual(this.value, value)) {\n      return;\n    }\n\n    this.value = cloneDate(value);\n    this.onControlChange(cloneDate(value));\n    this.valueChange.emit(cloneDate(value));\n  }\n  /**\n   * Indicates whether the focus target is part of this component,\n   * that is, whether the focus target is inside the component wrapper or in the popup.\n   */\n\n\n  focusTargetInComponent(event) {\n    if (!isPresent(event)) {\n      return false;\n    }\n\n    const relatedTarget = event.relatedTarget || document.activeElement;\n    const focusInPopup = isPresent(this.popupRef) && this.popupRef.popupElement.contains(relatedTarget);\n    const focusInWrapper = this.wrapper.nativeElement.contains(relatedTarget);\n    return focusInPopup || focusInWrapper;\n  }\n\n  setTimeSelectorMinMax(selectedDate) {\n    const minDateSelected = isPresent(selectedDate) && isEqual(getDate(selectedDate), getDate(this.min));\n    this.timeSelectorMin = cloneDate(minDateSelected ? this.min : MIN_TIME);\n    const maxDateSelected = isPresent(selectedDate) && isEqual(getDate(selectedDate), getDate(this.max));\n    this.timeSelectorMax = cloneDate(maxDateSelected ? this.max : MAX_TIME);\n  }\n\n  setCalendarValue(value) {\n    const isInCalendarRange = isPresent(value) && isInRange(value, this.calendarMin, this.calendarMax);\n    this.calendarValue = isInCalendarRange ? getDate(value) : null;\n  }\n  /**\n   * If the popup is available, runs a popup change detection.\n   */\n\n\n  detectPopupChanges() {\n    if (!this.isOpen) {\n      return;\n    }\n\n    this.popupRef.popup.changeDetectorRef.detectChanges();\n  }\n  /**\n   * Depending on the predicate `runInZone` value that is passed,\n   * runs the provided function either in the Angular or in the current zone.\n   */\n\n\n  run(runInZone, fn) {\n    if (runInZone) {\n      this.ngZone.run(() => fn());\n    } else {\n      fn();\n    }\n  }\n\n  handleDateCompletenessChange() {\n    this.cdr.markForCheck();\n    this.ngZone.run(() => this.onValidatorChange());\n  }\n\n};\n\nDateTimePickerComponent.ɵfac = function DateTimePickerComponent_Factory(t) {\n  return new (t || DateTimePickerComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc5.PopupService), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.IntlService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(PickerService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(TOUCH_ENABLED), ɵngcc0.ɵɵdirectiveInject(ɵngcc4.LocalizationService), ɵngcc0.ɵɵdirectiveInject(DisabledDatesService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2));\n};\n\nDateTimePickerComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n  type: DateTimePickerComponent,\n  selectors: [[\"kendo-datetimepicker\"]],\n  contentQueries: function DateTimePickerComponent_ContentQueries(rf, ctx, dirIndex) {\n    if (rf & 1) {\n      ɵngcc0.ɵɵcontentQuery(dirIndex, CellTemplateDirective, 5);\n      ɵngcc0.ɵɵcontentQuery(dirIndex, MonthCellTemplateDirective, 5);\n      ɵngcc0.ɵɵcontentQuery(dirIndex, YearCellTemplateDirective, 5);\n      ɵngcc0.ɵɵcontentQuery(dirIndex, DecadeCellTemplateDirective, 5);\n      ɵngcc0.ɵɵcontentQuery(dirIndex, CenturyCellTemplateDirective, 5);\n      ɵngcc0.ɵɵcontentQuery(dirIndex, WeekNumberCellTemplateDirective, 5);\n      ɵngcc0.ɵɵcontentQuery(dirIndex, HeaderTitleTemplateDirective, 5);\n    }\n\n    if (rf & 2) {\n      let _t;\n\n      ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.cellTemplate = _t.first);\n      ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.monthCellTemplate = _t.first);\n      ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.yearCellTemplate = _t.first);\n      ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.decadeCellTemplate = _t.first);\n      ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.centuryCellTemplate = _t.first);\n      ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.weekNumberTemplate = _t.first);\n      ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.headerTitleTemplate = _t.first);\n    }\n  },\n  viewQuery: function DateTimePickerComponent_Query(rf, ctx) {\n    if (rf & 1) {\n      ɵngcc0.ɵɵviewQuery(_c19, 7);\n      ɵngcc0.ɵɵviewQuery(_c17, 7, ViewContainerRef);\n      ɵngcc0.ɵɵviewQuery(_c18, 7, TemplateRef);\n    }\n\n    if (rf & 2) {\n      let _t;\n\n      ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.wrapper = _t.first);\n      ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.container = _t.first);\n      ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.popupTemplate = _t.first);\n    }\n  },\n  hostVars: 4,\n  hostBindings: function DateTimePickerComponent_HostBindings(rf, ctx) {\n    if (rf & 2) {\n      ɵngcc0.ɵɵclassProp(\"k-widget\", ctx.hostClasses)(\"k-datetimepicker\", ctx.hostClasses);\n    }\n  },\n  inputs: {\n    twoDigitYearMax: \"twoDigitYearMax\",\n    focusableId: \"focusableId\",\n    title: \"title\",\n    disabled: \"disabled\",\n    readonly: \"readonly\",\n    readOnlyInput: \"readOnlyInput\",\n    cancelButton: \"cancelButton\",\n    steps: \"steps\",\n    calendarType: \"calendarType\",\n    animateCalendarNavigation: \"animateCalendarNavigation\",\n    weekNumber: \"weekNumber\",\n    rangeValidation: \"rangeValidation\",\n    disabledDatesValidation: \"disabledDatesValidation\",\n    incompleteDateValidation: \"incompleteDateValidation\",\n    value: \"value\",\n    format: \"format\",\n    tabindex: \"tabindex\",\n    disabledDates: \"disabledDates\",\n    popupSettings: \"popupSettings\",\n    min: \"min\",\n    max: \"max\",\n    defaultTab: \"defaultTab\",\n    formatPlaceholder: \"formatPlaceholder\",\n    placeholder: \"placeholder\",\n    focusedDate: \"focusedDate\"\n  },\n  outputs: {\n    valueChange: \"valueChange\",\n    open: \"open\",\n    close: \"close\",\n    onFocus: \"focus\",\n    onBlur: \"blur\"\n  },\n  exportAs: [\"kendo-datetimepicker\"],\n  features: [ɵngcc0.ɵɵProvidersFeature([PickerService, LocalizationService, DisabledDatesService, {\n    provide: L10N_PREFIX,\n    useValue: 'kendo.datetimepicker'\n  }, {\n    provide: NG_VALUE_ACCESSOR,\n    useExisting: forwardRef(() => DateTimePickerComponent_1),\n    multi: true\n  }, {\n    provide: NG_VALIDATORS,\n    useExisting: forwardRef(() => DateTimePickerComponent_1),\n    multi: true\n  }, {\n    provide: KendoInput,\n    useExisting: forwardRef(() => DateTimePickerComponent_1)\n  }]), ɵngcc0.ɵɵNgOnChangesFeature],\n  decls: 11,\n  vars: 35,\n  consts: function () {\n    let i18n_45;\n\n    if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n      /**\n       * @desc The Date tab text in the datetimepicker popup header\n       * @meaning kendo.datetimepicker.dateTab\n       */\n      const MSG_EXTERNAL_3360129034450596425$$DIST_FESM2015_INDEX_JS_46 = goog.getMsg(\"Date\");\n      i18n_45 = MSG_EXTERNAL_3360129034450596425$$DIST_FESM2015_INDEX_JS_46;\n    } else {\n      i18n_45 = $localize`:kendo.datetimepicker.dateTab|The Date tab text in the datetimepicker popup header␟5bb17f81ae8dbc109499ce3792afffa6b7cef855␟3360129034450596425:Date`;\n    }\n\n    let i18n_47;\n\n    if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n      /**\n       * @desc The label for the Date tab in the datetimepicker popup header\n       * @meaning kendo.datetimepicker.dateTabLabel\n       */\n      const MSG_EXTERNAL_1810540079817643910$$DIST_FESM2015_INDEX_JS_48 = goog.getMsg(\"Date tab\");\n      i18n_47 = MSG_EXTERNAL_1810540079817643910$$DIST_FESM2015_INDEX_JS_48;\n    } else {\n      i18n_47 = $localize`:kendo.datetimepicker.dateTabLabel|The label for the Date tab in the datetimepicker popup header␟2a400c9e364a4c6d83ac39b5513c962805db54b2␟1810540079817643910:Date tab`;\n    }\n\n    let i18n_49;\n\n    if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n      /**\n       * @desc The Time tab text in the datetimepicker popup header\n       * @meaning kendo.datetimepicker.timeTab\n       */\n      const MSG_EXTERNAL_3807284594201983607$$DIST_FESM2015_INDEX_JS_50 = goog.getMsg(\"Time\");\n      i18n_49 = MSG_EXTERNAL_3807284594201983607$$DIST_FESM2015_INDEX_JS_50;\n    } else {\n      i18n_49 = $localize`:kendo.datetimepicker.timeTab|The Time tab text in the datetimepicker popup header␟e9b2b760a6916040e7520a9a2926d65de175944d␟3807284594201983607:Time`;\n    }\n\n    let i18n_51;\n\n    if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n      /**\n       * @desc The label for the Time tab in the datetimepicker popup header\n       * @meaning kendo.datetimepicker.timeTabLabel\n       */\n      const MSG_EXTERNAL_2577682127494513393$$DIST_FESM2015_INDEX_JS_52 = goog.getMsg(\"Time tab\");\n      i18n_51 = MSG_EXTERNAL_2577682127494513393$$DIST_FESM2015_INDEX_JS_52;\n    } else {\n      i18n_51 = $localize`:kendo.datetimepicker.timeTabLabel|The label for the Time tab in the datetimepicker popup header␟13bf7e3a1036140119732c6d5952f7a20c22999e␟2577682127494513393:Time tab`;\n    }\n\n    let i18n_53;\n\n    if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n      /**\n       * @desc The title of the toggle button in the datetimepicker component\n       * @meaning kendo.datetimepicker.toggle\n       */\n      const MSG_EXTERNAL_3159207801887264026$$DIST_FESM2015_INDEX_JS_54 = goog.getMsg(\"Toggle popup\");\n      i18n_53 = MSG_EXTERNAL_3159207801887264026$$DIST_FESM2015_INDEX_JS_54;\n    } else {\n      i18n_53 = $localize`:kendo.datetimepicker.toggle|The title of the toggle button in the datetimepicker component␟60296a83f0d3e3d07aaba87c4f8e91b0aca3c22a␟3159207801887264026:Toggle popup`;\n    }\n\n    let i18n_55;\n\n    if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n      /**\n       * @desc The Accept button text in the datetimepicker component\n       * @meaning kendo.datetimepicker.accept\n       */\n      const MSG_EXTERNAL_3915774704336012538$$DIST_FESM2015_INDEX_JS_56 = goog.getMsg(\"Set\");\n      i18n_55 = MSG_EXTERNAL_3915774704336012538$$DIST_FESM2015_INDEX_JS_56;\n    } else {\n      i18n_55 = $localize`:kendo.datetimepicker.accept|The Accept button text in the datetimepicker component␟4359b59db7ded88e106ada877e744c71b188f8f9␟3915774704336012538:Set`;\n    }\n\n    let i18n_57;\n\n    if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n      /**\n       * @desc The label for the Accept button in the datetimepicker component\n       * @meaning kendo.datetimepicker.acceptLabel\n       */\n      const MSG_EXTERNAL_4770689705864890748$$DIST_FESM2015_INDEX_JS_58 = goog.getMsg(\"Set\");\n      i18n_57 = MSG_EXTERNAL_4770689705864890748$$DIST_FESM2015_INDEX_JS_58;\n    } else {\n      i18n_57 = $localize`:kendo.datetimepicker.acceptLabel|The label for the Accept button in the datetimepicker component␟cbea4571cca81ad9767a6b29f0287d1f3f6372dc␟4770689705864890748:Set`;\n    }\n\n    let i18n_59;\n\n    if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n      /**\n       * @desc The Cancel button text in the datetimepicker component\n       * @meaning kendo.datetimepicker.cancel\n       */\n      const MSG_EXTERNAL_5100781969600382158$$DIST_FESM2015_INDEX_JS_60 = goog.getMsg(\"Cancel\");\n      i18n_59 = MSG_EXTERNAL_5100781969600382158$$DIST_FESM2015_INDEX_JS_60;\n    } else {\n      i18n_59 = $localize`:kendo.datetimepicker.cancel|The Cancel button text in the datetimepicker component␟17ab795d6f7527dd962a309759ca58cb4edd7e52␟5100781969600382158:Cancel`;\n    }\n\n    let i18n_61;\n\n    if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n      /**\n       * @desc The label for the Cancel button in the datetimepicker component\n       * @meaning kendo.datetimepicker.cancelLabel\n       */\n      const MSG_EXTERNAL_3535986227615756275$$DIST_FESM2015_INDEX_JS_62 = goog.getMsg(\"Cancel\");\n      i18n_61 = MSG_EXTERNAL_3535986227615756275$$DIST_FESM2015_INDEX_JS_62;\n    } else {\n      i18n_61 = $localize`:kendo.datetimepicker.cancelLabel|The label for the Cancel button in the datetimepicker component␟ba26795ab9f4c21d66b17549ba854a96fcdac1f9␟3535986227615756275:Cancel`;\n    }\n\n    let i18n_63;\n\n    if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n      /**\n       * @desc The Now button text in the timepicker component\n       * @meaning kendo.datetimepicker.now\n       */\n      const MSG_EXTERNAL_5497093725885127701$$DIST_FESM2015_INDEX_JS_64 = goog.getMsg(\"NOW\");\n      i18n_63 = MSG_EXTERNAL_5497093725885127701$$DIST_FESM2015_INDEX_JS_64;\n    } else {\n      i18n_63 = $localize`:kendo.datetimepicker.now|The Now button text in the timepicker component␟7172e7e9a1741f6b63439ec89e498c995cb23b0d␟5497093725885127701:NOW`;\n    }\n\n    let i18n_65;\n\n    if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n      /**\n       * @desc The label for the Now button in the timepicker component\n       * @meaning kendo.datetimepicker.nowLabel\n       */\n      const MSG_EXTERNAL_5046379108717037514$$DIST_FESM2015_INDEX_JS_66 = goog.getMsg(\"Select now\");\n      i18n_65 = MSG_EXTERNAL_5046379108717037514$$DIST_FESM2015_INDEX_JS_66;\n    } else {\n      i18n_65 = $localize`:kendo.datetimepicker.nowLabel|The label for the Now button in the timepicker component␟52d90641b26b1ce4c011cadf0437ce36c1dac1d5␟5046379108717037514:Select now`;\n    }\n\n    let i18n_67;\n\n    if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n      /**\n       * @desc The label for the today button in the calendar header\n       * @meaning kendo.datetimepicker.today\n       */\n      const MSG_EXTERNAL_2570147067439993260$$DIST_FESM2015_INDEX_JS_68 = goog.getMsg(\"Today\");\n      i18n_67 = MSG_EXTERNAL_2570147067439993260$$DIST_FESM2015_INDEX_JS_68;\n    } else {\n      i18n_67 = $localize`:kendo.datetimepicker.today|The label for the today button in the calendar header␟9ef9db9ac4951523d519b989d223f507878c612d␟2570147067439993260:Today`;\n    }\n\n    let i18n_69;\n\n    if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n      /**\n       * @desc The title of the previous button in the Classic calendar\n       * @meaning kendo.datetimepicker.prevButtonTitle\n       */\n      const MSG_EXTERNAL_6176055232586065404$$DIST_FESM2015_INDEX_JS_70 = goog.getMsg(\"Navigate to previous view\");\n      i18n_69 = MSG_EXTERNAL_6176055232586065404$$DIST_FESM2015_INDEX_JS_70;\n    } else {\n      i18n_69 = $localize`:kendo.datetimepicker.prevButtonTitle|The title of the previous button in the Classic calendar␟447d09c4ecfc2ab2b84d708f4c07fa0fcda85167␟6176055232586065404:Navigate to previous view`;\n    }\n\n    let i18n_71;\n\n    if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n      /**\n       * @desc The title of the next button in the Classic calendar\n       * @meaning kendo.datetimepicker.nextButtonTitle\n       */\n      const MSG_EXTERNAL_6424339255333594510$$DIST_FESM2015_INDEX_JS_72 = goog.getMsg(\"Navigate to next view\");\n      i18n_71 = MSG_EXTERNAL_6424339255333594510$$DIST_FESM2015_INDEX_JS_72;\n    } else {\n      i18n_71 = $localize`:kendo.datetimepicker.nextButtonTitle|The title of the next button in the Classic calendar␟80fd3325bfe94a180fd27391f2245c024472ec58␟6424339255333594510:Navigate to next view`;\n    }\n\n    return [[\"kendoDateTimePickerLocalizedMessages\", \"\", \"dateTab\", i18n_45, \"dateTabLabel\", i18n_47, \"timeTab\", i18n_49, \"timeTabLabel\", i18n_51, \"toggle\", i18n_53, \"accept\", i18n_55, \"acceptLabel\", i18n_57, \"cancel\", i18n_59, \"cancelLabel\", i18n_61, \"now\", i18n_63, \"nowLabel\", i18n_65, \"today\", i18n_67, \"prevButtonTitle\", i18n_69, \"nextButtonTitle\", i18n_71], [1, \"k-picker-wrap\"], [\"wrapper\", \"\"], [3, \"value\", \"format\", \"twoDigitYearMax\", \"min\", \"max\", \"incompleteDateValidation\", \"formatPlaceholder\", \"placeholder\", \"disabled\", \"readonly\", \"role\", \"ariaReadOnly\", \"steps\", \"tabindex\", \"title\", \"focusableId\", \"hasPopup\", \"isPopupOpen\", \"kendoEventsOutsideAngular\", \"scope\", \"valueChange\"], [1, \"k-select\", 3, \"kendoEventsOutsideAngular\", \"scope\"], [1, \"k-link\", \"k-link-date\"], [1, \"k-icon\"], [\"container\", \"\"], [\"popupTemplate\", \"\"], [3, \"kendoEventsOutsideAngular\", \"scope\"], [1, \"k-datetime-buttongroup\", 3, \"kendoEventsOutsideAngular\", \"scope\"], [1, \"k-button-group\", \"k-button-group-stretched\"], [\"type\", \"button\", 1, \"k-button\", \"k-date-tab\", 3, \"kendoEventsOutsideAngular\", \"scope\"], [\"type\", \"button\", 1, \"k-button\", \"k-time-tab\", 3, \"kendoEventsOutsideAngular\"], [1, \"k-datetime-selector\", 3, \"kendoEventsOutsideAngular\"], [\"dateTimeSelector\", \"\"], [1, \"k-datetime-calendar-wrap\"], [3, \"value\", \"type\", \"min\", \"max\", \"focusedDate\", \"weekNumber\", \"navigation\", \"animateNavigation\", \"cellTemplate\", \"monthCellTemplate\", \"yearCellTemplate\", \"decadeCellTemplate\", \"centuryCellTemplate\", \"weekNumberTemplate\", \"headerTitleTemplate\", \"disabled\", \"disabledDates\", \"valueChange\"], [3, \"today\", \"prevButtonTitle\", \"nextButtonTitle\"], [1, \"k-datetime-time-wrap\"], [3, \"value\", \"format\", \"min\", \"max\", \"setButton\", \"cancelButton\", \"steps\", \"disabled\"], [3, \"now\", \"nowLabel\"], [1, \"k-datetime-footer\", \"k-action-buttons\", \"k-actions\", \"k-hstack\", \"k-justify-content-stretch\", 3, \"kendoEventsOutsideAngular\", \"scope\"], [\"type\", \"button\", \"class\", \"k-button k-time-cancel\", 3, \"kendoEventsOutsideAngular\", \"scope\", 4, \"ngIf\"], [\"type\", \"button\", 1, \"k-time-accept\", \"k-button\", \"k-primary\", 3, \"disabled\", \"kendoEventsOutsideAngular\", \"scope\"], [\"type\", \"button\", 1, \"k-button\", \"k-time-cancel\", 3, \"kendoEventsOutsideAngular\", \"scope\"]];\n  },\n  template: function DateTimePickerComponent_Template(rf, ctx) {\n    if (rf & 1) {\n      ɵngcc0.ɵɵelementContainer(0, 0);\n      ɵngcc0.ɵɵelementStart(1, \"span\", 1, 2);\n      ɵngcc0.ɵɵelementStart(3, \"kendo-dateinput\", 3);\n      ɵngcc0.ɵɵlistener(\"valueChange\", function DateTimePickerComponent_Template_kendo_dateinput_valueChange_3_listener($event) {\n        return ctx.handleInputValueChange($event);\n      });\n      ɵngcc0.ɵɵelementEnd();\n      ɵngcc0.ɵɵelementStart(4, \"span\", 4);\n      ɵngcc0.ɵɵelementStart(5, \"span\", 5);\n      ɵngcc0.ɵɵelement(6, \"span\", 6);\n      ɵngcc0.ɵɵelementEnd();\n      ɵngcc0.ɵɵelementEnd();\n      ɵngcc0.ɵɵelementEnd();\n      ɵngcc0.ɵɵelementContainer(7, null, 7);\n      ɵngcc0.ɵɵtemplate(9, DateTimePickerComponent_ng_template_9_Template, 19, 81, \"ng-template\", null, 8, ɵngcc0.ɵɵtemplateRefExtractor);\n    }\n\n    if (rf & 2) {\n      ɵngcc0.ɵɵadvance(1);\n      ɵngcc0.ɵɵclassProp(\"k-state-disabled\", ctx.disabled);\n      ɵngcc0.ɵɵadvance(2);\n      ɵngcc0.ɵɵproperty(\"value\", ctx.value)(\"format\", ctx.format)(\"twoDigitYearMax\", ctx.twoDigitYearMax)(\"min\", ctx.min)(\"max\", ctx.max)(\"incompleteDateValidation\", ctx.incompleteDateValidation)(\"formatPlaceholder\", ctx.formatPlaceholder)(\"placeholder\", ctx.placeholder)(\"disabled\", ctx.disabled)(\"readonly\", ctx.readonly || ctx.readOnlyInput)(\"role\", ctx.inputRole)(\"ariaReadOnly\", ctx.readonly)(\"steps\", ctx.steps)(\"tabindex\", ctx.tabindex)(\"title\", ctx.title)(\"focusableId\", ctx.focusableId)(\"hasPopup\", true)(\"isPopupOpen\", ctx.isOpen)(\"kendoEventsOutsideAngular\", ɵngcc0.ɵɵpureFunction1(30, _c28, ctx.handleKeyDown))(\"scope\", ctx);\n      ɵngcc0.ɵɵadvance(1);\n      ɵngcc0.ɵɵproperty(\"kendoEventsOutsideAngular\", ɵngcc0.ɵɵpureFunction2(32, _c78, ctx.preventMouseDown, ctx.handleIconClick))(\"scope\", ctx);\n      ɵngcc0.ɵɵattribute(\"title\", ctx.localization.get(\"toggle\"))(\"aria-label\", ctx.localization.get(\"toggle\"));\n      ɵngcc0.ɵɵadvance(2);\n      ɵngcc0.ɵɵclassProp(\"k-i-calendar\", ctx.activeTab === \"date\")(\"k-i-clock\", ctx.activeTab === \"time\");\n    }\n  },\n  directives: function () {\n    return [LocalizedMessagesDirective, DateInputComponent, ɵngcc3.EventsOutsideAngularDirective, CalendarComponent, CalendarCustomMessagesComponent, TimeSelectorComponent, TimeSelectorCustomMessagesComponent, ɵngcc2.NgIf];\n  },\n  encapsulation: 2,\n  changeDetection: 0\n});\n\n__decorate([HostBinding('class.k-widget'), HostBinding('class.k-datetimepicker'), __metadata(\"design:type\", Boolean)], DateTimePickerComponent.prototype, \"hostClasses\", void 0);\n\n__decorate([ViewChild('wrapper', {\n  static: true\n}), __metadata(\"design:type\", ElementRef)], DateTimePickerComponent.prototype, \"wrapper\", void 0);\n\n__decorate([Input(), __metadata(\"design:type\", Date), __metadata(\"design:paramtypes\", [Date])], DateTimePickerComponent.prototype, \"value\", null);\n\n__decorate([Input(), __metadata(\"design:type\", Object), __metadata(\"design:paramtypes\", [Object])], DateTimePickerComponent.prototype, \"format\", null);\n\n__decorate([Input(), __metadata(\"design:type\", Number)], DateTimePickerComponent.prototype, \"twoDigitYearMax\", void 0);\n\n__decorate([Input(), __metadata(\"design:type\", Number), __metadata(\"design:paramtypes\", [Number])], DateTimePickerComponent.prototype, \"tabindex\", null);\n\n__decorate([Input(), __metadata(\"design:type\", Object), __metadata(\"design:paramtypes\", [Object])], DateTimePickerComponent.prototype, \"disabledDates\", null);\n\n__decorate([Input(), __metadata(\"design:type\", Object), __metadata(\"design:paramtypes\", [Object])], DateTimePickerComponent.prototype, \"popupSettings\", null);\n\n__decorate([Input(), __metadata(\"design:type\", String)], DateTimePickerComponent.prototype, \"focusableId\", void 0);\n\n__decorate([Input(), __metadata(\"design:type\", String)], DateTimePickerComponent.prototype, \"title\", void 0);\n\n__decorate([Input(), __metadata(\"design:type\", Boolean)], DateTimePickerComponent.prototype, \"disabled\", void 0);\n\n__decorate([Input(), __metadata(\"design:type\", Boolean)], DateTimePickerComponent.prototype, \"readonly\", void 0);\n\n__decorate([Input(), __metadata(\"design:type\", Boolean)], DateTimePickerComponent.prototype, \"readOnlyInput\", void 0);\n\n__decorate([Input(), __metadata(\"design:type\", Boolean)], DateTimePickerComponent.prototype, \"cancelButton\", void 0);\n\n__decorate([Input(), __metadata(\"design:type\", Object)], DateTimePickerComponent.prototype, \"formatPlaceholder\", void 0);\n\n__decorate([Input(), __metadata(\"design:type\", String)], DateTimePickerComponent.prototype, \"placeholder\", void 0);\n\n__decorate([Input(), __metadata(\"design:type\", Object)], DateTimePickerComponent.prototype, \"steps\", void 0);\n\n__decorate([Input(), __metadata(\"design:type\", Date)], DateTimePickerComponent.prototype, \"focusedDate\", void 0);\n\n__decorate([Input(), __metadata(\"design:type\", String)], DateTimePickerComponent.prototype, \"calendarType\", void 0);\n\n__decorate([Input(), __metadata(\"design:type\", Boolean)], DateTimePickerComponent.prototype, \"animateCalendarNavigation\", void 0);\n\n__decorate([Input(), __metadata(\"design:type\", Boolean)], DateTimePickerComponent.prototype, \"weekNumber\", void 0);\n\n__decorate([Input(), __metadata(\"design:type\", Date), __metadata(\"design:paramtypes\", [Date])], DateTimePickerComponent.prototype, \"min\", null);\n\n__decorate([Input(), __metadata(\"design:type\", Date), __metadata(\"design:paramtypes\", [Date])], DateTimePickerComponent.prototype, \"max\", null);\n\n__decorate([Input(), __metadata(\"design:type\", Boolean)], DateTimePickerComponent.prototype, \"rangeValidation\", void 0);\n\n__decorate([Input(), __metadata(\"design:type\", Boolean)], DateTimePickerComponent.prototype, \"disabledDatesValidation\", void 0);\n\n__decorate([Input(), __metadata(\"design:type\", Boolean)], DateTimePickerComponent.prototype, \"incompleteDateValidation\", void 0);\n\n__decorate([Output(), __metadata(\"design:type\", EventEmitter)], DateTimePickerComponent.prototype, \"valueChange\", void 0);\n\n__decorate([Output(), __metadata(\"design:type\", EventEmitter)], DateTimePickerComponent.prototype, \"open\", void 0);\n\n__decorate([Output(), __metadata(\"design:type\", EventEmitter)], DateTimePickerComponent.prototype, \"close\", void 0);\n\n__decorate([Output('focus'), __metadata(\"design:type\", EventEmitter)], DateTimePickerComponent.prototype, \"onFocus\", void 0);\n\n__decorate([Output('blur'), __metadata(\"design:type\", EventEmitter)], DateTimePickerComponent.prototype, \"onBlur\", void 0);\n\n__decorate([Input(), __metadata(\"design:type\", String), __metadata(\"design:paramtypes\", [String])], DateTimePickerComponent.prototype, \"defaultTab\", null);\n\n__decorate([ContentChild(CellTemplateDirective, {\n  static: false\n}), __metadata(\"design:type\", CellTemplateDirective)], DateTimePickerComponent.prototype, \"cellTemplate\", void 0);\n\n__decorate([ContentChild(MonthCellTemplateDirective, {\n  static: false\n}), __metadata(\"design:type\", MonthCellTemplateDirective)], DateTimePickerComponent.prototype, \"monthCellTemplate\", void 0);\n\n__decorate([ContentChild(YearCellTemplateDirective, {\n  static: false\n}), __metadata(\"design:type\", YearCellTemplateDirective)], DateTimePickerComponent.prototype, \"yearCellTemplate\", void 0);\n\n__decorate([ContentChild(DecadeCellTemplateDirective, {\n  static: false\n}), __metadata(\"design:type\", DecadeCellTemplateDirective)], DateTimePickerComponent.prototype, \"decadeCellTemplate\", void 0);\n\n__decorate([ContentChild(CenturyCellTemplateDirective, {\n  static: false\n}), __metadata(\"design:type\", CenturyCellTemplateDirective)], DateTimePickerComponent.prototype, \"centuryCellTemplate\", void 0);\n\n__decorate([ContentChild(WeekNumberCellTemplateDirective, {\n  static: false\n}), __metadata(\"design:type\", WeekNumberCellTemplateDirective)], DateTimePickerComponent.prototype, \"weekNumberTemplate\", void 0);\n\n__decorate([ContentChild(HeaderTitleTemplateDirective, {\n  static: false\n}), __metadata(\"design:type\", HeaderTitleTemplateDirective)], DateTimePickerComponent.prototype, \"headerTitleTemplate\", void 0);\n\n__decorate([ViewChild('container', {\n  read: ViewContainerRef,\n  static: true\n}), __metadata(\"design:type\", ViewContainerRef)], DateTimePickerComponent.prototype, \"container\", void 0);\n\n__decorate([ViewChild('popupTemplate', {\n  read: TemplateRef,\n  static: true\n}), __metadata(\"design:type\", TemplateRef)], DateTimePickerComponent.prototype, \"popupTemplate\", void 0);\n\nDateTimePickerComponent = DateTimePickerComponent_1 = __decorate([__param(6, Inject(TOUCH_ENABLED)), __metadata(\"design:paramtypes\", [PopupService, IntlService, ChangeDetectorRef, PickerService, NgZone, ElementRef, Boolean, LocalizationService, DisabledDatesService, Renderer2])], DateTimePickerComponent);\n/**\n * @hidden\n */\n\nlet WeekNamesService = /*#__PURE__*/(() => {\n  let WeekNamesService = class WeekNamesService {\n    constructor(intl) {\n      this.intl = intl;\n    }\n\n    getWeekNames(includeWeekNumber = false) {\n      const weekNames = shiftWeekNames(this.intl.dateFormatNames({\n        nameType: 'short',\n        type: 'days'\n      }), this.intl.firstDay());\n      return includeWeekNumber ? [''].concat(weekNames) : weekNames;\n    }\n\n  };\n\n  WeekNamesService.ɵfac = function WeekNamesService_Factory(t) {\n    return new (t || WeekNamesService)(ɵngcc0.ɵɵinject(ɵngcc1.IntlService));\n  };\n\n  WeekNamesService.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: WeekNamesService,\n    factory: function (t) {\n      return WeekNamesService.ɵfac(t);\n    }\n  });\n  WeekNamesService = __decorate([__metadata(\"design:paramtypes\", [IntlService])], WeekNamesService);\n  return WeekNamesService;\n})();\nconst DEFAULT_VIEWS_LENGTH = 2;\n/**\n * @hidden\n */\n\nlet HorizontalViewListComponent = /*#__PURE__*/(() => {\n  let HorizontalViewListComponent = class HorizontalViewListComponent {\n    constructor(bus, intl, weekService, cdr, element, renderer) {\n      this.bus = bus;\n      this.intl = intl;\n      this.weekService = weekService;\n      this.cdr = cdr;\n      this.element = element;\n      this.renderer = renderer;\n      this.activeView = CalendarViewEnum.month;\n      this.isActive = true;\n      this.min = new Date(MIN_DATE);\n      this.max = new Date(MAX_DATE);\n      this.selectedDates = [];\n      this.views = DEFAULT_VIEWS_LENGTH;\n      this.showViewHeader = false;\n      this.animateNavigation = false;\n      this.cellClick = new EventEmitter();\n      this.weekNumberCellClick = new EventEmitter();\n      this.cellEnter = new EventEmitter();\n      this.cellLeave = new EventEmitter();\n      this.activeDateChange = new EventEmitter();\n      this.getComponentClass = true;\n      this.weekNames = [];\n      this.dates = [];\n      this.intlSubscription = this.intl.changes.subscribe(this.intlChange.bind(this));\n    }\n\n    get weekNumber() {\n      return this.showWeekNumbers && this.isMonthView();\n    }\n\n    set weekNumber(showWeekNumbers) {\n      this.showWeekNumbers = showWeekNumbers;\n    }\n\n    get getComponentMonthClass() {\n      return this.activeView === CalendarViewEnum.month;\n    }\n\n    get getComponentYearClass() {\n      return this.activeView === CalendarViewEnum.year;\n    }\n\n    get getComponentDecadeClass() {\n      return this.activeView === CalendarViewEnum.decade;\n    }\n\n    get getComponentCenturyClass() {\n      return this.activeView === CalendarViewEnum.century;\n    }\n\n    ngOnChanges(changes) {\n      this.initService();\n\n      if (this.weekNames.length === 0 || changes.weekNumber) {\n        this.weekNames = this.weekService.getWeekNames(this.weekNumber);\n      }\n\n      if (!this.service) {\n        return;\n      }\n\n      this.views = this.views || DEFAULT_VIEWS_LENGTH;\n      const focusedDate = this.focusedDate;\n      const viewDate = this.clampDate(this.service.viewDate(focusedDate, this.max, this.views));\n      this.skip = this.service.skip(viewDate, this.min);\n      this.total = this.service.total(this.min, this.max);\n      const activeViewChanged = hasChange(changes, 'activeView');\n      const viewsHasChanged = this.views > 0 && hasChange(changes, 'views');\n\n      if (activeViewChanged || !this.isInDates(focusedDate) || viewsHasChanged || !this.activeDate) {\n        this.dates = this.service.datesList(viewDate, this.getTake(this.skip));\n        this.activeDate = cloneDate(this.dates[0]);\n        this.activeDateChange.emit(this.activeDate);\n      }\n    }\n\n    ngAfterViewInit() {\n      // make the calendar look the same in the different browsers\n      // which also smoothens the navigation animation\n      if (this.views === 1) {\n        this.setTableMinWidth();\n      }\n    }\n\n    ngOnDestroy() {\n      this.intlSubscription.unsubscribe();\n    }\n\n    initService() {\n      this.service = this.bus.service(this.activeView);\n    }\n\n    isMonthView() {\n      return this.activeView === CalendarViewEnum.month;\n    }\n\n    getCaptionTitle(date) {\n      return this.service.title(date);\n    }\n\n    getCaptionClass() {\n      return this.isMonthView() ? 'k-month-header' : 'k-meta-header';\n    }\n\n    animateView(action) {\n      const container = this.element.nativeElement;\n      const table = container.querySelector('table'); // the whole width excluding padding/margin\n\n      const initialContainerWidth = parseFloat(getComputedStyle(container).width); // table width\n\n      const tableWidth = parseFloat(getComputedStyle(table).width);\n      this.renderer.setStyle(container, 'width', `${initialContainerWidth}px`);\n      this.renderer.setStyle(container, 'overflow', 'visible'); // initialize an additional view for the animation\n\n      if (action === Action.NextView) {\n        // animating Action.NextView requires adding an additional view before the rendered views\n        this.nextAnimationDate = cloneDate(this.dates[0]);\n      } else {\n        // animating Action.PrevView requires adding an additional view after the rendered views\n        this.prevAnimationDate = cloneDate(this.dates[this.dates.length - 1]);\n      } // run cdr to render the additional view\n\n\n      this.cdr.detectChanges();\n      container.querySelectorAll('table').forEach(table => {\n        this.renderer.setStyle(table, 'width', `${tableWidth}px`);\n\n        if (this.views === 1) {\n          this.renderer.setStyle(table, 'min-width', `${initialContainerWidth}px`);\n        }\n      }); // we always slide by the width of 1 table\n      // cross-browser compatibility is ensured by measuring the client rectangle and substracting the gap\n\n      const tabRect = table.getBoundingClientRect();\n      const containerGap = parseFloat(getComputedStyle(container).columnGap);\n      const start = action === Action.NextView ? 'translateX(0)' : `translateX(-${tabRect.width + containerGap}px)`;\n      const end = action === Action.NextView ? `translateX(-${tabRect.width + containerGap}px)` : 'translateX(0)';\n\n      if (!this.animation) {\n        this.animation = container.animate([{\n          transform: start\n        }, {\n          transform: end\n        }], {\n          duration: 500,\n          easing: 'ease-out'\n        });\n\n        this.animation.oncancel = this.animation.onfinish = () => {\n          // clear all inline styles\n          this.renderer.removeStyle(container, 'width');\n          this.renderer.removeStyle(container, 'overflow');\n          container.querySelectorAll('table').forEach(table => {\n            this.renderer.removeStyle(table, 'width');\n          }); // clear the animation and the animation view\n\n          this.animation = null;\n          this.nextAnimationDate = null;\n          this.prevAnimationDate = null; // run cdr to remove additional animation view from the markup\n\n          this.cdr.detectChanges();\n        };\n      } else {\n        // if animation is already running, cancel it and show the end navigation result on multiple prev/next button clicks\n        this.animation.cancel();\n      }\n    }\n\n    navigate(action) {\n      if (this.animateNavigation && isDocumentAvailable() && isPresent(this.element.nativeElement.animate)) {\n        this.animateView(action);\n      }\n\n      const candidate = this.move(action);\n      const list = this.service.datesList(candidate, this.getTake(this.skip));\n\n      if (this.isListInRange(list)) {\n        this.dates = list;\n      }\n\n      this.activeDate = cloneDate(this.dates[0]);\n      this.focusedDate = cloneDate(candidate);\n      this.cdr.markForCheck();\n      this.activeDateChange.emit(this.activeDate);\n      return cloneDate(candidate);\n    }\n\n    canNavigate(action) {\n      if (!this.service) {\n        return false;\n      }\n\n      return this.isListInRange(this.service.datesList(this.move(action), this.getTake(this.skip)));\n    }\n\n    setTableMinWidth() {\n      const container = this.element.nativeElement;\n      const table = container.querySelector('table');\n\n      if (table) {\n        const containerWidth = parseFloat(getComputedStyle(container).width);\n        this.renderer.setStyle(table, 'min-width', `${containerWidth}px`);\n      }\n    }\n\n    intlChange() {\n      this.weekNames = this.weekService.getWeekNames(this.weekNumber);\n      this.cdr.markForCheck();\n    }\n\n    clampDate(value) {\n      return dateInRange(value, this.min, this.max);\n    }\n\n    move(action) {\n      return this.service.move(this.dates[0] || this.focusedDate, action);\n    }\n\n    isListInRange(list) {\n      const lowerBound = this.service.beginningOfPeriod(this.min);\n      const upperBound = this.service.beginningOfPeriod(this.service.addToDate(this.max, 1));\n      return lowerBound <= list[0] && list[list.length - 1] < upperBound;\n    }\n\n    isInDates(value) {\n      return this.service.isInArray(value, this.dates);\n    }\n\n    getTake(skip) {\n      return Math.min(this.total - skip, this.views);\n    }\n\n  };\n\n  HorizontalViewListComponent.ɵfac = function HorizontalViewListComponent_Factory(t) {\n    return new (t || HorizontalViewListComponent)(ɵngcc0.ɵɵdirectiveInject(BusViewService), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.IntlService), ɵngcc0.ɵɵdirectiveInject(WeekNamesService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2));\n  };\n\n  HorizontalViewListComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: HorizontalViewListComponent,\n    selectors: [[\"kendo-calendar-horizontal\"]],\n    hostVars: 12,\n    hostBindings: function HorizontalViewListComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        ɵngcc0.ɵɵclassProp(\"k-calendar-view\", ctx.getComponentClass)(\"k-justify-align-start\", ctx.getComponentClass)(\"k-calendar-monthview\", ctx.getComponentMonthClass)(\"k-calendar-yearview\", ctx.getComponentYearClass)(\"k-calendar-decadeview\", ctx.getComponentDecadeClass)(\"k-calendar-centuryview\", ctx.getComponentCenturyClass);\n      }\n    },\n    inputs: {\n      activeView: \"activeView\",\n      isActive: \"isActive\",\n      min: \"min\",\n      max: \"max\",\n      selectedDates: \"selectedDates\",\n      views: \"views\",\n      showViewHeader: \"showViewHeader\",\n      animateNavigation: \"animateNavigation\",\n      weekNumber: \"weekNumber\",\n      focusedDate: \"focusedDate\",\n      cellTemplateRef: \"cellTemplateRef\",\n      weekNumberTemplateRef: \"weekNumberTemplateRef\",\n      activeRangeEnd: \"activeRangeEnd\",\n      cellUID: \"cellUID\",\n      selectionRange: \"selectionRange\"\n    },\n    outputs: {\n      cellClick: \"cellClick\",\n      weekNumberCellClick: \"weekNumberCellClick\",\n      cellEnter: \"cellEnter\",\n      cellLeave: \"cellLeave\",\n      activeDateChange: \"activeDateChange\"\n    },\n    features: [ɵngcc0.ɵɵNgOnChangesFeature],\n    decls: 5,\n    vars: 3,\n    consts: [[\"tableTemplate\", \"\"], [4, \"ngIf\"], [4, \"kFor\", \"kForOf\"], [1, \"k-content\", \"k-calendar-content\", \"k-calendar-table\", 3, \"ngClass\"], [3, \"ngClass\", 4, \"ngIf\"], [\"class\", \"k-calendar-thead\", 4, \"ngIf\"], [\"kendoCalendarView\", \"\", \"role\", \"rowgroup\", \"direction\", \"horizontal\", 1, \"k-calendar-tbody\", 3, \"activeView\", \"isActive\", \"min\", \"max\", \"cellUID\", \"focusedDate\", \"selectedDates\", \"selectionRange\", \"activeRangeEnd\", \"weekNumber\", \"templateRef\", \"weekNumberTemplateRef\", \"viewDate\", \"cellClick\", \"weekNumberCellClick\", \"cellEnter\", \"cellLeave\"], [3, \"ngClass\"], [1, \"k-calendar-thead\"], [\"role\", \"row\", 1, \"k-calendar-tr\"], [\"class\", \"k-calendar-th\", 4, \"ngFor\", \"ngForOf\"], [1, \"k-calendar-th\"], [3, \"ngTemplateOutlet\", \"ngTemplateOutletContext\"]],\n    template: function HorizontalViewListComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵtemplate(0, HorizontalViewListComponent_ng_template_0_Template, 4, 16, \"ng-template\", null, 0, ɵngcc0.ɵɵtemplateRefExtractor);\n        ɵngcc0.ɵɵtemplate(2, HorizontalViewListComponent_2_Template, 1, 4, undefined, 1);\n        ɵngcc0.ɵɵtemplate(3, HorizontalViewListComponent_3_Template, 1, 4, undefined, 2);\n        ɵngcc0.ɵɵtemplate(4, HorizontalViewListComponent_4_Template, 1, 4, undefined, 1);\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵadvance(2);\n        ɵngcc0.ɵɵproperty(\"ngIf\", ctx.nextAnimationDate);\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"kForOf\", ctx.dates);\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngIf\", ctx.prevAnimationDate);\n      }\n    },\n    directives: function () {\n      return [ɵngcc2.NgIf, KForOf, ɵngcc2.NgClass, ViewComponent, ɵngcc2.NgForOf, ɵngcc2.NgTemplateOutlet];\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n\n  __decorate([Input(), __metadata(\"design:type\", TemplateRef)], HorizontalViewListComponent.prototype, \"cellTemplateRef\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", TemplateRef)], HorizontalViewListComponent.prototype, \"weekNumberTemplateRef\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", String)], HorizontalViewListComponent.prototype, \"activeRangeEnd\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", Number)], HorizontalViewListComponent.prototype, \"activeView\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", String)], HorizontalViewListComponent.prototype, \"cellUID\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", Date)], HorizontalViewListComponent.prototype, \"focusedDate\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", Boolean)], HorizontalViewListComponent.prototype, \"isActive\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", Date)], HorizontalViewListComponent.prototype, \"min\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", Date)], HorizontalViewListComponent.prototype, \"max\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", Object)], HorizontalViewListComponent.prototype, \"selectionRange\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", Array)], HorizontalViewListComponent.prototype, \"selectedDates\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", Number)], HorizontalViewListComponent.prototype, \"views\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", Boolean)], HorizontalViewListComponent.prototype, \"showViewHeader\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", Boolean)], HorizontalViewListComponent.prototype, \"animateNavigation\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", Boolean), __metadata(\"design:paramtypes\", [Boolean])], HorizontalViewListComponent.prototype, \"weekNumber\", null);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], HorizontalViewListComponent.prototype, \"cellClick\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], HorizontalViewListComponent.prototype, \"weekNumberCellClick\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], HorizontalViewListComponent.prototype, \"cellEnter\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], HorizontalViewListComponent.prototype, \"cellLeave\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], HorizontalViewListComponent.prototype, \"activeDateChange\", void 0);\n\n  __decorate([HostBinding(\"class.k-calendar-view\"), HostBinding(\"class.k-justify-align-start\"), __metadata(\"design:type\", Boolean)], HorizontalViewListComponent.prototype, \"getComponentClass\", void 0);\n\n  __decorate([HostBinding(\"class.k-calendar-monthview\"), __metadata(\"design:type\", Boolean), __metadata(\"design:paramtypes\", [])], HorizontalViewListComponent.prototype, \"getComponentMonthClass\", null);\n\n  __decorate([HostBinding(\"class.k-calendar-yearview\"), __metadata(\"design:type\", Boolean), __metadata(\"design:paramtypes\", [])], HorizontalViewListComponent.prototype, \"getComponentYearClass\", null);\n\n  __decorate([HostBinding(\"class.k-calendar-decadeview\"), __metadata(\"design:type\", Boolean), __metadata(\"design:paramtypes\", [])], HorizontalViewListComponent.prototype, \"getComponentDecadeClass\", null);\n\n  __decorate([HostBinding(\"class.k-calendar-centuryview\"), __metadata(\"design:type\", Boolean), __metadata(\"design:paramtypes\", [])], HorizontalViewListComponent.prototype, \"getComponentCenturyClass\", null);\n\n  HorizontalViewListComponent = __decorate([__metadata(\"design:paramtypes\", [BusViewService, IntlService, WeekNamesService, ChangeDetectorRef, ElementRef, Renderer2])], HorizontalViewListComponent);\n  return HorizontalViewListComponent;\n})();\n\nconst noop$2 = () => null;\n/**\n * @hidden\n */\n\n\nconst disabledDatesRangeValidator = isDateDisabled => {\n  if (!isPresent(isDateDisabled)) {\n    return noop$2;\n  }\n\n  return selectedRange => {\n    const isRangeComplete = isPresent(selectedRange) && isPresent(selectedRange.start) && isPresent(selectedRange.end);\n\n    if (!isRangeComplete || selectedRange.start > selectedRange.end) {\n      return null;\n    }\n\n    const disabledDates = disabledDatesInRange(selectedRange.start, selectedRange.end, isDateDisabled);\n    const error = {\n      disabledDatesInRange: disabledDates\n    };\n    return disabledDates.length ? error : null;\n  };\n};\n\nconst BOTTOM_VIEW_DOC_LINK$1 = 'http://www.telerik.com/kendo-angular-ui/components/dateinputs/api/CalendarComponent/#toc-bottomview';\nconst TOP_VIEW_DOC_LINK$1 = 'http://www.telerik.com/kendo-angular-ui/components/dateinputs/api/CalendarComponent/#toc-topview';\nconst MIN_DOC_LINK$3 = 'http://www.telerik.com/kendo-angular-ui/components/dateinputs/api/CalendarComponent/#toc-min';\nconst MAX_DOC_LINK$3 = 'http://www.telerik.com/kendo-angular-ui/components/dateinputs/api/CalendarComponent/#toc-max';\nconst VALUE_DOC_LINK$5 = 'http://www.telerik.com/kendo-angular-ui/components/dateinputs/calendar/#toc-using-with-json';\n/**\n * @hidden\n */\n\nconst RANGE_CALENDAR_VALUE_ACCESSOR = {\n  multi: true,\n  provide: NG_VALUE_ACCESSOR,\n  useExisting: forwardRef(() => MultiViewCalendarComponent) //tslint:disable-line:no-use-before-declare\n\n};\n/**\n * @hidden\n */\n\nconst RANGE_CALENDAR_RANGE_VALIDATORS = {\n  multi: true,\n  provide: NG_VALIDATORS,\n  useExisting: forwardRef(() => MultiViewCalendarComponent) //tslint:disable-line:no-use-before-declare\n\n};\n/**\n * Represents the Kendo UI MultiViewCalendar component for Angular.\n *\n * @example\n * ```ts\n * _@Component({\n * selector: 'my-app',\n * template: `\n *  <kendo-multiviewcalendar></kendo-multiviewcalendar>\n * `\n * })\n * export class AppComponent { }\n * ```\n */\n\nlet MultiViewCalendarComponent = /*#__PURE__*/(() => {\n  let MultiViewCalendarComponent = class MultiViewCalendarComponent {\n    constructor(bus, element, navigator, renderer, cdr, zone, disabledDatesService, selectionService) {\n      this.bus = bus;\n      this.element = element;\n      this.navigator = navigator;\n      this.renderer = renderer;\n      this.cdr = cdr;\n      this.zone = zone;\n      this.disabledDatesService = disabledDatesService;\n      this.selectionService = selectionService;\n      /**\n       * @hidden\n       */\n\n      this.id = guid();\n      /**\n       * Determines whether the built-in min or max validators are enforced when validating a form.\n       */\n\n      this.rangeValidation = false;\n      /**\n       * Determines whether the built-in validator for disabled\n       * date ranges is enforced when validating a form\n       * ([see example]({% slug disabled_dates_multiviewcalendar %}#toc-validation)).\n       */\n\n      this.disabledDatesRangeValidation = false;\n      /**\n       * Sets the Calendar selection mode\n       * ([see example]({% slug multiple_selection_multiviewcalendar %})).\n       *\n       * The available values are:\n       * * `single` (default)\n       * * `multiple`\n       */\n\n      this.selection = 'single';\n      /**\n       * Sets or gets the `disabled` property of the Calendar and\n       * determines whether the component is active\n       * ([see example]({% slug disabled_multiviewcalendar %})).\n       */\n\n      this.disabled = false;\n      /**\n       * Sets or gets the `tabindex` property of the Calendar. Based on the\n       * [HTML `tabindex`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) behavior,\n       * it determines whether the component is focusable.\n       */\n\n      this.tabindex = 0;\n      /**\n       * @hidden\n       */\n\n      this.isActive = false;\n      /**\n       * Defines the active view that the Calendar initially renders\n       * ([see example]({% slug activeview_multiviewcalendar %})).\n       * By default, the active view is `month`.\n       *\n       * > You have to set `activeView` within the `topView`-`bottomView` range.\n       */\n\n      this.activeView = CalendarViewEnum[CalendarViewEnum.month];\n      /**\n       * Defines the bottommost view, to which the user can navigate\n       * ([see example]({% slug dates_multiviewcalendar %}#toc-partial-dates)).\n       */\n\n      this.bottomView = CalendarViewEnum[CalendarViewEnum.month];\n      /**\n       * Defines the topmost view, to which the user can navigate.\n       */\n\n      this.topView = CalendarViewEnum[CalendarViewEnum.century];\n      /**\n       * Determines whether to display a header for every view (for example the month name).\n       */\n\n      this.showViewHeader = false;\n      /**\n       * Determines whether to enable animation when navigating to previous/next view.\n       *\n       * > This feature uses the [Web Animations API](https://developer.mozilla.org/en-US/docs/Web/API/Web_Animations_API). In order to run the animation in browsers that do not support it, you need the `web-animations-js` polyfill.\n       *\n       * @default false\n       */\n\n      this.animateNavigation = false;\n      /**\n       * Determines whether to display a week number column in the `month` view\n       * ([see example]({% slug weeknumcolumn_multiviewcalendar %})).\n       */\n\n      this.weekNumber = false;\n      /**\n       * Sets or gets the `views` property of the Calendar and\n       * defines the number of rendered months.\n       */\n\n      this.views = 2;\n      /**\n       * Fires when the active view is changed\n       * ([more information and example]({% slug overview_multiviewcalendar %}#toc-events)).\n       */\n\n      this.activeViewChange = new EventEmitter();\n      /**\n       * Fires when a view cell is entered\n       * ([more information and example]({% slug overview_multiviewcalendar %}#toc-events)).\n       */\n\n      this.cellEnter = new EventEmitter();\n      /**\n       * Fires when a view cell is leaved\n       * ([more information and example]({% slug overview_multiviewcalendar %}#toc-events)).\n       */\n\n      this.cellLeave = new EventEmitter();\n      /**\n       * Fires when the value is changed\n       * ([more information and example]({% slug overview_multiviewcalendar %}#toc-events)).\n       */\n\n      this.valueChange = new EventEmitter();\n      this.cellUID = guid();\n      this.isHovered = false;\n      this.isPrevDisabled = true;\n      this.isNextDisabled = true;\n      this.prevView = Action.PrevView;\n      this.nextView = Action.NextView;\n      this.selectedDates = [];\n      this._min = new Date(MIN_DATE);\n      this._max = new Date(MAX_DATE);\n      this._focusedDate = getToday();\n      this.resolvedPromise = Promise.resolve();\n      this.onControlChange = noop;\n      this.onControlTouched = noop;\n      this.onValidatorChange = noop;\n      this.minValidateFn = noop;\n      this.maxValidateFn = noop;\n      this.disabledDatesRangeValidateFn = noop;\n      this.subscriptions = new Subscription(() => {});\n      this.setClasses(element.nativeElement);\n    }\n    /**\n     * Sets or gets the `focusedDate` property of the Calendar and\n     * defines the focused date of the component\n     * ([see example]({% slug dates_multiviewcalendar %}#toc-focused-dates)).\n     *\n     * > If the Calendar is out of the min or max range, it normalizes the defined `focusedDate`.\n     */\n\n\n    set focusedDate(focusedDate) {\n      this._focusedDate = focusedDate || getToday();\n    }\n\n    get focusedDate() {\n      return this._focusedDate;\n    }\n    /**\n     * Sets or gets the `min` property of the Calendar and\n     * defines the minimum allowed date value.\n     * By default, the `min` value is `1900-1-1`.\n     */\n\n\n    set min(min) {\n      this._min = min || new Date(MIN_DATE);\n    }\n\n    get min() {\n      return this._min;\n    }\n    /**\n     * Sets or gets the `max` property of the Calendar and\n     * defines the maximum allowed date value.\n     * By default, the `max` value is `2099-12-31`.\n     */\n\n\n    set max(max) {\n      this._max = max || new Date(MAX_DATE);\n    }\n\n    get max() {\n      return this._max;\n    }\n    /**\n     * Sets or gets the `value` property of the Calendar and defines the selected value of the component.\n     *\n     * > The `value` has to be a valid\n     * [JavaScript `Date`](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Date)\n     * instance when in `single` selection mode or an array of valid JavaScript Date instances when in `multiple` selection mode.\n     */\n\n\n    get value() {\n      return this._value;\n    }\n\n    set value(candidate) {\n      this.verifyValue(candidate);\n      this._value = Array.isArray(candidate) ? candidate.filter(date => isPresent(date)).map(element => cloneDate(element)) : cloneDate(candidate);\n      const selection = [].concat(candidate).filter(date => isPresent(date)).map(date => cloneDate(date));\n\n      if (!areDatesEqual(selection, this.selectedDates)) {\n        const lastSelected = last(selection);\n        this.rangePivot = cloneDate(lastSelected);\n        this.focusedDate = cloneDate(lastSelected) || this.focusedDate;\n        this.selectedDates = selection;\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    set tabIndex(tabIndex) {\n      this.tabindex = tabIndex;\n    }\n\n    get tabIndex() {\n      return this.tabindex;\n    }\n    /**\n     * Sets the dates of the MultiViewCalendar that will be disabled\n     * ([see example]({% slug disabled_dates_multiviewcalendar %})).\n     */\n\n\n    set disabledDates(value) {\n      this.disabledDatesService.initialize(value);\n    }\n    /**\n     * Sets or gets the `selectionRange` property of the Calendar and\n     * defines the selection range of the component\n     * ([see example]({% slug dates_multiviewcalendar %}#toc-selection-range)).\n     */\n\n\n    set selectionRange(range$$1) {\n      this._selectionRange = range$$1;\n\n      if (this.disabledDatesRangeValidation) {\n        this.onValidatorChange();\n      }\n    }\n\n    get selectionRange() {\n      return this._selectionRange;\n    }\n    /**\n     * @hidden\n     */\n\n\n    set cellTemplateRef(template) {\n      this.cellTemplate = template;\n    }\n    /**\n     * @hidden\n     */\n\n\n    set monthCellTemplateRef(template) {\n      this.monthCellTemplate = template;\n    }\n    /**\n     * @hidden\n     */\n\n\n    set yearCellTemplateRef(template) {\n      this.yearCellTemplate = template;\n    }\n    /**\n     * @hidden\n     */\n\n\n    set decadeCellTemplateRef(template) {\n      this.decadeCellTemplate = template;\n    }\n    /**\n     * @hidden\n     */\n\n\n    set centuryCellTemplateRef(template) {\n      this.centuryCellTemplate = template;\n    }\n    /**\n     * @hidden\n     */\n\n\n    set weekNumberTemplateRef(template) {\n      this.weekNumberTemplate = template;\n    }\n    /**\n     * @hidden\n     */\n\n\n    set headerTitleTemplateRef(template) {\n      this.headerTitleTemplate = template;\n    }\n\n    get activeViewEnum() {\n      const activeView = CalendarViewEnum[this.activeView];\n      return activeView < this.bottomViewEnum ? this.bottomViewEnum : activeView;\n    }\n\n    get bottomViewEnum() {\n      return CalendarViewEnum[this.bottomView];\n    }\n\n    get topViewEnum() {\n      return CalendarViewEnum[this.topView];\n    }\n\n    get widgetId() {\n      return this.id;\n    }\n\n    get widgetRole() {\n      return 'grid';\n    }\n\n    get calendarTabIndex() {\n      return this.disabled ? undefined : this.tabIndex;\n    }\n\n    get ariaDisabled() {\n      return this.disabled;\n    }\n\n    get ariaActivedescendant() {\n      return this.cellUID + this.focusedDate.getTime();\n    }\n    /**\n     * @hidden\n     */\n\n\n    handleBlur() {\n      this.onControlTouched();\n      this.isActive = false;\n      this.isHovered = false; //ensure that hovered is also not active\n    }\n    /**\n     * @hidden\n     */\n\n\n    handleFocus() {\n      this.isActive = true;\n    }\n    /**\n     * @hidden\n     */\n\n\n    handleMouseEnter() {\n      this.isHovered = true;\n    }\n    /**\n     * @hidden\n     */\n\n\n    handleMouseLeave() {\n      this.isHovered = false;\n    }\n    /**\n     * @hidden\n     */\n\n\n    handleMousedown(event) {\n      event.preventDefault();\n    }\n    /**\n     * @hidden\n     */\n\n\n    handleClick() {\n      if (this.isActive) {\n        return;\n      }\n\n      this.focus();\n    }\n    /**\n     * @hidden\n     */\n\n\n    keydown(event) {\n      if (event.keyCode === Keys.Enter) {\n        this.performSelection(this.focusedDate, event);\n      }\n\n      const candidate = dateInRange(this.navigator.move(this.focusedDate, this.navigator.action(event), this.activeViewEnum), this.min, this.max);\n\n      if (isEqual(this.focusedDate, candidate)) {\n        return;\n      }\n\n      this.focusedDate = candidate;\n      event.preventDefault();\n    }\n\n    ngOnInit() {\n      this.subscriptions.add(this.bus.viewChanged.subscribe(({\n        view\n      }) => {\n        this.activeView = CalendarViewEnum[view];\n        this.activeViewChange.emit(this.activeView);\n        this.cdr.detectChanges();\n        this.updateButtonState();\n      }));\n    }\n\n    ngOnChanges(changes) {\n      this.verifyChanges();\n      this.bus.configure(this.bottomViewEnum, this.topViewEnum);\n\n      if (hasExistingValue(changes, 'focusedDate')) {\n        const focusedDate = changes.focusedDate.currentValue;\n        this.focusedDate = dateInRange(focusedDate, this.min, this.max);\n      }\n\n      if (changes.min || changes.max || changes.rangeValidation || changes.disabledDates || changes.disabledDatesRangeValidation) {\n        this.minValidateFn = this.rangeValidation ? minValidator(this.min) : noop;\n        this.maxValidateFn = this.rangeValidation ? maxValidator(this.max) : noop;\n        this.disabledDatesRangeValidateFn = this.disabledDatesRangeValidation ? disabledDatesRangeValidator(this.disabledDatesService.isDateDisabled) : noop;\n        this.onValidatorChange();\n      }\n\n      if (changes.min || changes.max || changes.focusedDate || changes.activeView) {\n        this.updateButtonState();\n      }\n    }\n\n    ngOnDestroy() {\n      this.subscriptions.unsubscribe();\n    }\n\n    ngAfterViewInit() {\n      this.updateButtonState();\n    }\n    /**\n     * Focuses the host element of the Calendar.\n     *\n     * @example\n     * ```ts\n     * _@Component({\n     * selector: 'my-app',\n     * template: `\n     *  <button (click)=\"multiviewcalendar.focus()\">Focus calendar</button>\n     *  <kendo-multiviewcalendar #multiviewcalendar></kendo-multiviewcalendar>\n     * `\n     * })\n     * export class AppComponent { }\n     * ```\n     */\n\n\n    focus() {\n      if (!this.element) {\n        return;\n      }\n\n      this.element.nativeElement.focus();\n    }\n    /**\n     * Blurs the Calendar component.\n     */\n\n\n    blur() {\n      if (!this.element) {\n        return;\n      }\n\n      this.element.nativeElement.blur();\n    }\n    /**\n     * @hidden\n     */\n\n\n    handleDateChange(args) {\n      const canNavigateDown = this.bus.canMoveDown(this.activeViewEnum);\n      const availableDates = args.selectedDates.filter(date => !this.disabledDatesService.isDateDisabled(date));\n      this.focusedDate = args.focusedDate || this.focusedDate;\n      const sameDates = !canNavigateDown && areDatesEqual(availableDates, this.selectedDates);\n\n      if (this.disabled || sameDates) {\n        return;\n      }\n\n      if (canNavigateDown) {\n        this.bus.moveDown(this.activeViewEnum);\n        return;\n      }\n\n      if (this.disabledDatesService.isDateDisabled(this.focusedDate)) {\n        return;\n      }\n\n      this.selectedDates = availableDates.map(date => cloneDate(date));\n      this.value = this.parseSelectionToValue(availableDates);\n      this.onControlChange(this.parseSelectionToValue(availableDates));\n      this.valueChange.emit(this.parseSelectionToValue(availableDates));\n    }\n    /**\n     * @hidden\n     */\n\n\n    setActiveDate(date) {\n      this.activeDate = cloneDate(date);\n      this.cdr.detectChanges();\n    }\n    /**\n     * @hidden\n     */\n\n\n    writeValue(candidate) {\n      this.verifyValue(candidate);\n      this.value = candidate;\n      this.cdr.markForCheck();\n    }\n    /**\n     * @hidden\n     */\n\n\n    registerOnChange(fn) {\n      this.onControlChange = fn;\n    }\n    /**\n     * @hidden\n     */\n\n\n    registerOnTouched(fn) {\n      this.onControlTouched = fn;\n    }\n    /**\n     * @hidden\n     */\n\n\n    setDisabledState(isDisabled) {\n      this.disabled = isDisabled;\n      this.cdr.markForCheck();\n    }\n    /**\n     * @hidden\n     */\n\n\n    validate(control) {\n      return this.minValidateFn(control) || this.maxValidateFn(control) || this.disabledDatesRangeValidateFn(this.selectionRange);\n    }\n    /**\n     * @hidden\n     */\n\n\n    registerOnValidatorChange(fn) {\n      this.onValidatorChange = fn;\n    }\n    /**\n     * @hidden\n     */\n\n\n    activeCellTemplate() {\n      switch (this.activeViewEnum) {\n        case CalendarViewEnum.month:\n          return this.monthCellTemplate || this.cellTemplate;\n\n        case CalendarViewEnum.year:\n          return this.yearCellTemplate;\n\n        case CalendarViewEnum.decade:\n          return this.decadeCellTemplate;\n\n        case CalendarViewEnum.century:\n          return this.centuryCellTemplate;\n\n        default:\n          return null;\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    navigate(action) {\n      this.focusedDate = this.viewList.navigate(action);\n      this.updateButtonState();\n    }\n    /**\n     * @hidden\n     */\n\n\n    emitCellEvent(emitter, args) {\n      if (hasObservers(emitter)) {\n        this.zone.run(() => {\n          emitter.emit(args);\n        });\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    handleCellClick({\n      date,\n      modifiers\n    }) {\n      this.performSelection(date, modifiers);\n    }\n    /**\n     * @hidden\n     */\n\n\n    handleWeekNumberClick(dates) {\n      if (this.selection === 'single') {\n        return;\n      }\n\n      this.zone.run(() => {\n        this.handleDateChange({\n          selectedDates: dates,\n          focusedDate: last(dates)\n        });\n      });\n    }\n\n    setClasses(element) {\n      this.renderer.addClass(element, 'k-widget');\n      this.renderer.addClass(element, 'k-calendar');\n      this.renderer.addClass(element, 'k-calendar-range');\n    }\n\n    verifyChanges() {\n      if (!isDevMode()) {\n        return;\n      }\n\n      if (this.min > this.max) {\n        throw new Error(`The max value should be bigger than the min. See ${MIN_DOC_LINK$3} and ${MAX_DOC_LINK$3}.`);\n      }\n\n      if (this.bottomViewEnum > this.topViewEnum) {\n        throw new Error(`The topView should be greater than bottomView. See ${BOTTOM_VIEW_DOC_LINK$1} and ${TOP_VIEW_DOC_LINK$1}.`);\n      }\n    }\n\n    verifyValue(candidate) {\n      if (!isDevMode()) {\n        return;\n      }\n\n      if (this.selection === 'single' && candidate && !(candidate instanceof Date)) {\n        throw new Error(`The 'value' should be a valid JavaScript Date instance. Check ${VALUE_DOC_LINK$5} for possible resolution.`);\n      } else if (this.selection === 'multiple' && candidate && Array.isArray(candidate)) {\n        const onlyDates = candidate.every(value => value instanceof Date);\n\n        if (!onlyDates) {\n          throw new Error(`The 'value' should be an array of valid JavaScript Date instances. Check ${VALUE_DOC_LINK$5} for possible resolution.`);\n        }\n      }\n    }\n\n    updateButtonState() {\n      this.resolvedPromise.then(() => {\n        this.isPrevDisabled = !this.viewList.canNavigate(this.prevView);\n        this.isNextDisabled = !this.viewList.canNavigate(this.nextView);\n        this.cdr.markForCheck();\n      });\n    }\n\n    parseSelectionToValue(selection) {\n      selection = selection || [];\n      return this.selection === 'single' ? cloneDate(last(selection)) : selection.map(date => cloneDate(date));\n    }\n\n    performSelection(date, selectionModifiers) {\n      const selection = this.selectionService.performSelection({\n        date: date,\n        modifiers: selectionModifiers,\n        selectionMode: this.selection,\n        activeViewEnum: this.activeViewEnum,\n        rangePivot: this.rangePivot,\n        selectedDates: this.selectedDates\n      });\n      this.rangePivot = selection.rangePivot;\n      this.handleDateChange({\n        selectedDates: selection.selectedDates,\n        focusedDate: date\n      });\n    }\n\n  };\n\n  MultiViewCalendarComponent.ɵfac = function MultiViewCalendarComponent_Factory(t) {\n    return new (t || MultiViewCalendarComponent)(ɵngcc0.ɵɵdirectiveInject(BusViewService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(NavigationService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(DisabledDatesService), ɵngcc0.ɵɵdirectiveInject(SelectionService));\n  };\n\n  MultiViewCalendarComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: MultiViewCalendarComponent,\n    selectors: [[\"kendo-multiviewcalendar\"]],\n    contentQueries: function MultiViewCalendarComponent_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵcontentQuery(dirIndex, CellTemplateDirective, 7);\n        ɵngcc0.ɵɵcontentQuery(dirIndex, MonthCellTemplateDirective, 7);\n        ɵngcc0.ɵɵcontentQuery(dirIndex, YearCellTemplateDirective, 7);\n        ɵngcc0.ɵɵcontentQuery(dirIndex, DecadeCellTemplateDirective, 7);\n        ɵngcc0.ɵɵcontentQuery(dirIndex, CenturyCellTemplateDirective, 7);\n        ɵngcc0.ɵɵcontentQuery(dirIndex, WeekNumberCellTemplateDirective, 7);\n        ɵngcc0.ɵɵcontentQuery(dirIndex, HeaderTitleTemplateDirective, 7);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.cellTemplate = _t.first);\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.monthCellTemplate = _t.first);\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.yearCellTemplate = _t.first);\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.decadeCellTemplate = _t.first);\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.centuryCellTemplate = _t.first);\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.weekNumberTemplate = _t.first);\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.headerTitleTemplate = _t.first);\n      }\n    },\n    viewQuery: function MultiViewCalendarComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵviewQuery(HorizontalViewListComponent, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.viewList = _t.first);\n      }\n    },\n    hostVars: 7,\n    hostBindings: function MultiViewCalendarComponent_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵlistener(\"blur\", function MultiViewCalendarComponent_blur_HostBindingHandler() {\n          return ctx.handleBlur();\n        })(\"focus\", function MultiViewCalendarComponent_focus_HostBindingHandler() {\n          return ctx.handleFocus();\n        })(\"mouseenter\", function MultiViewCalendarComponent_mouseenter_HostBindingHandler() {\n          return ctx.handleMouseEnter();\n        })(\"mouseleave\", function MultiViewCalendarComponent_mouseleave_HostBindingHandler() {\n          return ctx.handleMouseLeave();\n        })(\"mousedown\", function MultiViewCalendarComponent_mousedown_HostBindingHandler($event) {\n          return ctx.handleMousedown($event);\n        })(\"click\", function MultiViewCalendarComponent_click_HostBindingHandler() {\n          return ctx.handleClick();\n        })(\"keydown\", function MultiViewCalendarComponent_keydown_HostBindingHandler($event) {\n          return ctx.keydown($event);\n        });\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵattribute(\"id\", ctx.widgetId)(\"role\", ctx.widgetRole)(\"tabindex\", ctx.calendarTabIndex)(\"aria-disabled\", ctx.ariaDisabled)(\"aria-activedescendant\", ctx.ariaActivedescendant);\n        ɵngcc0.ɵɵclassProp(\"k-state-disabled\", ctx.ariaDisabled);\n      }\n    },\n    inputs: {\n      id: \"id\",\n      rangeValidation: \"rangeValidation\",\n      disabledDatesRangeValidation: \"disabledDatesRangeValidation\",\n      selection: \"selection\",\n      disabled: \"disabled\",\n      tabindex: \"tabindex\",\n      isActive: \"isActive\",\n      activeView: \"activeView\",\n      bottomView: \"bottomView\",\n      topView: \"topView\",\n      showViewHeader: \"showViewHeader\",\n      animateNavigation: \"animateNavigation\",\n      weekNumber: \"weekNumber\",\n      views: \"views\",\n      focusedDate: \"focusedDate\",\n      min: \"min\",\n      max: \"max\",\n      value: \"value\",\n      tabIndex: \"tabIndex\",\n      disabledDates: \"disabledDates\",\n      selectionRange: \"selectionRange\",\n      cellTemplateRef: [\"cellTemplate\", \"cellTemplateRef\"],\n      monthCellTemplateRef: [\"monthCellTemplate\", \"monthCellTemplateRef\"],\n      yearCellTemplateRef: [\"yearCellTemplate\", \"yearCellTemplateRef\"],\n      decadeCellTemplateRef: [\"decadeCellTemplate\", \"decadeCellTemplateRef\"],\n      centuryCellTemplateRef: [\"centuryCellTemplate\", \"centuryCellTemplateRef\"],\n      weekNumberTemplateRef: [\"weekNumberTemplate\", \"weekNumberTemplateRef\"],\n      headerTitleTemplateRef: [\"headerTitleTemplate\", \"headerTitleTemplateRef\"],\n      activeRangeEnd: \"activeRangeEnd\"\n    },\n    outputs: {\n      activeViewChange: \"activeViewChange\",\n      cellEnter: \"cellEnter\",\n      cellLeave: \"cellLeave\",\n      valueChange: \"valueChange\"\n    },\n    exportAs: [\"kendo-multiviewcalendar\"],\n    features: [ɵngcc0.ɵɵProvidersFeature([BusViewService, RANGE_CALENDAR_VALUE_ACCESSOR, RANGE_CALENDAR_RANGE_VALIDATORS, LocalizationService, DisabledDatesService, {\n      provide: L10N_PREFIX,\n      useValue: 'kendo.multiviewcalendar'\n    }, NavigationService, SelectionService]), ɵngcc0.ɵɵNgOnChangesFeature],\n    decls: 3,\n    vars: 24,\n    consts: function () {\n      let i18n_81;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The label for the today button in the calendar header\n         * @meaning kendo.multiviewcalendar.today\n         */\n        const MSG_EXTERNAL_7780927771207785084$$DIST_FESM2015_INDEX_JS_82 = goog.getMsg(\"Today\");\n        i18n_81 = MSG_EXTERNAL_7780927771207785084$$DIST_FESM2015_INDEX_JS_82;\n      } else {\n        i18n_81 = $localize`:kendo.multiviewcalendar.today|The label for the today button in the calendar header␟c237cef31a55d762ecfdcac701d283313f30bbfc␟7780927771207785084:Today`;\n      }\n\n      let i18n_83;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The label for the previous button in the Multiview calendar\n         * @meaning kendo.multiviewcalendar.prevButtonTitle\n         */\n        const MSG_EXTERNAL_9101635325676663492$$DIST_FESM2015_INDEX_JS_84 = goog.getMsg(\"Navigate to previous view\");\n        i18n_83 = MSG_EXTERNAL_9101635325676663492$$DIST_FESM2015_INDEX_JS_84;\n      } else {\n        i18n_83 = $localize`:kendo.multiviewcalendar.prevButtonTitle|The label for the previous button in the Multiview calendar␟e783e2af4828224b846fa92148ea1cc52b21bb13␟9101635325676663492:Navigate to previous view`;\n      }\n\n      let i18n_85;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The label for the next button in the Multiview calendar\n         * @meaning kendo.multiviewcalendar.nextButtonTitle\n         */\n        const MSG_EXTERNAL_3994336778698343633$$DIST_FESM2015_INDEX_JS_86 = goog.getMsg(\"Navigate to next view\");\n        i18n_85 = MSG_EXTERNAL_3994336778698343633$$DIST_FESM2015_INDEX_JS_86;\n      } else {\n        i18n_85 = $localize`:kendo.multiviewcalendar.nextButtonTitle|The label for the next button in the Multiview calendar␟3e3a529a242f39d22f841c3bd8045ec75b696b7a␟3994336778698343633:Navigate to next view`;\n      }\n\n      return [[\"kendoMultiViewCalendarLocalizedMessages\", \"\", \"today\", i18n_81, \"prevButtonTitle\", i18n_83, \"nextButtonTitle\", i18n_85], [3, \"activeView\", \"currentDate\", \"min\", \"max\", \"rangeLength\", \"templateRef\", \"isPrevDisabled\", \"isNextDisabled\", \"showNavigationButtons\", \"todayButtonClick\", \"prevButtonClick\", \"nextButtonClick\"], [3, \"activeView\", \"isActive\", \"cellTemplateRef\", \"weekNumberTemplateRef\", \"cellUID\", \"views\", \"min\", \"max\", \"focusedDate\", \"animateNavigation\", \"showViewHeader\", \"weekNumber\", \"activeRangeEnd\", \"selectionRange\", \"selectedDates\", \"valueChange\", \"cellClick\", \"weekNumberCellClick\", \"cellEnter\", \"cellLeave\", \"activeDateChange\"]];\n    },\n    template: function MultiViewCalendarComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵelementContainer(0, 0);\n        ɵngcc0.ɵɵelementStart(1, \"kendo-calendar-header\", 1);\n        ɵngcc0.ɵɵlistener(\"todayButtonClick\", function MultiViewCalendarComponent_Template_kendo_calendar_header_todayButtonClick_1_listener($event) {\n          return ctx.handleDateChange({\n            selectedDates: [$event],\n            focusedDate: $event\n          });\n        })(\"prevButtonClick\", function MultiViewCalendarComponent_Template_kendo_calendar_header_prevButtonClick_1_listener() {\n          return ctx.navigate(ctx.prevView);\n        })(\"nextButtonClick\", function MultiViewCalendarComponent_Template_kendo_calendar_header_nextButtonClick_1_listener() {\n          return ctx.navigate(ctx.nextView);\n        });\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵelementStart(2, \"kendo-calendar-horizontal\", 2);\n        ɵngcc0.ɵɵlistener(\"valueChange\", function MultiViewCalendarComponent_Template_kendo_calendar_horizontal_valueChange_2_listener($event) {\n          return ctx.handleDateChange($event);\n        })(\"cellClick\", function MultiViewCalendarComponent_Template_kendo_calendar_horizontal_cellClick_2_listener($event) {\n          return ctx.handleCellClick($event);\n        })(\"weekNumberCellClick\", function MultiViewCalendarComponent_Template_kendo_calendar_horizontal_weekNumberCellClick_2_listener($event) {\n          return ctx.handleWeekNumberClick($event);\n        })(\"cellEnter\", function MultiViewCalendarComponent_Template_kendo_calendar_horizontal_cellEnter_2_listener($event) {\n          return ctx.emitCellEvent(ctx.cellEnter, $event);\n        })(\"cellLeave\", function MultiViewCalendarComponent_Template_kendo_calendar_horizontal_cellLeave_2_listener($event) {\n          return ctx.emitCellEvent(ctx.cellLeave, $event);\n        })(\"activeDateChange\", function MultiViewCalendarComponent_Template_kendo_calendar_horizontal_activeDateChange_2_listener($event) {\n          return ctx.setActiveDate($event);\n        });\n        ɵngcc0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        let tmp_11_0;\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"activeView\", ctx.activeViewEnum)(\"currentDate\", ctx.activeDate)(\"min\", ctx.min)(\"max\", ctx.max)(\"rangeLength\", ctx.views)(\"templateRef\", ctx.headerTitleTemplate == null ? null : ctx.headerTitleTemplate.templateRef)(\"isPrevDisabled\", ctx.isPrevDisabled)(\"isNextDisabled\", ctx.isNextDisabled)(\"showNavigationButtons\", true);\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"activeView\", ctx.activeViewEnum)(\"isActive\", ctx.isActive || ctx.isHovered)(\"cellTemplateRef\", (tmp_11_0 = ctx.activeCellTemplate()) == null ? null : tmp_11_0.templateRef)(\"weekNumberTemplateRef\", ctx.weekNumberTemplate == null ? null : ctx.weekNumberTemplate.templateRef)(\"cellUID\", ctx.cellUID)(\"views\", ctx.views)(\"min\", ctx.min)(\"max\", ctx.max)(\"focusedDate\", ctx.focusedDate)(\"animateNavigation\", ctx.animateNavigation)(\"showViewHeader\", ctx.showViewHeader)(\"weekNumber\", ctx.weekNumber)(\"activeRangeEnd\", ctx.activeRangeEnd)(\"selectionRange\", ctx.selectionRange)(\"selectedDates\", ctx.selectedDates);\n      }\n    },\n    directives: function () {\n      return [MultiViewCalendarLocalizedMessagesDirective, HeaderComponent, HorizontalViewListComponent];\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n\n  __decorate([Input(), __metadata(\"design:type\", String)], MultiViewCalendarComponent.prototype, \"id\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", Date), __metadata(\"design:paramtypes\", [Date])], MultiViewCalendarComponent.prototype, \"focusedDate\", null);\n\n  __decorate([Input(), __metadata(\"design:type\", Date), __metadata(\"design:paramtypes\", [Date])], MultiViewCalendarComponent.prototype, \"min\", null);\n\n  __decorate([Input(), __metadata(\"design:type\", Date), __metadata(\"design:paramtypes\", [Date])], MultiViewCalendarComponent.prototype, \"max\", null);\n\n  __decorate([Input(), __metadata(\"design:type\", Boolean)], MultiViewCalendarComponent.prototype, \"rangeValidation\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", Boolean)], MultiViewCalendarComponent.prototype, \"disabledDatesRangeValidation\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", String)], MultiViewCalendarComponent.prototype, \"selection\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", Object), __metadata(\"design:paramtypes\", [Object])], MultiViewCalendarComponent.prototype, \"value\", null);\n\n  __decorate([Input(), __metadata(\"design:type\", Boolean)], MultiViewCalendarComponent.prototype, \"disabled\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", Number)], MultiViewCalendarComponent.prototype, \"tabindex\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", Number), __metadata(\"design:paramtypes\", [Number])], MultiViewCalendarComponent.prototype, \"tabIndex\", null);\n\n  __decorate([Input(), __metadata(\"design:type\", Boolean)], MultiViewCalendarComponent.prototype, \"isActive\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", Object), __metadata(\"design:paramtypes\", [Object])], MultiViewCalendarComponent.prototype, \"disabledDates\", null);\n\n  __decorate([Input(), __metadata(\"design:type\", String)], MultiViewCalendarComponent.prototype, \"activeView\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", String)], MultiViewCalendarComponent.prototype, \"bottomView\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", String)], MultiViewCalendarComponent.prototype, \"topView\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", Boolean)], MultiViewCalendarComponent.prototype, \"showViewHeader\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", Boolean)], MultiViewCalendarComponent.prototype, \"animateNavigation\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", Boolean)], MultiViewCalendarComponent.prototype, \"weekNumber\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", String)], MultiViewCalendarComponent.prototype, \"activeRangeEnd\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", Object), __metadata(\"design:paramtypes\", [Object])], MultiViewCalendarComponent.prototype, \"selectionRange\", null);\n\n  __decorate([Input(), __metadata(\"design:type\", Number)], MultiViewCalendarComponent.prototype, \"views\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], MultiViewCalendarComponent.prototype, \"activeViewChange\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], MultiViewCalendarComponent.prototype, \"cellEnter\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], MultiViewCalendarComponent.prototype, \"cellLeave\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], MultiViewCalendarComponent.prototype, \"valueChange\", void 0);\n\n  __decorate([ContentChild(CellTemplateDirective, {\n    static: true\n  }), __metadata(\"design:type\", CellTemplateDirective)], MultiViewCalendarComponent.prototype, \"cellTemplate\", void 0);\n\n  __decorate([Input('cellTemplate'), __metadata(\"design:type\", CellTemplateDirective), __metadata(\"design:paramtypes\", [CellTemplateDirective])], MultiViewCalendarComponent.prototype, \"cellTemplateRef\", null);\n\n  __decorate([ContentChild(MonthCellTemplateDirective, {\n    static: true\n  }), __metadata(\"design:type\", MonthCellTemplateDirective)], MultiViewCalendarComponent.prototype, \"monthCellTemplate\", void 0);\n\n  __decorate([Input('monthCellTemplate'), __metadata(\"design:type\", MonthCellTemplateDirective), __metadata(\"design:paramtypes\", [MonthCellTemplateDirective])], MultiViewCalendarComponent.prototype, \"monthCellTemplateRef\", null);\n\n  __decorate([ContentChild(YearCellTemplateDirective, {\n    static: true\n  }), __metadata(\"design:type\", YearCellTemplateDirective)], MultiViewCalendarComponent.prototype, \"yearCellTemplate\", void 0);\n\n  __decorate([Input('yearCellTemplate'), __metadata(\"design:type\", YearCellTemplateDirective), __metadata(\"design:paramtypes\", [YearCellTemplateDirective])], MultiViewCalendarComponent.prototype, \"yearCellTemplateRef\", null);\n\n  __decorate([ContentChild(DecadeCellTemplateDirective, {\n    static: true\n  }), __metadata(\"design:type\", DecadeCellTemplateDirective)], MultiViewCalendarComponent.prototype, \"decadeCellTemplate\", void 0);\n\n  __decorate([Input('decadeCellTemplate'), __metadata(\"design:type\", DecadeCellTemplateDirective), __metadata(\"design:paramtypes\", [DecadeCellTemplateDirective])], MultiViewCalendarComponent.prototype, \"decadeCellTemplateRef\", null);\n\n  __decorate([ContentChild(CenturyCellTemplateDirective, {\n    static: true\n  }), __metadata(\"design:type\", CenturyCellTemplateDirective)], MultiViewCalendarComponent.prototype, \"centuryCellTemplate\", void 0);\n\n  __decorate([Input('centuryCellTemplate'), __metadata(\"design:type\", CenturyCellTemplateDirective), __metadata(\"design:paramtypes\", [CenturyCellTemplateDirective])], MultiViewCalendarComponent.prototype, \"centuryCellTemplateRef\", null);\n\n  __decorate([ContentChild(WeekNumberCellTemplateDirective, {\n    static: true\n  }), __metadata(\"design:type\", WeekNumberCellTemplateDirective)], MultiViewCalendarComponent.prototype, \"weekNumberTemplate\", void 0);\n\n  __decorate([Input('weekNumberTemplate'), __metadata(\"design:type\", WeekNumberCellTemplateDirective), __metadata(\"design:paramtypes\", [WeekNumberCellTemplateDirective])], MultiViewCalendarComponent.prototype, \"weekNumberTemplateRef\", null);\n\n  __decorate([ContentChild(HeaderTitleTemplateDirective, {\n    static: true\n  }), __metadata(\"design:type\", HeaderTitleTemplateDirective)], MultiViewCalendarComponent.prototype, \"headerTitleTemplate\", void 0);\n\n  __decorate([Input('headerTitleTemplate'), __metadata(\"design:type\", HeaderTitleTemplateDirective), __metadata(\"design:paramtypes\", [HeaderTitleTemplateDirective])], MultiViewCalendarComponent.prototype, \"headerTitleTemplateRef\", null);\n\n  __decorate([ViewChild(HorizontalViewListComponent, {\n    static: false\n  }), __metadata(\"design:type\", HorizontalViewListComponent)], MultiViewCalendarComponent.prototype, \"viewList\", void 0);\n\n  __decorate([HostBinding('attr.id'), __metadata(\"design:type\", String), __metadata(\"design:paramtypes\", [])], MultiViewCalendarComponent.prototype, \"widgetId\", null);\n\n  __decorate([HostBinding('attr.role'), __metadata(\"design:type\", String), __metadata(\"design:paramtypes\", [])], MultiViewCalendarComponent.prototype, \"widgetRole\", null);\n\n  __decorate([HostBinding('attr.tabindex'), __metadata(\"design:type\", Number), __metadata(\"design:paramtypes\", [])], MultiViewCalendarComponent.prototype, \"calendarTabIndex\", null);\n\n  __decorate([HostBinding('attr.aria-disabled'), HostBinding('class.k-state-disabled'), __metadata(\"design:type\", Boolean), __metadata(\"design:paramtypes\", [])], MultiViewCalendarComponent.prototype, \"ariaDisabled\", null);\n\n  __decorate([HostBinding('attr.aria-activedescendant'), __metadata(\"design:type\", String), __metadata(\"design:paramtypes\", [])], MultiViewCalendarComponent.prototype, \"ariaActivedescendant\", null);\n\n  __decorate([HostListener(\"blur\"), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", []), __metadata(\"design:returntype\", void 0)], MultiViewCalendarComponent.prototype, \"handleBlur\", null);\n\n  __decorate([HostListener(\"focus\"), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", []), __metadata(\"design:returntype\", void 0)], MultiViewCalendarComponent.prototype, \"handleFocus\", null);\n\n  __decorate([HostListener(\"mouseenter\"), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", []), __metadata(\"design:returntype\", void 0)], MultiViewCalendarComponent.prototype, \"handleMouseEnter\", null);\n\n  __decorate([HostListener(\"mouseleave\"), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", []), __metadata(\"design:returntype\", void 0)], MultiViewCalendarComponent.prototype, \"handleMouseLeave\", null);\n\n  __decorate([HostListener(\"mousedown\", ['$event']), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [Object]), __metadata(\"design:returntype\", void 0)], MultiViewCalendarComponent.prototype, \"handleMousedown\", null);\n\n  __decorate([HostListener(\"click\"), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", []), __metadata(\"design:returntype\", void 0)], MultiViewCalendarComponent.prototype, \"handleClick\", null);\n\n  __decorate([HostListener(\"keydown\", [\"$event\"]), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [Object]), __metadata(\"design:returntype\", void 0)], MultiViewCalendarComponent.prototype, \"keydown\", null);\n\n  MultiViewCalendarComponent = __decorate([__metadata(\"design:paramtypes\", [BusViewService, ElementRef, NavigationService, Renderer2, ChangeDetectorRef, NgZone, DisabledDatesService, SelectionService])], MultiViewCalendarComponent);\n  /**\n   * A directive which renders the content of the DateRange Popup. To define the cell template, nest an\n   * `<ng-template>` tag with the `kendoRangePopupTemplate` directive inside the component tag.\n   */\n\n  return MultiViewCalendarComponent;\n})();\nlet DateRangePopupTemplateDirective = /*#__PURE__*/(() => {\n  let DateRangePopupTemplateDirective = class DateRangePopupTemplateDirective {\n    constructor(templateRef) {\n      this.templateRef = templateRef;\n    }\n\n  };\n\n  DateRangePopupTemplateDirective.ɵfac = function DateRangePopupTemplateDirective_Factory(t) {\n    return new (t || DateRangePopupTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef));\n  };\n\n  DateRangePopupTemplateDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: DateRangePopupTemplateDirective,\n    selectors: [[\"\", \"kendoDateRangePopupTemplate\", \"\"]]\n  });\n  DateRangePopupTemplateDirective = __decorate([__metadata(\"design:paramtypes\", [TemplateRef])], DateRangePopupTemplateDirective);\n  return DateRangePopupTemplateDirective;\n})();\n\nconst isActive = cmp => cmp && cmp.isActive || false;\n\nconst hasActiveContent = popup => popup && popup.hasActiveContent();\n/**\n * A service that handles the communication between the components that are placed inside the DateRangeComponent.\n * For example, the start and end `DateInput` and `DateRangePopup` components.\n */\n\n\nlet DateRangeService = /*#__PURE__*/(() => {\n  let DateRangeService = class DateRangeService {\n    /**\n     * A service that handles the communication between the components that are placed inside the DateRangeComponent.\n     * For example, the start and end `DateInput` and `DateRangePopup` components.\n     */\n    constructor() {\n      /**\n       * An Observable instance that notifies when the `activeRangeEnd` state is changed.\n       */\n      this.activeRangeEnd$ = new BehaviorSubject(null);\n      /**\n       * An Observable instance that notifies when the `focusedDate` is changed.\n       */\n\n      this.focusedDate$ = new BehaviorSubject(null);\n      /**\n       * An Observable instance that notifies when the end `DateInput` component is changed.\n       * For example, when a new end `DateInput` is attached or when the old one is detached.\n       */\n\n      this.endInput$ = new BehaviorSubject(null);\n      /**\n       * An Observable instance that notifies when the start `DateInput` component is changed.\n       * For example, when a new start `DateInput` is attached or the old one is detached.\n       */\n\n      this.startInput$ = new BehaviorSubject(null);\n      /**\n       * An Observable instance that notifies when the `DateRangePopup` component is changed.\n       */\n\n      this.dateRangePopup$ = new BehaviorSubject(null);\n      /**\n       * An Observable instance that notifies when the state of the selection range is changed.\n       */\n\n      this.range$ = new BehaviorSubject(EMPTY_SELECTIONRANGE);\n    }\n    /**\n     * Gets the current `activeRangeEnd` value.\n     */\n\n\n    get activeRangeEnd() {\n      return this.activeRangeEnd$.value;\n    }\n    /**\n     * Gets the current `focusedDate` value.\n     */\n\n\n    get focusedDate() {\n      return this.focusedDate$.value;\n    }\n    /**\n     * Gets the `min` range value.\n     * The `min` value is extracted from the `start` DateInput value or the `min` value of the Calendar.\n     */\n\n\n    get min() {\n      return (this.startInput$.value || {}).min || null;\n    }\n    /**\n     * Gets the `max` range value.\n     * The `max` value is extracted from the `end` DateInput value or the `max` value of the Calendar.\n     */\n\n\n    get max() {\n      return (this.endInput$.value || {}).max || null;\n    }\n    /**\n     * Gets the current `selectionRange` value.\n     */\n\n\n    get selectionRange() {\n      return this.range$.value;\n    }\n    /**\n     * Activates the registered `DateRangePopup` component.\n     * The method opens the popup and focuses the calendar.\n     */\n\n\n    activatePopup() {\n      const dateRangePopup = this.dateRangePopup$.value;\n\n      if (!dateRangePopup) {\n        return;\n      }\n\n      dateRangePopup.activate();\n    }\n    /**\n     * Deactivates the registered `DateRangePopup` component.\n     * The method closes the popup.\n     */\n\n\n    deactivatePopup() {\n      const dateRangePopup = this.dateRangePopup$.value;\n\n      if (!(dateRangePopup && dateRangePopup.show)) {\n        return;\n      }\n\n      dateRangePopup.show = false;\n    }\n    /**\n     * @hidden\n     *\n     * Deactivates the registered `DateRangePopup` component and fires the `cancel` event.\n     * The method closes the popup.\n     */\n\n\n    cancelPopup() {\n      const dateRangePopup = this.dateRangePopup$.value;\n\n      if (!(dateRangePopup && dateRangePopup.show)) {\n        return;\n      }\n\n      dateRangePopup.cancelPopup();\n    }\n    /**\n     * Completes all observables to mitigate possible memory leaks.\n     * Calls the method when a component that uses it is destroyed.\n     */\n\n\n    destroy() {\n      this.activeRangeEnd$.complete();\n      this.dateRangePopup$.complete();\n      this.focusedDate$.complete();\n      this.endInput$.complete();\n      this.startInput$.complete();\n      this.range$.complete();\n    }\n    /**\n     * Returns `true` when an active component that is placed inside the `DateRangeComponent` is detected.\n     * For example, the opened popup or the focused DateInput.\n     *\n     * @returns `true` if an active component is present.\n     */\n\n\n    hasActiveComponent() {\n      const popup = this.dateRangePopup$.value;\n      const isPopup = isActive(popup);\n      const isStart = isActive(this.startInput$.value);\n      const isEnd = isActive(this.endInput$.value);\n      return isPopup || isStart || isEnd || hasActiveContent(popup) || false;\n    }\n    /**\n     * Registers a new start `DateInput` component. Notifies all `startInput$` listeners.\n     */\n\n\n    registerStartInput(startInput) {\n      this.startInput$.next(startInput);\n    }\n    /**\n     * Registers a new end `DateInput` component. Notifies all `endInput$` listeners.\n     */\n\n\n    registerEndInput(endInput) {\n      this.endInput$.next(endInput);\n    }\n    /**\n     * Registers a new `DateRangePopup` component. Notifies all `dateRangePopup$` listeners.\n     */\n\n\n    registerPopup(dateRangePopup) {\n      this.dateRangePopup$.next(dateRangePopup);\n    }\n    /**\n     * Updates the `activeRangeEnd` value. Notifies all `activeRangeEnd$` listeners.\n     */\n\n\n    setActiveRangeEnd(activeRange) {\n      if (!activeRange || this.activeRangeEnd === activeRange) {\n        return;\n      }\n\n      this.activeRangeEnd$.next(activeRange);\n    }\n    /**\n     * Updates the focused date. Notifies all `focusedDate$` listeners.\n     */\n\n\n    setFocusedDate(value) {\n      if (isEqual(this.focusedDate$.value, value)) {\n        return;\n      }\n\n      this.focusedDate$.next(value);\n    }\n    /**\n     * Updates the selection range. Notifies all `range$` listeners.\n     */\n\n\n    setRange(range = EMPTY_SELECTIONRANGE) {\n      this.range$.next(range);\n    }\n\n  };\n\n  DateRangeService.ɵfac = function DateRangeService_Factory(t) {\n    return new (t || DateRangeService)();\n  };\n\n  DateRangeService.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: DateRangeService,\n    factory: function (t) {\n      return DateRangeService.ɵfac(t);\n    }\n  });\n  /**\n   * Represents the Kendo UI DateRangePopup component for Angular.\n   *\n   * @example\n   * ```ts\n   * import { DateInputsModule, DateRangeService } from '@progress/kendo-angular-dateinputs';\n   *\n   * _@Component({\n   * providers: [DateRangeService],\n   * selector: 'my-app',\n   * template: `\n   *  <button #anchor (click)=\"popup.toggle()\">Toggle</button>\n   *  <kendo-daterange-popup [anchor]=\"anchor\" #popup></kendo-daterange-popup>\n   * `\n   * })\n   * export class AppComponent {\n   * }\n   * ```\n   */\n\n  return DateRangeService;\n})();\nlet DateRangePopupComponent = /*#__PURE__*/(() => {\n  let DateRangePopupComponent = class DateRangePopupComponent {\n    constructor(popupService, dateRangeService, ref, zone, rtl) {\n      this.popupService = popupService;\n      this.dateRangeService = dateRangeService;\n      this.ref = ref;\n      this.zone = zone;\n      this.rtl = rtl;\n      /**\n       * Controls the popup animation.\n       * By default, the opening and closing animations are enabled.\n       * For more information about controlling the popup animations,\n       * refer to the article on [animations]({% slug animations_popup %}).\n       */\n\n      this.animate = true;\n      /**\n       * Configures the collision behavior of the popup.\n       * For more information, refer to the article on\n       * [viewport boundary detection]({% slug viewportboundarydetection_popup %}).\n       */\n\n      this.collision = {\n        horizontal: 'fit',\n        vertical: 'flip'\n      };\n      /**\n       * Fires each time the popup is about to open.\n       * This event is preventable. If you cancel the event, the popup will remain closed.\n       * For more information, refer to the section on\n       * [events]({% slug overview_datepicker %}#toc-events).\n       */\n\n      this.open = new EventEmitter();\n      /**\n       * Fires each time the popup is about to close.\n       * This event is preventable. If you cancel the event, the popup will remain open.\n       * For more information, refer to the section on\n       * [events]({% slug overview_datepicker %}#toc-events).\n       */\n\n      this.close = new EventEmitter();\n      /**\n       * Fires each time the calendar element is blurred.\n       */\n\n      this.onBlur = new EventEmitter(); //tslint:disable-line:no-output-rename\n\n      /**\n       * Fires each time the calendar element is focused.\n       */\n\n      this.onFocus = new EventEmitter(); //tslint:disable-line:no-output-rename\n\n      /**\n       * Fires each time the popup is closed either on `ESC` keypress or on leaving the viewport.\n       */\n\n      this.cancel = new EventEmitter();\n      /**\n       * @hidden\n       */\n\n      this.popupUID = guid();\n      this.calendarSubscriptions = new Subscription(() => {});\n      this.popupSubscriptions = new Subscription(() => {});\n      this.resolvedPromise = Promise.resolve();\n    }\n    /**\n     * The active calendar that is visible in the popup.\n     *\n     * > When the popup is closed, the property returns `null`.\n     */\n\n\n    get calendar() {\n      return this._calendar;\n    }\n\n    set calendar(calendar) {\n      this._calendar = calendar;\n      this.subscribeFocusBlur(calendar);\n    }\n    /**\n     * Gets the active state of the component.\n     * When the opened calendar is active, returns `true`.\n     */\n\n\n    get isActive() {\n      return this.calendar && this.calendar.isActive;\n    }\n    /**\n     * Gets or sets the visibility state of the component.\n     */\n\n\n    set show(show) {\n      if (this._show === show) {\n        return;\n      }\n\n      const event = new PreventableEvent();\n\n      if (show) {\n        this.open.emit(event);\n      } else {\n        this.close.emit(event);\n      }\n\n      if (event.isDefaultPrevented()) {\n        return;\n      }\n\n      this._toggle(show);\n    }\n\n    get show() {\n      return this._show;\n    }\n\n    ngOnInit() {\n      this.dateRangeService.registerPopup(this);\n    }\n\n    ngAfterViewInit() {\n      this.calendarSubscriptions.add(this.contentCalendar.changes.subscribe(changes => this.calendar = changes.first));\n      this.calendarSubscriptions.add(this.viewCalendar.changes.subscribe(changes => this.calendar = changes.first));\n\n      if (isWindowAvailable()) {\n        this.zone.runOutsideAngular(() => this.windowBlurSubscription = fromEvent(window, 'blur').subscribe(this.handleWindowBlur.bind(this)));\n      }\n    }\n\n    ngOnDestroy() {\n      this.destroyPopup();\n      this.calendarSubscriptions.unsubscribe();\n\n      if (this.activateSubscription) {\n        this.activateSubscription.unsubscribe();\n      }\n\n      if (this.blurSubscription) {\n        this.blurSubscription.unsubscribe();\n        this.focusSubscription.unsubscribe();\n      }\n\n      if (this.windowBlurSubscription) {\n        this.windowBlurSubscription.unsubscribe();\n      }\n    }\n    /**\n     *  Opens the popup component and focuses the calendar.\n     */\n\n\n    activate() {\n      if (this.show === true) {\n        return;\n      }\n\n      if (this.activateSubscription) {\n        this.activateSubscription.unsubscribe();\n      }\n\n      this.show = true;\n      this.ref.markForCheck();\n      this.zone.runOutsideAngular(() => {\n        this.activateSubscription = merge(this.contentCalendar.changes, this.viewCalendar.changes).pipe(filter(changes => changes && changes.first), map(changes => changes.first)).subscribe(calendar => setTimeout(() => calendar.focus()));\n      });\n    }\n    /**\n     *  Focuses the calendar (if available).\n     */\n\n\n    focus() {\n      if (this.calendar) {\n        this.calendar.focus();\n      }\n    }\n    /**\n     * Checks if a focused element ids placed inside the popup.\n     *\n     * @return boolean;\n     */\n\n\n    hasActiveContent() {\n      if (!isDocumentAvailable() || !this.popupRef) {\n        return false;\n      }\n\n      return this.popupRef.popupElement.contains(document.activeElement);\n    }\n    /**\n     * Toggles the visibility of the popup.\n     * If you use the `toggle` method to show or hide the popup,\n     * the `open` and `close` events do not fire.\n     *\n     * @param show The state of the popup.\n     */\n\n\n    toggle(show) {\n      this.resolvedPromise.then(() => {\n        this._toggle(show === undefined ? !this.show : show);\n      });\n    }\n    /**\n     * @hidden\n     *\n     * Closes the popup and triggers the `cancel` event.\n     */\n\n\n    cancelPopup() {\n      this.show = false;\n      this.cancel.emit();\n    }\n\n    handleWindowBlur() {\n      if (!this.show) {\n        return;\n      }\n\n      if (hasObservers(this.close)) {\n        this.zone.run(() => this.show = false);\n      } else {\n        this.show = false;\n      }\n    }\n\n    handleMouseLeave() {\n      this.dateRangeService.setRange(this.dateRangeService.selectionRange);\n    }\n\n    handleKeydown(event) {\n      const {\n        altKey,\n        keyCode\n      } = event;\n\n      if (keyCode === Keys.Escape || altKey && keyCode === Keys.ArrowUp) {\n        this.zone.run(() => this.cancelPopup());\n      }\n    }\n\n    subscribeFocusBlur(calendar) {\n      if (this.blurSubscription) {\n        this.blurSubscription.unsubscribe();\n        this.focusSubscription.unsubscribe();\n      }\n\n      if (!calendar) {\n        return;\n      }\n\n      const nativeElement = calendar.element.nativeElement;\n      this.blurSubscription = fromEvent(nativeElement, 'blur').subscribe(() => this.onBlur.emit());\n      this.focusSubscription = fromEvent(nativeElement, 'focus').subscribe(() => this.onFocus.emit());\n    }\n\n    addPopupSubscriptions(...subscriptions) {\n      if (!isPresent(this.popupSubscriptions)) {\n        this.popupSubscriptions = new Subscription();\n      }\n\n      subscriptions.map(s => this.popupSubscriptions.add(s));\n    }\n\n    get _appendTo() {\n      const appendTo = this.appendTo;\n\n      if (!appendTo || appendTo === 'root') {\n        return undefined;\n      }\n\n      return appendTo === 'component' ? this.container : appendTo;\n    }\n\n    _toggle(show) {\n      this._show = show;\n\n      if (this.popupRef) {\n        this.destroyPopup();\n      }\n\n      if (this._show) {\n        const direction = this.rtl ? 'right' : 'left';\n        this.popupRef = this.popupService.open({\n          anchor: this.anchor,\n          anchorAlign: this.anchorAlign || {\n            vertical: 'bottom',\n            horizontal: direction\n          },\n          animate: this.animate,\n          appendTo: this._appendTo,\n          collision: this.collision,\n          content: (this.contentTemplate || {}).templateRef || this.defaultTemplate,\n          margin: this.margin,\n          popupAlign: this.popupAlign || {\n            vertical: 'top',\n            horizontal: direction\n          },\n          positionMode: 'absolute'\n        });\n        const {\n          popupElement,\n          popupAnchorViewportLeave\n        } = this.popupRef;\n        popupElement.setAttribute('id', this.popupUID);\n        this.addPopupSubscriptions(this.zone.runOutsideAngular(() => fromEvent(popupElement, 'keydown').subscribe(this.handleKeydown.bind(this))), fromEvent(popupElement, 'mouseleave').subscribe(this.handleMouseLeave.bind(this)), popupAnchorViewportLeave.subscribe(() => this.cancelPopup()));\n      }\n    }\n\n    destroyPopup() {\n      if (isPresent(this.popupRef)) {\n        this.popupRef.close();\n        this.popupRef = null;\n      }\n\n      if (isPresent(this.popupSubscriptions)) {\n        this.popupSubscriptions.unsubscribe();\n      }\n    }\n\n  };\n\n  DateRangePopupComponent.ɵfac = function DateRangePopupComponent_Factory(t) {\n    return new (t || DateRangePopupComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc5.PopupService), ɵngcc0.ɵɵdirectiveInject(DateRangeService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(RTL, 8));\n  };\n\n  DateRangePopupComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: DateRangePopupComponent,\n    selectors: [[\"kendo-daterange-popup\"]],\n    contentQueries: function DateRangePopupComponent_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵcontentQuery(dirIndex, DateRangePopupTemplateDirective, 5);\n        ɵngcc0.ɵɵcontentQuery(dirIndex, MultiViewCalendarComponent, 4);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.contentTemplate = _t.first);\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.contentCalendar = _t);\n      }\n    },\n    viewQuery: function DateRangePopupComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵviewQuery(_c17, 5, ViewContainerRef);\n        ɵngcc0.ɵɵviewQuery(_c87, 5);\n        ɵngcc0.ɵɵviewQuery(MultiViewCalendarComponent, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.container = _t.first);\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.defaultTemplate = _t.first);\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.viewCalendar = _t);\n      }\n    },\n    inputs: {\n      animate: \"animate\",\n      collision: \"collision\",\n      anchor: \"anchor\",\n      anchorAlign: \"anchorAlign\",\n      appendTo: \"appendTo\",\n      popupAlign: \"popupAlign\",\n      margin: \"margin\"\n    },\n    outputs: {\n      open: \"open\",\n      close: \"close\",\n      onBlur: \"blur\",\n      onFocus: \"focus\",\n      cancel: \"cancel\"\n    },\n    exportAs: [\"kendo-daterange-popup\"],\n    decls: 4,\n    vars: 0,\n    consts: [[\"container\", \"\"], [\"defaultTemplate\", \"\"], [\"kendoDateRangeSelection\", \"\"]],\n    template: function DateRangePopupComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵelementContainer(0, null, 0);\n        ɵngcc0.ɵɵtemplate(2, DateRangePopupComponent_ng_template_2_Template, 1, 0, \"ng-template\", null, 1, ɵngcc0.ɵɵtemplateRefExtractor);\n      }\n    },\n    directives: function () {\n      return [MultiViewCalendarComponent, DateRangeSelectionDirective];\n    },\n    encapsulation: 2\n  });\n\n  __decorate([ViewChild('container', {\n    read: ViewContainerRef,\n    static: false\n  }), __metadata(\"design:type\", ViewContainerRef)], DateRangePopupComponent.prototype, \"container\", void 0);\n\n  __decorate([ViewChild('defaultTemplate', {\n    static: false\n  }), __metadata(\"design:type\", TemplateRef)], DateRangePopupComponent.prototype, \"defaultTemplate\", void 0);\n\n  __decorate([ContentChild(DateRangePopupTemplateDirective, {\n    static: false\n  }), __metadata(\"design:type\", DateRangePopupTemplateDirective)], DateRangePopupComponent.prototype, \"contentTemplate\", void 0);\n\n  __decorate([ViewChildren(MultiViewCalendarComponent), __metadata(\"design:type\", QueryList)], DateRangePopupComponent.prototype, \"viewCalendar\", void 0);\n\n  __decorate([ContentChildren(MultiViewCalendarComponent), __metadata(\"design:type\", QueryList)], DateRangePopupComponent.prototype, \"contentCalendar\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", Object)], DateRangePopupComponent.prototype, \"animate\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", ElementRef)], DateRangePopupComponent.prototype, \"anchor\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", Object)], DateRangePopupComponent.prototype, \"anchorAlign\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", Object)], DateRangePopupComponent.prototype, \"appendTo\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", Object)], DateRangePopupComponent.prototype, \"collision\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", Object)], DateRangePopupComponent.prototype, \"popupAlign\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", Object)], DateRangePopupComponent.prototype, \"margin\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], DateRangePopupComponent.prototype, \"open\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], DateRangePopupComponent.prototype, \"close\", void 0);\n\n  __decorate([Output('blur'), __metadata(\"design:type\", EventEmitter)], DateRangePopupComponent.prototype, \"onBlur\", void 0);\n\n  __decorate([Output('focus'), __metadata(\"design:type\", EventEmitter)], DateRangePopupComponent.prototype, \"onFocus\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], DateRangePopupComponent.prototype, \"cancel\", void 0);\n\n  DateRangePopupComponent = __decorate([__param(4, Optional()), __param(4, Inject(RTL)), __metadata(\"design:paramtypes\", [PopupService, DateRangeService, ChangeDetectorRef, NgZone, Boolean])], DateRangePopupComponent);\n  /**\n   * Represents the Kendo UI DateRange component for Angular.\n   *\n   * @example\n   * ```ts\n   * _@Component({\n   * selector: 'my-app',\n   * template: `\n   *  <kendo-daterange>\n   *      <kendo-dateinput kendoDateRangeStartInput [(value)]=\"dateRange.start\"></kendo-dateinput>\n   *      <kendo-dateinput kendoDateRangeEndInput [(value)]=\"dateRange.end\"></kendo-dateinput>\n   *  </kendo-daterange>\n   * `\n   * })\n   * export class AppComponent {\n   *   public dateRange: any = { start: null, end: null };\n   * }\n   * ```\n   */\n\n  return DateRangePopupComponent;\n})();\nlet DateRangeComponent = /*#__PURE__*/(() => {\n  let DateRangeComponent = class DateRangeComponent {\n    constructor() {\n      /**\n       * @hidden\n       */\n      this.showDefault = false;\n      validatePackage(packageMetadata);\n    }\n\n    get hasContentPopup() {\n      return this.contentPopup.length > 0;\n    }\n\n    ngAfterContentInit() {\n      this.showDefault = !this.hasContentPopup;\n      this.subscription = this.contentPopup.changes.subscribe(() => {\n        this.showDefault = !this.hasContentPopup;\n      });\n    }\n\n    ngOnDestroy() {\n      if (this.subscription) {\n        this.subscription.unsubscribe();\n      }\n    }\n\n  };\n\n  DateRangeComponent.ɵfac = function DateRangeComponent_Factory(t) {\n    return new (t || DateRangeComponent)();\n  };\n\n  DateRangeComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: DateRangeComponent,\n    selectors: [[\"kendo-daterange\"]],\n    contentQueries: function DateRangeComponent_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵcontentQuery(dirIndex, DateRangePopupComponent, 4);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.contentPopup = _t);\n      }\n    },\n    features: [ɵngcc0.ɵɵProvidersFeature([DateRangeService])],\n    ngContentSelectors: _c0,\n    decls: 2,\n    vars: 1,\n    consts: [[4, \"ngIf\"]],\n    template: function DateRangeComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵprojection(0);\n        ɵngcc0.ɵɵtemplate(1, DateRangeComponent_kendo_daterange_popup_1_Template, 1, 0, \"kendo-daterange-popup\", 0);\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngIf\", ctx.showDefault);\n      }\n    },\n    directives: [ɵngcc2.NgIf, DateRangePopupComponent],\n    encapsulation: 2\n  });\n\n  __decorate([ContentChildren(DateRangePopupComponent), __metadata(\"design:type\", QueryList)], DateRangeComponent.prototype, \"contentPopup\", void 0);\n\n  DateRangeComponent = __decorate([__metadata(\"design:paramtypes\", [])], DateRangeComponent);\n  /**\n   * @hidden\n   */\n\n  return DateRangeComponent;\n})();\n\nclass DateRangeInput {\n  constructor(activeRangeEnd, dateRangeService, input, element, renderer, zone) {\n    this.activeRangeEnd = activeRangeEnd;\n    this.dateRangeService = dateRangeService;\n    this.input = input;\n    this.element = element;\n    this.renderer = renderer;\n    this.zone = zone;\n    this.navigateCalendarOnFocus = false;\n    this.popupSubscriptions = new Subscription(() => {});\n    this.subscriptions = new Subscription(() => {});\n  }\n\n  get isActiveEnd() {\n    return this.dateRangeService.activeRangeEnd === this.activeRangeEnd;\n  }\n\n  get popupCalendarActivated() {\n    const popup = this.dateRangeService.dateRangePopup$.value;\n    return isPresent(popup) && isPresent(popup.calendar);\n  }\n\n  init() {\n    if (this.input.value) {\n      this.dateRangeService.setRange(this.getRange(this.input.value));\n    }\n\n    [this.input.onBlur.subscribe(() => this.deactivate()), this.input.onFocus.pipe(filter(() => !this.popupCalendarActivated)).subscribe(() => this.activate()), this.input.valueUpdate.subscribe(value => this.updateRange(value, 'change')), this.dateRangeService.activeRangeEnd$.subscribe(() => {\n      if (this.navigateCalendarOnFocus) {\n        this.focusActiveDate();\n      }\n\n      this.toggleActiveClass(this.isActiveEnd);\n    }), this.dateRangeService.dateRangePopup$.subscribe(popup => this.initPopup(popup)), this.dateRangeService.range$.subscribe(range => this.updateInputValue(range)), fromEvent(this.element.nativeElement, 'click').subscribe(() => this.activate()), fromEvent(this.element.nativeElement, 'keydown').subscribe(event => this.togglePopup(event || {}))].map(s => this.subscriptions.add(s));\n  }\n\n  destroy() {\n    this.subscriptions.unsubscribe();\n    this.unsubscribePopup();\n  }\n\n  initPopup(popup) {\n    if (!popup) {\n      this.unsubscribePopup();\n      return;\n    }\n\n    if (!popup.anchor) {\n      popup.anchor = this.element.nativeElement;\n    }\n\n    [popup.cancel.subscribe(() => this.isActiveEnd && this.input.focus()), popup.onFocus.subscribe(() => this.toggleActiveClass(this.isActiveEnd)), popup.onBlur.subscribe(() => this.deactivate())].map(s => this.popupSubscriptions.add(s));\n  }\n\n  unsubscribePopup() {\n    this.popupSubscriptions.unsubscribe();\n    this.popupSubscriptions = new Subscription(() => {});\n  }\n\n  activate() {\n    this.dateRangeService.setActiveRangeEnd(this.activeRangeEnd);\n    this.dateRangeService.activatePopup();\n  }\n\n  deactivate() {\n    this.zone.runOutsideAngular(() => {\n      setTimeout(() => {\n        this.updateRange(this.input.value, 'blur');\n\n        if (this.dateRangeService.hasActiveComponent()) {\n          return;\n        }\n\n        this.toggleActiveClass(false);\n        this.zone.run(() => this.dateRangeService.deactivatePopup());\n      });\n    });\n  }\n\n  updateRange(value, correctOn) {\n    const range = this.getRange(value, correctOn);\n\n    if (range) {\n      this.focusActiveDate();\n      this.dateRangeService.setRange(range);\n    }\n  }\n\n  togglePopup({\n    altKey,\n    keyCode\n  }) {\n    if (keyCode === Keys.Escape) {\n      this.dateRangeService.cancelPopup();\n    } else if (altKey && keyCode === Keys.ArrowDown) {\n      this.dateRangeService.activatePopup();\n    }\n  }\n\n  focusActiveDate() {\n    if (this.input.value && this.isActiveEnd) {\n      this.dateRangeService.setFocusedDate(cloneDate(this.input.value));\n    }\n  }\n\n  toggleActiveClass(show) {\n    const action = show ? 'addClass' : 'removeClass';\n    const nativeElement = this.element.nativeElement;\n\n    if (nativeElement && nativeElement.querySelector) {\n      this.renderer[action](nativeElement.querySelector('.k-dateinput-wrap'), 'k-state-focused');\n    }\n  }\n\n}\n/**\n * A directive which manages the end range selection.\n *\n * > You can use the DateRangeEndInputDirective only with a DateInput component.\n */\n\n\nlet DateRangeEndInputDirective = /*#__PURE__*/(() => {\n  let DateRangeEndInputDirective = class DateRangeEndInputDirective extends DateRangeInput {\n    constructor(rangeService, dateInput, element, renderer, zone) {\n      super('end', rangeService, dateInput, element, renderer, zone);\n      this.rangeService = rangeService;\n      this.dateInput = dateInput;\n      /**\n       * Specifies the navigation behavior of the calendar when the active end is changed on input focus. When enabled,\n       * the calendar navigates to the value of the focused input. Otherwise, the calendar displays the last picked date.\n       *\n       * By default, the automatic navigation behavior on input focus is disabled.\n       *\n       * @example\n       * ```ts\n       * _@Component({\n       * selector: 'my-app',\n       * template: `\n       *  <h5>Toggle input focus to see the calendar navigating between range ends.</h5>\n       *  <kendo-daterange>\n       *      <kendo-dateinput kendoDateRangeStartInput [navigateCalendarOnFocus]=\"true\" [(value)]=\"start\"></kendo-dateinput>\n       *      <kendo-dateinput kendoDateRangeEndInput [navigateCalendarOnFocus]=\"true\" [(value)]=\"end\"></kendo-dateinput>\n       *  </kendo-daterange>\n       * `\n       * })\n       * export class AppComponent {\n       *   public start: Date = new Date(2018, 3, 10);\n       *   public end: Date = new Date(2018, 10, 20);\n       * }\n       * ```\n       */\n\n      this.navigateCalendarOnFocus = false;\n    }\n\n    ngOnInit() {\n      this.rangeService.registerEndInput(this.dateInput);\n      super.init();\n    }\n\n    ngOnDestroy() {\n      super.destroy();\n    }\n\n    getRange(value, correctOn) {\n      const {\n        min,\n        max\n      } = this.dateInput;\n\n      if (!isInRange(value, min, max)) {\n        return null;\n      }\n\n      const {\n        start\n      } = this.rangeService.selectionRange || EMPTY_SELECTIONRANGE;\n      const shouldClamp = this.autoCorrectOn === correctOn && isPresent(value) && value < start;\n      return shouldClamp ? clampRange(value) : {\n        start,\n        end: cloneDate(value)\n      };\n    }\n\n    updateInputValue(range$$1) {\n      const {\n        end\n      } = range$$1 || EMPTY_SELECTIONRANGE;\n      const {\n        min,\n        max\n      } = this.dateInput;\n\n      if (isEqual(this.dateInput.value, end) || !isInRange(end, min, max)) {\n        return;\n      }\n\n      this.dateInput.writeValue(cloneDate(end));\n      this.dateInput.notify();\n    }\n\n  };\n\n  DateRangeEndInputDirective.ɵfac = function DateRangeEndInputDirective_Factory(t) {\n    return new (t || DateRangeEndInputDirective)(ɵngcc0.ɵɵdirectiveInject(DateRangeService), ɵngcc0.ɵɵdirectiveInject(DateInputComponent), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone));\n  };\n\n  DateRangeEndInputDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: DateRangeEndInputDirective,\n    selectors: [[\"\", \"kendoDateRangeEndInput\", \"\"]],\n    inputs: {\n      navigateCalendarOnFocus: \"navigateCalendarOnFocus\",\n      autoCorrectOn: \"autoCorrectOn\"\n    },\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature]\n  });\n\n  __decorate([Input(), __metadata(\"design:type\", String)], DateRangeEndInputDirective.prototype, \"autoCorrectOn\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", Boolean)], DateRangeEndInputDirective.prototype, \"navigateCalendarOnFocus\", void 0);\n\n  DateRangeEndInputDirective = __decorate([__metadata(\"design:paramtypes\", [DateRangeService, DateInputComponent, ElementRef, Renderer2, NgZone])], DateRangeEndInputDirective);\n  /**\n   * A directive which manages the start selection range.\n   *\n   * > You can use the DateRangeStartInputDirective only with a DateInput component.\n   */\n\n  return DateRangeEndInputDirective;\n})();\nlet DateRangeStartInputDirective = /*#__PURE__*/(() => {\n  let DateRangeStartInputDirective = class DateRangeStartInputDirective extends DateRangeInput {\n    constructor(rangeService, dateInput, element, renderer, zone) {\n      super('start', rangeService, dateInput, element, renderer, zone);\n      this.rangeService = rangeService;\n      this.dateInput = dateInput;\n      /**\n       * Specifies the navigation behavior of the calendar when the active end is changed on input focus.\n       * When enabled, the calendar navigates to the value of the focused input. Otherwise, the calendar\n       * displays the last picked date.\n       *\n       * By default, the automatic navigation behavior on input focus is disabled.\n       *\n       * @example\n       * ```ts\n       * _@Component({\n       * selector: 'my-app',\n       * template: `\n       *  <h5>Toggle input focus to see the calendar navigating between range ends.</h5>\n       *  <kendo-daterange>\n       *      <kendo-dateinput kendoDateRangeStartInput [navigateCalendarOnFocus]=\"true\" [(value)]=\"start\"></kendo-dateinput>\n       *      <kendo-dateinput kendoDateRangeEndInput [navigateCalendarOnFocus]=\"true\" [(value)]=\"end\"></kendo-dateinput>\n       *  </kendo-daterange>\n       * `\n       * })\n       * export class AppComponent {\n       *   public start: Date = new Date(2018, 3, 10);\n       *   public end: Date = new Date(2018, 10, 20);\n       * }\n       * ```\n       */\n\n      this.navigateCalendarOnFocus = false;\n    }\n\n    ngOnInit() {\n      this.rangeService.registerStartInput(this.dateInput);\n      super.init();\n    }\n\n    ngOnDestroy() {\n      super.destroy();\n    }\n\n    getRange(value, correctOn) {\n      const {\n        min,\n        max\n      } = this.dateInput;\n\n      if (!isInRange(value, min, max)) {\n        return null;\n      }\n\n      const {\n        end\n      } = this.rangeService.selectionRange || EMPTY_SELECTIONRANGE;\n      const shouldClamp = this.autoCorrectOn === correctOn && end && value > end;\n      return shouldClamp ? clampRange(value) : {\n        start: cloneDate(value),\n        end\n      };\n    }\n\n    updateInputValue(range$$1) {\n      const {\n        start\n      } = range$$1 || EMPTY_SELECTIONRANGE;\n      const {\n        min,\n        max\n      } = this.dateInput;\n\n      if (isEqual(this.dateInput.value, start) || !isInRange(start, min, max)) {\n        return;\n      }\n\n      this.dateInput.writeValue(cloneDate(start));\n      this.dateInput.notify();\n    }\n\n  };\n\n  DateRangeStartInputDirective.ɵfac = function DateRangeStartInputDirective_Factory(t) {\n    return new (t || DateRangeStartInputDirective)(ɵngcc0.ɵɵdirectiveInject(DateRangeService), ɵngcc0.ɵɵdirectiveInject(DateInputComponent), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone));\n  };\n\n  DateRangeStartInputDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: DateRangeStartInputDirective,\n    selectors: [[\"\", \"kendoDateRangeStartInput\", \"\"]],\n    inputs: {\n      navigateCalendarOnFocus: \"navigateCalendarOnFocus\",\n      autoCorrectOn: \"autoCorrectOn\"\n    },\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature]\n  });\n\n  __decorate([Input(), __metadata(\"design:type\", String)], DateRangeStartInputDirective.prototype, \"autoCorrectOn\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", Boolean)], DateRangeStartInputDirective.prototype, \"navigateCalendarOnFocus\", void 0);\n\n  DateRangeStartInputDirective = __decorate([__metadata(\"design:paramtypes\", [DateRangeService, DateInputComponent, ElementRef, Renderer2, NgZone])], DateRangeStartInputDirective);\n  /**\n   * A directive which manages the MultiViewCalendar range selection.\n   */\n\n  return DateRangeStartInputDirective;\n})();\nlet DateRangeSelectionDirective = /*#__PURE__*/(() => {\n  let DateRangeSelectionDirective = class DateRangeSelectionDirective {\n    constructor(calendar, cdr, element, renderer, dateRangeService) {\n      this.calendar = calendar;\n      this.cdr = cdr;\n      this.element = element;\n      this.dateRangeService = dateRangeService;\n      /**\n       * Specifies the auto-correction behavior. If the start date is greater than the end date,\n       * the directive fixes the date range to a single date either on input change or on blur\n       * ([see example]({% slug autocorrect_daterange %}#toc-configuring-the-calendar-selection-directive)).\n       *\n       * By default, the auto-correction is triggered on change.\n       * To disable this behavior, set the `autoCorrectOn` property to `none`.\n       */\n\n      this.autoCorrectOn = 'change';\n      /**\n       * Fires when the active range end is changed. For more information, refer to\n       * the section on [events]({% slug overview_multiviewcalendar %}#toc-events).\n       */\n\n      this.activeRangeEndChange = new EventEmitter();\n      /**\n       * Fires when the selection range is changed. For more information, refer to\n       * the section on [events]({% slug overview_multiviewcalendar %}#toc-events).\n       */\n\n      this.selectionRangeChange = new EventEmitter();\n      this.calendarSubscriptions = new Subscription(() => {});\n      this.dateRangeService = this.dateRangeService || new DateRangeService();\n      renderer.setAttribute(element.nativeElement, 'aria-multiselectable', 'true');\n    }\n    /**\n     * Gets or sets the selection range of the calendar. When a new range is set,\n     * the connected DateRangeService notifies all related parties.\n     */\n\n\n    get selectionRange() {\n      return this.calendar ? this.calendar.selectionRange : null;\n    }\n\n    set selectionRange(range$$1) {\n      if (!this.isEqualCalendarRange(range$$1)) {\n        this.setSelectionRange(range$$1);\n      }\n\n      if (!isEqualRange(this.dateRangeService.selectionRange, range$$1)) {\n        this.dateRangeService.setRange(range$$1);\n      }\n\n      this.updateFocusedDate(range$$1);\n    }\n    /**\n     * Gets or sets the active end of the selection range. This option determines which range end will be updated on\n     * user interaction. When a new active end is set, the connected DateRangeService notifies all related parties.\n     */\n\n    /**\n     * Specifies which end of the selection range will be marked as active. The active end gets modified upon user\n     * interaction. When a new active end is set, the wired DateRangeService notifies all related components. For\n     * example, the start and end DateInput components.\n     *\n     * > If the selection range is undefined, the value is ignored.\n     */\n\n\n    get activeRangeEnd() {\n      return this.calendar.activeRangeEnd;\n    }\n\n    set activeRangeEnd(activeRange) {\n      if (this.dateRangeService.activeRangeEnd === activeRange) {\n        return;\n      }\n\n      this.calendar.activeRangeEnd = activeRange;\n      this.dateRangeService.setActiveRangeEnd(activeRange);\n    }\n\n    get calendarRange() {\n      return this.selectionRange || EMPTY_SELECTIONRANGE;\n    }\n\n    ngOnInit() {\n      const calendar = this.calendar;\n      const dateRangeService = this.dateRangeService;\n      calendar.min = either(dateRangeService.min, calendar.min);\n      calendar.max = either(dateRangeService.max, calendar.max);\n      this.addSubscriptions(calendar.cellEnter.subscribe(value => this.handleHover(value)), calendar.valueChange.subscribe(value => this.handleChange(value)), dateRangeService.focusedDate$.subscribe(focusedDate => {\n        if (!isEqual(calendar.focusedDate, focusedDate)) {\n          calendar.focusedDate = focusedDate;\n        }\n      }), dateRangeService.activeRangeEnd$.subscribe(rangeEnd => {\n        if (calendar.activeRangeEnd === rangeEnd) {\n          return;\n        }\n\n        calendar.activeRangeEnd = rangeEnd;\n        this.activeRangeEndChange.emit(rangeEnd);\n        this.cdr.markForCheck();\n      }), dateRangeService.range$.subscribe(range$$1 => {\n        if (!this.isEqualCalendarRange(range$$1)) {\n          this.acceptAndEmit(range$$1);\n        }\n\n        this.updateFocusedDate(range$$1);\n      }), fromEvent(this.element.nativeElement, 'blur').subscribe(() => this.handleBlur()));\n    }\n\n    ngOnDestroy() {\n      this.calendarSubscriptions.unsubscribe();\n    }\n\n    addSubscriptions(...subscriptions) {\n      subscriptions.map(s => this.calendarSubscriptions.add(s));\n    }\n\n    isEqualCalendarRange(range$$1) {\n      return isEqualRange(this.calendar.selectionRange, range$$1);\n    }\n\n    handleBlur() {\n      const {\n        start,\n        end\n      } = this.calendarRange;\n      const autoCorrect = this.autoCorrectOn === 'blur' && start !== null && end !== null && end < start;\n\n      if (autoCorrect) {\n        this.dateRangeService.setRange(clampRange(start));\n      }\n    }\n\n    handleChange(value) {\n      const service = this.dateRangeService;\n      const autoCorrect = this.autoCorrectOn === 'change' && this.shouldAutoCorrect(value);\n      const activeEnd = this.calendar.activeRangeEnd !== 'end' ? 'end' : autoCorrect ? 'end' : 'start';\n      const range$$1 = autoCorrect ? clampRange(value) : this.updateRange(value);\n\n      if (!isEqualRange(service.selectionRange, range$$1)) {\n        this.acceptAndEmit(range$$1);\n        service.setActiveRangeEnd(activeEnd);\n        service.setRange(range$$1);\n      }\n    }\n\n    handleHover(value) {\n      if (this.hasCompleteRange()) {\n        return;\n      }\n\n      const {\n        start,\n        end\n      } = this.calendarRange;\n      const activeRangeEnd = this.calendar.activeRangeEnd;\n      const updateRange = start && activeRangeEnd === 'end' || end && activeRangeEnd === 'start';\n\n      if (updateRange) {\n        this.setSelectionRange(this.updateRange(value));\n      }\n    }\n\n    hasCompleteRange() {\n      const {\n        start,\n        end\n      } = this.dateRangeService.selectionRange || EMPTY_SELECTIONRANGE;\n      return Boolean(start) && Boolean(end);\n    }\n\n    shouldAutoCorrect(value) {\n      const {\n        end,\n        start\n      } = this.calendarRange;\n\n      if (this.calendar.activeRangeEnd !== 'end') {\n        return end !== null && value > end;\n      } else {\n        return start !== null && value < start;\n      }\n    }\n\n    updateFocusedDate(range$$1) {\n      if (!range$$1 || this.dateRangeService.focusedDate) {\n        return;\n      }\n\n      this.dateRangeService.setFocusedDate(range$$1.start || range$$1.end);\n    }\n\n    updateRange(value) {\n      const {\n        end,\n        start\n      } = this.calendarRange;\n      return this.calendar.activeRangeEnd !== 'end' ? {\n        start: value,\n        end\n      } : {\n        start,\n        end: value\n      };\n    }\n\n    setSelectionRange(range$$1) {\n      this.calendar.selectionRange = range$$1;\n      this.calendar.writeValue(null);\n    }\n\n    acceptAndEmit(range$$1) {\n      this.setSelectionRange(range$$1);\n      this.selectionRangeChange.emit(range$$1);\n    }\n\n  };\n\n  DateRangeSelectionDirective.ɵfac = function DateRangeSelectionDirective_Factory(t) {\n    return new (t || DateRangeSelectionDirective)(ɵngcc0.ɵɵdirectiveInject(MultiViewCalendarComponent), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(DateRangeService, 8));\n  };\n\n  DateRangeSelectionDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: DateRangeSelectionDirective,\n    selectors: [[\"\", \"kendoDateRangeSelection\", \"\"]],\n    inputs: {\n      autoCorrectOn: \"autoCorrectOn\",\n      selectionRange: \"selectionRange\",\n      activeRangeEnd: \"activeRangeEnd\"\n    },\n    outputs: {\n      activeRangeEndChange: \"activeRangeEndChange\",\n      selectionRangeChange: \"selectionRangeChange\"\n    }\n  });\n\n  __decorate([Input(), __metadata(\"design:type\", String)], DateRangeSelectionDirective.prototype, \"autoCorrectOn\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", Object), __metadata(\"design:paramtypes\", [Object])], DateRangeSelectionDirective.prototype, \"selectionRange\", null);\n\n  __decorate([Input(), __metadata(\"design:type\", String), __metadata(\"design:paramtypes\", [String])], DateRangeSelectionDirective.prototype, \"activeRangeEnd\", null);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], DateRangeSelectionDirective.prototype, \"activeRangeEndChange\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], DateRangeSelectionDirective.prototype, \"selectionRangeChange\", void 0);\n\n  DateRangeSelectionDirective = __decorate([__param(4, Optional()), __metadata(\"design:paramtypes\", [MultiViewCalendarComponent, ChangeDetectorRef, ElementRef, Renderer2, DateRangeService])], DateRangeSelectionDirective);\n  /* tslint:disable:directive-class-suffix directive-selector */\n\n  /**\n   * @hidden\n   */\n\n  return DateRangeSelectionDirective;\n})();\n\nclass KForOfContext {\n  constructor($implicit, kForOf, index, count) {\n    this.$implicit = $implicit;\n    this.kForOf = kForOf;\n    this.index = index;\n    this.count = count;\n  }\n\n  get first() {\n    return this.index === 0;\n  }\n\n  get last() {\n    return this.index === this.count - 1;\n  }\n\n  get even() {\n    return this.index % 2 === 0;\n  }\n\n  get odd() {\n    return !this.even;\n  }\n\n}\n/**\n * @hidden\n */\n\n\nlet KForOf = /*#__PURE__*/(() => {\n  let KForOf = class KForOf {\n    constructor(_viewContainer, _template, _differs) {\n      this._viewContainer = _viewContainer;\n      this._template = _template;\n      this._differs = _differs;\n      this._differ = null;\n    }\n\n    set kForTemplate(value) {\n      if (value) {\n        this._template = value;\n      }\n    }\n\n    ngOnChanges(changes) {\n      if ('kForOf' in changes) {\n        const value = changes.kForOf.currentValue;\n\n        if (this._differ || !value) {\n          return;\n        }\n\n        try {\n          this._differ = this._differs.find(value).create(this.kForTrackBy);\n        } catch (e) {\n          throw new Error(`Cannot find a differ supporting object '${value}' of type '${getTypeNameForDebugging(value)}'.`);\n        }\n      }\n    }\n\n    ngDoCheck() {\n      if (this._differ) {\n        const changes = this._differ.diff(this.kForOf);\n\n        if (changes) {\n          this._applyChanges(changes);\n        }\n      }\n    }\n\n    _applyChanges(changes) {\n      if (!isDocumentAvailable()) {\n        return;\n      }\n\n      const viewContainerLength = this._viewContainer.length;\n      const dataLength = this.kForOf.length;\n      const tuples = {};\n      changes.forEachOperation((record, _, currentIndex) => {\n        if (currentIndex !== null) {\n          tuples[currentIndex] = record.item;\n        }\n      });\n\n      for (let i = viewContainerLength; i < dataLength; i++) {\n        this._viewContainer.createEmbeddedView(this._template, new KForOfContext(null, this.kForOf, -1, -1), i);\n      }\n\n      for (let i = this._viewContainer.length; i > dataLength; i--) {\n        this._viewContainer.remove(i - 1);\n      }\n\n      for (let i = 0; i < this._viewContainer.length; i++) {\n        const view = this._viewContainer.get(i);\n\n        view.context.index = i;\n        view.context.count = length;\n        view.context.$implicit = tuples[i] || null;\n      }\n    }\n\n  };\n\n  KForOf.ɵfac = function KForOf_Factory(t) {\n    return new (t || KForOf)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.IterableDiffers));\n  };\n\n  KForOf.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: KForOf,\n    selectors: [[\"\", \"kFor\", \"\", \"kForOf\", \"\"]],\n    inputs: {\n      kForTemplate: \"kForTemplate\",\n      kForOf: \"kForOf\",\n      kForTrackBy: \"kForTrackBy\"\n    },\n    features: [ɵngcc0.ɵɵNgOnChangesFeature]\n  });\n\n  __decorate([Input(), __metadata(\"design:type\", Object)], KForOf.prototype, \"kForOf\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", Function)], KForOf.prototype, \"kForTrackBy\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", TemplateRef), __metadata(\"design:paramtypes\", [TemplateRef])], KForOf.prototype, \"kForTemplate\", null);\n\n  KForOf = __decorate([__metadata(\"design:paramtypes\", [ViewContainerRef, TemplateRef, IterableDiffers])], KForOf);\n  /**\n   * @hidden\n   */\n\n  return KForOf;\n})();\n\nfunction getTypeNameForDebugging(type) {\n  return type.name || typeof type;\n}\n/**\n * @hidden\n */\n\n\nlet HeaderComponent = /*#__PURE__*/(() => {\n  let HeaderComponent = class HeaderComponent {\n    constructor(bus, cdr, localization, intl, disabledDatesService) {\n      this.bus = bus;\n      this.cdr = cdr;\n      this.localization = localization;\n      this.intl = intl;\n      this.disabledDatesService = disabledDatesService;\n      this.navigate = true;\n      this.todayAvailable = true;\n      this.min = new Date(MIN_DATE);\n      this.max = new Date(MAX_DATE);\n      this.rangeLength = 1;\n      this.isPrevDisabled = true;\n      this.isNextDisabled = true;\n      this.showNavigationButtons = false;\n      this.todayButtonClick = new EventEmitter();\n      this.prevButtonClick = new EventEmitter();\n      this.nextButtonClick = new EventEmitter();\n      this.getComponentClass = true;\n      this.subscriptions = new Subscription();\n    }\n\n    ngOnInit() {\n      this.subscriptions.add(this.intl.changes.subscribe(this.intlChange.bind(this))).add(this.localization.changes.subscribe(this.l10nChange.bind(this))).add(this.disabledDatesService.changes.subscribe(this.setTodayAvailability.bind(this)));\n    }\n\n    ngOnChanges(_) {\n      const service = this.bus.service(this.activeView);\n\n      if (!service) {\n        return;\n      }\n\n      this.activeViewValue = CalendarViewEnum[this.activeView];\n      this.todayMessage = this.localization.get('today');\n      this.setTodayAvailability();\n      this.navigate = this.bus.canMoveUp(this.activeView);\n      this.title = this.getTitle();\n    }\n\n    ngOnDestroy() {\n      this.subscriptions.unsubscribe();\n    }\n\n    handleTodayClick() {\n      if (!this.todayAvailable) {\n        return;\n      }\n\n      this.bus.moveToBottom(this.activeView);\n      this.todayButtonClick.emit(dateInRange(getToday(), this.min, this.max));\n    }\n\n    handleNavigation() {\n      if (!this.navigate) {\n        return;\n      }\n\n      this.bus.moveUp(this.activeView);\n    }\n\n    intlChange() {\n      if (this.currentDate && this.bus.service(this.activeView)) {\n        this.title = this.getTitle();\n        this.cdr.markForCheck();\n      }\n    }\n\n    l10nChange() {\n      this.prevButtonTitle = this.localization.get('prevButtonTitle');\n      this.nextButtonTitle = this.localization.get('nextButtonTitle');\n      this.todayMessage = this.localization.get('today');\n      this.cdr.markForCheck();\n    }\n\n    getTitle() {\n      if (!this.currentDate) {\n        return '';\n      }\n\n      const service = this.bus.service(this.activeView);\n      const take = this.rangeLength - 1;\n      const title = service.title(this.currentDate);\n      const nextDate = service.addToDate(this.currentDate, take);\n\n      if (take < 1 || !service.isInRange(nextDate, this.min, this.max)) {\n        return title;\n      }\n\n      return `${title} - ${service.title(nextDate)}`;\n    }\n\n    setTodayAvailability() {\n      const today = getToday();\n      const isTodayInRange = isInRange(today, getDate(this.min), getDate(this.max));\n      const isDisabled = this.disabledDatesService.isDateDisabled(today);\n      this.todayAvailable = isTodayInRange && !isDisabled;\n      this.cdr.markForCheck();\n    }\n\n  };\n\n  HeaderComponent.ɵfac = function HeaderComponent_Factory(t) {\n    return new (t || HeaderComponent)(ɵngcc0.ɵɵdirectiveInject(BusViewService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc4.LocalizationService), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.IntlService), ɵngcc0.ɵɵdirectiveInject(DisabledDatesService));\n  };\n\n  HeaderComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: HeaderComponent,\n    selectors: [[\"kendo-calendar-header\"]],\n    hostVars: 4,\n    hostBindings: function HeaderComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        ɵngcc0.ɵɵclassProp(\"k-calendar-header\", ctx.getComponentClass)(\"k-hstack\", ctx.getComponentClass);\n      }\n    },\n    inputs: {\n      min: \"min\",\n      max: \"max\",\n      rangeLength: \"rangeLength\",\n      isPrevDisabled: \"isPrevDisabled\",\n      isNextDisabled: \"isNextDisabled\",\n      showNavigationButtons: \"showNavigationButtons\",\n      activeView: \"activeView\",\n      currentDate: \"currentDate\",\n      templateRef: \"templateRef\"\n    },\n    outputs: {\n      todayButtonClick: \"todayButtonClick\",\n      prevButtonClick: \"prevButtonClick\",\n      nextButtonClick: \"nextButtonClick\"\n    },\n    features: [ɵngcc0.ɵɵNgOnChangesFeature],\n    decls: 9,\n    vars: 23,\n    consts: [[1, \"k-button\", \"k-flat\", \"k-title\", \"k-calendar-title\", 3, \"kendoEventsOutsideAngular\", \"scope\"], [3, \"ngIf\"], [3, \"ngIf\", \"ngTemplateOutlet\", \"ngTemplateOutletContext\"], [1, \"k-spacer\"], [1, \"k-calendar-nav\", \"k-hstack\"], [\"class\", \"k-button k-flat k-icon-button k-prev-view\", \"type\", \"button\", 3, \"disabled\", \"title\", \"click\", 4, \"ngIf\"], [1, \"k-today\", \"k-nav-today\", 3, \"kendoEventsOutsideAngular\", \"scope\"], [\"class\", \"k-button k-flat k-icon-button k-next-view\", \"type\", \"button\", 3, \"disabled\", \"title\", \"click\", 4, \"ngIf\"], [\"type\", \"button\", 1, \"k-button\", \"k-flat\", \"k-icon-button\", \"k-prev-view\", 3, \"disabled\", \"title\", \"click\"], [1, \"k-icon\", \"k-i-arrow-60-left\"], [\"type\", \"button\", 1, \"k-button\", \"k-flat\", \"k-icon-button\", \"k-next-view\", 3, \"disabled\", \"title\", \"click\"], [1, \"k-icon\", \"k-i-arrow-60-right\"]],\n    template: function HeaderComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵelementStart(0, \"span\", 0);\n        ɵngcc0.ɵɵtemplate(1, HeaderComponent_ng_template_1_Template, 1, 1, \"ng-template\", 1);\n        ɵngcc0.ɵɵtemplate(2, HeaderComponent_ng_template_2_Template, 0, 0, \"ng-template\", 2);\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵelement(3, \"span\", 3);\n        ɵngcc0.ɵɵelementStart(4, \"span\", 4);\n        ɵngcc0.ɵɵtemplate(5, HeaderComponent_button_5_Template, 2, 3, \"button\", 5);\n        ɵngcc0.ɵɵelementStart(6, \"span\", 6);\n        ɵngcc0.ɵɵtext(7);\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵtemplate(8, HeaderComponent_button_8_Template, 2, 3, \"button\", 7);\n        ɵngcc0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵclassProp(\"k-state-disabled\", !ctx.navigate);\n        ɵngcc0.ɵɵproperty(\"kendoEventsOutsideAngular\", ɵngcc0.ɵɵpureFunction1(15, _c3, ctx.handleNavigation))(\"scope\", ctx);\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngIf\", !ctx.templateRef);\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngIf\", ctx.templateRef)(\"ngTemplateOutlet\", ctx.templateRef)(\"ngTemplateOutletContext\", ɵngcc0.ɵɵpureFunction3(17, _c2, ctx.title, ctx.activeViewValue, ctx.currentDate));\n        ɵngcc0.ɵɵadvance(3);\n        ɵngcc0.ɵɵproperty(\"ngIf\", ctx.showNavigationButtons);\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵclassProp(\"k-state-disabled\", !ctx.todayAvailable);\n        ɵngcc0.ɵɵproperty(\"kendoEventsOutsideAngular\", ɵngcc0.ɵɵpureFunction1(21, _c3, ctx.handleTodayClick))(\"scope\", ctx);\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵtextInterpolate1(\" \", ctx.todayMessage, \" \");\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngIf\", ctx.showNavigationButtons);\n      }\n    },\n    directives: [ɵngcc3.EventsOutsideAngularDirective, ɵngcc2.NgIf, ɵngcc2.NgTemplateOutlet],\n    encapsulation: 2\n  });\n\n  __decorate([Input(), __metadata(\"design:type\", Number)], HeaderComponent.prototype, \"activeView\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", Date)], HeaderComponent.prototype, \"currentDate\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", Date)], HeaderComponent.prototype, \"min\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", Date)], HeaderComponent.prototype, \"max\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", Number)], HeaderComponent.prototype, \"rangeLength\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", TemplateRef)], HeaderComponent.prototype, \"templateRef\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", Boolean)], HeaderComponent.prototype, \"isPrevDisabled\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", Boolean)], HeaderComponent.prototype, \"isNextDisabled\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", Boolean)], HeaderComponent.prototype, \"showNavigationButtons\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], HeaderComponent.prototype, \"todayButtonClick\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], HeaderComponent.prototype, \"prevButtonClick\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], HeaderComponent.prototype, \"nextButtonClick\", void 0);\n\n  __decorate([HostBinding(\"class.k-calendar-header\"), HostBinding(\"class.k-hstack\"), __metadata(\"design:type\", Boolean)], HeaderComponent.prototype, \"getComponentClass\", void 0);\n\n  HeaderComponent = __decorate([__metadata(\"design:paramtypes\", [BusViewService, ChangeDetectorRef, LocalizationService, IntlService, DisabledDatesService])], HeaderComponent);\n  /**\n   * @hidden\n   */\n\n  return HeaderComponent;\n})();\nlet ViewComponent = /*#__PURE__*/(() => {\n  let ViewComponent = class ViewComponent {\n    constructor(bus, intl, cdr, element, zone, renderer, disabledDatesService) {\n      this.bus = bus;\n      this.intl = intl;\n      this.cdr = cdr;\n      this.element = element;\n      this.zone = zone;\n      this.renderer = renderer;\n      this.disabledDatesService = disabledDatesService;\n      this.direction = 'vertical';\n      this.isActive = true;\n      this.selectedDates = [];\n      this.cellClick = new EventEmitter();\n      this.weekNumberCellClick = new EventEmitter();\n      this.cellEnter = new EventEmitter();\n      this.cellLeave = new EventEmitter();\n      this.colSpan = 0;\n      this.subscriptions = new Subscription();\n      this.domEvents = [];\n      this.subscriptions.add(this.intl.changes.subscribe(this.intlChange.bind(this)));\n      this.subscriptions.add(this.disabledDatesService.changes.subscribe(this.disabledDatesChange.bind(this)));\n    }\n\n    get weekNumber() {\n      return this.showWeekNumbers && this.activeView === CalendarViewEnum.month;\n    }\n\n    set weekNumber(showWeekNumbers) {\n      this.showWeekNumbers = showWeekNumbers;\n    }\n\n    ngOnInit() {\n      if (this.element) {\n        this.zone.runOutsideAngular(() => {\n          this.bindEvents();\n        });\n      }\n    }\n\n    ngOnChanges(changes) {\n      this.service = this.bus.service(this.activeView);\n\n      if (!this.service) {\n        return;\n      }\n\n      this.colSpan = this.service.rowLength({\n        prependCell: this.weekNumber\n      });\n      this.title = this.service.title(this.viewDate);\n      this.updateData();\n\n      if (changes.activeView) {\n        this.currentCellIndex = null;\n      }\n    }\n\n    ngOnDestroy() {\n      this.subscriptions.unsubscribe();\n      this.domEvents.forEach(unsubscribeCallback => unsubscribeCallback());\n    }\n\n    isHorizontal() {\n      return this.direction === 'horizontal';\n    }\n\n    isMonthView() {\n      return this.activeView === CalendarViewEnum.month;\n    }\n\n    shouldRenderCellContent(cellCtx) {\n      return isPresent(cellCtx) && !(!this.isHorizontal() && cellCtx.isOtherMonth);\n    }\n\n    firstDate(rowCtx) {\n      const ctx = this.firstWeekDateContext(rowCtx);\n      return ctx ? ctx.value : null;\n    }\n\n    getWeekNumber(date) {\n      if (!this.weekNumber) {\n        return null;\n      }\n\n      return weekInYear(date, this.intl.firstDay());\n    }\n\n    getWeekNumberContext(rowCtx) {\n      const ctx = this.firstWeekDateContext(rowCtx);\n\n      if (!this.weekNumber || !ctx) {\n        return null;\n      }\n\n      const weekNumber = weekInYear(ctx.value, this.intl.firstDay()).toString();\n      return {\n        formattedValue: weekNumber,\n        id: null,\n        isFocused: false,\n        isSelected: false,\n        isWeekend: false,\n        title: weekNumber,\n        value: cloneDate(ctx.value)\n      };\n    }\n\n    getStyles(context) {\n      const {\n        isRangeEnd,\n        isRangeStart\n      } = context;\n      const isEndActive = this.activeRangeEnd === 'end' && isRangeEnd;\n      const isStartActive = this.activeRangeEnd === 'start' && isRangeStart;\n      return stringifyClassObject({\n        'k-range-end': !context.isOtherMonth && isRangeEnd,\n        'k-range-mid': !context.isOtherMonth && context.isRangeMid,\n        'k-range-split-end': !context.isOtherMonth && context.isRangeSplitEnd,\n        'k-range-split-start': !context.isOtherMonth && context.isRangeSplitStart,\n        'k-range-start': !context.isOtherMonth && isRangeStart,\n        'k-state-active': isStartActive || isEndActive,\n        'k-state-focused': !context.isOtherMonth && this.isActive && context.isFocused,\n        'k-state-selected': !context.isOtherMonth && (context.isSelected || isRangeStart || isRangeEnd),\n        'k-today': !context.isOtherMonth && context.isToday,\n        'k-weekend': context.isWeekend,\n        'k-state-disabled': context.isDisabled,\n        'k-other-month': context.isOtherMonth\n      });\n    }\n\n    tableCellIndex(rowIndex, cellIndex) {\n      return `${rowIndex}:${cellIndex}`;\n    }\n\n    handleWeekNumberClick(week) {\n      const availableDates = week.map(item => item.value).filter(date => !this.disabledDatesService.isDateDisabled(date));\n      this.weekNumberCellClick.emit(availableDates);\n    }\n\n    firstWeekDateContext(rowCtx) {\n      if (!this.weekNumber) {\n        return null;\n      }\n\n      let idx = 0;\n      let ctx = this.shouldRenderCellContent(rowCtx[idx]) ? rowCtx[idx] : null;\n\n      while (!ctx && idx < rowCtx.length) {\n        const cellCtx = rowCtx[++idx];\n        ctx = this.shouldRenderCellContent(cellCtx) ? cellCtx : null;\n      }\n\n      return ctx;\n    }\n\n    updateData() {\n      const time = last(this.selectedDates) || getToday();\n      const viewDate = setTime(this.viewDate, time);\n      this.data = this.service.data({\n        cellUID: this.cellUID,\n        focusedDate: this.focusedDate,\n        isActiveView: !this.bus.canMoveDown(this.activeView),\n        max: this.max,\n        min: this.min,\n        selectedDates: this.selectedDates,\n        selectionRange: this.selectionRange,\n        viewDate: viewDate,\n        isDateDisabled: this.disabledDatesService.isDateDisabled,\n        direction: this.direction\n      });\n    }\n\n    intlChange() {\n      this.updateData();\n      this.cdr.markForCheck();\n    }\n\n    disabledDatesChange() {\n      this.updateData();\n      this.cdr.markForCheck();\n    }\n\n    bindEvents() {\n      const element = this.element.nativeElement;\n      this.domEvents.push(this.renderer.listen(element, 'mouseover', this.cellMouseoverHandler.bind(this)), this.renderer.listen(element, 'mouseleave', this.mouseLeaveHandler.bind(this)), this.renderer.listen(element, 'click', this.clickHandler.bind(this)));\n    }\n\n    clickHandler(args) {\n      const cell = this.closestCell(args);\n\n      if (!cell) {\n        return;\n      }\n\n      const index = cell.getAttribute('data-cell-index');\n      const cellContext = this.cellByIndex(index);\n\n      if (!cellContext.isDisabled) {\n        const {\n          ctrlKey,\n          metaKey,\n          shiftKey\n        } = args;\n        this.cellClick.emit({\n          date: cellContext.value,\n          modifiers: {\n            ctrlKey,\n            metaKey,\n            shiftKey\n          }\n        });\n      }\n    }\n\n    mouseLeaveHandler() {\n      if (this.currentCellIndex) {\n        this.emitCellLeave();\n      }\n    }\n\n    cellMouseoverHandler(args) {\n      const cell = this.closestCell(args);\n\n      if (cell) {\n        const index = cell.getAttribute('data-cell-index');\n\n        if (this.currentCellIndex && this.currentCellIndex !== index) {\n          this.emitCellLeave();\n        }\n\n        const value = this.cellByIndex(index).value;\n        this.cellEnter.emit(value);\n        this.currentCellIndex = index;\n      } else if (this.currentCellIndex) {\n        this.emitCellLeave();\n      }\n    }\n\n    closestCell(eventArgs) {\n      return closestInScope(eventArgs.target, node => node.hasAttribute('data-cell-index'), this.element.nativeElement);\n    }\n\n    emitCellLeave() {\n      const item = this.cellByIndex(this.currentCellIndex);\n\n      if (item) {\n        this.cellLeave.emit(item.value);\n      }\n\n      this.currentCellIndex = null;\n    }\n\n    cellByIndex(index) {\n      const [rowIndex, cellIndex] = index.split(':');\n      return this.data[rowIndex][cellIndex];\n    }\n\n  };\n\n  ViewComponent.ɵfac = function ViewComponent_Factory(t) {\n    return new (t || ViewComponent)(ɵngcc0.ɵɵdirectiveInject(BusViewService), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.IntlService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(DisabledDatesService));\n  };\n\n  ViewComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: ViewComponent,\n    selectors: [[\"\", \"kendoCalendarView\", \"\"]],\n    inputs: {\n      direction: \"direction\",\n      isActive: \"isActive\",\n      selectedDates: \"selectedDates\",\n      weekNumber: \"weekNumber\",\n      activeView: \"activeView\",\n      cellUID: \"cellUID\",\n      focusedDate: \"focusedDate\",\n      viewDate: \"viewDate\",\n      activeRangeEnd: \"activeRangeEnd\",\n      selectionRange: \"selectionRange\",\n      min: \"min\",\n      max: \"max\",\n      viewIndex: \"viewIndex\",\n      templateRef: \"templateRef\",\n      weekNumberTemplateRef: \"weekNumberTemplateRef\"\n    },\n    outputs: {\n      cellClick: \"cellClick\",\n      weekNumberCellClick: \"weekNumberCellClick\",\n      cellEnter: \"cellEnter\",\n      cellLeave: \"cellLeave\"\n    },\n    features: [ɵngcc0.ɵɵNgOnChangesFeature],\n    attrs: _c88,\n    decls: 4,\n    vars: 2,\n    consts: [[\"emptyCell\", \"\"], [\"class\", \"k-calendar-tr\", \"role\", \"row\", 4, \"ngIf\"], [\"class\", \"k-calendar-tr\", \"role\", \"row\", 4, \"kFor\", \"kForOf\"], [1, \"k-empty\", \"k-calendar-td\"], [\"role\", \"row\", 1, \"k-calendar-tr\"], [\"scope\", \"col\", 1, \"k-calendar-caption\", 3, \"colSpan\"], [3, \"ngIf\"], [4, \"kFor\", \"kForOf\"], [\"class\", \"k-alt k-calendar-td\", 3, \"kendoEventsOutsideAngular\", 4, \"ngIf\", \"ngIfElse\"], [1, \"k-alt\", \"k-calendar-td\", 3, \"kendoEventsOutsideAngular\"], [3, \"ngIf\", \"ngTemplateOutlet\", \"ngTemplateOutletContext\"], [\"class\", \"k-calendar-td\", \"role\", \"gridcell\", 3, \"ngClass\", \"title\", 4, \"ngIf\", \"ngIfElse\"], [\"role\", \"gridcell\", 1, \"k-calendar-td\", 3, \"ngClass\", \"title\"], [1, \"k-link\"], [4, \"ngIf\"], [3, \"ngTemplateOutlet\", \"ngTemplateOutletContext\"]],\n    template: function ViewComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵtemplate(0, ViewComponent_ng_template_0_Template, 2, 0, \"ng-template\", null, 0, ɵngcc0.ɵɵtemplateRefExtractor);\n        ɵngcc0.ɵɵtemplate(2, ViewComponent_tr_2_Template, 3, 2, \"tr\", 1);\n        ɵngcc0.ɵɵtemplate(3, ViewComponent_tr_3_Template, 3, 2, \"tr\", 2);\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵadvance(2);\n        ɵngcc0.ɵɵproperty(\"ngIf\", !ctx.isHorizontal());\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"kForOf\", ctx.data);\n      }\n    },\n    directives: [ɵngcc2.NgIf, KForOf, ɵngcc3.EventsOutsideAngularDirective, ɵngcc2.NgTemplateOutlet, ɵngcc2.NgClass],\n    encapsulation: 2\n  });\n\n  __decorate([Input(), __metadata(\"design:type\", String)], ViewComponent.prototype, \"direction\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", Boolean)], ViewComponent.prototype, \"isActive\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", Number)], ViewComponent.prototype, \"activeView\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", String)], ViewComponent.prototype, \"cellUID\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", Date)], ViewComponent.prototype, \"focusedDate\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", Date)], ViewComponent.prototype, \"viewDate\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", String)], ViewComponent.prototype, \"activeRangeEnd\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", Object)], ViewComponent.prototype, \"selectionRange\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", Date)], ViewComponent.prototype, \"min\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", Date)], ViewComponent.prototype, \"max\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", Array)], ViewComponent.prototype, \"selectedDates\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", Boolean), __metadata(\"design:paramtypes\", [Boolean])], ViewComponent.prototype, \"weekNumber\", null);\n\n  __decorate([Input(), __metadata(\"design:type\", Number)], ViewComponent.prototype, \"viewIndex\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", TemplateRef)], ViewComponent.prototype, \"templateRef\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", TemplateRef)], ViewComponent.prototype, \"weekNumberTemplateRef\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], ViewComponent.prototype, \"cellClick\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], ViewComponent.prototype, \"weekNumberCellClick\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], ViewComponent.prototype, \"cellEnter\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], ViewComponent.prototype, \"cellLeave\", void 0);\n\n  ViewComponent = __decorate([__metadata(\"design:paramtypes\", [BusViewService, IntlService, ChangeDetectorRef, ElementRef, NgZone, Renderer2, DisabledDatesService])], ViewComponent);\n  /**\n   * @hidden\n   *\n   * The exported package module.\n   *\n   * The package exports:\n   * - `HeaderComponent`&mdash;The component that renders the UI for vertical navigation.\n   * - `ViewComponent`&mdash;The component that renders the active Calendar view.\n   */\n\n  return ViewComponent;\n})();\nlet CalendarCommonModule = /*#__PURE__*/(() => {\n  let CalendarCommonModule = class CalendarCommonModule {};\n\n  CalendarCommonModule.ɵfac = function CalendarCommonModule_Factory(t) {\n    return new (t || CalendarCommonModule)();\n  };\n\n  CalendarCommonModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: CalendarCommonModule\n  });\n  CalendarCommonModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    imports: [[CommonModule, EventsModule]]\n  });\n  /**\n   * @hidden\n   *\n   * The exported package module.\n   *\n   * The package exports:\n   * - `CellTemplateDirective`&mdash;The month cell template directive.\n   * - `MonthCellTemplateDirective`&mdash;The month cell template directive.\n   * - `YearCellTemplateDirective`&mdash;The year cell template directive.\n   * - `DecadeCellTemplateDirective`&mdash;The decade cell template directive.\n   * - `CenturyCellTemplateDirective`&mdash;The century cell template directive.\n   * - `WeekNumberCellTemplateDirective`&mdash;The month week number cell template directive.\n   * - `HeaderTitleTemplateDirective`&mdash;The header title template directive.\n   * - `NavigationItemTemplateDirective`&mdash;The navigation item template directive.\n   */\n\n  return CalendarCommonModule;\n})();\nlet TemplatesModule = /*#__PURE__*/(() => {\n  let TemplatesModule = class TemplatesModule {};\n\n  TemplatesModule.ɵfac = function TemplatesModule_Factory(t) {\n    return new (t || TemplatesModule)();\n  };\n\n  TemplatesModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: TemplatesModule\n  });\n  TemplatesModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({});\n  /**\n   * @hidden\n   */\n\n  return TemplatesModule;\n})();\nlet Messages = /*#__PURE__*/(() => {\n  class Messages extends ComponentMessages {}\n\n  Messages.ɵfac = /*@__PURE__*/function () {\n    let ɵMessages_BaseFactory;\n    return function Messages_Factory(t) {\n      return (ɵMessages_BaseFactory || (ɵMessages_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(Messages)))(t || Messages);\n    };\n  }();\n\n  Messages.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: Messages,\n    inputs: {\n      today: \"today\",\n      prevButtonTitle: \"prevButtonTitle\",\n      nextButtonTitle: \"nextButtonTitle\"\n    },\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature]\n  });\n\n  __decorate([Input(), __metadata(\"design:type\", String)], Messages.prototype, \"today\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", String)], Messages.prototype, \"prevButtonTitle\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", String)], Messages.prototype, \"nextButtonTitle\", void 0);\n\n  return Messages;\n})();\nvar MultiViewCalendarLocalizedMessagesDirective_1;\n/**\n * @hidden\n */\n\nlet MultiViewCalendarLocalizedMessagesDirective = MultiViewCalendarLocalizedMessagesDirective_1 = class MultiViewCalendarLocalizedMessagesDirective extends Messages {\n  constructor(service) {\n    super();\n    this.service = service;\n  }\n\n};\n\nMultiViewCalendarLocalizedMessagesDirective.ɵfac = function MultiViewCalendarLocalizedMessagesDirective_Factory(t) {\n  return new (t || MultiViewCalendarLocalizedMessagesDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc4.LocalizationService));\n};\n\nMultiViewCalendarLocalizedMessagesDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n  type: MultiViewCalendarLocalizedMessagesDirective,\n  selectors: [[\"\", \"kendoMultiViewCalendarLocalizedMessages\", \"\"]],\n  features: [ɵngcc0.ɵɵProvidersFeature([{\n    provide: Messages,\n    useExisting: forwardRef(() => MultiViewCalendarLocalizedMessagesDirective_1) // tslint:disable-line:no-forward-ref\n\n  }]), ɵngcc0.ɵɵInheritDefinitionFeature]\n});\nMultiViewCalendarLocalizedMessagesDirective = MultiViewCalendarLocalizedMessagesDirective_1 = __decorate([__metadata(\"design:paramtypes\", [LocalizationService])], MultiViewCalendarLocalizedMessagesDirective);\nvar MultiViewCalendarCustomMessagesComponent_1;\n/**\n * Custom component messages override default component messages ([see example]({% slug globalization_dateinputs %}#toc-custom-messages)).\n */\n\nlet MultiViewCalendarCustomMessagesComponent = MultiViewCalendarCustomMessagesComponent_1 = class MultiViewCalendarCustomMessagesComponent extends Messages {\n  constructor(service) {\n    super();\n    this.service = service;\n  }\n\n  get override() {\n    return true;\n  }\n\n};\n\nMultiViewCalendarCustomMessagesComponent.ɵfac = function MultiViewCalendarCustomMessagesComponent_Factory(t) {\n  return new (t || MultiViewCalendarCustomMessagesComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc4.LocalizationService));\n};\n\nMultiViewCalendarCustomMessagesComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n  type: MultiViewCalendarCustomMessagesComponent,\n  selectors: [[\"kendo-multiviewcalendar-messages\"]],\n  features: [ɵngcc0.ɵɵProvidersFeature([{\n    provide: Messages,\n    useExisting: forwardRef(() => MultiViewCalendarCustomMessagesComponent_1) // tslint:disable-line:no-forward-ref\n\n  }]), ɵngcc0.ɵɵInheritDefinitionFeature],\n  decls: 0,\n  vars: 0,\n  template: function MultiViewCalendarCustomMessagesComponent_Template(rf, ctx) {},\n  encapsulation: 2\n});\nMultiViewCalendarCustomMessagesComponent = MultiViewCalendarCustomMessagesComponent_1 = __decorate([__metadata(\"design:paramtypes\", [LocalizationService])], MultiViewCalendarCustomMessagesComponent);\n/**\n * The package exports:\n * - `CellTemplateDirective`&mdash;The month cell template directive.\n * - `MonthCellTemplateDirective`&mdash;The month cell template directive.\n * - `YearCellTemplateDirective`&mdash;The year cell template directive.\n * - `DecadeCellTemplateDirective`&mdash;The decade cell template directive.\n * - `CenturyCellTemplateDirective`&mdash;The century cell template directive.\n * - `WeekNumberCellTemplateDirective`&mdash;The month week number cell template directive.\n * - `HeaderTitleTemplateDirective`&mdash;The header title template directive.\n *\n * @example\n *\n * ```ts-no-run\n * // Import the MultiViewCalendar module\n * import { MultiViewCalendarModule } from '@progress/kendo-angular-dateinputs';\n *\n * // The browser platform with a compiler\n * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n *\n * import { NgModule } from '@angular/core';\n *\n * // Import the app component\n * import { AppComponent } from './app.component';\n *\n * // Define the app module\n * _@NgModule({\n *     declarations: [AppComponent], // declare app component\n *     imports:      [BrowserModule, MultiViewCalendarModule], // import MultiViewCalendar module\n *     bootstrap:    [AppComponent]\n * })\n * export class AppModule {}\n *\n * // Compile and launch the module\n * platformBrowserDynamic().bootstrapModule(AppModule);\n */\n\nlet MultiViewCalendarModule = /*#__PURE__*/(() => {\n  let MultiViewCalendarModule = class MultiViewCalendarModule {};\n\n  MultiViewCalendarModule.ɵfac = function MultiViewCalendarModule_Factory(t) {\n    return new (t || MultiViewCalendarModule)();\n  };\n\n  MultiViewCalendarModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: MultiViewCalendarModule\n  });\n  MultiViewCalendarModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    providers: [NavigationService, CenturyViewService, DecadeViewService, MonthViewService, YearViewService, WeekNamesService],\n    imports: [[CommonModule, CalendarCommonModule, IntlModule, TemplatesModule, PopupModule], CalendarCommonModule, TemplatesModule]\n  });\n  /**\n   * @hidden\n   */\n\n  return MultiViewCalendarModule;\n})();\nlet CalendarMessages = /*#__PURE__*/(() => {\n  class CalendarMessages extends ComponentMessages {}\n\n  CalendarMessages.ɵfac = /*@__PURE__*/function () {\n    let ɵCalendarMessages_BaseFactory;\n    return function CalendarMessages_Factory(t) {\n      return (ɵCalendarMessages_BaseFactory || (ɵCalendarMessages_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(CalendarMessages)))(t || CalendarMessages);\n    };\n  }();\n\n  CalendarMessages.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: CalendarMessages,\n    inputs: {\n      today: \"today\",\n      prevButtonTitle: \"prevButtonTitle\",\n      nextButtonTitle: \"nextButtonTitle\"\n    },\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature]\n  });\n\n  __decorate([Input(), __metadata(\"design:type\", String)], CalendarMessages.prototype, \"today\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", String)], CalendarMessages.prototype, \"prevButtonTitle\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", String)], CalendarMessages.prototype, \"nextButtonTitle\", void 0);\n\n  return CalendarMessages;\n})();\nvar CalendarLocalizedMessagesDirective_1;\n/**\n * @hidden\n */\n\nlet CalendarLocalizedMessagesDirective = CalendarLocalizedMessagesDirective_1 = class CalendarLocalizedMessagesDirective extends CalendarMessages {\n  constructor(service) {\n    super();\n    this.service = service;\n  }\n\n};\n\nCalendarLocalizedMessagesDirective.ɵfac = function CalendarLocalizedMessagesDirective_Factory(t) {\n  return new (t || CalendarLocalizedMessagesDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc4.LocalizationService));\n};\n\nCalendarLocalizedMessagesDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n  type: CalendarLocalizedMessagesDirective,\n  selectors: [[\"\", \"kendoCalendarLocalizedMessages\", \"\"]],\n  features: [ɵngcc0.ɵɵProvidersFeature([{\n    provide: CalendarMessages,\n    useExisting: forwardRef(() => CalendarLocalizedMessagesDirective_1) // tslint:disable-line:no-forward-ref\n\n  }]), ɵngcc0.ɵɵInheritDefinitionFeature]\n});\nCalendarLocalizedMessagesDirective = CalendarLocalizedMessagesDirective_1 = __decorate([__metadata(\"design:paramtypes\", [LocalizationService])], CalendarLocalizedMessagesDirective);\nvar CalendarCustomMessagesComponent_1;\n/**\n * Custom component messages override default component messages ([see example]({% slug globalization_dateinputs %}#toc-custom-messages)).\n */\n\nlet CalendarCustomMessagesComponent = CalendarCustomMessagesComponent_1 = class CalendarCustomMessagesComponent extends CalendarMessages {\n  constructor(service) {\n    super();\n    this.service = service;\n  }\n\n  get override() {\n    return true;\n  }\n\n};\n\nCalendarCustomMessagesComponent.ɵfac = function CalendarCustomMessagesComponent_Factory(t) {\n  return new (t || CalendarCustomMessagesComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc4.LocalizationService));\n};\n\nCalendarCustomMessagesComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n  type: CalendarCustomMessagesComponent,\n  selectors: [[\"kendo-calendar-messages\"]],\n  features: [ɵngcc0.ɵɵProvidersFeature([{\n    provide: CalendarMessages,\n    useExisting: forwardRef(() => CalendarCustomMessagesComponent_1)\n  }]), ɵngcc0.ɵɵInheritDefinitionFeature],\n  decls: 0,\n  vars: 0,\n  template: function CalendarCustomMessagesComponent_Template(rf, ctx) {},\n  encapsulation: 2\n});\nCalendarCustomMessagesComponent = CalendarCustomMessagesComponent_1 = __decorate([__metadata(\"design:paramtypes\", [LocalizationService])], CalendarCustomMessagesComponent);\nconst COMPONENT_DIRECTIVES = [VirtualizationComponent];\n/**\n * @hidden\n *\n * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})\n * definition for the Virtualization component.\n */\n\nlet VirtualizationModule = /*#__PURE__*/(() => {\n  let VirtualizationModule = class VirtualizationModule {};\n\n  VirtualizationModule.ɵfac = function VirtualizationModule_Factory(t) {\n    return new (t || VirtualizationModule)();\n  };\n\n  VirtualizationModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: VirtualizationModule\n  });\n  VirtualizationModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    imports: [[CommonModule]]\n  });\n  /**\n   * The exported package module.\n   *\n   * The package exports:\n   * - `CellTemplateDirective`&mdash;The month cell template directive.\n   * - `MonthCellTemplateDirective`&mdash;The month cell template directive.\n   * - `YearCellTemplateDirective`&mdash;The year cell template directive.\n   * - `DecadeCellTemplateDirective`&mdash;The decade cell template directive.\n   * - `CenturyCellTemplateDirective`&mdash;The century cell template directive.\n   * - `WeekNumberCellTemplateDirective`&mdash;The month week number cell template directive.\n   * - `HeaderTitleTemplateDirective`&mdash;The header title template directive.\n   * - `NavigationItemTemplateDirective`&mdash;The navigation item template directive.\n   *\n   * @example\n   *\n   * ```ts-no-run\n   * // Import the Calendar module\n   * import { CalendarModule } from '@progress/kendo-angular-dateinputs';\n   *\n   * // The browser platform with a compiler\n   * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n   *\n   * import { NgModule } from '@angular/core';\n   *\n   * // Import the app component\n   * import { AppComponent } from './app.component';\n   *\n   * // Define the app module\n   * _@NgModule({\n   *     declarations: [AppComponent], // declare app component\n   *     imports:      [BrowserModule, CalendarModule], // import Calendar module\n   *     bootstrap:    [AppComponent]\n   * })\n   * export class AppModule {}\n   *\n   * // Compile and launch the module\n   * platformBrowserDynamic().bootstrapModule(AppModule);\n   *\n   * ```\n   */\n\n  return VirtualizationModule;\n})();\nlet CalendarModule = /*#__PURE__*/(() => {\n  let CalendarModule = class CalendarModule {};\n\n  CalendarModule.ɵfac = function CalendarModule_Factory(t) {\n    return new (t || CalendarModule)();\n  };\n\n  CalendarModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: CalendarModule\n  });\n  CalendarModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    providers: [CalendarDOMService, CenturyViewService, DecadeViewService, MonthViewService, YearViewService, WeekNamesService],\n    imports: [[CommonModule, CalendarCommonModule, MultiViewCalendarModule, IntlModule, TemplatesModule, VirtualizationModule, EventsModule, ResizeSensorModule], CalendarCommonModule, TemplatesModule]\n  });\n  /**\n   * The exported package module.\n   *\n   * The package exports:\n   * - `CalendarModule`&mdash;The calendar module.\n   * - `MultiViewCalendarModule`&mdash;The multi-view calendar module.\n   *\n   * @example\n   *\n   * ```ts-no-run\n   * // Import the Calendars module\n   * import { CalendarsModule } from '@progress/kendo-angular-dateinputs';\n   *\n   * // The browser platform with a compiler\n   * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n   *\n   * import { NgModule } from '@angular/core';\n   *\n   * // Import the app component\n   * import { AppComponent } from './app.component';\n   *\n   * // Define the app module\n   * _@NgModule({\n   *     declarations: [AppComponent], // declare app component\n   *     imports:      [BrowserModule, CalendarsModule], // import the Calendars module\n   *     bootstrap:    [AppComponent]\n   * })\n   * export class AppModule {}\n   *\n   * // Compile and launch the module\n   * platformBrowserDynamic().bootstrapModule(AppModule);\n   *\n   * ```\n   */\n\n  return CalendarModule;\n})();\nlet CalendarsModule = /*#__PURE__*/(() => {\n  let CalendarsModule = class CalendarsModule {};\n\n  CalendarsModule.ɵfac = function CalendarsModule_Factory(t) {\n    return new (t || CalendarsModule)();\n  };\n\n  CalendarsModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: CalendarsModule\n  });\n  CalendarsModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    imports: [[CalendarModule, MultiViewCalendarModule], CalendarModule, MultiViewCalendarModule]\n  });\n  /**\n   * @hidden\n   */\n\n  return CalendarsModule;\n})();\nlet DateInputMessages = /*#__PURE__*/(() => {\n  class DateInputMessages extends ComponentMessages {}\n\n  DateInputMessages.ɵfac = /*@__PURE__*/function () {\n    let ɵDateInputMessages_BaseFactory;\n    return function DateInputMessages_Factory(t) {\n      return (ɵDateInputMessages_BaseFactory || (ɵDateInputMessages_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(DateInputMessages)))(t || DateInputMessages);\n    };\n  }();\n\n  DateInputMessages.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: DateInputMessages,\n    inputs: {\n      decrement: \"decrement\",\n      increment: \"increment\"\n    },\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature]\n  });\n\n  __decorate([Input(), __metadata(\"design:type\", String)], DateInputMessages.prototype, \"decrement\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", String)], DateInputMessages.prototype, \"increment\", void 0);\n\n  return DateInputMessages;\n})();\nvar DateInputLocalizedMessagesDirective_1;\n/**\n * @hidden\n */\n\nlet DateInputLocalizedMessagesDirective = DateInputLocalizedMessagesDirective_1 = class DateInputLocalizedMessagesDirective extends DateInputMessages {\n  constructor(service) {\n    super();\n    this.service = service;\n  }\n\n};\n\nDateInputLocalizedMessagesDirective.ɵfac = function DateInputLocalizedMessagesDirective_Factory(t) {\n  return new (t || DateInputLocalizedMessagesDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc4.LocalizationService));\n};\n\nDateInputLocalizedMessagesDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n  type: DateInputLocalizedMessagesDirective,\n  selectors: [[\"\", \"kendoDateInputLocalizedMessages\", \"\"]],\n  features: [ɵngcc0.ɵɵProvidersFeature([{\n    provide: DateInputMessages,\n    useExisting: forwardRef(() => DateInputLocalizedMessagesDirective_1) // tslint:disable-line:no-forward-ref\n\n  }]), ɵngcc0.ɵɵInheritDefinitionFeature]\n});\nDateInputLocalizedMessagesDirective = DateInputLocalizedMessagesDirective_1 = __decorate([__metadata(\"design:paramtypes\", [LocalizationService])], DateInputLocalizedMessagesDirective);\nvar DateInputCustomMessagesComponent_1;\n/**\n * Custom component messages override default component messages ([see example]({% slug globalization_dateinputs %}#toc-custom-messages)).\n */\n\nlet DateInputCustomMessagesComponent = DateInputCustomMessagesComponent_1 = class DateInputCustomMessagesComponent extends DateInputMessages {\n  constructor(service) {\n    super();\n    this.service = service;\n  }\n\n  get override() {\n    return true;\n  }\n\n};\n\nDateInputCustomMessagesComponent.ɵfac = function DateInputCustomMessagesComponent_Factory(t) {\n  return new (t || DateInputCustomMessagesComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc4.LocalizationService));\n};\n\nDateInputCustomMessagesComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n  type: DateInputCustomMessagesComponent,\n  selectors: [[\"kendo-dateinput-messages\"]],\n  features: [ɵngcc0.ɵɵProvidersFeature([{\n    provide: DateInputMessages,\n    useExisting: forwardRef(() => DateInputCustomMessagesComponent_1) // tslint:disable-line:no-forward-ref\n\n  }]), ɵngcc0.ɵɵInheritDefinitionFeature],\n  decls: 0,\n  vars: 0,\n  template: function DateInputCustomMessagesComponent_Template(rf, ctx) {},\n  encapsulation: 2\n});\nDateInputCustomMessagesComponent = DateInputCustomMessagesComponent_1 = __decorate([__metadata(\"design:paramtypes\", [LocalizationService])], DateInputCustomMessagesComponent);\n/**\n * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})\n * definition for the DateInput component.\n */\n\nlet DateInputModule = /*#__PURE__*/(() => {\n  let DateInputModule = class DateInputModule {};\n\n  DateInputModule.ɵfac = function DateInputModule_Factory(t) {\n    return new (t || DateInputModule)();\n  };\n\n  DateInputModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: DateInputModule\n  });\n  DateInputModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    imports: [[CommonModule, IntlModule, EventsModule]]\n  });\n  /**\n   * @hidden\n   */\n\n  return DateInputModule;\n})();\nlet DatePickerMessages = /*#__PURE__*/(() => {\n  class DatePickerMessages extends ComponentMessages {}\n\n  DatePickerMessages.ɵfac = /*@__PURE__*/function () {\n    let ɵDatePickerMessages_BaseFactory;\n    return function DatePickerMessages_Factory(t) {\n      return (ɵDatePickerMessages_BaseFactory || (ɵDatePickerMessages_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(DatePickerMessages)))(t || DatePickerMessages);\n    };\n  }();\n\n  DatePickerMessages.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: DatePickerMessages,\n    inputs: {\n      today: \"today\",\n      toggle: \"toggle\",\n      prevButtonTitle: \"prevButtonTitle\",\n      nextButtonTitle: \"nextButtonTitle\"\n    },\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature]\n  });\n\n  __decorate([Input(), __metadata(\"design:type\", String)], DatePickerMessages.prototype, \"today\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", String)], DatePickerMessages.prototype, \"toggle\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", String)], DatePickerMessages.prototype, \"prevButtonTitle\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", String)], DatePickerMessages.prototype, \"nextButtonTitle\", void 0);\n\n  return DatePickerMessages;\n})();\nvar DatePickerLocalizedMessagesDirective_1;\n/**\n * @hidden\n */\n\nlet DatePickerLocalizedMessagesDirective = DatePickerLocalizedMessagesDirective_1 = class DatePickerLocalizedMessagesDirective extends DatePickerMessages {\n  constructor(service) {\n    super();\n    this.service = service;\n  }\n\n};\n\nDatePickerLocalizedMessagesDirective.ɵfac = function DatePickerLocalizedMessagesDirective_Factory(t) {\n  return new (t || DatePickerLocalizedMessagesDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc4.LocalizationService));\n};\n\nDatePickerLocalizedMessagesDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n  type: DatePickerLocalizedMessagesDirective,\n  selectors: [[\"\", \"kendoDatePickerLocalizedMessages\", \"\"]],\n  features: [ɵngcc0.ɵɵProvidersFeature([{\n    provide: DatePickerMessages,\n    useExisting: forwardRef(() => DatePickerLocalizedMessagesDirective_1) // tslint:disable-line:no-forward-ref\n\n  }]), ɵngcc0.ɵɵInheritDefinitionFeature]\n});\nDatePickerLocalizedMessagesDirective = DatePickerLocalizedMessagesDirective_1 = __decorate([__metadata(\"design:paramtypes\", [LocalizationService])], DatePickerLocalizedMessagesDirective);\nvar DatePickerCustomMessagesComponent_1;\n/**\n * Custom component messages override default component messages ([see example]({% slug globalization_dateinputs %}#toc-custom-messages)).\n */\n\nlet DatePickerCustomMessagesComponent = DatePickerCustomMessagesComponent_1 = class DatePickerCustomMessagesComponent extends DatePickerMessages {\n  constructor(service) {\n    super();\n    this.service = service;\n  }\n\n  get override() {\n    return true;\n  }\n\n};\n\nDatePickerCustomMessagesComponent.ɵfac = function DatePickerCustomMessagesComponent_Factory(t) {\n  return new (t || DatePickerCustomMessagesComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc4.LocalizationService));\n};\n\nDatePickerCustomMessagesComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n  type: DatePickerCustomMessagesComponent,\n  selectors: [[\"kendo-datepicker-messages\"]],\n  features: [ɵngcc0.ɵɵProvidersFeature([{\n    provide: DatePickerMessages,\n    useExisting: forwardRef(() => DatePickerCustomMessagesComponent_1) // tslint:disable-line:no-forward-ref\n\n  }]), ɵngcc0.ɵɵInheritDefinitionFeature],\n  decls: 0,\n  vars: 0,\n  template: function DatePickerCustomMessagesComponent_Template(rf, ctx) {},\n  encapsulation: 2\n});\nDatePickerCustomMessagesComponent = DatePickerCustomMessagesComponent_1 = __decorate([__metadata(\"design:paramtypes\", [LocalizationService])], DatePickerCustomMessagesComponent);\nconst ɵ0$e = touchEnabled;\n/**\n * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})\n * definition for the DatePicker component.\n */\n\nlet DatePickerModule = /*#__PURE__*/(() => {\n  let DatePickerModule = class DatePickerModule {};\n\n  DatePickerModule.ɵfac = function DatePickerModule_Factory(t) {\n    return new (t || DatePickerModule)();\n  };\n\n  DatePickerModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: DatePickerModule\n  });\n  DatePickerModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    providers: [{\n      provide: TOUCH_ENABLED,\n      useValue: ɵ0$e\n    }],\n    imports: [[CommonModule, DateInputModule, CalendarModule, IntlModule, PopupModule, TemplatesModule, EventsModule], TemplatesModule]\n  });\n  return DatePickerModule;\n})();\nconst COMPONENT_DIRECTIVES$1 = [DateRangeComponent, DateRangePopupComponent, DateRangePopupTemplateDirective, DateRangeSelectionDirective, DateRangeStartInputDirective, DateRangeEndInputDirective];\nconst COMPONENT_MODULES = [MultiViewCalendarModule, DateInputModule, PopupModule, EventsModule];\n/**\n * The exported package module.\n *\n * The package exports:\n * - `DateRangeComponent`&mdash;The DateRange component class.\n * - `DateRangePopupComponent`&mdash;The DateRangePopup component class.\n * - `DateRangeSelectionDirective`&mdash;The MultiviewCalendar date range selection directive.\n * - `DateRangeEndInputDirective`&mdash;The end DateInput date range selection directive.\n * - `DateRangeStartInputDirective`&mdash;The start DateInput date range selection directive.\n * - `DateRangePopupTemplateDirective`&mdash;The DateRangePopup content template directive.\n * - `MultiViewCalendarModule`&mdash;The MultiViewCalendar module.\n *\n * @example\n *\n * ```ts-no-run\n * // Import the DateRange module\n * import { DateRangeModule } from '@progress/kendo-angular-dateinputs';\n *\n * // The browser platform with a compiler\n * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n *\n * import { NgModule } from '@angular/core';\n *\n * // Import the app component\n * import { AppComponent } from './app.component';\n *\n * // Define the app module\n * _@NgModule({\n *     declarations: [AppComponent], // declare app component\n *     imports:      [BrowserModule, DateRangeModule], // import DateRange module\n *     bootstrap:    [AppComponent]\n * })\n * export class AppModule {}\n *\n * // Compile and launch the module\n * platformBrowserDynamic().bootstrapModule(AppModule);\n *\n * ```\n */\n\nlet DateRangeModule = /*#__PURE__*/(() => {\n  let DateRangeModule = class DateRangeModule {};\n\n  DateRangeModule.ɵfac = function DateRangeModule_Factory(t) {\n    return new (t || DateRangeModule)();\n  };\n\n  DateRangeModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: DateRangeModule\n  });\n  DateRangeModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    imports: [[CommonModule, COMPONENT_MODULES]]\n  });\n  return DateRangeModule;\n})();\nconst div$1 = domContainerFactory('div');\nconst ul$1 = domContainerFactory('ul');\nconst li$1 = domContainerFactory('li');\n\nconst listItem = () => li$1('<span>02</span>', 'k-item');\n\nconst list = () => ul$1([listItem()], 'k-reset');\n\nconst scrollable$1 = () => div$1([list()], 'k-time-container k-content k-scrollable');\n\nconst timeListWrapper = () => {\n  if (!isDocumentAvailable()) {\n    return null;\n  }\n\n  return div$1([div$1([scrollable$1()], 'k-time-list')], 'k-time-list-wrapper', {\n    left: '-10000px',\n    position: 'absolute'\n  });\n};\n\nconst TIMELIST_WRAPPER = timeListWrapper();\n/**\n * @hidden\n */\n\nlet TimePickerDOMService = /*#__PURE__*/(() => {\n  let TimePickerDOMService = class TimePickerDOMService {\n    ensureHeights() {\n      if (this.timeListHeight !== undefined) {\n        return;\n      }\n\n      this.calculateHeights();\n    }\n\n    calculateHeights(container) {\n      if (!isDocumentAvailable()) {\n        return;\n      }\n\n      const listContainer = container && container.querySelector('.k-time-list-container');\n      const hostContainer = listContainer || document.body;\n      const wrapper = hostContainer.appendChild(TIMELIST_WRAPPER);\n      this.timeListHeight = wrapper.querySelector('.k-scrollable').getBoundingClientRect().height;\n      this.itemHeight = wrapper.querySelector('li').getBoundingClientRect().height;\n      hostContainer.removeChild(wrapper);\n    }\n\n    isActive(element) {\n      if (!isDocumentAvailable() || !element) {\n        return false;\n      }\n\n      return (element.nativeElement || element) === document.activeElement;\n    }\n\n  };\n\n  TimePickerDOMService.ɵfac = function TimePickerDOMService_Factory(t) {\n    return new (t || TimePickerDOMService)();\n  };\n\n  TimePickerDOMService.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: TimePickerDOMService,\n    factory: function (t) {\n      return TimePickerDOMService.ɵfac(t);\n    }\n  });\n  return TimePickerDOMService;\n})();\nconst HOURS_IN_DAY = 24;\n\nconst clampToRange = rangeValue => value => value % rangeValue;\n\nconst clamp = clampToRange(HOURS_IN_DAY);\n\nconst stepper = (start, step) => idx => clamp(start + idx * step);\n\nconst distanceFromMin = (value, min) => clamp(HOURS_IN_DAY + value - min);\n\nconst limit = borderValue => (barrier, value) => {\n  const useBarrier = !value || getDate(barrier).getTime() === getDate(value).getTime();\n  return useBarrier ? barrier : setHours(barrier, borderValue);\n};\n\nconst limitDown = limit(0);\nconst limitUp = limit(HOURS_IN_DAY - 1);\n/**\n * @hidden\n */\n\nlet HoursService = /*#__PURE__*/(() => {\n  let HoursService = class HoursService {\n    constructor(intl) {\n      this.intl = intl;\n      this.boundRange = false;\n      this.insertUndividedMax = false;\n    }\n\n    apply(value, candidate) {\n      return setHours(value, candidate.getHours());\n    }\n\n    configure(settings) {\n      const {\n        boundRange = this.boundRange,\n        insertUndividedMax = this.insertUndividedMax,\n        min = this.min,\n        max = this.max,\n        part,\n        step = this.step\n      } = settings;\n      this.boundRange = boundRange;\n      this.insertUndividedMax = insertUndividedMax;\n\n      this.toListItem = hour => {\n        const date = setHours(MIDNIGHT_DATE, hour);\n        return {\n          text: this.intl.formatDate(date, part.pattern),\n          value: date\n        };\n      };\n\n      this.min = min;\n      this.max = max;\n      this.step = step;\n    }\n\n    data(selectedValue) {\n      const [min] = this.range(selectedValue);\n      const getHour = stepper(min, this.step);\n\n      const convertToItem = idx => this.toListItem(getHour(idx));\n\n      const data = range(0, this.countFromMin(selectedValue)).map(convertToItem);\n      this.addLast(data);\n      this.addMissing(data, selectedValue);\n      return data;\n    }\n\n    isRangeChanged(min, max) {\n      return !isEqual(this.min, min) || !isEqual(this.max, max);\n    }\n\n    limitRange(min, max, value) {\n      return this.boundRange ? [limitDown(min, value), limitUp(max, value)] : [min, max];\n    }\n\n    total(value) {\n      const last$$1 = this.insertUndividedMax && this.isLastMissing(value) ? 1 : 0;\n      const missing = this.isMissing(value) ? 1 : 0;\n      return this.countFromMin(value) + missing + last$$1;\n    }\n\n    selectedIndex(value) {\n      return Math.ceil(this.divideByStep(value));\n    }\n\n    valueInList(value) {\n      if (!value) {\n        return true;\n      }\n\n      const matchMax = this.insertUndividedMax && this.lastHour(value) === value.getHours();\n      return matchMax || !this.isMissing(value);\n    }\n\n    addLast(data, value) {\n      if (this.insertUndividedMax && this.isLastMissing(value)) {\n        data.push(this.toListItem(this.lastHour(value)));\n      }\n\n      return data;\n    }\n\n    addMissing(data, value) {\n      if (this.valueInList(value)) {\n        return data;\n      }\n\n      const missingItem = this.toListItem(value.getHours());\n      data.splice(this.selectedIndex(value), 0, missingItem);\n      return data;\n    }\n\n    countFromMin(value) {\n      const [min, max] = this.range(value);\n      return Math.floor(distanceFromMin(max, min) / this.step) + 1;\n      /* include min */\n    }\n\n    isMissing(value) {\n      if (!value) {\n        return false;\n      }\n\n      return this.selectedIndex(value) !== this.divideByStep(value);\n    }\n\n    isLastMissing(value) {\n      return this.isMissing(setHours(this.max, this.lastHour(value)));\n    }\n\n    divideByStep(value) {\n      return distanceFromMin(value.getHours(), this.min.getHours()) / this.step;\n    }\n\n    lastHour(value) {\n      return this.range(value)[1];\n    }\n\n    range(value) {\n      const [min, max] = this.limitRange(this.min, this.max, value);\n      return [min.getHours(), max.getHours()];\n    }\n\n  };\n\n  HoursService.ɵfac = function HoursService_Factory(t) {\n    return new (t || HoursService)(ɵngcc0.ɵɵinject(ɵngcc1.IntlService));\n  };\n\n  HoursService.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: HoursService,\n    factory: function (t) {\n      return HoursService.ɵfac(t);\n    }\n  });\n  HoursService = __decorate([__metadata(\"design:paramtypes\", [IntlService])], HoursService);\n  return HoursService;\n})();\nconst MINUTES_IN_HOUR = 60;\n\nconst clampToRange$1 = rangeValue => value => value % rangeValue;\n\nconst clamp$1 = clampToRange$1(MINUTES_IN_HOUR);\n\nconst stepper$1 = (start, step) => idx => clamp$1(start + idx * step);\n\nconst distanceFromMin$1 = (value, min) => clamp$1(MINUTES_IN_HOUR + value - min);\n\nconst limit$1 = borderValue => (barrier, value) => {\n  const useBarrier = !value || barrier.getHours() === value.getHours();\n  return useBarrier ? barrier : setMinutes(barrier, borderValue);\n};\n\nconst limitDown$1 = limit$1(0);\nconst limitUp$1 = limit$1(MINUTES_IN_HOUR - 1);\n/**\n * @hidden\n */\n\nlet MinutesService = /*#__PURE__*/(() => {\n  let MinutesService = class MinutesService {\n    constructor(intl) {\n      this.intl = intl;\n      this.insertUndividedMax = false;\n    }\n\n    apply(value, candidate) {\n      return setMinutes(value, candidate.getMinutes());\n    }\n\n    configure(settings) {\n      const {\n        insertUndividedMax = this.insertUndividedMax,\n        min = this.min,\n        max = this.max,\n        part,\n        step = this.step\n      } = settings;\n      this.insertUndividedMax = insertUndividedMax;\n\n      this.toListItem = minute => {\n        const date = setMinutes(MIDNIGHT_DATE, minute);\n        return {\n          text: this.intl.formatDate(date, part.pattern),\n          value: date\n        };\n      };\n\n      this.min = min;\n      this.max = max;\n      this.step = step;\n    }\n\n    data(selectedValue) {\n      const [min] = this.range(selectedValue);\n      const getMinute = stepper$1(min, this.step);\n\n      const convertToItem = idx => this.toListItem(getMinute(idx));\n\n      const data = range(0, this.countFromMin(selectedValue)).map(convertToItem);\n      this.addLast(data);\n      this.addMissing(data, selectedValue);\n      return data;\n    }\n\n    isRangeChanged(min, max) {\n      return !isEqual(this.min, min) || !isEqual(this.max, max);\n    }\n\n    limitRange(min, max, value) {\n      return [limitDown$1(min, value), limitUp$1(max, value)];\n    }\n\n    total(value) {\n      const last$$1 = this.insertUndividedMax && this.isLastMissing(value) ? 1 : 0;\n      const missing = this.isMissing(value) ? 1 : 0;\n      return this.countFromMin(value) + missing + last$$1;\n    }\n\n    selectedIndex(value) {\n      return Math.ceil(this.divideByStep(value));\n    }\n\n    valueInList(value) {\n      if (!value) {\n        return true;\n      }\n\n      const matchMax = this.insertUndividedMax && this.lastMinute(value) === value.getMinutes();\n      return matchMax || !this.isMissing(value);\n    }\n\n    addLast(data, value) {\n      if (this.insertUndividedMax && this.isLastMissing(value)) {\n        data.push(this.toListItem(this.lastMinute(value)));\n      }\n\n      return data;\n    }\n\n    addMissing(data, value) {\n      if (this.valueInList(value)) {\n        return data;\n      }\n\n      const missingItem = this.toListItem(value.getMinutes());\n      data.splice(this.selectedIndex(value), 0, missingItem);\n      return data;\n    }\n\n    countFromMin(value) {\n      const [min, max] = this.range(value);\n      return Math.floor(distanceFromMin$1(max, min) / this.step) + 1;\n      /* include min */\n    }\n\n    isMissing(value) {\n      if (!value) {\n        return false;\n      }\n\n      return this.selectedIndex(value) !== this.divideByStep(value);\n    }\n\n    isLastMissing(value) {\n      return this.isMissing(setMinutes(this.max, this.lastMinute(value)));\n    }\n\n    divideByStep(value) {\n      return distanceFromMin$1(value.getMinutes(), this.min.getMinutes()) / this.step;\n    }\n\n    lastMinute(value) {\n      return this.range(value)[1];\n    }\n\n    range(value) {\n      const [min, max] = this.limitRange(this.min, this.max, value);\n      return [min.getMinutes(), max.getMinutes()];\n    }\n\n  };\n\n  MinutesService.ɵfac = function MinutesService_Factory(t) {\n    return new (t || MinutesService)(ɵngcc0.ɵɵinject(ɵngcc1.IntlService));\n  };\n\n  MinutesService.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: MinutesService,\n    factory: function (t) {\n      return MinutesService.ɵfac(t);\n    }\n  });\n  MinutesService = __decorate([__metadata(\"design:paramtypes\", [IntlService])], MinutesService);\n  return MinutesService;\n})();\nconst SECONDS_IN_HOUR = 60;\n\nconst clampToRange$2 = rangeValue => value => value % rangeValue;\n\nconst clamp$2 = clampToRange$2(SECONDS_IN_HOUR);\n\nconst stepper$2 = (start, step) => idx => clamp$2(start + idx * step);\n\nconst distanceFromMin$2 = (value, min) => clamp$2(SECONDS_IN_HOUR + value - min);\n\nconst limit$2 = borderValue => (barrier, value) => {\n  const useBarrier = !value || barrier.getHours() === value.getHours() && barrier.getMinutes() === value.getMinutes();\n  return useBarrier ? barrier : setSeconds(barrier, borderValue);\n};\n\nconst limitDown$2 = limit$2(0);\nconst limitUp$2 = limit$2(SECONDS_IN_HOUR - 1);\n/**\n * @hidden\n */\n\nlet SecondsService = /*#__PURE__*/(() => {\n  let SecondsService = class SecondsService {\n    constructor(intl) {\n      this.intl = intl;\n      this.insertUndividedMax = false;\n    }\n\n    apply(value, candidate) {\n      return setSeconds(value, candidate.getSeconds());\n    }\n\n    configure(settings) {\n      const {\n        insertUndividedMax = this.insertUndividedMax,\n        min = this.min,\n        max = this.max,\n        part,\n        step = this.step\n      } = settings;\n      this.insertUndividedMax = insertUndividedMax;\n\n      this.toListItem = second => {\n        const date = setSeconds(MIDNIGHT_DATE, second);\n        return {\n          text: this.intl.formatDate(date, part.pattern),\n          value: date\n        };\n      };\n\n      this.min = min;\n      this.max = max;\n      this.step = step;\n    }\n\n    data(selectedValue) {\n      const [min] = this.range(selectedValue);\n      const getSecond = stepper$2(min, this.step);\n\n      const convertToItem = idx => this.toListItem(getSecond(idx));\n\n      const data = range(0, this.countFromMin(selectedValue)).map(convertToItem);\n      this.addLast(data);\n      this.addMissing(data, selectedValue);\n      return data;\n    }\n\n    isRangeChanged(min, max) {\n      return !isEqual(this.min, min) || !isEqual(this.max, max);\n    }\n\n    limitRange(min, max, value) {\n      return [limitDown$2(min, value), limitUp$2(max, value)];\n    }\n\n    total(value) {\n      const last$$1 = this.insertUndividedMax && this.isLastMissing(value) ? 1 : 0;\n      const missing = this.isMissing(value) ? 1 : 0;\n      return this.countFromMin(value) + missing + last$$1;\n    }\n\n    selectedIndex(value) {\n      return Math.ceil(this.divideByStep(value));\n    }\n\n    valueInList(value) {\n      if (!value) {\n        return true;\n      }\n\n      const matchMax = this.insertUndividedMax && this.lastSecond(value) === value.getSeconds();\n      return matchMax || !this.isMissing(value);\n    }\n\n    divideByStep(value) {\n      return distanceFromMin$2(value.getSeconds(), this.min.getSeconds()) / this.step;\n    }\n\n    addLast(data, value) {\n      if (this.insertUndividedMax && this.isLastMissing(value)) {\n        data.push(this.toListItem(this.lastSecond(value)));\n      }\n\n      return data;\n    }\n\n    addMissing(data, value) {\n      if (this.valueInList(value)) {\n        return data;\n      }\n\n      const missingItem = this.toListItem(value.getSeconds());\n      data.splice(this.selectedIndex(value), 0, missingItem);\n      return data;\n    }\n\n    countFromMin(value) {\n      const [min, max] = this.range(value);\n      return Math.floor(distanceFromMin$2(max, min) / this.step) + 1;\n      /* include min */\n    }\n\n    isMissing(value) {\n      if (!value) {\n        return false;\n      }\n\n      return this.selectedIndex(value) !== this.divideByStep(value);\n    }\n\n    isLastMissing(value) {\n      return this.isMissing(setSeconds(this.max, this.lastSecond(value)));\n    }\n\n    lastSecond(value) {\n      return this.range(value)[1];\n    }\n\n    range(value) {\n      const [min, max] = this.limitRange(this.min, this.max, value);\n      return [min.getSeconds(), max.getSeconds()];\n    }\n\n  };\n\n  SecondsService.ɵfac = function SecondsService_Factory(t) {\n    return new (t || SecondsService)(ɵngcc0.ɵɵinject(ɵngcc1.IntlService));\n  };\n\n  SecondsService.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: SecondsService,\n    factory: function (t) {\n      return SecondsService.ɵfac(t);\n    }\n  });\n  SecondsService = __decorate([__metadata(\"design:paramtypes\", [IntlService])], SecondsService);\n  return SecondsService;\n})();\nconst MILLISECONDS_IN_SECOND = 1000;\n\nconst clampToRange$3 = rangeValue => value => value % rangeValue;\n\nconst clamp$3 = clampToRange$3(MILLISECONDS_IN_SECOND);\n\nconst stepper$3 = (start, step) => idx => clamp$3(start + idx * step);\n\nconst distanceFromMin$3 = (value, min) => clamp$3(MILLISECONDS_IN_SECOND + value - min);\n\nconst limit$3 = borderValue => (barrier, value) => {\n  const useBarrier = !value || barrier.getHours() === value.getHours() && barrier.getMinutes() === value.getMinutes() && barrier.getSeconds() === value.getSeconds();\n  return useBarrier ? barrier : setMilliseconds(barrier, borderValue);\n};\n\nconst limitDown$3 = limit$3(0);\nconst limitUp$3 = limit$3(MILLISECONDS_IN_SECOND - 1);\n/**\n * @hidden\n */\n\nlet MillisecondsService = /*#__PURE__*/(() => {\n  let MillisecondsService = class MillisecondsService {\n    constructor(intl) {\n      this.intl = intl;\n      this.insertUndividedMax = false;\n    }\n\n    apply(value, candidate) {\n      return setMilliseconds(value, candidate.getMilliseconds());\n    }\n\n    configure(settings) {\n      const {\n        insertUndividedMax = this.insertUndividedMax,\n        min = this.min,\n        max = this.max,\n        step = this.step\n      } = settings;\n      this.insertUndividedMax = insertUndividedMax;\n\n      this.toListItem = millisecond => {\n        const date = setMilliseconds(MIDNIGHT_DATE, millisecond);\n        return {\n          text: this.intl.formatDate(date, \"SSS\"),\n          value: date\n        };\n      };\n\n      this.min = min;\n      this.max = max;\n      this.step = step;\n    }\n\n    data(selectedValue) {\n      const [min] = this.range(selectedValue);\n      const getMillisecond = stepper$3(min, this.step);\n\n      const convertToItem = idx => this.toListItem(getMillisecond(idx));\n\n      const data = range(0, this.countFromMin(selectedValue)).map(convertToItem);\n      this.addLast(data);\n      this.addMissing(data, selectedValue);\n      return data;\n    }\n\n    isRangeChanged(min, max) {\n      return !isEqual(this.min, min) || !isEqual(this.max, max);\n    }\n\n    limitRange(min, max, value) {\n      return [limitDown$3(min, value), limitUp$3(max, value)];\n    }\n\n    total(value) {\n      const last$$1 = this.insertUndividedMax && this.isLastMissing(value) ? 1 : 0;\n      const missing = this.isMissing(value) ? 1 : 0;\n      return this.countFromMin(value) + missing + last$$1;\n    }\n\n    selectedIndex(value) {\n      return Math.ceil(this.divideByStep(value));\n    }\n\n    valueInList(value) {\n      if (!value) {\n        return true;\n      }\n\n      const matchMax = this.insertUndividedMax && this.lastMillisecond(value) === value.getMilliseconds();\n      return matchMax || !this.isMissing(value);\n    }\n\n    divideByStep(value) {\n      return distanceFromMin$3(value.getMilliseconds(), this.min.getMilliseconds()) / this.step;\n    }\n\n    addLast(data, value) {\n      if (this.insertUndividedMax && this.isLastMissing(value)) {\n        data.push(this.toListItem(this.lastMillisecond(value)));\n      }\n\n      return data;\n    }\n\n    addMissing(data, value) {\n      if (this.valueInList(value)) {\n        return data;\n      }\n\n      const missingItem = this.toListItem(value.getMilliseconds());\n      data.splice(this.selectedIndex(value), 0, missingItem);\n      return data;\n    }\n\n    countFromMin(value) {\n      const [min, max] = this.range(value);\n      return Math.floor(distanceFromMin$3(max, min) / this.step) + 1;\n      /* include min */\n    }\n\n    isMissing(value) {\n      if (!value) {\n        return false;\n      }\n\n      return this.selectedIndex(value) !== this.divideByStep(value);\n    }\n\n    isLastMissing(value) {\n      return this.isMissing(setMilliseconds(this.max, this.lastMillisecond(value)));\n    }\n\n    lastMillisecond(value) {\n      return this.range(value)[1];\n    }\n\n    range(value) {\n      const [min, max] = this.limitRange(this.min, this.max, value);\n      return [min.getMilliseconds(), max.getMilliseconds()];\n    }\n\n  };\n\n  MillisecondsService.ɵfac = function MillisecondsService_Factory(t) {\n    return new (t || MillisecondsService)(ɵngcc0.ɵɵinject(ɵngcc1.IntlService));\n  };\n\n  MillisecondsService.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: MillisecondsService,\n    factory: function (t) {\n      return MillisecondsService.ɵfac(t);\n    }\n  });\n  MillisecondsService = __decorate([__metadata(\"design:paramtypes\", [IntlService])], MillisecondsService);\n  return MillisecondsService;\n})();\n\nconst setHours$1 = (date, hours) => {\n  const clone = cloneDate(date);\n  clone.setHours(hours);\n  return clone;\n};\n\nconst isAM = value => value !== null && value < 12;\n\nconst isPM = value => value !== null && (!value || value > 11);\n\nconst inRange = (value, min, max) => !min && !max || value >= min && value <= max;\n\nconst inReverseRange = (value, min, max) => !min && !max || value >= min || value <= max;\n/**\n * @hidden\n */\n\n\nlet DayPeriodService = /*#__PURE__*/(() => {\n  let DayPeriodService = class DayPeriodService {\n    constructor(intl) {\n      this.intl = intl;\n    }\n    /**\n     * @hidden\n     */\n\n\n    apply(value, candidate) {\n      const hour = value.getHours();\n      const hourAM = isAM(hour);\n      const candidateAM = isAM(candidate.getHours());\n\n      if (hourAM && candidateAM || !hourAM && !candidateAM) {\n        return value;\n      }\n\n      const [min, max = 24] = this.normalizedRange();\n      const result = hour + (candidateAM ? -12 : 12);\n      return setHours$1(value, Math.min(Math.max(min, result), max || 24));\n    }\n    /**\n     * @hidden\n     */\n\n\n    configure(settings) {\n      const {\n        min = this.min,\n        max = this.max,\n        part = this.part\n      } = settings;\n      this.min = min;\n      this.max = max;\n      this.part = part;\n    }\n    /**\n     * @hidden\n     */\n\n\n    data(_) {\n      const names = this.part.names;\n\n      if (!names) {\n        return [];\n      }\n\n      const data = [];\n      const [min, max] = this.normalizedRange();\n      const dayPeriod = this.intl.dateFormatNames(names);\n\n      if (isAM(min)) {\n        data.push({\n          text: dayPeriod.am,\n          value: setHours$1(this.min, min)\n        });\n      }\n\n      if (isPM(max)) {\n        data.push({\n          text: dayPeriod.pm,\n          value: setHours$1(this.min, Math.max(12, max))\n        });\n      }\n\n      return this.min.getHours() !== min ? data.reverse() : data;\n    }\n    /**\n     * @hidden\n     */\n\n\n    isRangeChanged(_, __) {\n      return false;\n    }\n    /**\n     * @hidden\n     */\n\n\n    limitRange(min, max, _) {\n      return [min, max];\n    }\n    /**\n     * @hidden\n     */\n\n\n    total() {\n      const [min, max] = this.normalizedRange();\n\n      if (!min && !max) {\n        return 2;\n      }\n\n      if (min > 11 || max < 12) {\n        return 1;\n      }\n\n      return 2;\n    }\n    /**\n     * @hidden\n     */\n\n\n    selectedIndex(value) {\n      if (!this.valueInList(value)) {\n        return -1;\n      }\n\n      const index = Math.floor(value.getHours() / 12);\n      return this.min.getHours() === this.normalizedRange()[0] ? index : index === 0 ? 1 : 0;\n    }\n    /**\n     * @hidden\n     */\n\n\n    valueInList(value) {\n      const reverse = this.min.getHours() !== this.normalizedRange()[0];\n      const isInRange = reverse ? inReverseRange : inRange;\n      return isInRange(value.getHours(), this.min.getHours(), this.max.getHours());\n    }\n\n    normalizedRange() {\n      const minHour = this.min.getHours();\n      const maxHour = this.max.getHours();\n      return [Math.min(minHour, maxHour), Math.max(minHour, maxHour)];\n    }\n\n  };\n\n  DayPeriodService.ɵfac = function DayPeriodService_Factory(t) {\n    return new (t || DayPeriodService)(ɵngcc0.ɵɵinject(ɵngcc1.IntlService));\n  };\n\n  DayPeriodService.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: DayPeriodService,\n    factory: function (t) {\n      return DayPeriodService.ɵfac(t);\n    }\n  });\n  DayPeriodService = __decorate([__metadata(\"design:paramtypes\", [IntlService])], DayPeriodService);\n  return DayPeriodService;\n})();\nconst SNAP_THRESHOLD = 0.05; //% of the item height\n\nconst SCROLL_THRESHOLD = 2; //< 2px threshold\n\nconst nil = () => null;\n\nconst getters = {\n  35: (data, _) => data[data.length - 1],\n  36: (data, _) => data[0],\n  38: (data, index) => data[index - 1],\n  40: (data, index) => data[index + 1]\n};\nconst services$1 = {\n  [TIME_PART.dayperiod]: DayPeriodService,\n  [TIME_PART.hour]: HoursService,\n  [TIME_PART.minute]: MinutesService,\n  [TIME_PART.second]: SecondsService,\n  [TIME_PART.millisecond]: MillisecondsService\n};\n/**\n * @hidden\n */\n\nlet TimeListComponent = /*#__PURE__*/(() => {\n  let TimeListComponent = class TimeListComponent {\n    constructor(element, injector, dom, renderer, zone) {\n      this.element = element;\n      this.injector = injector;\n      this.dom = dom;\n      this.renderer = renderer;\n      this.zone = zone;\n      this.min = cloneDate(MIDNIGHT_DATE);\n      this.max = cloneDate(MAX_TIME);\n      this.step = 1;\n      this.disabled = false;\n      this.valueChange = new EventEmitter();\n      this.componentClass = true;\n      this.animateToIndex = true;\n      this.isActive = false;\n      this.skip = 0;\n      this.total = 60;\n      this.data = [];\n      this.indexToScroll = -1;\n      this.domEvents = [];\n    }\n\n    get tabIndex() {\n      return this.disabled ? undefined : 0;\n    }\n\n    ngOnChanges(changes) {\n      if (changes.part) {\n        this.service = this.injector.get(services$1[this.part.type]);\n        this.service.configure(this.serviceSettings());\n      }\n\n      const value = this.value;\n      const valueChanges = changes.value || {};\n      const [min, max] = this.service.limitRange(this.min, this.max, value);\n\n      if (this.service.isRangeChanged(min, max) || changes.min || changes.max || changes.step) {\n        this.data = [];\n        this.service.configure(this.serviceSettings({\n          min,\n          max\n        }));\n      } // Skip the rendering of the list whenever possible\n\n\n      if (!this.data.length || this.hasMissingValue(valueChanges)) {\n        this.animateToIndex = false;\n        this.data = this.service.data(value);\n      }\n\n      this.animateToIndex = this.animateToIndex && this.textHasChanged(valueChanges);\n      this.total = this.service.total(value);\n      this.indexToScroll = this.selectedIndex(value);\n    }\n\n    ngOnInit() {\n      this.animateToIndex = true;\n      this.dom.ensureHeights();\n      this.itemHeight = this.dom.itemHeight;\n      this.listHeight = this.dom.timeListHeight;\n      this.topOffset = (this.listHeight - this.itemHeight) / 2;\n      this.bottomOffset = this.listHeight - this.itemHeight;\n      this.topThreshold = this.itemHeight * SNAP_THRESHOLD;\n      this.bottomThreshold = this.itemHeight * (1 - SNAP_THRESHOLD);\n      const translate = `translateY(${this.topOffset}px)`;\n      this.style = {\n        transform: translate,\n        '-ms-transform': translate\n      };\n\n      if (this.element) {\n        this.zone.runOutsideAngular(() => {\n          this.bindEvents();\n        });\n      }\n    }\n\n    ngOnDestroy() {\n      this.scrollSubscription.unsubscribe();\n      this.domEvents.forEach(unbindCallback => unbindCallback());\n    }\n\n    ngAfterViewInit() {\n      this.scrollOnce(index => this.virtualization.scrollToIndex(index));\n    }\n\n    ngAfterViewChecked() {\n      this.scrollOnce(index => {\n        const action = this.animateToIndex ? 'animateToIndex' : 'scrollToIndex';\n        this.virtualization[action](index);\n        this.animateToIndex = true;\n      });\n    }\n\n    handleChange(dataItem) {\n      const candidate = this.service.apply(this.value, dataItem.value);\n\n      if (this.value.getTime() === candidate.getTime()) {\n        return;\n      }\n\n      this.indexToScroll = this.data.indexOf(dataItem);\n      this.value = candidate;\n      this.valueChange.emit(candidate);\n    }\n\n    handleItemClick(args) {\n      const item = closestInScope(args.target, node => node.hasAttribute('data-timelist-item-index'), this.element.nativeElement);\n\n      if (item) {\n        const index = item.getAttribute('data-timelist-item-index');\n        this.handleChange(this.data[index]);\n      }\n    }\n    /**\n     * Focuses the host element of the TimeList.\n     *\n     * @example\n     * ```ts\n     * _@Component({\n     * selector: 'my-app',\n     * template: `\n     *  <button (click)=\"timelist.focus()\">Focus TimeList</button>\n     *  <kendo-timelist #timelist></kendo-timelist>\n     * `\n     * })\n     * export class AppComponent { }\n     * ```\n     */\n\n\n    focus() {\n      if (!this.element) {\n        return;\n      }\n\n      this.element.nativeElement.focus();\n    }\n    /**\n     * Blurs the TimeList component.\n     */\n\n\n    blur() {\n      if (!this.element) {\n        return;\n      }\n\n      this.element.nativeElement.blur();\n    }\n\n    itemOffset(scrollTop) {\n      const valueIndex = this.selectedIndex(this.value);\n      const activeIndex = this.virtualization.activeIndex();\n      const offset = this.virtualization.itemOffset(activeIndex);\n      const distance = Math.abs(Math.ceil(scrollTop) - offset);\n\n      if (valueIndex === activeIndex && distance < SCROLL_THRESHOLD) {\n        return offset;\n      }\n\n      const scrollUp = valueIndex > activeIndex;\n      const moveToNext = scrollUp && distance >= this.bottomThreshold || !scrollUp && distance > this.topThreshold;\n      return moveToNext ? this.virtualization.itemOffset(activeIndex + 1) : offset;\n    }\n\n    hasMissingValue({\n      previousValue,\n      currentValue\n    }) {\n      const isPreviousMissing = previousValue && !this.service.valueInList(previousValue);\n      const isCurrentMissing = currentValue && !this.service.valueInList(currentValue);\n      return isPreviousMissing || isCurrentMissing;\n    }\n\n    scrollOnce(action) {\n      if (this.indexToScroll !== -1) {\n        action(this.indexToScroll);\n        this.indexToScroll = -1;\n      }\n    }\n\n    serviceSettings(settings) {\n      const defaults = {\n        boundRange: false,\n        insertUndividedMax: false,\n        max: this.max,\n        min: this.min,\n        part: this.part,\n        step: this.step\n      };\n      const result = Object.assign({}, defaults, settings);\n      result.boundRange = result.part.type !== 'hour';\n      return result;\n    }\n\n    selectedIndex(value) {\n      if (!value) {\n        return -1;\n      }\n\n      return this.service.selectedIndex(value);\n    }\n\n    textHasChanged({\n      previousValue,\n      currentValue\n    }) {\n      if (!previousValue || !currentValue) {\n        return false;\n      }\n\n      const oldData = this.data[this.selectedIndex(previousValue)];\n      const newData = this.data[this.selectedIndex(currentValue)];\n      return oldData && newData && oldData.text !== newData.text;\n    }\n\n    handleKeyDown(e) {\n      const getter = getters[e.keyCode] || nil;\n      const dataItem = getter(this.data, this.service.selectedIndex(this.value));\n\n      if (dataItem) {\n        this.handleChange(dataItem);\n        e.preventDefault();\n      }\n    }\n\n    bindEvents() {\n      this.scrollSubscription = this.virtualization.scroll$().pipe(debounceTime(100), map(e => e.target.scrollTop), map(top => this.itemOffset(top)), map(itemOffset => this.virtualization.itemIndex(itemOffset))).subscribe(index => {\n        this.virtualization.scrollToIndex(index);\n        this.handleChange(this.data[index]);\n      });\n      const element = this.element.nativeElement;\n      this.domEvents.push(this.renderer.listen(element, 'mouseover', () => !this.isActive && this.focus()), this.renderer.listen(element, 'click', () => this.focus()), this.renderer.listen(element, 'blur', () => this.isActive = false), this.renderer.listen(element, 'focus', () => this.isActive = true), this.renderer.listen(element, 'keydown', this.handleKeyDown.bind(this)));\n    }\n\n  };\n\n  TimeListComponent.ɵfac = function TimeListComponent_Factory(t) {\n    return new (t || TimeListComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Injector), ɵngcc0.ɵɵdirectiveInject(TimePickerDOMService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone));\n  };\n\n  TimeListComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: TimeListComponent,\n    selectors: [[\"kendo-timelist\"]],\n    viewQuery: function TimeListComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵviewQuery(VirtualizationComponent, 7);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.virtualization = _t.first);\n      }\n    },\n    hostVars: 3,\n    hostBindings: function TimeListComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        ɵngcc0.ɵɵattribute(\"tabindex\", ctx.tabIndex);\n        ɵngcc0.ɵɵclassProp(\"k-time-list\", ctx.componentClass);\n      }\n    },\n    inputs: {\n      min: \"min\",\n      max: \"max\",\n      step: \"step\",\n      disabled: \"disabled\",\n      value: \"value\",\n      part: \"part\"\n    },\n    outputs: {\n      valueChange: \"valueChange\"\n    },\n    features: [ɵngcc0.ɵɵNgOnChangesFeature],\n    decls: 3,\n    vars: 13,\n    consts: [[\"role\", \"presentation\", \"tabindex\", \"-1\", 1, \"k-time-container\", 3, \"skip\", \"take\", \"total\", \"itemHeight\", \"maxScrollDifference\", \"topOffset\", \"bottomOffset\"], [1, \"k-reset\", 3, \"ngStyle\", \"kendoEventsOutsideAngular\", \"scope\"], [\"class\", \"k-item\", 4, \"ngFor\", \"ngForOf\"], [1, \"k-item\"]],\n    template: function TimeListComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵelementStart(0, \"kendo-virtualization\", 0);\n        ɵngcc0.ɵɵelementStart(1, \"ul\", 1);\n        ɵngcc0.ɵɵtemplate(2, TimeListComponent_li_2_Template, 3, 2, \"li\", 2);\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵproperty(\"skip\", ctx.skip)(\"take\", ctx.total)(\"total\", ctx.total)(\"itemHeight\", ctx.itemHeight)(\"maxScrollDifference\", ctx.listHeight)(\"topOffset\", ctx.topOffset)(\"bottomOffset\", ctx.bottomOffset);\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngStyle\", ctx.style)(\"kendoEventsOutsideAngular\", ɵngcc0.ɵɵpureFunction1(11, _c3, ctx.handleItemClick))(\"scope\", ctx);\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngForOf\", ctx.data);\n      }\n    },\n    directives: [VirtualizationComponent, ɵngcc2.NgStyle, ɵngcc3.EventsOutsideAngularDirective, ɵngcc2.NgForOf],\n    encapsulation: 2\n  });\n\n  __decorate([Input(), __metadata(\"design:type\", Date)], TimeListComponent.prototype, \"min\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", Date)], TimeListComponent.prototype, \"max\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", Object)], TimeListComponent.prototype, \"part\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", Number)], TimeListComponent.prototype, \"step\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", Boolean)], TimeListComponent.prototype, \"disabled\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", Date)], TimeListComponent.prototype, \"value\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], TimeListComponent.prototype, \"valueChange\", void 0);\n\n  __decorate([ViewChild(VirtualizationComponent, {\n    static: true\n  }), __metadata(\"design:type\", VirtualizationComponent)], TimeListComponent.prototype, \"virtualization\", void 0);\n\n  __decorate([HostBinding(\"attr.tabindex\"), __metadata(\"design:type\", Number), __metadata(\"design:paramtypes\", [])], TimeListComponent.prototype, \"tabIndex\", null);\n\n  __decorate([HostBinding(\"class.k-time-list\"), __metadata(\"design:type\", Boolean)], TimeListComponent.prototype, \"componentClass\", void 0);\n\n  TimeListComponent = __decorate([__metadata(\"design:paramtypes\", [ElementRef, Injector, TimePickerDOMService, Renderer2, NgZone])], TimeListComponent);\n  return TimeListComponent;\n})();\n\nconst isEqualTillMinute = (value, min) => value.getHours() === min.getHours() && value.getMinutes() === min.getMinutes();\n\nconst isEqualTillSecond = (value, min) => isEqualTillMinute(value, min) && value.getSeconds() === min.getSeconds();\n\nconst isEqualTillMillisecond = (value, min) => isEqualTillSecond(value, min) && value.getMilliseconds() === min.getMilliseconds();\n\nconst ɵ3$7 = value => value.getHours(),\n      ɵ4$2 = (_, min) => min.getHours(),\n      ɵ5$1 = value => value.getMinutes(),\n      ɵ6$1 = (value, min) => isEqualTillMinute(value, min) ? min.getMinutes() : 0,\n      ɵ7$1 = value => value.getSeconds(),\n      ɵ8$1 = (value, min) => isEqualTillSecond(value, min) ? min.getSeconds() : 0,\n      ɵ9$1 = value => value.getMilliseconds(),\n      ɵ10$1 = (value, min) => isEqualTillMillisecond(value, min) ? min.getMilliseconds() : 0;\n\nconst defaultGetters = [{\n  type: TIME_PART.hour,\n  getter: ɵ3$7,\n  minGetter: ɵ4$2\n}, {\n  type: TIME_PART.minute,\n  getter: ɵ5$1,\n  minGetter: ɵ6$1\n}, {\n  type: TIME_PART.second,\n  getter: ɵ7$1,\n  minGetter: ɵ8$1\n}, {\n  type: TIME_PART.millisecond,\n  getter: ɵ9$1,\n  minGetter: ɵ10$1\n}];\n\nconst left = getter => (origin, _) => getter(origin);\n\nconst right = getter => (_, candidate) => getter(candidate);\n\nconst convertToObject = parts => parts.reduce((obj, p) => {\n  obj[p.type] = p.type;\n  return obj;\n}, {});\n\nconst getterByPart = parts => g => parts[g.type] ? right(g.getter) : left(g.getter);\n\nconst gettersFactory = getters => parts => getters.map(getterByPart(convertToObject(parts)));\n\nconst snapValue = (getter, minGetter, step) => (date, min) => {\n  const value = getter(date);\n  const minValue = minGetter(date, min);\n  const rest = value - minValue;\n\n  if (rest < 0) {\n    return minValue;\n  }\n\n  const mod = rest % step;\n  return value - mod + (mod > step / 2 ? step : 0);\n};\n\nconst snappersFactory = getters => steps => getters.map(g => {\n  const step = steps[g.type];\n  return step ? snapValue(g.getter, g.minGetter, step) : g.getter;\n});\n/**\n * @hidden\n */\n\n\nconst generateGetters = gettersFactory(defaultGetters);\n/**\n * @hidden\n */\n\nconst generateSnappers = snappersFactory(defaultGetters);\n/**\n * @hidden\n */\n\nconst valueMerger = getters => (origin, candidate) => {\n  origin.setHours(...getters.map(g => g(origin, candidate)));\n  return origin;\n};\n/**\n * @hidden\n */\n\n\nconst snapTime = snappers => (candidate, min) => {\n  const date = cloneDate(candidate);\n  date.setHours(...snappers.map(s => s(date, min)));\n  return date;\n};\n\nconst listReducer = (state, list, idx, all) => {\n  if (state.length || !list.isActive) {\n    return state;\n  }\n\n  return [{\n    next: all[idx + 1] || list,\n    prev: all[idx - 1] || list\n  }];\n};\n\nvar Direction = /*#__PURE__*/(() => {\n  (function (Direction) {\n    Direction[Direction[\"Left\"] = 0] = \"Left\";\n    Direction[Direction[\"Right\"] = 1] = \"Right\";\n  })(Direction || (Direction = {}));\n\n  return Direction;\n})();\n\n/**\n * @hidden\n *\n * Represents the Kendo UI TimeSelector component for Angular.\n */\nlet TimeSelectorComponent = /*#__PURE__*/(() => {\n  let TimeSelectorComponent = class TimeSelectorComponent {\n    constructor(localization, cdr, element, intl, dom, zone, renderer, pickerService) {\n      this.localization = localization;\n      this.cdr = cdr;\n      this.element = element;\n      this.intl = intl;\n      this.dom = dom;\n      this.zone = zone;\n      this.renderer = renderer;\n      this.pickerService = pickerService;\n      /**\n       * @hidden\n       */\n\n      this.componentClass = true;\n      /**\n       * Specifies the time format used to display the time list columns.\n       */\n\n      this.format = 't';\n      /**\n       * Specifies the smallest valid time value.\n       */\n\n      this.min = cloneDate(MIN_TIME);\n      /**\n       * Specifies the biggest valid time value.\n       */\n\n      this.max = cloneDate(MAX_TIME);\n      /**\n       * Determines whether to display the **Cancel** button in the popup.\n       */\n\n      this.cancelButton = true;\n      /**\n       * Determines whether to display the **Set** button in the popup.\n       */\n\n      this.setButton = true;\n      /**\n       * Determines whether to display the **Now** button in the popup.\n       *\n       * > If the current time is out of range or the incremental step is greater than `1`, the **Now** button will be hidden.\n       */\n\n      this.nowButton = true;\n      /**\n       * Sets or gets the `disabled` property of the TimeSelector and determines whether the component is active.\n       */\n\n      this.disabled = false;\n      /**\n       * Specifies the value of the TimeSelector component.\n       */\n\n      this.value = null;\n      /**\n       * Fires each time the user selects a new value.\n       */\n\n      this.valueChange = new EventEmitter();\n      /**\n       * Fires each time the user cancels the selected value.\n       */\n\n      this.valueReject = new EventEmitter();\n      this.isActive = false;\n      this.showNowButton = true;\n      this._activeListIndex = -1;\n      this._steps = {};\n      this.domEvents = [];\n\n      if (this.pickerService) {\n        this.pickerService.timeSelector = this;\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    get disabledClass() {\n      return this.disabled;\n    }\n    /**\n     * Configures the incremental steps of the TimeSelector.\n     *\n     * The available options are:\n     * - `hour: Number`&mdash;Controls the incremental step of the hour value.\n     * - `minute: Number`&mdash;Controls the incremental step of the minute value.\n     * - `second: Number`&mdash;Controls the incremental step of the second value.\n     *\n     * @example\n     * ```ts\n     * _@Component({\n     * selector: 'my-app',\n     * template: `\n     *  <kendo-timeselector format=\"HH:mm:ss\" [steps]=\"steps\"></kendo-timeselector>\n     * `\n     * })\n     * export class AppComponent {\n     *   public steps = { hour: 2, minute: 15, second: 15 };\n     * }\n     * ```\n     *\n     * > If the incremental step is greater than `1`, the **Now** button will be hidden.\n     */\n\n\n    set steps(steps) {\n      this._steps = steps || {};\n    }\n\n    get steps() {\n      return this._steps;\n    }\n\n    set current(value) {\n      this._current = timeInRange(this.snapTime(cloneDate(value || MIDNIGHT_DATE), this.min), this.min, this.max);\n\n      if (!NgZone.isInAngularZone()) {\n        this.cdr.detectChanges();\n      }\n    }\n\n    get current() {\n      return this._current;\n    }\n\n    get activeListIndex() {\n      return this._activeListIndex;\n    }\n\n    set activeListIndex(value) {\n      this._activeListIndex = value;\n\n      if (!this.timeListWrappers || !this.timeListWrappers.length) {\n        return;\n      }\n\n      this.timeListWrappers.forEach(listWrapper => {\n        this.renderer.removeClass(listWrapper.nativeElement, 'k-state-focused');\n      });\n\n      if (value >= 0) {\n        const listIndex = this.listIndex(value);\n        const focusedWrapper = this.timeListWrappers.toArray()[listIndex];\n\n        if (focusedWrapper) {\n          this.renderer.addClass(focusedWrapper.nativeElement, 'k-state-focused');\n        }\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    ngOnInit() {\n      this.subscriptions = this.intl.changes.subscribe(this.intlChange.bind(this));\n\n      if (this.localization) {\n        this.subscriptions.add(this.localization.changes.subscribe(() => this.cdr.markForCheck()));\n      }\n\n      this.dom.calculateHeights(this.element.nativeElement);\n      this.init();\n      this.bindEvents();\n    }\n    /**\n     * @hidden\n     */\n\n\n    ngOnChanges(_) {\n      this.init();\n    }\n\n    ngOnDestroy() {\n      if (this.subscriptions) {\n        this.subscriptions.unsubscribe();\n      }\n\n      if (this.pickerService) {\n        this.pickerService.timeSelector = null;\n      }\n\n      this.domEvents.forEach(unbindCallback => unbindCallback());\n    }\n    /**\n     * Focuses the TimeSelector component.\n     *\n     * @example\n     * ```ts\n     * _@Component({\n     * selector: 'my-app',\n     * template: `\n     *  <button (click)=\"timeselector.focus()\">Focus time picker</button>\n     *  <kendo-timeselector #timeselector></kendo-timeselector>\n     * `\n     * })\n     * export class AppComponent { }\n     * ```\n     */\n\n\n    focus() {\n      const list = this.timeLists.first;\n\n      if (!list) {\n        return;\n      }\n\n      list.focus();\n    }\n    /**\n     * Blurs the TimeSelector component.\n     */\n\n\n    blur() {\n      const list = this.timeLists.first;\n\n      if (!list) {\n        return;\n      }\n\n      list.blur();\n    }\n    /**\n     * @hidden\n     */\n\n\n    handleAccept() {\n      this.handleChange(this.mergeValue(cloneDate(this.value || getDate(getNow())), this.current));\n    }\n    /**\n     * @hidden\n     */\n\n\n    handleNow() {\n      this.current = getNow();\n      this.handleChange(this.current);\n      this.cdr.markForCheck();\n    }\n    /**\n     * @hidden\n     */\n\n\n    handleReject() {\n      this.current = this.value;\n      this.valueReject.emit();\n    }\n    /**\n     * @hidden\n     */\n\n\n    handleFocus(args) {\n      if (this.isActive) {\n        return;\n      }\n\n      this.isActive = true;\n      this.emitFocus(args);\n    }\n    /**\n     * @hidden\n     */\n\n\n    handleListFocus(args) {\n      const index = parseInt(args.target.getAttribute('data-timelist-index'), 10);\n      this.activeListIndex = index;\n      this.handleFocus(args);\n    }\n    /**\n     * @hidden\n     */\n\n\n    handleBlur(args) {\n      const currentTarget = currentFocusTarget(args);\n\n      if (currentTarget && this.containsElement(currentTarget)) {\n        return;\n      }\n\n      this.activeListIndex = -1;\n      this.isActive = false;\n      this.emitBlur(args);\n    }\n    /**\n     * @hidden\n     */\n\n\n    containsElement(element) {\n      return Boolean(closest(element, node => node === this.element.nativeElement));\n    }\n\n    partStep(part) {\n      return this.steps[part.type] || 1;\n    }\n\n    init(changes) {\n      if (!changes || hasChange(changes, 'format')) {\n        this.dateFormatParts = this.intl.splitDateFormat(this.format);\n        this.mergeValue = valueMerger(generateGetters(this.dateFormatParts));\n      }\n\n      if (!changes || hasChange(changes, 'steps')) {\n        this.snapTime = snapTime(generateSnappers(this.steps));\n      }\n\n      if (!changes || hasChange(changes, 'value')) {\n        this.current = this.value;\n      }\n\n      this.showNowButton = !this.hasSteps() && this.nowButton && isInTimeRange(getNow(), this.min, this.max);\n    }\n\n    focusList(dir) {\n      if (!this.timeLists.length) {\n        return;\n      }\n\n      this.timeLists.reduce(listReducer, []).map(state => dir === Direction.Right ? state.next : state.prev).map(list => list && list.focus());\n    }\n\n    handleChange(value) {\n      this.value = value;\n      this.valueChange.emit(cloneDate(value));\n    }\n\n    hasActiveButton() {\n      if (!this.accept) {\n        return false;\n      }\n\n      return [this.accept, this.cancel, this.now].reduce((isActive, el) => isActive || this.dom.isActive(el), false);\n    }\n\n    hasSteps() {\n      const keys = Object.keys(this.steps);\n      return keys.length !== keys.reduce((acc, k) => acc + this.steps[k], 0);\n    }\n\n    intlChange() {\n      this.dateFormatParts = this.intl.splitDateFormat(this.format);\n      this.mergeValue = valueMerger(generateGetters(this.dateFormatParts));\n      this.cdr.markForCheck();\n    }\n\n    bindEvents() {\n      if (this.element) {\n        this.zone.runOutsideAngular(() => {\n          this.domEvents.push(this.renderer.listen(this.element.nativeElement, 'keydown', this.handleKeydown.bind(this)));\n        });\n      }\n    }\n\n    handleKeydown(args) {\n      const {\n        keyCode,\n        altKey\n      } = args; // reserve the alt + arrow key commands for the picker\n\n      const arrowKeyPressed = [Keys.ArrowLeft, Keys.ArrowRight].indexOf(keyCode) !== -1;\n\n      if (isPresent(this.pickerService) && arrowKeyPressed && altKey) {\n        return;\n      }\n\n      if (keyCode === Keys.Enter && !this.hasActiveButton()) {\n        this.handleAccept();\n      } else if (keyCode === Keys.ArrowLeft || keyCode === Keys.ArrowRight) {\n        this.focusList(keyCode === Keys.ArrowLeft ? Direction.Left : Direction.Right);\n      }\n    }\n\n    emitBlur(args) {\n      if (this.pickerService) {\n        this.pickerService.onBlur.emit(args);\n      }\n    }\n\n    emitFocus(args) {\n      if (this.pickerService) {\n        this.pickerService.onFocus.emit(args);\n      }\n    }\n\n    listIndex(partIndex) {\n      let listIdx = 0;\n      let partIdx = 0;\n\n      while (partIdx < partIndex) {\n        if (this.dateFormatParts[partIdx].type !== 'literal') {\n          listIdx++;\n        }\n\n        partIdx++;\n      }\n\n      return listIdx;\n    }\n\n  };\n\n  TimeSelectorComponent.ɵfac = function TimeSelectorComponent_Factory(t) {\n    return new (t || TimeSelectorComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc4.LocalizationService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.IntlService), ɵngcc0.ɵɵdirectiveInject(TimePickerDOMService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(PickerService, 8));\n  };\n\n  TimeSelectorComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: TimeSelectorComponent,\n    selectors: [[\"kendo-timeselector\"]],\n    viewQuery: function TimeSelectorComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵviewQuery(_c90, 5);\n        ɵngcc0.ɵɵviewQuery(_c91, 5);\n        ɵngcc0.ɵɵviewQuery(_c92, 5);\n        ɵngcc0.ɵɵviewQuery(TimeListComponent, 5);\n        ɵngcc0.ɵɵviewQuery(_c93, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.accept = _t.first);\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.cancel = _t.first);\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.now = _t.first);\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.timeLists = _t);\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.timeListWrappers = _t);\n      }\n    },\n    hostVars: 4,\n    hostBindings: function TimeSelectorComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        ɵngcc0.ɵɵclassProp(\"k-timeselector\", ctx.componentClass)(\"k-state-disabled\", ctx.disabledClass);\n      }\n    },\n    inputs: {\n      format: \"format\",\n      min: \"min\",\n      max: \"max\",\n      cancelButton: \"cancelButton\",\n      setButton: \"setButton\",\n      nowButton: \"nowButton\",\n      disabled: \"disabled\",\n      value: \"value\",\n      steps: \"steps\"\n    },\n    outputs: {\n      valueChange: \"valueChange\",\n      valueReject: \"valueReject\"\n    },\n    exportAs: [\"kendo-timeselector\"],\n    features: [ɵngcc0.ɵɵProvidersFeature([LocalizationService, {\n      provide: L10N_PREFIX,\n      useValue: 'kendo.timeselector'\n    }]), ɵngcc0.ɵɵNgOnChangesFeature],\n    decls: 9,\n    vars: 4,\n    consts: function () {\n      let i18n_94;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The Accept button text in the timeselector component\n         * @meaning kendo.timeselector.accept\n         */\n        const MSG_EXTERNAL_5362895271044573681$$DIST_FESM2015_INDEX_JS_95 = goog.getMsg(\"Set\");\n        i18n_94 = MSG_EXTERNAL_5362895271044573681$$DIST_FESM2015_INDEX_JS_95;\n      } else {\n        i18n_94 = $localize`:kendo.timeselector.accept|The Accept button text in the timeselector component␟801811aa1609e3f173c86baa82cee037f75a215f␟5362895271044573681:Set`;\n      }\n\n      let i18n_96;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The label for the Accept button in the timeselector component\n         * @meaning kendo.timeselector.acceptLabel\n         */\n        const MSG_EXTERNAL_3417396278000787211$$DIST_FESM2015_INDEX_JS_97 = goog.getMsg(\"Set time\");\n        i18n_96 = MSG_EXTERNAL_3417396278000787211$$DIST_FESM2015_INDEX_JS_97;\n      } else {\n        i18n_96 = $localize`:kendo.timeselector.acceptLabel|The label for the Accept button in the timeselector component␟b4b1e5ac55f0330f6c4e32b866ae4339ad969978␟3417396278000787211:Set time`;\n      }\n\n      let i18n_98;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The Cancel button text in the timeselector component\n         * @meaning kendo.timeselector.cancel\n         */\n        const MSG_EXTERNAL_1890188482755567622$$DIST_FESM2015_INDEX_JS_99 = goog.getMsg(\"Cancel\");\n        i18n_98 = MSG_EXTERNAL_1890188482755567622$$DIST_FESM2015_INDEX_JS_99;\n      } else {\n        i18n_98 = $localize`:kendo.timeselector.cancel|The Cancel button text in the timeselector component␟3004d7704ffa6202a3b3925fcea490e486203a3e␟1890188482755567622:Cancel`;\n      }\n\n      let i18n_100;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The label for the Cancel button in the timeselector component\n         * @meaning kendo.timeselector.cancelLabel\n         */\n        const MSG_EXTERNAL_5738120209397145846$$DIST_FESM2015_INDEX_JS_101 = goog.getMsg(\"Cancel changes\");\n        i18n_100 = MSG_EXTERNAL_5738120209397145846$$DIST_FESM2015_INDEX_JS_101;\n      } else {\n        i18n_100 = $localize`:kendo.timeselector.cancelLabel|The label for the Cancel button in the timeselector component␟08dfbdfffd662371a6ff4c0b6ed82b9faa48143b␟5738120209397145846:Cancel changes`;\n      }\n\n      let i18n_102;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The Now button text in the timeselector component\n         * @meaning kendo.timeselector.now\n         */\n        const MSG_EXTERNAL_1926162752852226109$$DIST_FESM2015_INDEX_JS_103 = goog.getMsg(\"Now\");\n        i18n_102 = MSG_EXTERNAL_1926162752852226109$$DIST_FESM2015_INDEX_JS_103;\n      } else {\n        i18n_102 = $localize`:kendo.timeselector.now|The Now button text in the timeselector component␟98cba1ae36a7bbe15e1bac1837e07922ec109e7d␟1926162752852226109:Now`;\n      }\n\n      let i18n_104;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The label for the Now button in the timeselector component\n         * @meaning kendo.timeselector.nowLabel\n         */\n        const MSG_EXTERNAL_7789175884909488647$$DIST_FESM2015_INDEX_JS_105 = goog.getMsg(\"Select now\");\n        i18n_104 = MSG_EXTERNAL_7789175884909488647$$DIST_FESM2015_INDEX_JS_105;\n      } else {\n        i18n_104 = $localize`:kendo.timeselector.nowLabel|The label for the Now button in the timeselector component␟08e6a8a51d970609e138950fdd89c5cf201869f3␟7789175884909488647:Select now`;\n      }\n\n      return [[\"kendoTimeSelectorLocalizedMessages\", \"\", \"accept\", i18n_94, \"acceptLabel\", i18n_96, \"cancel\", i18n_98, \"cancelLabel\", i18n_100, \"now\", i18n_102, \"nowLabel\", i18n_104], [1, \"k-time-header\"], [1, \"k-title\", \"k-timeselector-title\"], [\"class\", \"k-button k-flat k-time-now\", \"type\", \"button\", 3, \"kendoEventsOutsideAngular\", \"scope\", \"disabled\", 4, \"ngIf\"], [1, \"k-time-list-container\"], [1, \"k-time-highlight\"], [\"ngFor\", \"\", 3, \"ngForOf\"], [\"class\", \"k-time-footer k-action-buttons\", 4, \"ngIf\"], [\"type\", \"button\", 1, \"k-button\", \"k-flat\", \"k-time-now\", 3, \"kendoEventsOutsideAngular\", \"scope\", \"disabled\"], [\"now\", \"\"], [\"class\", \"k-time-list-wrapper\", \"role\", \"presentation\", \"tabindex\", \"-1\", 4, \"ngIf\"], [\"class\", \"k-time-separator\", 4, \"ngIf\"], [\"role\", \"presentation\", \"tabindex\", \"-1\", 1, \"k-time-list-wrapper\"], [\"listWrapper\", \"\"], [3, \"min\", \"max\", \"part\", \"step\", \"disabled\", \"value\", \"kendoEventsOutsideAngular\", \"scope\", \"valueChange\"], [1, \"k-time-separator\"], [1, \"k-time-footer\", \"k-action-buttons\"], [\"class\", \"k-button k-time-cancel\", \"type\", \"button\", 3, \"kendoEventsOutsideAngular\", \"scope\", \"disabled\", 4, \"ngIf\"], [\"type\", \"button\", \"class\", \"k-time-accept k-button k-primary\", 3, \"kendoEventsOutsideAngular\", \"scope\", \"disabled\", 4, \"ngIf\"], [\"type\", \"button\", 1, \"k-button\", \"k-time-cancel\", 3, \"kendoEventsOutsideAngular\", \"scope\", \"disabled\"], [\"cancel\", \"\"], [\"type\", \"button\", 1, \"k-time-accept\", \"k-button\", \"k-primary\", 3, \"kendoEventsOutsideAngular\", \"scope\", \"disabled\"], [\"accept\", \"\"]];\n    },\n    template: function TimeSelectorComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵelementContainer(0, 0);\n        ɵngcc0.ɵɵelementStart(1, \"div\", 1);\n        ɵngcc0.ɵɵelementStart(2, \"span\", 2);\n        ɵngcc0.ɵɵtext(3);\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵtemplate(4, TimeSelectorComponent_button_4_Template, 3, 10, \"button\", 3);\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵelementStart(5, \"div\", 4);\n        ɵngcc0.ɵɵelement(6, \"span\", 5);\n        ɵngcc0.ɵɵtemplate(7, TimeSelectorComponent_ng_template_7_Template, 2, 2, \"ng-template\", 6);\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵtemplate(8, TimeSelectorComponent_div_8_Template, 3, 2, \"div\", 7);\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵadvance(3);\n        ɵngcc0.ɵɵtextInterpolate1(\" \", ctx.intl.formatDate(ctx.current, ctx.format), \" \");\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngIf\", ctx.showNowButton);\n        ɵngcc0.ɵɵadvance(3);\n        ɵngcc0.ɵɵproperty(\"ngForOf\", ctx.dateFormatParts);\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngIf\", ctx.setButton || ctx.cancelButton);\n      }\n    },\n    directives: function () {\n      return [TimeSelectorLocalizedMessagesDirective, ɵngcc2.NgIf, ɵngcc2.NgForOf, ɵngcc3.EventsOutsideAngularDirective, TimeListComponent];\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n\n  __decorate([ViewChild('accept', {\n    static: false\n  }), __metadata(\"design:type\", ElementRef)], TimeSelectorComponent.prototype, \"accept\", void 0);\n\n  __decorate([ViewChild('cancel', {\n    static: false\n  }), __metadata(\"design:type\", ElementRef)], TimeSelectorComponent.prototype, \"cancel\", void 0);\n\n  __decorate([ViewChild('now', {\n    static: false\n  }), __metadata(\"design:type\", ElementRef)], TimeSelectorComponent.prototype, \"now\", void 0);\n\n  __decorate([ViewChildren(TimeListComponent), __metadata(\"design:type\", QueryList)], TimeSelectorComponent.prototype, \"timeLists\", void 0);\n\n  __decorate([ViewChildren('listWrapper'), __metadata(\"design:type\", QueryList)], TimeSelectorComponent.prototype, \"timeListWrappers\", void 0);\n\n  __decorate([HostBinding('class.k-timeselector'), __metadata(\"design:type\", Boolean)], TimeSelectorComponent.prototype, \"componentClass\", void 0);\n\n  __decorate([HostBinding('class.k-state-disabled'), __metadata(\"design:type\", Boolean), __metadata(\"design:paramtypes\", [])], TimeSelectorComponent.prototype, \"disabledClass\", null);\n\n  __decorate([Input(), __metadata(\"design:type\", String)], TimeSelectorComponent.prototype, \"format\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", Date)], TimeSelectorComponent.prototype, \"min\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", Date)], TimeSelectorComponent.prototype, \"max\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", Boolean)], TimeSelectorComponent.prototype, \"cancelButton\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", Boolean)], TimeSelectorComponent.prototype, \"setButton\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", Boolean)], TimeSelectorComponent.prototype, \"nowButton\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", Boolean)], TimeSelectorComponent.prototype, \"disabled\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", Object), __metadata(\"design:paramtypes\", [Object])], TimeSelectorComponent.prototype, \"steps\", null);\n\n  __decorate([Input(), __metadata(\"design:type\", Date)], TimeSelectorComponent.prototype, \"value\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], TimeSelectorComponent.prototype, \"valueChange\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], TimeSelectorComponent.prototype, \"valueReject\", void 0);\n\n  TimeSelectorComponent = __decorate([__param(7, Optional()), __metadata(\"design:paramtypes\", [LocalizationService, ChangeDetectorRef, ElementRef, IntlService, TimePickerDOMService, NgZone, Renderer2, PickerService])], TimeSelectorComponent);\n  /**\n   * @hidden\n   */\n\n  return TimeSelectorComponent;\n})();\nlet TimePickerMessages = /*#__PURE__*/(() => {\n  class TimePickerMessages extends ComponentMessages {}\n\n  TimePickerMessages.ɵfac = /*@__PURE__*/function () {\n    let ɵTimePickerMessages_BaseFactory;\n    return function TimePickerMessages_Factory(t) {\n      return (ɵTimePickerMessages_BaseFactory || (ɵTimePickerMessages_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(TimePickerMessages)))(t || TimePickerMessages);\n    };\n  }();\n\n  TimePickerMessages.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: TimePickerMessages,\n    inputs: {\n      accept: \"accept\",\n      acceptLabel: \"acceptLabel\",\n      cancel: \"cancel\",\n      cancelLabel: \"cancelLabel\",\n      now: \"now\",\n      nowLabel: \"nowLabel\",\n      toggle: \"toggle\"\n    },\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature]\n  });\n\n  __decorate([Input(), __metadata(\"design:type\", String)], TimePickerMessages.prototype, \"accept\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", String)], TimePickerMessages.prototype, \"acceptLabel\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", String)], TimePickerMessages.prototype, \"cancel\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", String)], TimePickerMessages.prototype, \"cancelLabel\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", String)], TimePickerMessages.prototype, \"now\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", String)], TimePickerMessages.prototype, \"nowLabel\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", String)], TimePickerMessages.prototype, \"toggle\", void 0);\n\n  return TimePickerMessages;\n})();\nvar TimePickerLocalizedMessagesDirective_1;\n/**\n * @hidden\n */\n\nlet TimePickerLocalizedMessagesDirective = TimePickerLocalizedMessagesDirective_1 = class TimePickerLocalizedMessagesDirective extends TimePickerMessages {\n  constructor(service) {\n    super();\n    this.service = service;\n  }\n\n};\n\nTimePickerLocalizedMessagesDirective.ɵfac = function TimePickerLocalizedMessagesDirective_Factory(t) {\n  return new (t || TimePickerLocalizedMessagesDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc4.LocalizationService));\n};\n\nTimePickerLocalizedMessagesDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n  type: TimePickerLocalizedMessagesDirective,\n  selectors: [[\"\", \"kendoTimePickerLocalizedMessages\", \"\"]],\n  features: [ɵngcc0.ɵɵProvidersFeature([{\n    provide: TimePickerMessages,\n    useExisting: forwardRef(() => TimePickerLocalizedMessagesDirective_1) // tslint:disable-line:no-forward-ref\n\n  }]), ɵngcc0.ɵɵInheritDefinitionFeature]\n});\nTimePickerLocalizedMessagesDirective = TimePickerLocalizedMessagesDirective_1 = __decorate([__metadata(\"design:paramtypes\", [LocalizationService])], TimePickerLocalizedMessagesDirective);\nvar TimePickerCustomMessagesComponent_1;\n/**\n * Custom component messages override default component messages ([see example]({% slug globalization_dateinputs %}#toc-custom-messages)).\n */\n\nlet TimePickerCustomMessagesComponent = TimePickerCustomMessagesComponent_1 = class TimePickerCustomMessagesComponent extends TimePickerMessages {\n  constructor(service) {\n    super();\n    this.service = service;\n  }\n\n  get override() {\n    return true;\n  }\n\n};\n\nTimePickerCustomMessagesComponent.ɵfac = function TimePickerCustomMessagesComponent_Factory(t) {\n  return new (t || TimePickerCustomMessagesComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc4.LocalizationService));\n};\n\nTimePickerCustomMessagesComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n  type: TimePickerCustomMessagesComponent,\n  selectors: [[\"kendo-timepicker-messages\"]],\n  features: [ɵngcc0.ɵɵProvidersFeature([{\n    provide: TimePickerMessages,\n    useExisting: forwardRef(() => TimePickerCustomMessagesComponent_1) // tslint:disable-line:no-forward-ref\n\n  }]), ɵngcc0.ɵɵInheritDefinitionFeature],\n  decls: 0,\n  vars: 0,\n  template: function TimePickerCustomMessagesComponent_Template(rf, ctx) {},\n  encapsulation: 2\n});\nTimePickerCustomMessagesComponent = TimePickerCustomMessagesComponent_1 = __decorate([__metadata(\"design:paramtypes\", [LocalizationService])], TimePickerCustomMessagesComponent);\nvar TimeSelectorLocalizedMessagesDirective_1;\n/**\n * @hidden\n */\n\nlet TimeSelectorLocalizedMessagesDirective = TimeSelectorLocalizedMessagesDirective_1 = class TimeSelectorLocalizedMessagesDirective extends TimePickerMessages {\n  constructor(service) {\n    super();\n    this.service = service;\n  }\n\n};\n\nTimeSelectorLocalizedMessagesDirective.ɵfac = function TimeSelectorLocalizedMessagesDirective_Factory(t) {\n  return new (t || TimeSelectorLocalizedMessagesDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc4.LocalizationService));\n};\n\nTimeSelectorLocalizedMessagesDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n  type: TimeSelectorLocalizedMessagesDirective,\n  selectors: [[\"\", \"kendoTimeSelectorLocalizedMessages\", \"\"]],\n  features: [ɵngcc0.ɵɵProvidersFeature([{\n    provide: TimePickerMessages,\n    useExisting: forwardRef(() => TimeSelectorLocalizedMessagesDirective_1) // tslint:disable-line:no-forward-ref\n\n  }]), ɵngcc0.ɵɵInheritDefinitionFeature]\n});\nTimeSelectorLocalizedMessagesDirective = TimeSelectorLocalizedMessagesDirective_1 = __decorate([__metadata(\"design:paramtypes\", [LocalizationService])], TimeSelectorLocalizedMessagesDirective);\nvar TimeSelectorCustomMessagesComponent_1;\n/**\n * @hidden\n *\n * Custom component messages override default component messages.\n */\n\nlet TimeSelectorCustomMessagesComponent = TimeSelectorCustomMessagesComponent_1 = class TimeSelectorCustomMessagesComponent extends TimePickerMessages {\n  constructor(service) {\n    super();\n    this.service = service;\n  }\n\n  get override() {\n    return true;\n  }\n\n};\n\nTimeSelectorCustomMessagesComponent.ɵfac = function TimeSelectorCustomMessagesComponent_Factory(t) {\n  return new (t || TimeSelectorCustomMessagesComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc4.LocalizationService));\n};\n\nTimeSelectorCustomMessagesComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n  type: TimeSelectorCustomMessagesComponent,\n  selectors: [[\"kendo-timeselector-messages\"]],\n  features: [ɵngcc0.ɵɵProvidersFeature([{\n    provide: TimePickerMessages,\n    useExisting: forwardRef(() => TimeSelectorCustomMessagesComponent_1) // tslint:disable-line:no-forward-ref\n\n  }]), ɵngcc0.ɵɵInheritDefinitionFeature],\n  decls: 0,\n  vars: 0,\n  template: function TimeSelectorCustomMessagesComponent_Template(rf, ctx) {},\n  encapsulation: 2\n});\nTimeSelectorCustomMessagesComponent = TimeSelectorCustomMessagesComponent_1 = __decorate([__metadata(\"design:paramtypes\", [LocalizationService])], TimeSelectorCustomMessagesComponent);\nconst COMPONENT_DIRECTIVES$2 = [TimePickerLocalizedMessagesDirective, TimeListComponent, TimePickerCustomMessagesComponent, TimePickerComponent, TimeSelectorLocalizedMessagesDirective, TimeSelectorCustomMessagesComponent, TimeSelectorComponent];\nconst COMPONENT_MODULES$1 = [DateInputModule, IntlModule, PopupModule, VirtualizationModule, EventsModule];\nconst ɵ0$o = touchEnabled;\nconst providers = [TimePickerDOMService, HoursService, MinutesService, SecondsService, MillisecondsService, DayPeriodService, {\n  provide: TOUCH_ENABLED,\n  useValue: ɵ0$o\n}];\n/**\n * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})\n * definition for the TimePicker component.\n */\n\nlet TimePickerModule = /*#__PURE__*/(() => {\n  let TimePickerModule = class TimePickerModule {};\n\n  TimePickerModule.ɵfac = function TimePickerModule_Factory(t) {\n    return new (t || TimePickerModule)();\n  };\n\n  TimePickerModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: TimePickerModule\n  });\n  TimePickerModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    providers: providers,\n    imports: [[CommonModule, ...COMPONENT_MODULES$1]]\n  });\n  /**\n   * @hidden\n   */\n\n  return TimePickerModule;\n})();\nlet Messages$1 = /*#__PURE__*/(() => {\n  class Messages$1 extends ComponentMessages {}\n\n  Messages$1.ɵfac = /*@__PURE__*/function () {\n    let ɵMessages$1_BaseFactory;\n    return function Messages$1_Factory(t) {\n      return (ɵMessages$1_BaseFactory || (ɵMessages$1_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(Messages$1)))(t || Messages$1);\n    };\n  }();\n\n  Messages$1.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: Messages$1,\n    inputs: {\n      toggle: \"toggle\",\n      dateTab: \"dateTab\",\n      dateTabLabel: \"dateTabLabel\",\n      timeTab: \"timeTab\",\n      timeTabLabel: \"timeTabLabel\",\n      accept: \"accept\",\n      acceptLabel: \"acceptLabel\",\n      cancel: \"cancel\",\n      cancelLabel: \"cancelLabel\",\n      today: \"today\",\n      now: \"now\",\n      nowLabel: \"nowLabel\",\n      prevButtonTitle: \"prevButtonTitle\",\n      nextButtonTitle: \"nextButtonTitle\"\n    },\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature]\n  });\n\n  __decorate([Input(), __metadata(\"design:type\", String)], Messages$1.prototype, \"toggle\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", String)], Messages$1.prototype, \"dateTab\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", String)], Messages$1.prototype, \"dateTabLabel\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", String)], Messages$1.prototype, \"timeTab\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", String)], Messages$1.prototype, \"timeTabLabel\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", String)], Messages$1.prototype, \"accept\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", String)], Messages$1.prototype, \"acceptLabel\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", String)], Messages$1.prototype, \"cancel\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", String)], Messages$1.prototype, \"cancelLabel\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", String)], Messages$1.prototype, \"today\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", String)], Messages$1.prototype, \"now\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", String)], Messages$1.prototype, \"nowLabel\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", String)], Messages$1.prototype, \"prevButtonTitle\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", String)], Messages$1.prototype, \"nextButtonTitle\", void 0);\n\n  return Messages$1;\n})();\nvar DateTimePickerCustomMessagesComponent_1;\n/**\n * Custom component messages override default component messages ([see example]({% slug globalization_dateinputs %}#toc-custom-messages)).\n */\n\nlet DateTimePickerCustomMessagesComponent = DateTimePickerCustomMessagesComponent_1 = class DateTimePickerCustomMessagesComponent extends Messages$1 {\n  constructor(service) {\n    super();\n    this.service = service;\n  }\n\n  get override() {\n    return true;\n  }\n\n};\n\nDateTimePickerCustomMessagesComponent.ɵfac = function DateTimePickerCustomMessagesComponent_Factory(t) {\n  return new (t || DateTimePickerCustomMessagesComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc4.LocalizationService));\n};\n\nDateTimePickerCustomMessagesComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n  type: DateTimePickerCustomMessagesComponent,\n  selectors: [[\"kendo-datetimepicker-messages\"]],\n  features: [ɵngcc0.ɵɵProvidersFeature([{\n    provide: Messages$1,\n    useExisting: forwardRef(() => DateTimePickerCustomMessagesComponent_1)\n  }]), ɵngcc0.ɵɵInheritDefinitionFeature],\n  decls: 0,\n  vars: 0,\n  template: function DateTimePickerCustomMessagesComponent_Template(rf, ctx) {},\n  encapsulation: 2\n});\nDateTimePickerCustomMessagesComponent = DateTimePickerCustomMessagesComponent_1 = __decorate([__metadata(\"design:paramtypes\", [LocalizationService])], DateTimePickerCustomMessagesComponent);\nvar LocalizedMessagesDirective_1;\n/**\n * @hidden\n */\n\nlet LocalizedMessagesDirective = LocalizedMessagesDirective_1 = class LocalizedMessagesDirective extends Messages$1 {\n  constructor(service) {\n    super();\n    this.service = service;\n  }\n\n};\n\nLocalizedMessagesDirective.ɵfac = function LocalizedMessagesDirective_Factory(t) {\n  return new (t || LocalizedMessagesDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc4.LocalizationService));\n};\n\nLocalizedMessagesDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n  type: LocalizedMessagesDirective,\n  selectors: [[\"\", \"kendoDateTimePickerLocalizedMessages\", \"\"]],\n  features: [ɵngcc0.ɵɵProvidersFeature([{\n    provide: Messages$1,\n    useExisting: forwardRef(() => LocalizedMessagesDirective_1)\n  }]), ɵngcc0.ɵɵInheritDefinitionFeature]\n});\nLocalizedMessagesDirective = LocalizedMessagesDirective_1 = __decorate([__metadata(\"design:paramtypes\", [LocalizationService])], LocalizedMessagesDirective);\nconst COMPONENT_DIRECTIVES$3 = [DateTimePickerComponent, DateTimePickerCustomMessagesComponent, LocalizedMessagesDirective];\nconst ɵ0$p = touchEnabled;\n/**\n * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})\n * definition for the DateTimePicker component.\n */\n\nlet DateTimePickerModule = /*#__PURE__*/(() => {\n  let DateTimePickerModule = class DateTimePickerModule {};\n\n  DateTimePickerModule.ɵfac = function DateTimePickerModule_Factory(t) {\n    return new (t || DateTimePickerModule)();\n  };\n\n  DateTimePickerModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: DateTimePickerModule\n  });\n  DateTimePickerModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    providers: [{\n      provide: TOUCH_ENABLED,\n      useValue: ɵ0$p\n    }],\n    imports: [[CommonModule, IntlModule, DateInputModule, CalendarModule, TimePickerModule, PopupModule, EventsModule, TemplatesModule], TemplatesModule]\n  });\n  return DateTimePickerModule;\n})();\nconst COMPONENT_MODULES$2 = [CalendarsModule, DateInputModule, DatePickerModule, TimePickerModule, DateRangeModule, DateTimePickerModule];\n/**\n * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})\n * definition for the Date Inputs components.\n *\n * @example\n *\n * ```ts-no-run\n * // Import the Date Inputs module\n * import { DateInputsModule } from '@progress/kendo-angular-dateinputs';\n *\n * // The browser platform with a compiler\n * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n *\n * import { NgModule } from '@angular/core';\n *\n * // Import the app component\n * import { AppComponent } from './app.component';\n *\n * // Define the app module\n * _@NgModule({\n *     declarations: [AppComponent], // declare the app component\n *     imports:      [BrowserModule, DateInputsModule], // import the Date Inputs module\n *     bootstrap:    [AppComponent]\n * })\n * export class AppModule {}\n *\n * // Compile and launch the module\n * platformBrowserDynamic().bootstrapModule(AppModule);\n *\n * ```\n */\n\nlet DateInputsModule = /*#__PURE__*/(() => {\n  let DateInputsModule = class DateInputsModule {};\n\n  DateInputsModule.ɵfac = function DateInputsModule_Factory(t) {\n    return new (t || DateInputsModule)();\n  };\n\n  DateInputsModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: DateInputsModule\n  });\n  DateInputsModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    imports: [COMPONENT_MODULES$2, CalendarsModule, DateInputModule, DatePickerModule, TimePickerModule, DateRangeModule, DateTimePickerModule]\n  });\n  return DateInputsModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(CalendarCommonModule, {\n    declarations: function () {\n      return [KForOf, HeaderComponent, ViewComponent];\n    },\n    imports: function () {\n      return [CommonModule, EventsModule];\n    },\n    exports: function () {\n      return [KForOf, HeaderComponent, ViewComponent];\n    }\n  });\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(TemplatesModule, {\n    declarations: [CellTemplateDirective, MonthCellTemplateDirective, YearCellTemplateDirective, DecadeCellTemplateDirective, CenturyCellTemplateDirective, WeekNumberCellTemplateDirective, HeaderTitleTemplateDirective, NavigationItemTemplateDirective],\n    exports: [CellTemplateDirective, MonthCellTemplateDirective, YearCellTemplateDirective, DecadeCellTemplateDirective, CenturyCellTemplateDirective, WeekNumberCellTemplateDirective, HeaderTitleTemplateDirective, NavigationItemTemplateDirective]\n  });\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MultiViewCalendarModule, {\n    declarations: function () {\n      return [HorizontalViewListComponent, MultiViewCalendarLocalizedMessagesDirective, MultiViewCalendarCustomMessagesComponent, MultiViewCalendarComponent];\n    },\n    imports: function () {\n      return [CommonModule, CalendarCommonModule, IntlModule, TemplatesModule, PopupModule];\n    },\n    exports: function () {\n      return [HorizontalViewListComponent, MultiViewCalendarLocalizedMessagesDirective, MultiViewCalendarCustomMessagesComponent, MultiViewCalendarComponent, CalendarCommonModule, TemplatesModule];\n    }\n  });\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(VirtualizationModule, {\n    declarations: function () {\n      return [VirtualizationComponent];\n    },\n    imports: function () {\n      return [CommonModule];\n    },\n    exports: function () {\n      return [VirtualizationComponent];\n    }\n  });\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(CalendarModule, {\n    declarations: function () {\n      return [CalendarComponent, NavigationComponent, CalendarCustomMessagesComponent, CalendarLocalizedMessagesDirective, ViewListComponent];\n    },\n    imports: function () {\n      return [CommonModule, CalendarCommonModule, MultiViewCalendarModule, IntlModule, TemplatesModule, VirtualizationModule, EventsModule, ResizeSensorModule];\n    },\n    exports: function () {\n      return [CalendarComponent, NavigationComponent, CalendarCustomMessagesComponent, CalendarLocalizedMessagesDirective, ViewListComponent, CalendarCommonModule, TemplatesModule];\n    }\n  });\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(CalendarsModule, {\n    imports: [CalendarModule, MultiViewCalendarModule],\n    exports: [CalendarModule, MultiViewCalendarModule]\n  });\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(DateInputModule, {\n    declarations: function () {\n      return [DateInputComponent, DateInputCustomMessagesComponent, DateInputLocalizedMessagesDirective];\n    },\n    imports: function () {\n      return [CommonModule, IntlModule, EventsModule];\n    },\n    exports: function () {\n      return [DateInputComponent, DateInputCustomMessagesComponent, DateInputLocalizedMessagesDirective];\n    }\n  });\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(DatePickerModule, {\n    declarations: function () {\n      return [DatePickerComponent, DatePickerCustomMessagesComponent, DatePickerLocalizedMessagesDirective];\n    },\n    imports: function () {\n      return [CommonModule, DateInputModule, CalendarModule, IntlModule, PopupModule, TemplatesModule, EventsModule];\n    },\n    exports: function () {\n      return [DatePickerComponent, DatePickerCustomMessagesComponent, DatePickerLocalizedMessagesDirective, TemplatesModule];\n    }\n  });\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(DateRangeModule, {\n    declarations: function () {\n      return [DateRangeComponent, DateRangePopupComponent, DateRangePopupTemplateDirective, DateRangeSelectionDirective, DateRangeStartInputDirective, DateRangeEndInputDirective];\n    },\n    imports: function () {\n      return [CommonModule, MultiViewCalendarModule, DateInputModule, PopupModule, EventsModule];\n    },\n    exports: function () {\n      return [DateRangeComponent, DateRangePopupComponent, DateRangePopupTemplateDirective, DateRangeSelectionDirective, DateRangeStartInputDirective, DateRangeEndInputDirective];\n    }\n  });\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(TimePickerModule, {\n    declarations: function () {\n      return [TimePickerLocalizedMessagesDirective, TimeListComponent, TimePickerCustomMessagesComponent, TimePickerComponent, TimeSelectorLocalizedMessagesDirective, TimeSelectorCustomMessagesComponent, TimeSelectorComponent];\n    },\n    imports: function () {\n      return [CommonModule, DateInputModule, IntlModule, PopupModule, VirtualizationModule, EventsModule];\n    },\n    exports: function () {\n      return [TimePickerLocalizedMessagesDirective, TimeListComponent, TimePickerCustomMessagesComponent, TimePickerComponent, TimeSelectorLocalizedMessagesDirective, TimeSelectorCustomMessagesComponent, TimeSelectorComponent];\n    }\n  });\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(DateTimePickerModule, {\n    declarations: function () {\n      return [DateTimePickerComponent, DateTimePickerCustomMessagesComponent, LocalizedMessagesDirective];\n    },\n    imports: function () {\n      return [CommonModule, IntlModule, DateInputModule, CalendarModule, TimePickerModule, PopupModule, EventsModule, TemplatesModule];\n    },\n    exports: function () {\n      return [DateTimePickerComponent, DateTimePickerCustomMessagesComponent, LocalizedMessagesDirective, TemplatesModule];\n    }\n  });\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(DateInputsModule, {\n    imports: [CalendarsModule, DateInputModule, DatePickerModule, TimePickerModule, DateRangeModule, DateTimePickerModule],\n    exports: [CalendarsModule, DateInputModule, DatePickerModule, TimePickerModule, DateRangeModule, DateTimePickerModule]\n  });\n})();\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { CalendarCommonModule, CALENDAR_RANGE_VALIDATORS, CALENDAR_VALUE_ACCESSOR, KENDO_INPUT_PROVIDER, KForOf, KForOfContext, HeaderComponent, HorizontalViewListComponent, CalendarMessages, MultiViewCalendarCustomMessagesComponent, Messages, RANGE_CALENDAR_RANGE_VALIDATORS, RANGE_CALENDAR_VALUE_ACCESSOR, NavigationComponent, BusViewService, CenturyViewService, DecadeViewService, DisabledDatesService, CalendarDOMService, MonthViewService, NavigationService, ScrollSyncService, SelectionService, WeekNamesService, YearViewService, TemplatesModule, CellTemplateDirective, CenturyCellTemplateDirective, DecadeCellTemplateDirective, HeaderTitleTemplateDirective, MonthCellTemplateDirective, NavigationItemTemplateDirective, WeekNumberCellTemplateDirective, YearCellTemplateDirective, ViewListComponent, ViewComponent, PickerService, DateInputMessages, DatePickerMessages, DateRangeInput, DateRangePopupTemplateDirective, DateTimePickerCustomMessagesComponent, LocalizedMessagesDirective, Messages$1, TimePickerMessages, TimePickerCustomMessagesComponent, TimeSelectorCustomMessagesComponent, DayPeriodService, TimePickerDOMService, HoursService, MillisecondsService, MinutesService, SecondsService, TimeListComponent, TimeSelectorComponent, TOUCH_ENABLED, ScrollerService, DEFAULT_SCROLLER_FACTORY, SCROLLER_FACTORY_TOKEN, VirtualizationComponent, VirtualizationModule, CalendarComponent, DateInputComponent, DatePickerComponent, TimePickerComponent, DateTimePickerComponent, MultiViewCalendarComponent, DateRangeComponent, DateRangePopupComponent, DateRangeEndInputDirective, DateRangeStartInputDirective, DateRangeSelectionDirective, CalendarModule, CalendarsModule, DateInputModule, DatePickerModule, DateInputsModule, TimePickerModule, DateTimePickerModule, MultiViewCalendarModule, DateRangeModule, DateRangeService, CalendarCustomMessagesComponent, DateInputCustomMessagesComponent, DatePickerCustomMessagesComponent, PreventableEvent, CalendarLocalizedMessagesDirective, MultiViewCalendarLocalizedMessagesDirective, DateInputLocalizedMessagesDirective, DatePickerLocalizedMessagesDirective, TimePickerLocalizedMessagesDirective, TimeSelectorLocalizedMessagesDirective }; //# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VzIjpbImluZGV4LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztnS0FHdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7NkpBR3NCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzswSkFBRTtBQUNGLCtCQUVHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzt1SkFBRTtBQUNGLDhCQUVHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztvSkFBRTtBQUNGLDZCQUVHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztnS0FHdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OzsyREFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FnQkc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvTUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FnQ0c7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7cUxBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBMkRHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs2SkFBRTtBQUNGLGdDQUVHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7c0tBR3lCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OzBKQUFFO0FBQ0YsK0JBRUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7NkpBQUU7QUFDRixnQ0FFRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzt5SkFBRTtBQUNGLG9DQUlHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O3dLQUFFO0FBQ0YseUNBSUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7cUtBQUU7QUFDRix3Q0FJRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7MktBQUU7QUFDRiwwQ0FJRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OEtBQUU7QUFDRiwyQ0FJRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzt1TEFBRTtBQUNGLDhDQUlHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OEtBQUU7QUFDRiwyQ0FJRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O3VMQUFFO0FBQ0YsOENBSUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7cUhBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b1JBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQXdHRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OytLQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQTJFRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzsyT0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBOEdHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzttUEFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBOEdHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7MFNBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBZ1FHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OzBKQUFFO0FBQ0YsK0JBRUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7b0xBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQTJFRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztrTEFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQXVFRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7K0tBQUU7QUFDRiw4Q0FJRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OzBKQUdxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7NEhBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBV0c7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O2lGQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FTRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OytTQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUlHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztxVEFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FJRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7NFhBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUlHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7cVBBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUVHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozt1SEFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFxREc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7K0lBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBb0RHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OzsrR0FleUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7aUVBd0JvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OzhOQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztrREFBRTtBQUNGLDBHQVVHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OzBLQUFFO0FBQ0Ysb0dBV0c7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7MklBMkI0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OzhPQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztrREFBRTtBQUNGLHdGQVVHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O2lLQUFFO0FBQ0Ysa0ZBV0c7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O2lHQU95QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztxREFzQ21CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7dURBWW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7d01BQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztrREFBRTtBQUNGLDBGQVVHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O2tLQUFFO0FBQ0Ysb0ZBV0c7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7c0hBZW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7b1FBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7a0RBQUU7QUFDRiw0RkFVRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OzttS0FBRTtBQUNGLHNGQVdHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OzsrQkF5QnFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OzsrR0FPb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztzS0FHeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OElBQUU7QUFDRiwyQkFFRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztvSkFBRTtBQUNGLDZCQUVHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O29KQUFFO0FBQ0YsNkJBRUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7bUtBQUU7QUFDRixrQ0FFRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzswSkFBRTtBQUNGLCtCQUVHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzBJQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQThCRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O3FOQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQW1IRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7MFNBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7a0RBQUU7QUFDRiw0RkFVRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OzttS0FBRTtBQUNGLHNGQVdHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O2tEQUFFO0FBQ0YsZ0dBVUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O3FLQUFFO0FBQ0YsMEZBV0c7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OzJJQVFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O3NkQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7dUtBQUU7QUFDRiw4RkFXRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztrREFBRTtBQUNGLHdFQVVHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7K0JBd0J5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBTXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXNDb250ZW50IjpbIi8qKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4qIENvcHlyaWdodCDCqSAyMDIxIFByb2dyZXNzIFNvZnR3YXJlIENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuKiBMaWNlbnNlZCB1bmRlciBjb21tZXJjaWFsIGxpY2Vuc2UuIFNlZSBMSUNFTlNFLm1kIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIG1vcmUgaW5mb3JtYXRpb25cbiotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmltcG9ydCB7IF9fZGVjb3JhdGUsIF9fbWV0YWRhdGEsIF9fcGFyYW0gfSBmcm9tICd0c2xpYic7XG5pbXBvcnQgeyBJbmplY3RhYmxlLCBFdmVudEVtaXR0ZXIsIEluamVjdG9yLCBJbmplY3Rpb25Ub2tlbiwgSW5wdXQsIE91dHB1dCwgSG9zdEJpbmRpbmcsIENvbXBvbmVudCwgSW5qZWN0LCBFbGVtZW50UmVmLCBSZW5kZXJlcjIsIE5nWm9uZSwgVGVtcGxhdGVSZWYsIFZpZXdDaGlsZCwgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksIENoYW5nZURldGVjdG9yUmVmLCBpc0Rldk1vZGUsIERpcmVjdGl2ZSwgZm9yd2FyZFJlZiwgQ29udGVudENoaWxkLCBPcHRpb25hbCwgVmlld0NvbnRhaW5lclJlZiwgSG9zdExpc3RlbmVyLCBWaWV3Q2hpbGRyZW4sIFF1ZXJ5TGlzdCwgQ29udGVudENoaWxkcmVuLCBJdGVyYWJsZURpZmZlcnMsIE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBOR19WQUxVRV9BQ0NFU1NPUiwgTkdfVkFMSURBVE9SUywgTmdDb250cm9sIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHsgTG9jYWxpemF0aW9uU2VydmljZSwgTDEwTl9QUkVGSVgsIFJUTCwgQ29tcG9uZW50TWVzc2FnZXMgfSBmcm9tICdAcHJvZ3Jlc3Mva2VuZG8tYW5ndWxhci1sMTBuJztcbmltcG9ydCB7IGdldERhdGUsIGlzRXF1YWwsIGNsb25lRGF0ZSwgYWRkRGF5cywgYWRkRGVjYWRlcywgYWRkQ2VudHVyaWVzLCBmaXJzdERlY2FkZU9mQ2VudHVyeSwgbGFzdERlY2FkZU9mQ2VudHVyeSwgZmlyc3RZZWFyT2ZEZWNhZGUsIGNyZWF0ZURhdGUsIGR1cmF0aW9uSW5DZW50dXJpZXMsIGFkZFllYXJzLCBsYXN0WWVhck9mRGVjYWRlLCBkdXJhdGlvbkluRGVjYWRlcywgYWRkV2Vla3MsIGFkZE1vbnRocywgZmlyc3REYXlPZk1vbnRoLCBsYXN0RGF5T2ZNb250aCwgZGF5T2ZXZWVrLCBkdXJhdGlvbkluTW9udGhzLCBmaXJzdE1vbnRoT2ZZZWFyLCBsYXN0TW9udGhPZlllYXIsIGR1cmF0aW9uSW5ZZWFycywgd2Vla0luWWVhciB9IGZyb20gJ0Bwcm9ncmVzcy9rZW5kby1kYXRlLW1hdGgnO1xuaW1wb3J0IHsgaXNEb2N1bWVudEF2YWlsYWJsZSwgS2VuZG9JbnB1dCwgZ3VpZCwgaGFzT2JzZXJ2ZXJzLCBLZXlzLCBFdmVudHNNb2R1bGUsIFJlc2l6ZVNlbnNvck1vZHVsZSB9IGZyb20gJ0Bwcm9ncmVzcy9rZW5kby1hbmd1bGFyLWNvbW1vbic7XG5pbXBvcnQgeyB2YWxpZGF0ZVBhY2thZ2UgfSBmcm9tICdAcHJvZ3Jlc3Mva2VuZG8tbGljZW5zaW5nJztcbmltcG9ydCB7IEludGxTZXJ2aWNlLCBJbnRsTW9kdWxlIH0gZnJvbSAnQHByb2dyZXNzL2tlbmRvLWFuZ3VsYXItaW50bCc7XG5pbXBvcnQgeyBSZXBsYXlTdWJqZWN0LCBPYnNlcnZhYmxlLCBTdWJqZWN0LCBjb21iaW5lTGF0ZXN0LCBvZiwgaW50ZXJ2YWwsIGFuaW1hdGlvbkZyYW1lU2NoZWR1bGVyLCBmcm9tRXZlbnQsIEVNUFRZLCBmcm9tLCBTdWJzY3JpcHRpb24sIEJlaGF2aW9yU3ViamVjdCwgbWVyZ2UgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IG1hcCwgc2NhbiwgdGFrZVdoaWxlLCB0YXAsIGZpbHRlciwgZGVib3VuY2VUaW1lIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgUG9wdXBTZXJ2aWNlLCBQb3B1cE1vZHVsZSB9IGZyb20gJ0Bwcm9ncmVzcy9rZW5kby1hbmd1bGFyLXBvcHVwJztcbmltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyB0b3VjaEVuYWJsZWQgfSBmcm9tICdAcHJvZ3Jlc3Mva2VuZG8tY29tbW9uJztcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IHBhY2thZ2VNZXRhZGF0YSA9IHtcbiAgICBuYW1lOiAnQHByb2dyZXNzL2tlbmRvLWFuZ3VsYXItZGF0ZWlucHV0cycsXG4gICAgcHJvZHVjdE5hbWU6ICdLZW5kbyBVSSBmb3IgQW5ndWxhcicsXG4gICAgcHJvZHVjdENvZGVzOiBbJ0tFTkRPVUlBTkdVTEFSJywgJ0tFTkRPVUlDT01QTEVURSddLFxuICAgIHB1Ymxpc2hEYXRlOiAxNjMxNjIzNjE4LFxuICAgIHZlcnNpb246ICcnLFxuICAgIGxpY2Vuc2luZ0RvY3NVcmw6ICdodHRwczovL3d3dy50ZWxlcmlrLmNvbS9rZW5kby1hbmd1bGFyLXVpL215LWxpY2Vuc2UvP3V0bV9tZWRpdW09cHJvZHVjdCZ1dG1fc291cmNlPWtlbmRvYW5ndWxhciZ1dG1fY2FtcGFpZ249a2VuZG8tdWktYW5ndWxhci1wdXJjaGFzZS1saWNlbnNlLWtleXMtd2FybmluZydcbn07XG5cbi8qKlxuICogQGhpZGRlblxuICovXG52YXIgQWN0aW9uO1xuKGZ1bmN0aW9uIChBY3Rpb24pIHtcbiAgICBBY3Rpb25bQWN0aW9uW1wiTGVmdFwiXSA9IDBdID0gXCJMZWZ0XCI7XG4gICAgQWN0aW9uW0FjdGlvbltcIlJpZ2h0XCJdID0gMV0gPSBcIlJpZ2h0XCI7XG4gICAgQWN0aW9uW0FjdGlvbltcIlVwXCJdID0gMl0gPSBcIlVwXCI7XG4gICAgQWN0aW9uW0FjdGlvbltcIkRvd25cIl0gPSAzXSA9IFwiRG93blwiO1xuICAgIEFjdGlvbltBY3Rpb25bXCJQcmV2Vmlld1wiXSA9IDRdID0gXCJQcmV2Vmlld1wiO1xuICAgIEFjdGlvbltBY3Rpb25bXCJOZXh0Vmlld1wiXSA9IDVdID0gXCJOZXh0Vmlld1wiO1xuICAgIEFjdGlvbltBY3Rpb25bXCJGaXJzdEluVmlld1wiXSA9IDZdID0gXCJGaXJzdEluVmlld1wiO1xuICAgIEFjdGlvbltBY3Rpb25bXCJMYXN0SW5WaWV3XCJdID0gN10gPSBcIkxhc3RJblZpZXdcIjtcbiAgICBBY3Rpb25bQWN0aW9uW1wiTG93ZXJWaWV3XCJdID0gOF0gPSBcIkxvd2VyVmlld1wiO1xuICAgIEFjdGlvbltBY3Rpb25bXCJVcHBlclZpZXdcIl0gPSA5XSA9IFwiVXBwZXJWaWV3XCI7XG59KShBY3Rpb24gfHwgKEFjdGlvbiA9IHt9KSk7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBFTVBUWV9TRUxFQ1RJT05SQU5HRSA9IHsgc3RhcnQ6IG51bGwsIGVuZDogbnVsbCB9O1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgTUlETklHSFRfREFURSA9IG5ldyBEYXRlKDE5ODAsIDAsIDEpO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IE1JTl9EQVRFID0gbmV3IERhdGUoMTkwMCwgMCwgMSk7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgTUFYX0RBVEUgPSBuZXcgRGF0ZSgyMDk5LCAxMSwgMzEpO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IE1JTl9USU1FID0gbmV3IERhdGUoMTk4MCwgMCwgMSk7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgTUFYX1RJTUUgPSBuZXcgRGF0ZSgxOTgwLCAwLCAxLCAyMywgNTksIDU5KTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IHJlcXVpcmVzWm9uZU9uQmx1ciA9IChuZ0NvbnRyb2wpID0+IG5nQ29udHJvbCAmJlxuICAgICghbmdDb250cm9sLnRvdWNoZWQgfHwgKG5nQ29udHJvbC5jb250cm9sICYmIG5nQ29udHJvbC5jb250cm9sLnVwZGF0ZU9uID09PSAnYmx1cicpKTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBwcmV2ZW50RGVmYXVsdCA9IChhcmdzKSA9PiBhcmdzLnByZXZlbnREZWZhdWx0KCk7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgY3VycmVudEZvY3VzVGFyZ2V0ID0gKGJsdXJBcmdzKSA9PiBibHVyQXJncy5yZWxhdGVkVGFyZ2V0IHx8IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgaXNQcmVzZW50ID0gKHZhbHVlKSA9PiB2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsO1xuLyoqXG4gKiBAaGlkZGVuXG4gKlxuICogSWYgdGhlIHByb3ZpZGVkIHBhcmFtZXRlciBpcyBhbiBhcnJheSB3aXRoIGF0IGxlYXN0IG9uZSBpdGVtXG4gKiBhbmQgYWxsIGl0ZW1zIGluIHRoZSBhcnJheSBhcmUgbnVtYmVycywgcmV0dXJucyBgdHJ1ZS5cbiAqL1xuY29uc3QgaXNOdW1iZXJBcnJheSA9ICh2YWx1ZSkgPT4gQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgdmFsdWUubGVuZ3RoID4gMCAmJiB2YWx1ZS5ldmVyeShpdGVtID0+IHR5cGVvZiBpdGVtID09PSAnbnVtYmVyJyk7XG4vKipcbiAqIEBoaWRkZW5cbiAqXG4gKiBJZiB0aGUgcHJvdmlkZWQgcGFyYW1ldGVyIGlzIGFuIGFycmF5IHdpdGggYXQgbGVhc3Qgb25lIGl0ZW1cbiAqIGFuZCBhbGwgaXRlbXMgaW4gdGhlIGFycmF5IGFyZSBkYXRlcywgcmV0dXJucyBgdHJ1ZWAuXG4gKi9cbmNvbnN0IGlzRGF0ZUFycmF5ID0gKHZhbHVlKSA9PiBBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGggPiAwICYmIHZhbHVlLmV2ZXJ5KGl0ZW0gPT4gaXRlbSBpbnN0YW5jZW9mIERhdGUpO1xuXG4vKiB0c2xpbnQ6ZGlzYWJsZTpuby1iaXR3aXNlIG1heC1saW5lLWxlbmd0aCAqL1xuY29uc3QgaXNTZXQgPSAodmFsdWUpID0+IHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB1bmRlZmluZWQ7XG5jb25zdCBzZXR0ZXIgPSAobWV0aG9kKSA9PiAoZGF0ZSwgdmFsdWUpID0+IHtcbiAgICBjb25zdCBjbG9uZSA9IGNsb25lRGF0ZShkYXRlKTtcbiAgICBjbG9uZVttZXRob2RdKHZhbHVlKTtcbiAgICByZXR1cm4gY2xvbmU7XG59O1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IHNldFRpbWUgPSAob3JpZ2luLCBjYW5kaWRhdGUpID0+IHtcbiAgICBjb25zdCBkYXRlID0gY2xvbmVEYXRlKG9yaWdpbik7XG4gICAgZGF0ZS5zZXRIb3VycyhjYW5kaWRhdGUuZ2V0SG91cnMoKSwgY2FuZGlkYXRlLmdldE1pbnV0ZXMoKSwgY2FuZGlkYXRlLmdldFNlY29uZHMoKSwgY2FuZGlkYXRlLmdldE1pbGxpc2Vjb25kcygpKTtcbiAgICByZXR1cm4gZGF0ZTtcbn07XG5jb25zdCBub3JtYWxpemVUaW1lcyA9IChjYW5kaWRhdGUsIG1pbiwgbWF4KSA9PiAoe1xuICAgIGNhbmRpZGF0ZVZhbHVlOiBzZXRUaW1lKE1JRE5JR0hUX0RBVEUsIGNhbmRpZGF0ZSksXG4gICAgbWF4VmFsdWU6IGFkZERheXMoc2V0VGltZShNSUROSUdIVF9EQVRFLCBtYXgpLCBtaW4uZ2V0SG91cnMoKSA8IG1heC5nZXRIb3VycygpIHx8XG4gICAgICAgIChtaW4uZ2V0SG91cnMoKSA9PT0gbWF4LmdldEhvdXJzKCkgJiYgbWluLmdldE1pbnV0ZXMoKSA8IG1heC5nZXRNaW51dGVzKCkpID8gMCA6IDEpLFxuICAgIG1pblZhbHVlOiBzZXRUaW1lKE1JRE5JR0hUX0RBVEUsIG1pbilcbn0pO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IHNldFllYXJzID0gc2V0dGVyKCdzZXRGdWxsWWVhcicpO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IHNldEhvdXJzID0gc2V0dGVyKCdzZXRIb3VycycpO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IHNldE1pbnV0ZXMgPSBzZXR0ZXIoJ3NldE1pbnV0ZXMnKTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBzZXRTZWNvbmRzID0gc2V0dGVyKCdzZXRTZWNvbmRzJyk7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3Qgc2V0TWlsbGlzZWNvbmRzID0gc2V0dGVyKCdzZXRNaWxsaXNlY29uZHMnKTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCByYW5nZSA9IChzdGFydCwgZW5kLCBzdGVwID0gMSkgPT4ge1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGVuZDsgaSA9IGkgKyBzdGVwKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKGkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBpc0luUmFuZ2UgPSAoY2FuZGlkYXRlLCBtaW4sIG1heCkgPT4gKCFjYW5kaWRhdGUgfHwgISgobWluICYmIG1pbiA+IGNhbmRpZGF0ZSkgfHwgKG1heCAmJiBtYXggPCBjYW5kaWRhdGUpKSk7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgaXNJblRpbWVSYW5nZSA9IChjYW5kaWRhdGUsIG1pbiwgbWF4KSA9PiB7XG4gICAgaWYgKCFjYW5kaWRhdGUgfHwgIW1pbiB8fCAhbWF4KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjb25zdCB7IGNhbmRpZGF0ZVZhbHVlLCBtaW5WYWx1ZSwgbWF4VmFsdWUgfSA9IG5vcm1hbGl6ZVRpbWVzKGNhbmRpZGF0ZSwgbWluLCBtYXgpO1xuICAgIHJldHVybiBtaW5WYWx1ZSA8PSBjYW5kaWRhdGVWYWx1ZSAmJiBjYW5kaWRhdGVWYWx1ZSA8PSBtYXhWYWx1ZTtcbn07XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgaXNWYWxpZFJhbmdlID0gKG1pbiwgbWF4KSA9PiAoIWlzU2V0KG1pbikgfHwgIWlzU2V0KG1heCkgfHwgbWluIDw9IG1heCk7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgZGF0ZUluUmFuZ2UgPSAoY2FuZGlkYXRlLCBtaW4sIG1heCkgPT4ge1xuICAgIGlmICghY2FuZGlkYXRlKSB7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGU7XG4gICAgfVxuICAgIGlmIChtaW4gJiYgY2FuZGlkYXRlIDwgbWluKSB7XG4gICAgICAgIHJldHVybiBjbG9uZURhdGUobWluKTtcbiAgICB9XG4gICAgaWYgKG1heCAmJiBjYW5kaWRhdGUgPiBtYXgpIHtcbiAgICAgICAgcmV0dXJuIGNsb25lRGF0ZShtYXgpO1xuICAgIH1cbiAgICByZXR1cm4gY2FuZGlkYXRlO1xufTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCB0aW1lSW5SYW5nZSA9IChjYW5kaWRhdGUsIG1pbiwgbWF4KSA9PiB7XG4gICAgaWYgKCFjYW5kaWRhdGUgfHwgIW1pbiB8fCAhbWF4KSB7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGU7XG4gICAgfVxuICAgIGNvbnN0IHsgY2FuZGlkYXRlVmFsdWUsIG1pblZhbHVlLCBtYXhWYWx1ZSB9ID0gbm9ybWFsaXplVGltZXMoY2FuZGlkYXRlLCBtaW4sIG1heCk7XG4gICAgaWYgKGNhbmRpZGF0ZVZhbHVlIDwgbWluVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHNldFRpbWUoY2FuZGlkYXRlLCBtaW4pO1xuICAgIH1cbiAgICBpZiAoY2FuZGlkYXRlVmFsdWUgPiBtYXhWYWx1ZSkge1xuICAgICAgICByZXR1cm4gc2V0VGltZShjYW5kaWRhdGUsIG1heCk7XG4gICAgfVxuICAgIHJldHVybiBjYW5kaWRhdGU7XG59O1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGdldE5vdyA9ICgpID0+IG5ldyBEYXRlKCk7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgZ2V0VG9kYXkgPSAoKSA9PiBnZXREYXRlKG5ldyBEYXRlKCkpO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IG5vb3AgPSAoXykgPT4geyB9OyAvLyB0c2xpbnQ6ZGlzYWJsZS1saW5lOm5vLWVtcHR5XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgaXNXaW5kb3dBdmFpbGFibGUgPSAoKSA9PiB7XG4gICAgcmV0dXJuIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnO1xufTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBzdHJpbmdpZnlDbGFzc09iamVjdCA9IChjbGFzc2VzKSA9PiB7XG4gICAgY29uc3QgcHVzaFRvQWNjID0gKGFjYywgY2xzKSA9PiBjbGFzc2VzW2Nsc10gPyBhY2MuY29uY2F0KGNscykgOiBhY2M7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKGNsYXNzZXMpLnJlZHVjZShwdXNoVG9BY2MsIFtdKS5qb2luKCcgJyk7XG59O1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IHNoaWZ0V2Vla05hbWVzID0gKG5hbWVzLCBvZmZzZXQpID0+IChuYW1lcy5zbGljZShvZmZzZXQpLmNvbmNhdChuYW1lcy5zbGljZSgwLCBvZmZzZXQpKSk7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgYXBwcm94aW1hdGVTdHJpbmdNYXRjaGluZyA9IChvbGRUZXh0T3JpZ2luLCBvbGRGb3JtYXQsIG5ld1RleHRPcmlnaW4sIGNhcmV0KSA9PiB7XG4gICAgLy8gUmVtb3ZlIHRoZSByaWdodCBwYXJ0IG9mIHRoZSBjdXJzb3IuXG4gICAgLy9vbGRGb3JtYXQgPSBvbGRGb3JtYXQuc3Vic3RyaW5nKDAsIGNhcmV0ICsgb2xkVGV4dC5sZW5ndGggLSBuZXdUZXh0Lmxlbmd0aCk7XG4gICAgY29uc3Qgb2xkSW5kZXggPSBjYXJldCArIG9sZFRleHRPcmlnaW4ubGVuZ3RoIC0gbmV3VGV4dE9yaWdpbi5sZW5ndGg7XG4gICAgY29uc3Qgb2xkVGV4dFNlcGFyYXRvciA9IG9sZFRleHRPcmlnaW5bb2xkSW5kZXhdO1xuICAgIGNvbnN0IG9sZFRleHQgPSBvbGRUZXh0T3JpZ2luLnN1YnN0cmluZygwLCBjYXJldCArIG9sZFRleHRPcmlnaW4ubGVuZ3RoIC0gbmV3VGV4dE9yaWdpbi5sZW5ndGgpO1xuICAgIGNvbnN0IG5ld1RleHQgPSBuZXdUZXh0T3JpZ2luLnN1YnN0cmluZygwLCBjYXJldCk7XG4gICAgY29uc3QgZGlmZiA9IFtdO1xuICAgIC8vIEhhbmRsZSB0eXBpbmcgYSBzaW5nbGUgY2hhcmFjdGVyIG92ZXIgdGhlIHNhbWUgc2VsZWN0aW9uLlxuICAgIGlmIChvbGRUZXh0ID09PSBuZXdUZXh0ICYmIGNhcmV0ID4gMCkge1xuICAgICAgICBkaWZmLnB1c2goW29sZEZvcm1hdFtjYXJldCAtIDFdLCBuZXdUZXh0W2NhcmV0IC0gMV1dKTtcbiAgICAgICAgcmV0dXJuIGRpZmY7XG4gICAgfVxuICAgIGlmIChvbGRUZXh0LmluZGV4T2YobmV3VGV4dCkgPT09IDAgJiYgKG5ld1RleHQubGVuZ3RoID09PSAwIHx8IG9sZEZvcm1hdFtuZXdUZXh0Lmxlbmd0aCAtIDFdICE9PSBvbGRGb3JtYXRbbmV3VGV4dC5sZW5ndGhdKSkge1xuICAgICAgICAvLyBIYW5kbGUgRGVsZXRlL0JhY2tzcGFjZS5cbiAgICAgICAgbGV0IGRlbGV0ZWRTeW1ib2wgPSBcIlwiO1xuICAgICAgICAvL1hYWDpcbiAgICAgICAgLy8gV2hvbGUgdGV4dCBpcyByZXBsYWNlZCB3aXRoIGEgc2FtZSBjaGFyXG4gICAgICAgIC8vIE5hc3R5IHBhdGNoIHJlcXVpcmVkIHRvIGtlZXAgdGhlIHNlbGVjdGlvbiBpbiB0aGUgZmlyc3Qgc2VnbWVudFxuICAgICAgICBpZiAobmV3VGV4dC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIGRpZmYucHVzaChbb2xkRm9ybWF0WzBdLCBuZXdUZXh0WzBdXSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IG5ld1RleHQubGVuZ3RoOyBpIDwgb2xkVGV4dC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKG9sZEZvcm1hdFtpXSAhPT0gZGVsZXRlZFN5bWJvbCAmJiBvbGRGb3JtYXRbaV0gIT09IFwiX1wiKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlZFN5bWJvbCA9IG9sZEZvcm1hdFtpXTtcbiAgICAgICAgICAgICAgICBkaWZmLnB1c2goW2RlbGV0ZWRTeW1ib2wsIFwiXCJdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGlmZjtcbiAgICB9XG4gICAgLy8gSGFuZGxlIGluc2VydGluZyB0ZXh0ICh0aGUgbmV3IHRleHQgaXMgbG9uZ2VyIHRoYW4gdGhlIHByZXZpb3VzIG9uZSkuXG4gICAgLy8gSGFuZGxlIHR5cGluZyBvdmVyIGEgbGl0ZXJhbCBhcyB3ZWxsLlxuICAgIGlmIChuZXdUZXh0LmluZGV4T2Yob2xkVGV4dCkgPT09IDAgfHwgb2xkRm9ybWF0W2NhcmV0IC0gMV0gPT09IFwiX1wiKSB7XG4gICAgICAgIGxldCBzeW1ib2wgPSBvbGRGb3JtYXRbMF07XG4gICAgICAgIGZvciAobGV0IGkgPSBNYXRoLm1heCgwLCBvbGRUZXh0Lmxlbmd0aCAtIDEpOyBpIDwgb2xkRm9ybWF0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAob2xkRm9ybWF0W2ldICE9PSBcIl9cIikge1xuICAgICAgICAgICAgICAgIHN5bWJvbCA9IG9sZEZvcm1hdFtpXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW1tzeW1ib2wsIG5ld1RleHRbY2FyZXQgLSAxXV1dO1xuICAgIH1cbiAgICAvLyBIYW5kbGUgZW50ZXJpbmcgYSBzcGFjZSBvciBhIHNlcGFyYXRvciwgZm9yIG5hdmlnYXRpb24gdG8gdGhlIG5leHQgaXRlbS5cbiAgICBpZiAobmV3VGV4dFtuZXdUZXh0Lmxlbmd0aCAtIDFdID09PSBcIiBcIiB8fCAobmV3VGV4dFtuZXdUZXh0Lmxlbmd0aCAtIDFdID09PSBvbGRUZXh0U2VwYXJhdG9yICYmIG9sZEZvcm1hdFtvbGRJbmRleF0gPT09ICdfJykpIHtcbiAgICAgICAgcmV0dXJuIFtbb2xkRm9ybWF0W2NhcmV0IC0gMV0sIFwiX1wiXV07XG4gICAgfVxuICAgIC8vIEhhbmRsZSB0eXBpbmcgb3ZlciBhIGNvcnJlY3RseSBzZWxlY3RlZCBwYXJ0LlxuICAgIHJldHVybiBbW29sZEZvcm1hdFtjYXJldCAtIDFdLCBuZXdUZXh0W2NhcmV0IC0gMV1dXTtcbn07XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgZG9tQ29udGFpbmVyRmFjdG9yeSA9ICh0eXBlKSA9PiAoY2hpbGRyZW4sIGNsYXNzZXMgPSBcIlwiLCBzdHlsZXMgPSB7fSkgPT4ge1xuICAgIGNvbnN0IGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodHlwZSk7XG4gICAgY29udGFpbmVyLmNsYXNzTmFtZSA9IGNsYXNzZXM7XG4gICAgT2JqZWN0LmtleXMoc3R5bGVzKS5tYXAoa2V5ID0+IGNvbnRhaW5lci5zdHlsZVtrZXldID0gc3R5bGVzW2tleV0pO1xuICAgIGlmICh0eXBlb2YgY2hpbGRyZW4gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGNvbnRhaW5lci5pbm5lckhUTUwgPSBjaGlsZHJlbiB8fCAnJztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIChjaGlsZHJlbiB8fCBbXSkuZm9yRWFjaChjaGlsZCA9PiBjaGlsZCAmJiBjb250YWluZXIuYXBwZW5kQ2hpbGQoY2hpbGQpKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbnRhaW5lcjtcbn07XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgaGFzQ2hhbmdlID0gKGNoYW5nZXMsIGZpZWxkKSA9PiBjaGFuZ2VzW2ZpZWxkXSAhPT0gdW5kZWZpbmVkO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGhhc0V4aXN0aW5nVmFsdWUgPSAoY2hhbmdlcywgZmllbGQpID0+IGNoYW5nZXNbZmllbGRdICYmIGNoYW5nZXNbZmllbGRdLmN1cnJlbnRWYWx1ZSAhPT0gdW5kZWZpbmVkICYmIGNoYW5nZXNbZmllbGRdLmN1cnJlbnRWYWx1ZSAhPT0gbnVsbDtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBsYXN0ID0gKGxpc3QgPSBbXSkgPT4gbGlzdCAmJiBsaXN0W2xpc3QubGVuZ3RoIC0gMV07XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgaXNJblNlbGVjdGlvblJhbmdlID0gKHZhbHVlLCBzZWxlY3Rpb25SYW5nZSkgPT4ge1xuICAgIGNvbnN0IHsgc3RhcnQsIGVuZCB9ID0gc2VsZWN0aW9uUmFuZ2UgfHwgRU1QVFlfU0VMRUNUSU9OUkFOR0U7XG4gICAgaWYgKCFzdGFydCB8fCAhZW5kKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHN0YXJ0IDwgdmFsdWUgJiYgdmFsdWUgPCBlbmQ7XG59O1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGVpdGhlciA9ICh2YWx1ZTEsIHZhbHVlMikgPT4gdmFsdWUxIHx8IHZhbHVlMjtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBjbGFtcFJhbmdlID0gKHZhbHVlKSA9PiAoeyBzdGFydDogdmFsdWUsIGVuZDogdmFsdWUgfSk7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgaXNFcXVhbFJhbmdlID0gKGluaXRpYWwsIHVwZGF0ZWQpID0+IHtcbiAgICBjb25zdCB7IHN0YXJ0OiBpbml0aWFsU3RhcnQsIGVuZDogaW5pdGlhbEVuZCB9ID0gaW5pdGlhbCB8fCBFTVBUWV9TRUxFQ1RJT05SQU5HRTtcbiAgICBjb25zdCB7IHN0YXJ0OiB1cGRhdGVkU3RhcnQsIGVuZDogdXBkYXRlZEVuZCB9ID0gdXBkYXRlZCB8fCBFTVBUWV9TRUxFQ1RJT05SQU5HRTtcbiAgICByZXR1cm4gaXNFcXVhbChpbml0aWFsU3RhcnQsIHVwZGF0ZWRTdGFydCkgJiYgaXNFcXVhbChpbml0aWFsRW5kLCB1cGRhdGVkRW5kKTtcbn07XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgYXJlRGF0ZXNFcXVhbCA9IChmaXJzdCwgc2Vjb25kKSA9PiB7XG4gICAgZmlyc3QgPSBmaXJzdCB8fCBbXTtcbiAgICBzZWNvbmQgPSBzZWNvbmQgfHwgW107XG4gICAgcmV0dXJuIGZpcnN0Lmxlbmd0aCA9PT0gc2Vjb25kLmxlbmd0aCAmJiBmaXJzdC5ldmVyeSgoZGF0ZSwgaW5kZXgpID0+IGlzRXF1YWwoZGF0ZSwgc2Vjb25kW2luZGV4XSkpO1xufTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBzb3J0RGF0ZXMgPSAoZGF0ZXMpID0+IHtcbiAgICByZXR1cm4gZGF0ZXMuZmlsdGVyKGRhdGUgPT4gaXNQcmVzZW50KGRhdGUpKS5zb3J0KChhLCBiKSA9PiBhLmdldFRpbWUoKSAtIGIuZ2V0VGltZSgpKTtcbn07XG4vKipcbiAqIEBoaWRkZW5cbiAqXG4gKiBDcmVhdGVzIGEgbmV3IGRhdGUgYmFzZWQgb24gdGhlIGRhdGUgaW5mb3JtYXRpb24gZnJvbSB0aGUgc3BlY2lmaWVkIGRhdGUgcG9ydGlvblxuICogYW5kIHRoZSB0aW1lIGluZm9ybWF0aW9uIGZyb20gdGhlIHRpbWUgcG9ydGlvbi5cbiAqIElmIGEgcGFyYW1ldGVyIGlzIG5vdCBwcm92aWRlZCwgcmV0dXJucyBgbnVsbGAuXG4gKi9cbmNvbnN0IG1lcmdlRGF0ZUFuZFRpbWUgPSAoZGF0ZSwgdGltZSkgPT4ge1xuICAgIGlmICghKGRhdGUgJiYgdGltZSkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBuZXcgRGF0ZShkYXRlLmdldEZ1bGxZZWFyKCksIGRhdGUuZ2V0TW9udGgoKSwgZGF0ZS5nZXREYXRlKCksIHRpbWUuZ2V0SG91cnMoKSwgdGltZS5nZXRNaW51dGVzKCksIHRpbWUuZ2V0U2Vjb25kcygpLCB0aW1lLmdldE1pbGxpc2Vjb25kcygpKTtcbn07XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgbGFzdE1pbGxpc2Vjb25kT2ZEYXRlID0gKGRhdGUpID0+IHtcbiAgICBpZiAoIWRhdGUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBuZXcgRGF0ZShkYXRlLmdldEZ1bGxZZWFyKCksIGRhdGUuZ2V0TW9udGgoKSwgZGF0ZS5nZXREYXRlKCksIDIzLCA1OSwgNTksIDk5OSk7XG59O1xuLyoqXG4gKiBAaGlkZGVuXG4gKlxuICogUmV0dXJucyBhbiBhcnJheSB3aXRoIGRhdGVzIHJhbmdpbmcgYmV0d2VlbiBhbmQgaW5jbHVkaW5nIHRoZSBzcGVjaWZpZWQgc3RhcnQgYW5kXG4gKiBlbmQgZGF0ZXMgdGhhdCBhcmUgZXZhbHVhdGVkIGFzIGRpc2FibGVkLlxuICovXG5jb25zdCBkaXNhYmxlZERhdGVzSW5SYW5nZSA9IChzdGFydCwgZW5kLCBpc0RhdGVEaXNhYmxlZCkgPT4ge1xuICAgIGlmICghKHN0YXJ0ICYmIGVuZCAmJiBpc0RhdGVEaXNhYmxlZCkgfHwgKHN0YXJ0ID4gZW5kKSkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGNvbnN0IGRhdGVzID0gW107XG4gICAgbGV0IGN1cnJlbnQgPSBzdGFydDtcbiAgICB3aGlsZSAoY3VycmVudCA8PSBlbmQpIHtcbiAgICAgICAgaWYgKGlzRGF0ZURpc2FibGVkKGN1cnJlbnQpKSB7XG4gICAgICAgICAgICBkYXRlcy5wdXNoKGN1cnJlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnQgPSBhZGREYXlzKGN1cnJlbnQsIDEpO1xuICAgIH1cbiAgICByZXR1cm4gZGF0ZXM7XG59O1xuLyoqXG4gKiBAaGlkZGVuXG4gKlxuICogQ3JvcHMgdGhlIGxhc3QgdHdvIGRpZ2l0cyBmcm9tIHRoZSB5ZWFyIG9mIHRoZSBwcm92aWRlZCBkYXRlIHZhbHVlLlxuICovXG5jb25zdCBjcm9wVHdvRGlnaXRZZWFyID0gKGRhdGUpID0+IHtcbiAgICBpZiAoIWlzUHJlc2VudChkYXRlKSB8fCBpc05hTihkYXRlLmdldFRpbWUoKSkpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIHJldHVybiBOdW1iZXIoZGF0ZVxuICAgICAgICAuZ2V0RnVsbFllYXIoKVxuICAgICAgICAudG9TdHJpbmcoKVxuICAgICAgICAuc2xpY2UoLTIpKTtcbn07XG4vKipcbiAqIEBoaWRkZW5cbiAqXG4gKiBVc2VkIHdoZW4gcmVzZXR0aW5nIG1pbGxpc2Vjb25kIHNlZ21lbnQgdmFsdWUgaW4gdGhlIERhdGVJbnB1dFxuICovXG5jb25zdCBtc1BhZGRpbmdGcm9tRm9ybWF0ID0gKGZvcm1hdCkgPT4ge1xuICAgIHJldHVybiBBcnJheShmb3JtYXQubWF0Y2goL1MrKFxcMSkvKVswXS5sZW5ndGgpLmpvaW4oXCIwXCIpO1xufTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBtaWxsaXNlY29uZERpZ2l0c0luRm9ybWF0ID0gKGZvcm1hdCkgPT4ge1xuICAgIGNvbnN0IHJlc3VsdCA9IGZvcm1hdCAmJiBmb3JtYXQubWF0Y2goL1MrKFxcMSkvKTtcbiAgICByZXR1cm4gcmVzdWx0ID8gcmVzdWx0WzBdLmxlbmd0aCA6IDA7XG59O1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IG1pbGxpc2Vjb25kU3RlcEZvciA9IChkaWdpdHMpID0+IHtcbiAgICByZXR1cm4gTWF0aC5wb3coMTAsIDMgLSBkaWdpdHMpO1xufTtcblxuY29uc3QgRU1QVFlfREFUQSA9IFtbXV07XG5jb25zdCBDRUxMU19MRU5HVEggPSA0O1xuY29uc3QgUk9XU19MRU5HVEggPSAzO1xuY29uc3QgQUNUSU9OUyA9IHtcbiAgICBbQWN0aW9uLkxlZnRdOiAoZGF0ZSkgPT4gYWRkRGVjYWRlcyhkYXRlLCAtMSksXG4gICAgW0FjdGlvbi5VcF06IChkYXRlKSA9PiBhZGREZWNhZGVzKGRhdGUsIC01KSxcbiAgICBbQWN0aW9uLlJpZ2h0XTogKGRhdGUpID0+IGFkZERlY2FkZXMoZGF0ZSwgMSksXG4gICAgW0FjdGlvbi5Eb3duXTogKGRhdGUpID0+IGFkZERlY2FkZXMoZGF0ZSwgNSksXG4gICAgW0FjdGlvbi5QcmV2Vmlld106IChkYXRlKSA9PiBhZGRDZW50dXJpZXMoZGF0ZSwgLTEpLFxuICAgIFtBY3Rpb24uTmV4dFZpZXddOiAoZGF0ZSkgPT4gYWRkQ2VudHVyaWVzKGRhdGUsIDEpLFxuICAgIFtBY3Rpb24uRmlyc3RJblZpZXddOiAoZGF0ZSkgPT4gZmlyc3REZWNhZGVPZkNlbnR1cnkoZGF0ZSksXG4gICAgW0FjdGlvbi5MYXN0SW5WaWV3XTogKGRhdGUpID0+IGxhc3REZWNhZGVPZkNlbnR1cnkoZGF0ZSlcbn07XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xubGV0IENlbnR1cnlWaWV3U2VydmljZSA9IGNsYXNzIENlbnR1cnlWaWV3U2VydmljZSB7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmRhdGVSYW5nZSA9IChzdGFydCwgZW5kKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWlzUHJlc2VudChzdGFydCkgfHwgIWlzUHJlc2VudChlbmQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgICAgICBsZXQgY3VycmVudCA9IHN0YXJ0O1xuICAgICAgICAgICAgd2hpbGUgKGN1cnJlbnQgPD0gZW5kKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goY3VycmVudCk7XG4gICAgICAgICAgICAgICAgY3VycmVudCA9IGFkZERlY2FkZXMoY3VycmVudCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuICAgIH1cbiAgICBhZGRUb0RhdGUobWluLCBza2lwKSB7XG4gICAgICAgIHJldHVybiBhZGRDZW50dXJpZXMobWluLCBza2lwKTtcbiAgICB9XG4gICAgZGF0ZXNMaXN0KHN0YXJ0LCBjb3VudCkge1xuICAgICAgICByZXR1cm4gcmFuZ2UoMCwgY291bnQpLm1hcChpID0+IGFkZENlbnR1cmllcyhzdGFydCwgaSkpO1xuICAgIH1cbiAgICBkYXRhKG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgeyBjZWxsVUlELCBmb2N1c2VkRGF0ZSwgaXNBY3RpdmVWaWV3LCBtYXgsIG1pbiwgc2VsZWN0ZWREYXRlcywgc2VsZWN0aW9uUmFuZ2UgPSBFTVBUWV9TRUxFQ1RJT05SQU5HRSwgdmlld0RhdGUgfSA9IG9wdGlvbnM7XG4gICAgICAgIGlmICghdmlld0RhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiBFTVBUWV9EQVRBO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNlbGxzID0gcmFuZ2UoMCwgQ0VMTFNfTEVOR1RIKTtcbiAgICAgICAgY29uc3QgZmlyc3REYXRlID0gZmlyc3REZWNhZGVPZkNlbnR1cnkodmlld0RhdGUpO1xuICAgICAgICBjb25zdCBsYXN0RGF0ZSA9IGxhc3REZWNhZGVPZkNlbnR1cnkodmlld0RhdGUpO1xuICAgICAgICBjb25zdCB0b2RheSA9IGdldFRvZGF5KCk7XG4gICAgICAgIHJldHVybiByYW5nZSgwLCBST1dTX0xFTkdUSCkubWFwKHJvd09mZnNldCA9PiB7XG4gICAgICAgICAgICBjb25zdCBiYXNlRGF0ZSA9IGFkZERlY2FkZXMoZmlyc3REYXRlLCByb3dPZmZzZXQgKiBDRUxMU19MRU5HVEgpO1xuICAgICAgICAgICAgcmV0dXJuIGNlbGxzLm1hcChjZWxsT2Zmc2V0ID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjZWxsRGF0ZSA9IHRoaXMubm9ybWFsaXplKGFkZERlY2FkZXMoYmFzZURhdGUsIGNlbGxPZmZzZXQpLCBtaW4sIG1heCk7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dENlbnR1cnkgPSBjZWxsRGF0ZS5nZXRGdWxsWWVhcigpID4gbGFzdERhdGUuZ2V0RnVsbFllYXIoKTtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaXNJblJhbmdlKGNlbGxEYXRlLCBtaW4sIG1heCkgfHwgbmV4dENlbnR1cnkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGlzUmFuZ2VTdGFydCA9IHRoaXMuaXNFcXVhbChjZWxsRGF0ZSwgc2VsZWN0aW9uUmFuZ2Uuc3RhcnQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzUmFuZ2VFbmQgPSB0aGlzLmlzRXF1YWwoY2VsbERhdGUsIHNlbGVjdGlvblJhbmdlLmVuZCk7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNJbk1pZGRsZSA9ICFpc1JhbmdlU3RhcnQgJiYgIWlzUmFuZ2VFbmQ7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNSYW5nZU1pZCA9IGlzSW5NaWRkbGUgJiYgaXNJblNlbGVjdGlvblJhbmdlKGNlbGxEYXRlLCBzZWxlY3Rpb25SYW5nZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgZm9ybWF0dGVkVmFsdWU6IHRoaXMudmFsdWUoY2VsbERhdGUpLFxuICAgICAgICAgICAgICAgICAgICBpZDogYCR7Y2VsbFVJRH0ke2NlbGxEYXRlLmdldFRpbWUoKX1gLFxuICAgICAgICAgICAgICAgICAgICBpc0ZvY3VzZWQ6IHRoaXMuaXNFcXVhbChjZWxsRGF0ZSwgZm9jdXNlZERhdGUpLFxuICAgICAgICAgICAgICAgICAgICBpc1NlbGVjdGVkOiBpc0FjdGl2ZVZpZXcgJiYgc2VsZWN0ZWREYXRlcy5zb21lKGRhdGUgPT4gdGhpcy5pc0VxdWFsKGNlbGxEYXRlLCBkYXRlKSksXG4gICAgICAgICAgICAgICAgICAgIGlzV2Vla2VuZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGlzUmFuZ2VTdGFydDogaXNSYW5nZVN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICBpc1JhbmdlTWlkOiBpc1JhbmdlTWlkLFxuICAgICAgICAgICAgICAgICAgICBpc1JhbmdlRW5kOiBpc1JhbmdlRW5kLFxuICAgICAgICAgICAgICAgICAgICBpc1JhbmdlU3BsaXRFbmQ6IGlzUmFuZ2VNaWQgJiYgdGhpcy5pc0VxdWFsKGNlbGxEYXRlLCBsYXN0RGF0ZSksXG4gICAgICAgICAgICAgICAgICAgIGlzUmFuZ2VTcGxpdFN0YXJ0OiBpc1JhbmdlTWlkICYmIHRoaXMuaXNFcXVhbChjZWxsRGF0ZSwgZmlyc3REYXRlKSxcbiAgICAgICAgICAgICAgICAgICAgaXNUb2RheTogdGhpcy5pc0VxdWFsKGNlbGxEYXRlLCB0b2RheSksXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiB0aGlzLmNlbGxUaXRsZShjZWxsRGF0ZSksXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBjZWxsRGF0ZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlzRXF1YWwoY2FuZGlkYXRlLCBleHBlY3RlZCkge1xuICAgICAgICBpZiAoIWNhbmRpZGF0ZSB8fCAhZXhwZWN0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmlyc3RZZWFyT2ZEZWNhZGUoY2FuZGlkYXRlKS5nZXRGdWxsWWVhcigpID09PSBmaXJzdFllYXJPZkRlY2FkZShleHBlY3RlZCkuZ2V0RnVsbFllYXIoKTtcbiAgICB9XG4gICAgaXNJbkFycmF5KGRhdGUsIGRhdGVzKSB7XG4gICAgICAgIGlmICghZGF0ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeWVhciA9IGRhdGUuZ2V0RnVsbFllYXIoKTtcbiAgICAgICAgcmV0dXJuIGRhdGVzWzBdLmdldEZ1bGxZZWFyKCkgPD0geWVhciAmJiB5ZWFyIDw9IChkYXRlc1tkYXRlcy5sZW5ndGggLSAxXS5nZXRGdWxsWWVhcigpICsgOTkpO1xuICAgIH1cbiAgICBpc0luUmFuZ2UoY2FuZGlkYXRlLCBtaW4sIG1heCkge1xuICAgICAgICBjb25zdCB5ZWFyID0gZmlyc3RZZWFyT2ZEZWNhZGUoY2FuZGlkYXRlKS5nZXRGdWxsWWVhcigpO1xuICAgICAgICBjb25zdCBhYm92ZU1pbiA9ICFtaW4gfHwgZmlyc3RZZWFyT2ZEZWNhZGUobWluKS5nZXRGdWxsWWVhcigpIDw9IHllYXI7XG4gICAgICAgIGNvbnN0IGJlbG93TWF4ID0gIW1heCB8fCB5ZWFyIDw9IGZpcnN0WWVhck9mRGVjYWRlKG1heCkuZ2V0RnVsbFllYXIoKTtcbiAgICAgICAgcmV0dXJuIGFib3ZlTWluICYmIGJlbG93TWF4O1xuICAgIH1cbiAgICBiZWdpbm5pbmdPZlBlcmlvZChkYXRlKSB7XG4gICAgICAgIGlmICghZGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZmlyc3RZZWFyID0gZmlyc3RZZWFyT2ZEZWNhZGUoZmlyc3REZWNhZGVPZkNlbnR1cnkoZGF0ZSkpO1xuICAgICAgICByZXR1cm4gY3JlYXRlRGF0ZShmaXJzdFllYXIuZ2V0RnVsbFllYXIoKSwgMCwgMSk7XG4gICAgfVxuICAgIGlzUmFuZ2VTdGFydCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUuZ2V0RnVsbFllYXIoKSAlIDEwMDAgPT09IDA7XG4gICAgfVxuICAgIG1vdmUodmFsdWUsIGFjdGlvbikge1xuICAgICAgICBjb25zdCBtb2RpZmllciA9IEFDVElPTlNbYWN0aW9uXTtcbiAgICAgICAgaWYgKCFtb2RpZmllcikge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtb2RpZmllcih2YWx1ZSk7XG4gICAgfVxuICAgIGNlbGxUaXRsZSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gZmlyc3RZZWFyT2ZEZWNhZGUodmFsdWUpLmdldEZ1bGxZZWFyKCkudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgbmF2aWdhdGlvblRpdGxlKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA/IGZpcnN0RGVjYWRlT2ZDZW50dXJ5KHZhbHVlKS5nZXRGdWxsWWVhcigpLnRvU3RyaW5nKCkgOiAnJztcbiAgICB9XG4gICAgdGl0bGUodmFsdWUpIHtcbiAgICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgJHtmaXJzdERlY2FkZU9mQ2VudHVyeSh2YWx1ZSkuZ2V0RnVsbFllYXIoKX0gLSAke2xhc3REZWNhZGVPZkNlbnR1cnkodmFsdWUpLmdldEZ1bGxZZWFyKCl9YDtcbiAgICB9XG4gICAgcm93TGVuZ3RoKCkge1xuICAgICAgICByZXR1cm4gQ0VMTFNfTEVOR1RIO1xuICAgIH1cbiAgICBza2lwKHZhbHVlLCBtaW4pIHtcbiAgICAgICAgcmV0dXJuIGR1cmF0aW9uSW5DZW50dXJpZXMobWluLCB2YWx1ZSk7XG4gICAgfVxuICAgIHRvdGFsKG1pbiwgbWF4KSB7XG4gICAgICAgIHJldHVybiBkdXJhdGlvbkluQ2VudHVyaWVzKG1pbiwgbWF4KSArIDE7XG4gICAgfVxuICAgIHZhbHVlKGN1cnJlbnQpIHtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnQgPyBmaXJzdFllYXJPZkRlY2FkZShjdXJyZW50KS5nZXRGdWxsWWVhcigpLnRvU3RyaW5nKCkgOiAnJztcbiAgICB9XG4gICAgdmlld0RhdGUoZGF0ZSwgbWF4LCB2aWV3c0NvdW50ID0gMSkge1xuICAgICAgICBjb25zdCB2aWV3c0luUmFuZ2UgPSB0aGlzLnRvdGFsKGRhdGUsIG1heCk7XG4gICAgICAgIGlmICh2aWV3c0luUmFuZ2UgPCB2aWV3c0NvdW50KSB7XG4gICAgICAgICAgICBjb25zdCBjZW50dXJpZXNUb1N1YnRyYWN0ID0gdmlld3NDb3VudCAtIHZpZXdzSW5SYW5nZTtcbiAgICAgICAgICAgIHJldHVybiBhZGRDZW50dXJpZXMoZGF0ZSwgLTEgKiBjZW50dXJpZXNUb1N1YnRyYWN0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0ZTtcbiAgICB9XG4gICAgbm9ybWFsaXplKGNlbGxEYXRlLCBtaW4sIG1heCkge1xuICAgICAgICBpZiAoY2VsbERhdGUgPCBtaW4gJiYgdGhpcy5pc0VxdWFsKGNlbGxEYXRlLCBtaW4pKSB7XG4gICAgICAgICAgICByZXR1cm4gY2xvbmVEYXRlKG1pbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNlbGxEYXRlID4gbWF4ICYmIHRoaXMuaXNFcXVhbChjZWxsRGF0ZSwgbWF4KSkge1xuICAgICAgICAgICAgcmV0dXJuIGNsb25lRGF0ZShtYXgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjZWxsRGF0ZTtcbiAgICB9XG59O1xuQ2VudHVyeVZpZXdTZXJ2aWNlID0gX19kZWNvcmF0ZShbXG4gICAgSW5qZWN0YWJsZSgpXG5dLCBDZW50dXJ5Vmlld1NlcnZpY2UpO1xuXG5jb25zdCBFTVBUWV9EQVRBJDEgPSBbW11dO1xuY29uc3QgQ0VMTFNfTEVOR1RIJDEgPSA0O1xuY29uc3QgUk9XU19MRU5HVEgkMSA9IDM7XG5jb25zdCBBQ1RJT05TJDEgPSB7XG4gICAgW0FjdGlvbi5MZWZ0XTogKGRhdGUpID0+IGFkZFllYXJzKGRhdGUsIC0xKSxcbiAgICBbQWN0aW9uLlVwXTogKGRhdGUpID0+IGFkZFllYXJzKGRhdGUsIC01KSxcbiAgICBbQWN0aW9uLlJpZ2h0XTogKGRhdGUpID0+IGFkZFllYXJzKGRhdGUsIDEpLFxuICAgIFtBY3Rpb24uRG93bl06IChkYXRlKSA9PiBhZGRZZWFycyhkYXRlLCA1KSxcbiAgICBbQWN0aW9uLlByZXZWaWV3XTogKGRhdGUpID0+IGFkZERlY2FkZXMoZGF0ZSwgLTEpLFxuICAgIFtBY3Rpb24uTmV4dFZpZXddOiAoZGF0ZSkgPT4gYWRkRGVjYWRlcyhkYXRlLCAxKSxcbiAgICBbQWN0aW9uLkZpcnN0SW5WaWV3XTogKGRhdGUpID0+IGZpcnN0WWVhck9mRGVjYWRlKGRhdGUpLFxuICAgIFtBY3Rpb24uTGFzdEluVmlld106IChkYXRlKSA9PiBsYXN0WWVhck9mRGVjYWRlKGRhdGUpXG59O1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmxldCBEZWNhZGVWaWV3U2VydmljZSA9IGNsYXNzIERlY2FkZVZpZXdTZXJ2aWNlIHtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuZGF0ZVJhbmdlID0gKHN0YXJ0LCBlbmQpID0+IHtcbiAgICAgICAgICAgIGlmICghaXNQcmVzZW50KHN0YXJ0KSB8fCAhaXNQcmVzZW50KGVuZCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgIGxldCBjdXJyZW50ID0gc3RhcnQ7XG4gICAgICAgICAgICB3aGlsZSAoY3VycmVudCA8PSBlbmQpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChjdXJyZW50KTtcbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gYWRkWWVhcnMoY3VycmVudCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuICAgIH1cbiAgICBhZGRUb0RhdGUobWluLCBza2lwKSB7XG4gICAgICAgIHJldHVybiBhZGREZWNhZGVzKG1pbiwgc2tpcCk7XG4gICAgfVxuICAgIGRhdGVzTGlzdChzdGFydCwgY291bnQpIHtcbiAgICAgICAgcmV0dXJuIHJhbmdlKDAsIGNvdW50KS5tYXAoaSA9PiBhZGREZWNhZGVzKHN0YXJ0LCBpKSk7XG4gICAgfVxuICAgIGRhdGEob3B0aW9ucykge1xuICAgICAgICBjb25zdCB7IGNlbGxVSUQsIGZvY3VzZWREYXRlLCBpc0FjdGl2ZVZpZXcsIG1heCwgbWluLCBzZWxlY3RlZERhdGVzLCBzZWxlY3Rpb25SYW5nZSA9IEVNUFRZX1NFTEVDVElPTlJBTkdFLCB2aWV3RGF0ZSB9ID0gb3B0aW9ucztcbiAgICAgICAgaWYgKCF2aWV3RGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIEVNUFRZX0RBVEEkMTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjZWxscyA9IHJhbmdlKDAsIENFTExTX0xFTkdUSCQxKTtcbiAgICAgICAgY29uc3QgZmlyc3REYXRlID0gZmlyc3RZZWFyT2ZEZWNhZGUodmlld0RhdGUpO1xuICAgICAgICBjb25zdCBsYXN0RGF0ZSA9IGxhc3RZZWFyT2ZEZWNhZGUodmlld0RhdGUpO1xuICAgICAgICBjb25zdCB0b2RheSA9IGdldFRvZGF5KCk7XG4gICAgICAgIHJldHVybiByYW5nZSgwLCBST1dTX0xFTkdUSCQxKS5tYXAocm93T2Zmc2V0ID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGJhc2VEYXRlID0gYWRkWWVhcnMoZmlyc3REYXRlLCByb3dPZmZzZXQgKiBDRUxMU19MRU5HVEgkMSk7XG4gICAgICAgICAgICByZXR1cm4gY2VsbHMubWFwKGNlbGxPZmZzZXQgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNlbGxEYXRlID0gdGhpcy5ub3JtYWxpemUoYWRkWWVhcnMoYmFzZURhdGUsIGNlbGxPZmZzZXQpLCBtaW4sIG1heCk7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dERlY2FkZSA9IGNlbGxEYXRlLmdldEZ1bGxZZWFyKCkgPiBsYXN0RGF0ZS5nZXRGdWxsWWVhcigpO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5pc0luUmFuZ2UoY2VsbERhdGUsIG1pbiwgbWF4KSB8fCBuZXh0RGVjYWRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBpc1JhbmdlU3RhcnQgPSB0aGlzLmlzRXF1YWwoY2VsbERhdGUsIHNlbGVjdGlvblJhbmdlLnN0YXJ0KTtcbiAgICAgICAgICAgICAgICBjb25zdCBpc1JhbmdlRW5kID0gdGhpcy5pc0VxdWFsKGNlbGxEYXRlLCBzZWxlY3Rpb25SYW5nZS5lbmQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzSW5NaWRkbGUgPSAhaXNSYW5nZVN0YXJ0ICYmICFpc1JhbmdlRW5kO1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzUmFuZ2VNaWQgPSBpc0luTWlkZGxlICYmIGlzSW5TZWxlY3Rpb25SYW5nZShjZWxsRGF0ZSwgc2VsZWN0aW9uUmFuZ2UpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdHRlZFZhbHVlOiB0aGlzLnZhbHVlKGNlbGxEYXRlKSxcbiAgICAgICAgICAgICAgICAgICAgaWQ6IGAke2NlbGxVSUR9JHtjZWxsRGF0ZS5nZXRUaW1lKCl9YCxcbiAgICAgICAgICAgICAgICAgICAgaXNGb2N1c2VkOiB0aGlzLmlzRXF1YWwoY2VsbERhdGUsIGZvY3VzZWREYXRlKSxcbiAgICAgICAgICAgICAgICAgICAgaXNTZWxlY3RlZDogaXNBY3RpdmVWaWV3ICYmIHNlbGVjdGVkRGF0ZXMuc29tZShkYXRlID0+IHRoaXMuaXNFcXVhbChjZWxsRGF0ZSwgZGF0ZSkpLFxuICAgICAgICAgICAgICAgICAgICBpc1dlZWtlbmQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBpc1JhbmdlU3RhcnQ6IGlzUmFuZ2VTdGFydCxcbiAgICAgICAgICAgICAgICAgICAgaXNSYW5nZU1pZDogaXNSYW5nZU1pZCxcbiAgICAgICAgICAgICAgICAgICAgaXNSYW5nZUVuZDogaXNSYW5nZUVuZCxcbiAgICAgICAgICAgICAgICAgICAgaXNSYW5nZVNwbGl0RW5kOiBpc1JhbmdlTWlkICYmIHRoaXMuaXNFcXVhbChjZWxsRGF0ZSwgbGFzdERhdGUpLFxuICAgICAgICAgICAgICAgICAgICBpc1JhbmdlU3BsaXRTdGFydDogaXNSYW5nZU1pZCAmJiB0aGlzLmlzRXF1YWwoY2VsbERhdGUsIGZpcnN0RGF0ZSksXG4gICAgICAgICAgICAgICAgICAgIGlzVG9kYXk6IHRoaXMuaXNFcXVhbChjZWxsRGF0ZSwgdG9kYXkpLFxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogdGhpcy5jZWxsVGl0bGUoY2VsbERhdGUpLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogY2VsbERhdGVcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpc0VxdWFsKGNhbmRpZGF0ZSwgZXhwZWN0ZWQpIHtcbiAgICAgICAgaWYgKCFjYW5kaWRhdGUgfHwgIWV4cGVjdGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZS5nZXRGdWxsWWVhcigpID09PSBleHBlY3RlZC5nZXRGdWxsWWVhcigpO1xuICAgIH1cbiAgICBpc0luQXJyYXkoZGF0ZSwgZGF0ZXMpIHtcbiAgICAgICAgaWYgKCFkYXRlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB5ZWFyID0gZGF0ZS5nZXRGdWxsWWVhcigpO1xuICAgICAgICByZXR1cm4gZGF0ZXNbMF0uZ2V0RnVsbFllYXIoKSA8PSB5ZWFyICYmIHllYXIgPD0gKGRhdGVzW2RhdGVzLmxlbmd0aCAtIDFdLmdldEZ1bGxZZWFyKCkgKyA5KTtcbiAgICB9XG4gICAgaXNJblJhbmdlKGNhbmRpZGF0ZSwgbWluLCBtYXgpIHtcbiAgICAgICAgY29uc3QgeWVhciA9IGNhbmRpZGF0ZS5nZXRGdWxsWWVhcigpO1xuICAgICAgICBjb25zdCBhYm92ZU1pbiA9ICFtaW4gfHwgbWluLmdldEZ1bGxZZWFyKCkgPD0geWVhcjtcbiAgICAgICAgY29uc3QgYmVsb3dNYXggPSAhbWF4IHx8IHllYXIgPD0gbWF4LmdldEZ1bGxZZWFyKCk7XG4gICAgICAgIHJldHVybiBhYm92ZU1pbiAmJiBiZWxvd01heDtcbiAgICB9XG4gICAgYmVnaW5uaW5nT2ZQZXJpb2QoZGF0ZSkge1xuICAgICAgICBpZiAoIWRhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZpcnN0WWVhciA9IGZpcnN0WWVhck9mRGVjYWRlKGRhdGUpO1xuICAgICAgICByZXR1cm4gY3JlYXRlRGF0ZShmaXJzdFllYXIuZ2V0RnVsbFllYXIoKSwgMCwgMSk7XG4gICAgfVxuICAgIGlzUmFuZ2VTdGFydCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUuZ2V0RnVsbFllYXIoKSAlIDEwMCA9PT0gMDtcbiAgICB9XG4gICAgbW92ZSh2YWx1ZSwgYWN0aW9uKSB7XG4gICAgICAgIGNvbnN0IG1vZGlmaWVyID0gQUNUSU9OUyQxW2FjdGlvbl07XG4gICAgICAgIGlmICghbW9kaWZpZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbW9kaWZpZXIodmFsdWUpO1xuICAgIH1cbiAgICBjZWxsVGl0bGUodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLmdldEZ1bGxZZWFyKCkudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgbmF2aWdhdGlvblRpdGxlKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA/IGZpcnN0WWVhck9mRGVjYWRlKHZhbHVlKS5nZXRGdWxsWWVhcigpLnRvU3RyaW5nKCkgOiAnJztcbiAgICB9XG4gICAgdGl0bGUodmFsdWUpIHtcbiAgICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgJHtmaXJzdFllYXJPZkRlY2FkZSh2YWx1ZSkuZ2V0RnVsbFllYXIoKX0gLSAke2xhc3RZZWFyT2ZEZWNhZGUodmFsdWUpLmdldEZ1bGxZZWFyKCl9YDtcbiAgICB9XG4gICAgcm93TGVuZ3RoKCkge1xuICAgICAgICByZXR1cm4gQ0VMTFNfTEVOR1RIJDE7XG4gICAgfVxuICAgIHNraXAodmFsdWUsIG1pbikge1xuICAgICAgICByZXR1cm4gZHVyYXRpb25JbkRlY2FkZXMobWluLCB2YWx1ZSk7XG4gICAgfVxuICAgIHRvdGFsKG1pbiwgbWF4KSB7XG4gICAgICAgIHJldHVybiBkdXJhdGlvbkluRGVjYWRlcyhtaW4sIG1heCkgKyAxO1xuICAgIH1cbiAgICB2YWx1ZShjdXJyZW50KSB7XG4gICAgICAgIHJldHVybiBjdXJyZW50ID8gY3VycmVudC5nZXRGdWxsWWVhcigpLnRvU3RyaW5nKCkgOiAnJztcbiAgICB9XG4gICAgdmlld0RhdGUoZGF0ZSwgbWF4LCB2aWV3c0NvdW50ID0gMSkge1xuICAgICAgICBjb25zdCB2aWV3c0luUmFuZ2UgPSB0aGlzLnRvdGFsKGRhdGUsIG1heCk7XG4gICAgICAgIGlmICh2aWV3c0luUmFuZ2UgPCB2aWV3c0NvdW50KSB7XG4gICAgICAgICAgICBjb25zdCBkZWNhZGVzVG9TdWJ0cmFjdCA9IHZpZXdzQ291bnQgLSB2aWV3c0luUmFuZ2U7XG4gICAgICAgICAgICByZXR1cm4gYWRkRGVjYWRlcyhkYXRlLCAtMSAqIGRlY2FkZXNUb1N1YnRyYWN0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0ZTtcbiAgICB9XG4gICAgbm9ybWFsaXplKGNlbGxEYXRlLCBtaW4sIG1heCkge1xuICAgICAgICBpZiAoY2VsbERhdGUgPCBtaW4gJiYgdGhpcy5pc0VxdWFsKGNlbGxEYXRlLCBtaW4pKSB7XG4gICAgICAgICAgICByZXR1cm4gY2xvbmVEYXRlKG1pbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNlbGxEYXRlID4gbWF4ICYmIHRoaXMuaXNFcXVhbChjZWxsRGF0ZSwgbWF4KSkge1xuICAgICAgICAgICAgcmV0dXJuIGNsb25lRGF0ZShtYXgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjZWxsRGF0ZTtcbiAgICB9XG59O1xuRGVjYWRlVmlld1NlcnZpY2UgPSBfX2RlY29yYXRlKFtcbiAgICBJbmplY3RhYmxlKClcbl0sIERlY2FkZVZpZXdTZXJ2aWNlKTtcblxuY29uc3QgRU1QVFlfREFUQSQyID0gW1tdXTtcbmNvbnN0IENFTExTX0xFTkdUSCQyID0gNztcbmNvbnN0IFJPV1NfTEVOR1RIJDIgPSA2O1xuY29uc3QgQUNUSU9OUyQyID0ge1xuICAgIFtBY3Rpb24uTGVmdF06IChkYXRlKSA9PiBhZGREYXlzKGRhdGUsIC0xKSxcbiAgICBbQWN0aW9uLlVwXTogKGRhdGUpID0+IGFkZFdlZWtzKGRhdGUsIC0xKSxcbiAgICBbQWN0aW9uLlJpZ2h0XTogKGRhdGUpID0+IGFkZERheXMoZGF0ZSwgMSksXG4gICAgW0FjdGlvbi5Eb3duXTogKGRhdGUpID0+IGFkZFdlZWtzKGRhdGUsIDEpLFxuICAgIFtBY3Rpb24uUHJldlZpZXddOiAoZGF0ZSkgPT4gYWRkTW9udGhzKGRhdGUsIC0xKSxcbiAgICBbQWN0aW9uLk5leHRWaWV3XTogKGRhdGUpID0+IGFkZE1vbnRocyhkYXRlLCAxKSxcbiAgICBbQWN0aW9uLkZpcnN0SW5WaWV3XTogKGRhdGUpID0+IGZpcnN0RGF5T2ZNb250aChkYXRlKSxcbiAgICBbQWN0aW9uLkxhc3RJblZpZXddOiAoZGF0ZSkgPT4gbGFzdERheU9mTW9udGgoZGF0ZSlcbn07XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xubGV0IE1vbnRoVmlld1NlcnZpY2UgPSBjbGFzcyBNb250aFZpZXdTZXJ2aWNlIHtcbiAgICBjb25zdHJ1Y3RvcihfaW50bFNlcnZpY2UpIHtcbiAgICAgICAgdGhpcy5faW50bFNlcnZpY2UgPSBfaW50bFNlcnZpY2U7XG4gICAgICAgIHRoaXMuZGF0ZVJhbmdlID0gKHN0YXJ0LCBlbmQpID0+IHtcbiAgICAgICAgICAgIGlmICghaXNQcmVzZW50KHN0YXJ0KSB8fCAhaXNQcmVzZW50KGVuZCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgIGxldCBjdXJyZW50ID0gc3RhcnQ7XG4gICAgICAgICAgICB3aGlsZSAoY3VycmVudCA8PSBlbmQpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChjdXJyZW50KTtcbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gYWRkRGF5cyhjdXJyZW50LCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGFkZFRvRGF0ZShtaW4sIHNraXApIHtcbiAgICAgICAgcmV0dXJuIGFkZE1vbnRocyhtaW4sIHNraXApO1xuICAgIH1cbiAgICBkYXRlc0xpc3Qoc3RhcnQsIGNvdW50KSB7XG4gICAgICAgIHJldHVybiByYW5nZSgwLCBjb3VudCkubWFwKGkgPT4gYWRkTW9udGhzKHN0YXJ0LCBpKSk7XG4gICAgfVxuICAgIGRhdGEob3B0aW9ucykge1xuICAgICAgICBjb25zdCB7IGNlbGxVSUQsIGZvY3VzZWREYXRlLCBpc0FjdGl2ZVZpZXcsIG1heCwgbWluLCBzZWxlY3RlZERhdGVzLCBzZWxlY3Rpb25SYW5nZSA9IEVNUFRZX1NFTEVDVElPTlJBTkdFLCB2aWV3RGF0ZSwgaXNEYXRlRGlzYWJsZWQgPSAoKSA9PiBmYWxzZSB9ID0gb3B0aW9ucztcbiAgICAgICAgaWYgKCF2aWV3RGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIEVNUFRZX0RBVEEkMjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmaXJzdE1vbnRoRGF0ZSA9IGZpcnN0RGF5T2ZNb250aCh2aWV3RGF0ZSk7XG4gICAgICAgIGNvbnN0IGZpcnN0TW9udGhEYXkgPSBnZXREYXRlKGZpcnN0TW9udGhEYXRlKTtcbiAgICAgICAgY29uc3QgbGFzdE1vbnRoRGF0ZSA9IGxhc3REYXlPZk1vbnRoKHZpZXdEYXRlKTtcbiAgICAgICAgY29uc3QgbGFzdE1vbnRoRGF5ID0gZ2V0RGF0ZShsYXN0TW9udGhEYXRlKTtcbiAgICAgICAgY29uc3QgYmFja3dhcmQgPSAtMTtcbiAgICAgICAgY29uc3QgZGF0ZSA9IGRheU9mV2VlayhmaXJzdE1vbnRoRGF0ZSwgdGhpcy5faW50bFNlcnZpY2UuZmlyc3REYXkoKSwgYmFja3dhcmQpO1xuICAgICAgICBjb25zdCBjZWxscyA9IHJhbmdlKDAsIENFTExTX0xFTkdUSCQyKTtcbiAgICAgICAgY29uc3QgdG9kYXkgPSBnZXRUb2RheSgpO1xuICAgICAgICByZXR1cm4gcmFuZ2UoMCwgUk9XU19MRU5HVEgkMikubWFwKHJvd09mZnNldCA9PiB7XG4gICAgICAgICAgICBjb25zdCBiYXNlRGF0ZSA9IGFkZERheXMoZGF0ZSwgcm93T2Zmc2V0ICogQ0VMTFNfTEVOR1RIJDIpO1xuICAgICAgICAgICAgcmV0dXJuIGNlbGxzLm1hcChjZWxsT2Zmc2V0ID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjZWxsRGF0ZSA9IHRoaXMubm9ybWFsaXplKGFkZERheXMoYmFzZURhdGUsIGNlbGxPZmZzZXQpLCBtaW4sIG1heCk7XG4gICAgICAgICAgICAgICAgY29uc3QgY2VsbERheSA9IGdldERhdGUoY2VsbERhdGUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG90aGVyTW9udGggPSBjZWxsRGF5IDwgZmlyc3RNb250aERheSB8fCBjZWxsRGF5ID4gbGFzdE1vbnRoRGF5O1xuICAgICAgICAgICAgICAgIGNvbnN0IG91dE9mUmFuZ2UgPSBjZWxsRGF0ZSA8IG1pbiB8fCBjZWxsRGF0ZSA+IG1heDtcbiAgICAgICAgICAgICAgICBpZiAob3V0T2ZSYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgaXNSYW5nZVN0YXJ0ID0gdGhpcy5pc0VxdWFsKGNlbGxEYXRlLCBzZWxlY3Rpb25SYW5nZS5zdGFydCk7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNSYW5nZUVuZCA9IHRoaXMuaXNFcXVhbChjZWxsRGF0ZSwgc2VsZWN0aW9uUmFuZ2UuZW5kKTtcbiAgICAgICAgICAgICAgICBjb25zdCBpc0luTWlkZGxlID0gIWlzUmFuZ2VTdGFydCAmJiAhaXNSYW5nZUVuZDtcbiAgICAgICAgICAgICAgICBjb25zdCBpc1JhbmdlTWlkID0gaXNJbk1pZGRsZSAmJiBpc0luU2VsZWN0aW9uUmFuZ2UoY2VsbERhdGUsIHNlbGVjdGlvblJhbmdlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBmb3JtYXR0ZWRWYWx1ZTogdGhpcy52YWx1ZShjZWxsRGF0ZSksXG4gICAgICAgICAgICAgICAgICAgIGlkOiBgJHtjZWxsVUlEfSR7Y2VsbERhdGUuZ2V0VGltZSgpfWAsXG4gICAgICAgICAgICAgICAgICAgIGlzRm9jdXNlZDogdGhpcy5pc0VxdWFsKGNlbGxEYXRlLCBmb2N1c2VkRGF0ZSksXG4gICAgICAgICAgICAgICAgICAgIGlzU2VsZWN0ZWQ6IGlzQWN0aXZlVmlldyAmJiBzZWxlY3RlZERhdGVzLnNvbWUoZGF0ZSA9PiB0aGlzLmlzRXF1YWwoY2VsbERhdGUsIGRhdGUpKSxcbiAgICAgICAgICAgICAgICAgICAgaXNXZWVrZW5kOiB0aGlzLmlzV2Vla2VuZChjZWxsRGF0ZSksXG4gICAgICAgICAgICAgICAgICAgIGlzUmFuZ2VTdGFydDogaXNSYW5nZVN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICBpc1JhbmdlTWlkOiBpc1JhbmdlTWlkLFxuICAgICAgICAgICAgICAgICAgICBpc1JhbmdlRW5kOiBpc1JhbmdlRW5kLFxuICAgICAgICAgICAgICAgICAgICBpc1JhbmdlU3BsaXRTdGFydDogaXNSYW5nZU1pZCAmJiB0aGlzLmlzRXF1YWwoY2VsbERhdGUsIGZpcnN0TW9udGhEYXRlKSxcbiAgICAgICAgICAgICAgICAgICAgaXNSYW5nZVNwbGl0RW5kOiBpc1JhbmdlTWlkICYmIHRoaXMuaXNFcXVhbChjZWxsRGF0ZSwgbGFzdE1vbnRoRGF0ZSksXG4gICAgICAgICAgICAgICAgICAgIGlzVG9kYXk6IHRoaXMuaXNFcXVhbChjZWxsRGF0ZSwgdG9kYXkpLFxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogdGhpcy5jZWxsVGl0bGUoY2VsbERhdGUpLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogY2VsbERhdGUsXG4gICAgICAgICAgICAgICAgICAgIGlzRGlzYWJsZWQ6IGlzRGF0ZURpc2FibGVkKGNlbGxEYXRlKSxcbiAgICAgICAgICAgICAgICAgICAgaXNPdGhlck1vbnRoOiBvdGhlck1vbnRoXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgaXNFcXVhbChjYW5kaWRhdGUsIGV4cGVjdGVkKSB7XG4gICAgICAgIGlmICghY2FuZGlkYXRlIHx8ICFleHBlY3RlZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnZXREYXRlKGNhbmRpZGF0ZSkuZ2V0VGltZSgpID09PSBnZXREYXRlKGV4cGVjdGVkKS5nZXRUaW1lKCk7XG4gICAgfVxuICAgIGlzSW5BcnJheShkYXRlLCBkYXRlcykge1xuICAgICAgICBpZiAoZGF0ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbG93ZXJCb3VuZCA9IHRoaXMuYmVnaW5uaW5nT2ZQZXJpb2QoZGF0ZXNbMF0pO1xuICAgICAgICBjb25zdCB1cHBlckJvdW5kID0gdGhpcy5iZWdpbm5pbmdPZlBlcmlvZChhZGRNb250aHMoZGF0ZXNbZGF0ZXMubGVuZ3RoIC0gMV0sIDEpKTtcbiAgICAgICAgcmV0dXJuIGxvd2VyQm91bmQgPD0gZGF0ZSAmJiBkYXRlIDwgdXBwZXJCb3VuZDtcbiAgICB9XG4gICAgaXNJblJhbmdlKGNhbmRpZGF0ZSwgbWluLCBtYXgpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBnZXREYXRlKGNhbmRpZGF0ZSk7XG4gICAgICAgIGNvbnN0IGFib3ZlTWluID0gIW1pbiB8fCBnZXREYXRlKG1pbikgPD0gdmFsdWU7XG4gICAgICAgIGNvbnN0IGJlbG93TWF4ID0gIW1heCB8fCB2YWx1ZSA8PSBnZXREYXRlKG1heCk7XG4gICAgICAgIHJldHVybiBhYm92ZU1pbiAmJiBiZWxvd01heDtcbiAgICB9XG4gICAgYmVnaW5uaW5nT2ZQZXJpb2QoZGF0ZSkge1xuICAgICAgICBpZiAoIWRhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjcmVhdGVEYXRlKGRhdGUuZ2V0RnVsbFllYXIoKSwgZGF0ZS5nZXRNb250aCgpLCAxKTtcbiAgICB9XG4gICAgaXNSYW5nZVN0YXJ0KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAhdmFsdWUuZ2V0TW9udGgoKTtcbiAgICB9XG4gICAgbW92ZSh2YWx1ZSwgYWN0aW9uKSB7XG4gICAgICAgIGNvbnN0IG1vZGlmaWVyID0gQUNUSU9OUyQyW2FjdGlvbl07XG4gICAgICAgIGlmICghbW9kaWZpZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbW9kaWZpZXIodmFsdWUpO1xuICAgIH1cbiAgICBjZWxsVGl0bGUodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludGxTZXJ2aWNlLmZvcm1hdERhdGUodmFsdWUsICdEJyk7XG4gICAgfVxuICAgIG5hdmlnYXRpb25UaXRsZSh2YWx1ZSkge1xuICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuaXNSYW5nZVN0YXJ0KHZhbHVlKSA/IHZhbHVlLmdldEZ1bGxZZWFyKCkudG9TdHJpbmcoKSA6IHRoaXMuYWJick1vbnRoTmFtZXMoKVt2YWx1ZS5nZXRNb250aCgpXTtcbiAgICB9XG4gICAgdGl0bGUoY3VycmVudCkge1xuICAgICAgICByZXR1cm4gYCR7dGhpcy53aWRlTW9udGhOYW1lcygpW2N1cnJlbnQuZ2V0TW9udGgoKV19ICR7Y3VycmVudC5nZXRGdWxsWWVhcigpfWA7XG4gICAgfVxuICAgIHJvd0xlbmd0aChvcHRpb25zID0ge30pIHtcbiAgICAgICAgcmV0dXJuIENFTExTX0xFTkdUSCQyICsgKG9wdGlvbnMucHJlcGVuZENlbGwgPyAxIDogMCk7XG4gICAgfVxuICAgIHNraXAodmFsdWUsIG1pbikge1xuICAgICAgICByZXR1cm4gZHVyYXRpb25Jbk1vbnRocyhtaW4sIHZhbHVlKTtcbiAgICB9XG4gICAgdG90YWwobWluLCBtYXgpIHtcbiAgICAgICAgcmV0dXJuIGR1cmF0aW9uSW5Nb250aHMobWluLCBtYXgpICsgMTtcbiAgICB9XG4gICAgdmFsdWUoY3VycmVudCkge1xuICAgICAgICByZXR1cm4gY3VycmVudCA/IGN1cnJlbnQuZ2V0RGF0ZSgpLnRvU3RyaW5nKCkgOiBcIlwiO1xuICAgIH1cbiAgICB2aWV3RGF0ZShkYXRlLCBtYXgsIHZpZXdzQ291bnQgPSAxKSB7XG4gICAgICAgIGNvbnN0IHZpZXdzSW5SYW5nZSA9IHRoaXMudG90YWwoZGF0ZSwgbWF4KTtcbiAgICAgICAgaWYgKHZpZXdzSW5SYW5nZSA8IHZpZXdzQ291bnQpIHtcbiAgICAgICAgICAgIGNvbnN0IG1vbnRoc1RvU3VidHJhY3QgPSB2aWV3c0NvdW50IC0gdmlld3NJblJhbmdlO1xuICAgICAgICAgICAgcmV0dXJuIGFkZE1vbnRocyhkYXRlLCAtMSAqIG1vbnRoc1RvU3VidHJhY3QpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRlO1xuICAgIH1cbiAgICBpc1dlZWtlbmQoZGF0ZSkge1xuICAgICAgICBjb25zdCB7IHN0YXJ0LCBlbmQgfSA9IHRoaXMuX2ludGxTZXJ2aWNlLndlZWtlbmRSYW5nZSgpO1xuICAgICAgICBjb25zdCBkYXkgPSBkYXRlLmdldERheSgpO1xuICAgICAgICBpZiAoZW5kIDwgc3RhcnQpIHtcbiAgICAgICAgICAgIHJldHVybiBkYXkgPD0gZW5kIHx8IHN0YXJ0IDw9IGRheTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RhcnQgPD0gZGF5ICYmIGRheSA8PSBlbmQ7XG4gICAgfVxuICAgIGFiYnJNb250aE5hbWVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW50bFNlcnZpY2UuZGF0ZUZvcm1hdE5hbWVzKHsgbmFtZVR5cGU6ICdhYmJyZXZpYXRlZCcsIHR5cGU6ICdtb250aHMnIH0pO1xuICAgIH1cbiAgICBub3JtYWxpemUoY2VsbERhdGUsIG1pbiwgbWF4KSB7XG4gICAgICAgIGlmIChjZWxsRGF0ZSA8IG1pbiAmJiB0aGlzLmlzRXF1YWwoY2VsbERhdGUsIG1pbikpIHtcbiAgICAgICAgICAgIHJldHVybiBjbG9uZURhdGUobWluKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2VsbERhdGUgPiBtYXggJiYgdGhpcy5pc0VxdWFsKGNlbGxEYXRlLCBtYXgpKSB7XG4gICAgICAgICAgICByZXR1cm4gY2xvbmVEYXRlKG1heCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNlbGxEYXRlO1xuICAgIH1cbiAgICB3aWRlTW9udGhOYW1lcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludGxTZXJ2aWNlLmRhdGVGb3JtYXROYW1lcyh7IG5hbWVUeXBlOiAnd2lkZScsIHR5cGU6ICdtb250aHMnIH0pO1xuICAgIH1cbn07XG5Nb250aFZpZXdTZXJ2aWNlID0gX19kZWNvcmF0ZShbXG4gICAgSW5qZWN0YWJsZSgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbSW50bFNlcnZpY2VdKVxuXSwgTW9udGhWaWV3U2VydmljZSk7XG5cbmNvbnN0IEVNUFRZX0RBVEEkMyA9IFtbXV07XG5jb25zdCBDRUxMU19MRU5HVEgkMyA9IDQ7XG5jb25zdCBST1dTX0xFTkdUSCQzID0gMztcbmNvbnN0IHVwU3RlcCA9IChtb250aCkgPT4ge1xuICAgIGlmIChtb250aCA+IDQpIHtcbiAgICAgICAgcmV0dXJuIC01O1xuICAgIH1cbiAgICBpZiAobW9udGggPCAyKSB7XG4gICAgICAgIHJldHVybiAtMjtcbiAgICB9XG4gICAgcmV0dXJuIC03O1xufTtcbmNvbnN0IGRvd25TdGVwID0gKG1vbnRoKSA9PiB7XG4gICAgaWYgKG1vbnRoIDwgNykge1xuICAgICAgICByZXR1cm4gNTtcbiAgICB9XG4gICAgaWYgKG1vbnRoIDwgMTApIHtcbiAgICAgICAgcmV0dXJuIDc7XG4gICAgfVxuICAgIHJldHVybiAyO1xufTtcbmNvbnN0IEFDVElPTlMkMyA9IHtcbiAgICBbQWN0aW9uLkxlZnRdOiAoZGF0ZSkgPT4gYWRkTW9udGhzKGRhdGUsIC0xKSxcbiAgICBbQWN0aW9uLlVwXTogKGRhdGUpID0+IGFkZE1vbnRocyhkYXRlLCB1cFN0ZXAoZGF0ZS5nZXRNb250aCgpKSksXG4gICAgW0FjdGlvbi5SaWdodF06IChkYXRlKSA9PiBhZGRNb250aHMoZGF0ZSwgMSksXG4gICAgW0FjdGlvbi5Eb3duXTogKGRhdGUpID0+IGFkZE1vbnRocyhkYXRlLCBkb3duU3RlcChkYXRlLmdldE1vbnRoKCkpKSxcbiAgICBbQWN0aW9uLlByZXZWaWV3XTogKGRhdGUpID0+IGFkZFllYXJzKGRhdGUsIC0xKSxcbiAgICBbQWN0aW9uLk5leHRWaWV3XTogKGRhdGUpID0+IGFkZFllYXJzKGRhdGUsIDEpLFxuICAgIFtBY3Rpb24uRmlyc3RJblZpZXddOiAoZGF0ZSkgPT4gZmlyc3RNb250aE9mWWVhcihkYXRlKSxcbiAgICBbQWN0aW9uLkxhc3RJblZpZXddOiAoZGF0ZSkgPT4gbGFzdE1vbnRoT2ZZZWFyKGRhdGUpXG59O1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmxldCBZZWFyVmlld1NlcnZpY2UgPSBjbGFzcyBZZWFyVmlld1NlcnZpY2Uge1xuICAgIGNvbnN0cnVjdG9yKF9pbnRsU2VydmljZSkge1xuICAgICAgICB0aGlzLl9pbnRsU2VydmljZSA9IF9pbnRsU2VydmljZTtcbiAgICAgICAgdGhpcy5kYXRlUmFuZ2UgPSAoc3RhcnQsIGVuZCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFpc1ByZXNlbnQoc3RhcnQpIHx8ICFpc1ByZXNlbnQoZW5kKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICAgICAgbGV0IGN1cnJlbnQgPSBzdGFydDtcbiAgICAgICAgICAgIHdoaWxlIChjdXJyZW50IDw9IGVuZCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGN1cnJlbnQpO1xuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBhZGRNb250aHMoY3VycmVudCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuICAgIH1cbiAgICBhZGRUb0RhdGUobWluLCBza2lwKSB7XG4gICAgICAgIHJldHVybiBhZGRZZWFycyhtaW4sIHNraXApO1xuICAgIH1cbiAgICBkYXRlc0xpc3Qoc3RhcnQsIGNvdW50KSB7XG4gICAgICAgIHJldHVybiByYW5nZSgwLCBjb3VudCkubWFwKGkgPT4gYWRkWWVhcnMoc3RhcnQsIGkpKTtcbiAgICB9XG4gICAgZGF0YShvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHsgY2VsbFVJRCwgZm9jdXNlZERhdGUsIGlzQWN0aXZlVmlldywgbWF4LCBtaW4sIHNlbGVjdGVkRGF0ZXMsIHNlbGVjdGlvblJhbmdlID0gRU1QVFlfU0VMRUNUSU9OUkFOR0UsIHZpZXdEYXRlIH0gPSBvcHRpb25zO1xuICAgICAgICBpZiAoIXZpZXdEYXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gRU1QVFlfREFUQSQzO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1vbnRocyA9IHRoaXMuYWJick1vbnRoTmFtZXMoKTtcbiAgICAgICAgY29uc3QgZmlyc3REYXRlID0gZmlyc3RNb250aE9mWWVhcih2aWV3RGF0ZSk7XG4gICAgICAgIGNvbnN0IGxhc3REYXRlID0gbGFzdE1vbnRoT2ZZZWFyKHZpZXdEYXRlKTtcbiAgICAgICAgY29uc3QgY3VycmVudFllYXIgPSBmaXJzdERhdGUuZ2V0RnVsbFllYXIoKTtcbiAgICAgICAgY29uc3QgY2VsbHMgPSByYW5nZSgwLCBDRUxMU19MRU5HVEgkMyk7XG4gICAgICAgIGNvbnN0IHRvZGF5ID0gZ2V0VG9kYXkoKTtcbiAgICAgICAgcmV0dXJuIHJhbmdlKDAsIFJPV1NfTEVOR1RIJDMpLm1hcChyb3dPZmZzZXQgPT4ge1xuICAgICAgICAgICAgY29uc3QgYmFzZURhdGUgPSBhZGRNb250aHMoZmlyc3REYXRlLCByb3dPZmZzZXQgKiBDRUxMU19MRU5HVEgkMyk7XG4gICAgICAgICAgICByZXR1cm4gY2VsbHMubWFwKGNlbGxPZmZzZXQgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNlbGxEYXRlID0gdGhpcy5ub3JtYWxpemUoYWRkTW9udGhzKGJhc2VEYXRlLCBjZWxsT2Zmc2V0KSwgbWluLCBtYXgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoYW5nZWRZZWFyID0gY3VycmVudFllYXIgPCBjZWxsRGF0ZS5nZXRGdWxsWWVhcigpO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5pc0luUmFuZ2UoY2VsbERhdGUsIG1pbiwgbWF4KSB8fCBjaGFuZ2VkWWVhcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgaXNSYW5nZVN0YXJ0ID0gdGhpcy5pc0VxdWFsKGNlbGxEYXRlLCBzZWxlY3Rpb25SYW5nZS5zdGFydCk7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNSYW5nZUVuZCA9IHRoaXMuaXNFcXVhbChjZWxsRGF0ZSwgc2VsZWN0aW9uUmFuZ2UuZW5kKTtcbiAgICAgICAgICAgICAgICBjb25zdCBpc0luTWlkZGxlID0gIWlzUmFuZ2VTdGFydCAmJiAhaXNSYW5nZUVuZDtcbiAgICAgICAgICAgICAgICBjb25zdCBpc1JhbmdlTWlkID0gaXNJbk1pZGRsZSAmJiBpc0luU2VsZWN0aW9uUmFuZ2UoY2VsbERhdGUsIHNlbGVjdGlvblJhbmdlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBmb3JtYXR0ZWRWYWx1ZTogbW9udGhzW2NlbGxEYXRlLmdldE1vbnRoKCldLFxuICAgICAgICAgICAgICAgICAgICBpZDogYCR7Y2VsbFVJRH0ke2NlbGxEYXRlLmdldFRpbWUoKX1gLFxuICAgICAgICAgICAgICAgICAgICBpc0ZvY3VzZWQ6IHRoaXMuaXNFcXVhbChjZWxsRGF0ZSwgZm9jdXNlZERhdGUpLFxuICAgICAgICAgICAgICAgICAgICBpc1NlbGVjdGVkOiBpc0FjdGl2ZVZpZXcgJiYgc2VsZWN0ZWREYXRlcy5zb21lKGRhdGUgPT4gdGhpcy5pc0VxdWFsKGNlbGxEYXRlLCBkYXRlKSksXG4gICAgICAgICAgICAgICAgICAgIGlzV2Vla2VuZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGlzUmFuZ2VTdGFydDogaXNSYW5nZVN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICBpc1JhbmdlTWlkOiBpc1JhbmdlTWlkLFxuICAgICAgICAgICAgICAgICAgICBpc1JhbmdlRW5kOiBpc1JhbmdlRW5kLFxuICAgICAgICAgICAgICAgICAgICBpc1JhbmdlU3BsaXRFbmQ6IGlzUmFuZ2VNaWQgJiYgdGhpcy5pc0VxdWFsKGNlbGxEYXRlLCBsYXN0RGF0ZSksXG4gICAgICAgICAgICAgICAgICAgIGlzUmFuZ2VTcGxpdFN0YXJ0OiBpc1JhbmdlTWlkICYmIHRoaXMuaXNFcXVhbChjZWxsRGF0ZSwgZmlyc3REYXRlKSxcbiAgICAgICAgICAgICAgICAgICAgaXNUb2RheTogdGhpcy5pc0VxdWFsKGNlbGxEYXRlLCB0b2RheSksXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiB0aGlzLmNlbGxUaXRsZShjZWxsRGF0ZSksXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBjZWxsRGF0ZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlzRXF1YWwoY2FuZGlkYXRlLCBleHBlY3RlZCkge1xuICAgICAgICBpZiAoIWNhbmRpZGF0ZSB8fCAhZXhwZWN0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2FuZGlkYXRlLmdldEZ1bGxZZWFyKCkgPT09IGV4cGVjdGVkLmdldEZ1bGxZZWFyKCkgJiZcbiAgICAgICAgICAgIGNhbmRpZGF0ZS5nZXRNb250aCgpID09PSBleHBlY3RlZC5nZXRNb250aCgpO1xuICAgIH1cbiAgICBpc0luQXJyYXkoZGF0ZSwgZGF0ZXMpIHtcbiAgICAgICAgaWYgKCFkYXRlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB5ZWFyID0gZGF0ZS5nZXRGdWxsWWVhcigpO1xuICAgICAgICByZXR1cm4gZGF0ZXNbMF0uZ2V0RnVsbFllYXIoKSA8PSB5ZWFyICYmIHllYXIgPD0gZGF0ZXNbZGF0ZXMubGVuZ3RoIC0gMV0uZ2V0RnVsbFllYXIoKTtcbiAgICB9XG4gICAgaXNJblJhbmdlKGNhbmRpZGF0ZSwgbWluLCBtYXgpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlVmFsdWUgPSBjcmVhdGVEYXRlKGNhbmRpZGF0ZS5nZXRGdWxsWWVhcigpLCBjYW5kaWRhdGUuZ2V0TW9udGgoKSwgMSk7XG4gICAgICAgIGNvbnN0IGFib3ZlTWluID0gIW1pbiB8fCBjcmVhdGVEYXRlKG1pbi5nZXRGdWxsWWVhcigpLCBtaW4uZ2V0TW9udGgoKSwgMSkgPD0gY2FuZGlkYXRlVmFsdWU7XG4gICAgICAgIGNvbnN0IGJlbG93TWF4ID0gIW1heCB8fCBjYW5kaWRhdGVWYWx1ZSA8PSBjcmVhdGVEYXRlKG1heC5nZXRGdWxsWWVhcigpLCBtYXguZ2V0TW9udGgoKSwgMSk7XG4gICAgICAgIHJldHVybiBhYm92ZU1pbiAmJiBiZWxvd01heDtcbiAgICB9XG4gICAgYmVnaW5uaW5nT2ZQZXJpb2QoZGF0ZSkge1xuICAgICAgICBpZiAoIWRhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjcmVhdGVEYXRlKGRhdGUuZ2V0RnVsbFllYXIoKSwgMCwgMSk7XG4gICAgfVxuICAgIGlzUmFuZ2VTdGFydCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUuZ2V0RnVsbFllYXIoKSAlIDEwID09PSAwO1xuICAgIH1cbiAgICBtb3ZlKHZhbHVlLCBhY3Rpb24pIHtcbiAgICAgICAgY29uc3QgbW9kaWZpZXIgPSBBQ1RJT05TJDNbYWN0aW9uXTtcbiAgICAgICAgaWYgKCFtb2RpZmllcikge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtb2RpZmllcih2YWx1ZSk7XG4gICAgfVxuICAgIGNlbGxUaXRsZSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gYCR7dmFsdWUuZ2V0RnVsbFllYXIoKX0gJHt0aGlzLnZhbHVlKHZhbHVlKX1gO1xuICAgIH1cbiAgICBuYXZpZ2F0aW9uVGl0bGUodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGl0bGUodmFsdWUpO1xuICAgIH1cbiAgICB0aXRsZShjdXJyZW50KSB7XG4gICAgICAgIHJldHVybiBjdXJyZW50ID8gY3VycmVudC5nZXRGdWxsWWVhcigpLnRvU3RyaW5nKCkgOiAnJztcbiAgICB9XG4gICAgcm93TGVuZ3RoKCkge1xuICAgICAgICByZXR1cm4gQ0VMTFNfTEVOR1RIJDM7XG4gICAgfVxuICAgIHNraXAodmFsdWUsIG1pbikge1xuICAgICAgICByZXR1cm4gZHVyYXRpb25JblllYXJzKG1pbiwgdmFsdWUpO1xuICAgIH1cbiAgICB0b3RhbChtaW4sIG1heCkge1xuICAgICAgICByZXR1cm4gZHVyYXRpb25JblllYXJzKG1pbiwgbWF4KSArIDE7XG4gICAgfVxuICAgIHZhbHVlKGN1cnJlbnQpIHtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnQgPyB0aGlzLmFiYnJNb250aE5hbWVzKClbY3VycmVudC5nZXRNb250aCgpXSA6ICcnO1xuICAgIH1cbiAgICB2aWV3RGF0ZShkYXRlLCBtYXgsIHZpZXdzQ291bnQgPSAxKSB7XG4gICAgICAgIGNvbnN0IHZpZXdzSW5SYW5nZSA9IHRoaXMudG90YWwoZGF0ZSwgbWF4KTtcbiAgICAgICAgaWYgKHZpZXdzSW5SYW5nZSA8IHZpZXdzQ291bnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHllYXJzVG9TdWJ0cmFjdCA9IHZpZXdzQ291bnQgLSB2aWV3c0luUmFuZ2U7XG4gICAgICAgICAgICByZXR1cm4gYWRkWWVhcnMoZGF0ZSwgLTEgKiB5ZWFyc1RvU3VidHJhY3QpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRlO1xuICAgIH1cbiAgICBhYmJyTW9udGhOYW1lcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludGxTZXJ2aWNlLmRhdGVGb3JtYXROYW1lcyh7IG5hbWVUeXBlOiAnYWJicmV2aWF0ZWQnLCB0eXBlOiAnbW9udGhzJyB9KTtcbiAgICB9XG4gICAgbm9ybWFsaXplKGNlbGxEYXRlLCBtaW4sIG1heCkge1xuICAgICAgICBpZiAoY2VsbERhdGUgPCBtaW4gJiYgdGhpcy5pc0VxdWFsKGNlbGxEYXRlLCBtaW4pKSB7XG4gICAgICAgICAgICByZXR1cm4gY2xvbmVEYXRlKG1pbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNlbGxEYXRlID4gbWF4ICYmIHRoaXMuaXNFcXVhbChjZWxsRGF0ZSwgbWF4KSkge1xuICAgICAgICAgICAgcmV0dXJuIGNsb25lRGF0ZShtYXgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjZWxsRGF0ZTtcbiAgICB9XG59O1xuWWVhclZpZXdTZXJ2aWNlID0gX19kZWNvcmF0ZShbXG4gICAgSW5qZWN0YWJsZSgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbSW50bFNlcnZpY2VdKVxuXSwgWWVhclZpZXdTZXJ2aWNlKTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKlxuICogVGhlIEVudW0gd2hpY2ggZGVmaW5lcyBhbGwgcG9zc2libGUgQ2FsZW5kYXIgdmlldyB0eXBlcy5cbiAqL1xudmFyIENhbGVuZGFyVmlld0VudW07XG4oZnVuY3Rpb24gKENhbGVuZGFyVmlld0VudW0pIHtcbiAgICBDYWxlbmRhclZpZXdFbnVtW0NhbGVuZGFyVmlld0VudW1bXCJtb250aFwiXSA9IDBdID0gXCJtb250aFwiO1xuICAgIENhbGVuZGFyVmlld0VudW1bQ2FsZW5kYXJWaWV3RW51bVtcInllYXJcIl0gPSAxXSA9IFwieWVhclwiO1xuICAgIENhbGVuZGFyVmlld0VudW1bQ2FsZW5kYXJWaWV3RW51bVtcImRlY2FkZVwiXSA9IDJdID0gXCJkZWNhZGVcIjtcbiAgICBDYWxlbmRhclZpZXdFbnVtW0NhbGVuZGFyVmlld0VudW1bXCJjZW50dXJ5XCJdID0gM10gPSBcImNlbnR1cnlcIjtcbn0pKENhbGVuZGFyVmlld0VudW0gfHwgKENhbGVuZGFyVmlld0VudW0gPSB7fSkpO1xuXG5jb25zdCBzZXJ2aWNlcyA9IHtcbiAgICBbQ2FsZW5kYXJWaWV3RW51bS5tb250aF06IE1vbnRoVmlld1NlcnZpY2UsXG4gICAgW0NhbGVuZGFyVmlld0VudW0ueWVhcl06IFllYXJWaWV3U2VydmljZSxcbiAgICBbQ2FsZW5kYXJWaWV3RW51bS5kZWNhZGVdOiBEZWNhZGVWaWV3U2VydmljZSxcbiAgICBbQ2FsZW5kYXJWaWV3RW51bS5jZW50dXJ5XTogQ2VudHVyeVZpZXdTZXJ2aWNlXG59O1xuY29uc3Qgdmlld09mZnNldCA9ICh2aWV3LCBvZmZzZXQpID0+IHtcbiAgICBjb25zdCBjYW5kaWRhdGUgPSBDYWxlbmRhclZpZXdFbnVtW0NhbGVuZGFyVmlld0VudW1bdmlldyArIG9mZnNldF1dO1xuICAgIHJldHVybiBjYW5kaWRhdGUgIT09IHVuZGVmaW5lZCA/IGNhbmRpZGF0ZSA6IHZpZXc7XG59O1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmxldCBCdXNWaWV3U2VydmljZSA9IGNsYXNzIEJ1c1ZpZXdTZXJ2aWNlIHtcbiAgICBjb25zdHJ1Y3RvcihpbmplY3Rvcikge1xuICAgICAgICB0aGlzLmluamVjdG9yID0gaW5qZWN0b3I7XG4gICAgICAgIHRoaXMudmlld0NoYW5nZWQgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuYm90dG9tID0gQ2FsZW5kYXJWaWV3RW51bS5tb250aDtcbiAgICAgICAgdGhpcy50b3AgPSBDYWxlbmRhclZpZXdFbnVtLmNlbnR1cnk7XG4gICAgfVxuICAgIGNvbmZpZ3VyZShib3R0b20sIHRvcCkge1xuICAgICAgICB0aGlzLmJvdHRvbSA9IGJvdHRvbTtcbiAgICAgICAgdGhpcy50b3AgPSB0b3A7XG4gICAgfVxuICAgIHNlcnZpY2Uodmlldykge1xuICAgICAgICBjb25zdCBzZXJ2aWNlVHlwZSA9IHNlcnZpY2VzW3ZpZXddO1xuICAgICAgICByZXR1cm4gc2VydmljZVR5cGUgPyB0aGlzLmluamVjdG9yLmdldChzZXJ2aWNlVHlwZSkgOiBudWxsO1xuICAgIH1cbiAgICBtb3ZlRG93bih2aWV3KSB7XG4gICAgICAgIHRoaXMubW92ZSh2aWV3LCAtMSk7XG4gICAgfVxuICAgIG1vdmVVcCh2aWV3KSB7XG4gICAgICAgIHRoaXMubW92ZSh2aWV3LCAxKTtcbiAgICB9XG4gICAgbW92ZVRvQm90dG9tKGFjdGl2ZVZpZXcpIHtcbiAgICAgICAgaWYgKGFjdGl2ZVZpZXcgPT09IHRoaXMuYm90dG9tKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52aWV3Q2hhbmdlZC5lbWl0KHsgdmlldzogdGhpcy5ib3R0b20gfSk7XG4gICAgfVxuICAgIGNhbk1vdmVEb3duKHZpZXcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYm90dG9tIDwgdmlldztcbiAgICB9XG4gICAgY2FuTW92ZVVwKHZpZXcpIHtcbiAgICAgICAgcmV0dXJuIHZpZXcgPCB0aGlzLnRvcDtcbiAgICB9XG4gICAgY2xhbXAodmlldykge1xuICAgICAgICBpZiAodmlldyA8IHRoaXMuYm90dG9tKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ib3R0b207XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZpZXcgPiB0aGlzLnRvcCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9wO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2aWV3O1xuICAgIH1cbiAgICBtb3ZlKHZpZXcsIG9mZnNldCkge1xuICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSB0aGlzLmNsYW1wKHZpZXdPZmZzZXQodmlldywgb2Zmc2V0KSk7XG4gICAgICAgIGlmIChjYW5kaWRhdGUgPT09IHZpZXcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnZpZXdDaGFuZ2VkLmVtaXQoeyB2aWV3OiBjYW5kaWRhdGUgfSk7XG4gICAgfVxufTtcbkJ1c1ZpZXdTZXJ2aWNlID0gX19kZWNvcmF0ZShbXG4gICAgSW5qZWN0YWJsZSgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbSW5qZWN0b3JdKVxuXSwgQnVzVmlld1NlcnZpY2UpO1xuXG5jb25zdCBkaXYgPSBkb21Db250YWluZXJGYWN0b3J5KCdkaXYnKTtcbmNvbnN0IHVsID0gZG9tQ29udGFpbmVyRmFjdG9yeSgndWwnKTtcbmNvbnN0IGxpID0gZG9tQ29udGFpbmVyRmFjdG9yeSgnbGknKTtcbmNvbnN0IHRkID0gZG9tQ29udGFpbmVyRmFjdG9yeSgndGQnKTtcbmNvbnN0IHRoID0gZG9tQ29udGFpbmVyRmFjdG9yeSgndGgnKTtcbmNvbnN0IHRyID0gZG9tQ29udGFpbmVyRmFjdG9yeSgndHInKTtcbmNvbnN0IHRib2R5ID0gZG9tQ29udGFpbmVyRmFjdG9yeSgndGJvZHknKTtcbmNvbnN0IHRoZWFkID0gZG9tQ29udGFpbmVyRmFjdG9yeSgndGhlYWQnKTtcbmNvbnN0IHRhYmxlID0gZG9tQ29udGFpbmVyRmFjdG9yeSgndGFibGUnKTtcbmNvbnN0IG1vbnRoSGVhZGVyID0gKCkgPT4gKGRpdihgXG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cImstYnV0dG9uIGstZmxhdCBrLXRpdGxlIGstY2FsZW5kYXItdGl0bGVcIj5NYXJjaCAyMDE3PC9zcGFuPlxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJrLXNwYWNlclwiPjwvc3Bhbj5cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiay1jYWxlbmRhci1uYXYgay1oc3RhY2tcIj5cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImstdG9kYXkgay1uYXYtdG9kYXlcIj5UT0RBWTwvc3Bhbj5cbiAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgYCwgJ2stY2FsZW5kYXItaGVhZGVyIGstaHN0YWNrJykpO1xuY29uc3QgbW9udGhXZWVrSGVhZGVyID0gKCkgPT4gKHRhYmxlKFtcbiAgICB0aGVhZChbXG4gICAgICAgIHRyKFt0aCgnTU8nLCAnay1jYWxlbmRhci10aCcpXSwgJ2stY2FsZW5kYXItdHInKVxuICAgIF0sICdrLWNhbGVuZGFyLXRoZWFkJylcbl0sICdrLWNhbGVuZGFyLXdlZWtkYXlzIGstY2FsZW5kYXItdGFibGUnKSk7XG5jb25zdCByZXBlYXQgPSAoY291bnQsIG1hcHBlcikgPT4gbmV3IEFycmF5KGNvdW50KS5maWxsKCcxJykubWFwKG1hcHBlcik7XG5jb25zdCBjb250ZW50ID0gKHJvd3MsIGNlbGxzID0gMSkgPT4gKHRhYmxlKFtcbiAgICB0Ym9keShbdHIoW3RoKCcxJywgJ2stY2FsZW5kYXItdGgnKV0sICdrLWNhbGVuZGFyLXRyJyldLmNvbmNhdChyZXBlYXQocm93cywgKCkgPT4gdHIocmVwZWF0KGNlbGxzLCBjID0+IHRkKGA8c3BhbiBjbGFzcz1cImstbGlua1wiPiR7Y308L3NwYW4+YCwgJ2stY2FsZW5kYXItdGQnKSksICdrLWNhbGVuZGFyLXRyJykpKSwgJ2stY2FsZW5kYXItdGJvZHknKVxuXSwgJ2stY2FsZW5kYXItdGFibGUnKSk7XG5jb25zdCBzY3JvbGxhYmxlID0gKGNoaWxkcmVuKSA9PiBkaXYoY2hpbGRyZW4sICdrLWZsZXggay1jb250ZW50IGstY2FsZW5kYXItY29udGVudCBrLXNjcm9sbGFibGUnKTtcbmNvbnN0IHZpZXcgPSAoY29udGVudEVsZW1lbnQsIGNsYXNzTmFtZSwgcmVuZGVyV2Vla0hlYWRlcikgPT4gKGRpdihbXG4gICAgbW9udGhIZWFkZXIoKSxcbiAgICByZW5kZXJXZWVrSGVhZGVyID8gbW9udGhXZWVrSGVhZGVyKCkgOiBudWxsLFxuICAgIHNjcm9sbGFibGUoW2NvbnRlbnRFbGVtZW50LCBjb250ZW50RWxlbWVudF0pXG5dLCBjbGFzc05hbWUsIHsgbGVmdDogJy0xMDAwMHB4JywgcG9zaXRpb246ICdhYnNvbHV0ZScgfSkpO1xuY29uc3QgybU2ID0gKCkgPT4ge1xuICAgIGxldCBuYXZFbGVtZW50O1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGlmICghaXNEb2N1bWVudEF2YWlsYWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFuYXZFbGVtZW50KSB7XG4gICAgICAgICAgICBuYXZFbGVtZW50ID0gZGl2KFtzY3JvbGxhYmxlKFt1bChbbGkoJzxzcGFuPkZFQjwvc3Bhbj4nKV0pXSldLCAnay1jYWxlbmRhci1uYXZpZ2F0aW9uJywgeyBsZWZ0OiAnMHB4JywgcG9zaXRpb246ICdhYnNvbHV0ZScgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5hdkVsZW1lbnQ7XG4gICAgfTtcbn07XG5jb25zdCBuYXZpZ2F0aW9uTGlzdCA9ICjJtTYpKCk7XG5jb25zdCB2aWV3RmFjdG9yeSA9ICh7IGNlbGxzLCByb3dzIH0sIGNsYXNzTmFtZSwgcmVuZGVyV2Vla0hlYWRlcikgPT4ge1xuICAgIGxldCB2aWV3RWxlbWVudDtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBpZiAoIWlzRG9jdW1lbnRBdmFpbGFibGUpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdmlld0VsZW1lbnQpIHtcbiAgICAgICAgICAgIHZpZXdFbGVtZW50ID0gdmlldyhjb250ZW50KHJvd3MsIGNlbGxzKSwgY2xhc3NOYW1lLCByZW5kZXJXZWVrSGVhZGVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmlld0VsZW1lbnQ7XG4gICAgfTtcbn07XG5jb25zdCBnZXRTY3JvbGxhYmxlID0gKGVsZW1lbnQpID0+IGVsZW1lbnQucXVlcnlTZWxlY3RvcignLmstc2Nyb2xsYWJsZScpO1xuY29uc3QgaG9yaXpvbnRhbCA9IGVsZW1lbnQgPT4ge1xuICAgIGNvbnN0IHNjcm9sbGFibGVFbGVtZW50ID0gZ2V0U2Nyb2xsYWJsZShlbGVtZW50KTtcbiAgICBzY3JvbGxhYmxlRWxlbWVudC5jbGFzc0xpc3QuYWRkKCdrLXNjcm9sbGFibGUtaG9yaXpvbnRhbCcpO1xuICAgIHJldHVybiBlbGVtZW50O1xufTtcbmNvbnN0IG1vbnRoVmlldyA9IHZpZXdGYWN0b3J5KHsgY2VsbHM6IDcsIHJvd3M6IDYgfSwgJ2stdnN0YWNrIGstY2FsZW5kYXItdmlldyBrLWNhbGVuZGFyLW1vbnRodmlldycsIHRydWUpO1xuY29uc3QgeWVhclZpZXcgPSB2aWV3RmFjdG9yeSh7IGNlbGxzOiA0LCByb3dzOiAzIH0sICdrLXZzdGFjayBrLWNhbGVuZGFyLXZpZXcgay1jYWxlbmRhci15ZWFydmlldycsIGZhbHNlKTtcbmNvbnN0IGRlY2FkZVZpZXcgPSB2aWV3RmFjdG9yeSh7IGNlbGxzOiA0LCByb3dzOiAzIH0sICdrLXZzdGFjayBrLWNhbGVuZGFyLXZpZXcgay1jYWxlbmRhci1kZWNhZGV2aWV3JywgZmFsc2UpO1xuY29uc3QgaG9yek1vbnRoVmlldyA9ICgpID0+IGhvcml6b250YWwobW9udGhWaWV3KCkpO1xuY29uc3QgaG9yelllYXJWaWV3ID0gKCkgPT4gaG9yaXpvbnRhbCh5ZWFyVmlldygpKTtcbmNvbnN0IGhvcnpEZWNhZGVWaWV3ID0gKCkgPT4gaG9yaXpvbnRhbChkZWNhZGVWaWV3KCkpO1xuY29uc3QgaGVpZ2h0ID0gKGVsZW1lbnQpID0+IChwYXJzZUZsb2F0KHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLmhlaWdodCkgfHwgZWxlbWVudC5vZmZzZXRIZWlnaHQpO1xuY29uc3Qgd2lkdGggPSAoZWxlbWVudCkgPT4ge1xuICAgIGNvbnN0IHN0eWxlcyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xuICAgIGNvbnN0IGNvbXB1dGVkID0gcGFyc2VGbG9hdChzdHlsZXMud2lkdGgpXG4gICAgICAgICsgcGFyc2VGbG9hdChzdHlsZXMucGFkZGluZ0xlZnQpXG4gICAgICAgICsgcGFyc2VGbG9hdChzdHlsZXMucGFkZGluZ1JpZ2h0KTtcbiAgICByZXR1cm4gY29tcHV0ZWQgfHwgZWxlbWVudC5vZmZzZXRXaWR0aDtcbn07XG5jb25zdCBnZXRCb2R5ID0gKGVsZW1lbnQpID0+IGVsZW1lbnQucXVlcnlTZWxlY3RvcigndGJvZHknKTtcbi8qKlxuICogQGhpZGRlblxuICovXG5sZXQgQ2FsZW5kYXJET01TZXJ2aWNlID0gY2xhc3MgQ2FsZW5kYXJET01TZXJ2aWNlIHtcbiAgICBlbnN1cmVIZWlnaHRzKCkge1xuICAgICAgICBpZiAodGhpcy5jYWxlbmRhckhlaWdodCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jYWxjdWxhdGVIZWlnaHRzKCk7XG4gICAgfVxuICAgIGNhbGN1bGF0ZUhlaWdodHMoY29udGFpbmVyKSB7XG4gICAgICAgIGlmICghaXNEb2N1bWVudEF2YWlsYWJsZSgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ob3N0Q29udGFpbmVyID0gY29udGFpbmVyO1xuICAgICAgICB0aGlzLmJhdGNoKG1vbnRoVmlldygpLCAoY29udGVudEVsZW1lbnQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHZpZXdFbGVtZW50ID0gZ2V0Qm9keShjb250ZW50RWxlbWVudCk7XG4gICAgICAgICAgICB0aGlzLmNhbGVuZGFySGVpZ2h0ID0gaGVpZ2h0KGNvbnRlbnRFbGVtZW50KTtcbiAgICAgICAgICAgIHRoaXMubW9udGhWaWV3SGVpZ2h0ID0gaGVpZ2h0KHZpZXdFbGVtZW50KTtcbiAgICAgICAgICAgIHRoaXMuaGVhZGVySGVpZ2h0ID0gaGVpZ2h0KHZpZXdFbGVtZW50LmNoaWxkcmVuWzBdKTtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsYWJsZUNvbnRlbnRIZWlnaHQgPSBoZWlnaHQoZ2V0U2Nyb2xsYWJsZShjb250ZW50RWxlbWVudCkpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5iYXRjaChob3J6TW9udGhWaWV3KCksIChjb250ZW50RWxlbWVudCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgdmlld0VsZW1lbnQgPSBnZXRCb2R5KGNvbnRlbnRFbGVtZW50KTtcbiAgICAgICAgICAgIHRoaXMuY2FsZW5kYXJXaWR0aCA9IHdpZHRoKGNvbnRlbnRFbGVtZW50KTtcbiAgICAgICAgICAgIHRoaXMubW9udGhWaWV3V2lkdGggPSB3aWR0aCh2aWV3RWxlbWVudCk7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbGFibGVDb250ZW50V2lkdGggPSB3aWR0aChnZXRTY3JvbGxhYmxlKGNvbnRlbnRFbGVtZW50KSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmJhdGNoKHllYXJWaWV3KCksIChjb250ZW50RWxlbWVudCkgPT4ge1xuICAgICAgICAgICAgdGhpcy55ZWFyVmlld0hlaWdodCA9IGhlaWdodChnZXRCb2R5KGNvbnRlbnRFbGVtZW50KSk7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbGFibGVZZWFyQ29udGVudEhlaWdodCA9IGhlaWdodChnZXRTY3JvbGxhYmxlKGNvbnRlbnRFbGVtZW50KSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmJhdGNoKGhvcnpZZWFyVmlldygpLCAoY29udGVudEVsZW1lbnQpID0+IHtcbiAgICAgICAgICAgIHRoaXMueWVhclZpZXdXaWR0aCA9IHdpZHRoKGdldEJvZHkoY29udGVudEVsZW1lbnQpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYmF0Y2goZGVjYWRlVmlldygpLCAoY29udGVudEVsZW1lbnQpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZGVjYWRlVmlld0hlaWdodCA9IGhlaWdodChnZXRCb2R5KGNvbnRlbnRFbGVtZW50KSk7XG4gICAgICAgICAgICB0aGlzLmNlbnR1cnlWaWV3SGVpZ2h0ID0gdGhpcy5kZWNhZGVWaWV3SGVpZ2h0O1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5iYXRjaChob3J6RGVjYWRlVmlldygpLCAoY29udGVudEVsZW1lbnQpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZGVjYWRlVmlld1dpZHRoID0gd2lkdGgoZ2V0Qm9keShjb250ZW50RWxlbWVudCkpO1xuICAgICAgICAgICAgdGhpcy5jZW50dXJ5Vmlld1dpZHRoID0gdGhpcy5kZWNhZGVWaWV3V2lkdGg7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmJhdGNoKG5hdmlnYXRpb25MaXN0KCksIChjb250ZW50RWxlbWVudCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5uYXZpZ2F0aW9uSXRlbUhlaWdodCA9IGhlaWdodChjb250ZW50RWxlbWVudC5xdWVyeVNlbGVjdG9yKCdsaScpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHZpZXdIZWlnaHQodmlld1R5cGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld0RpbWVuc2lvbih2aWV3VHlwZSwgJ2hlaWdodCcpO1xuICAgIH1cbiAgICB2aWV3V2lkdGgodmlld1R5cGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld0RpbWVuc2lvbih2aWV3VHlwZSwgJ3dpZHRoJyk7XG4gICAgfVxuICAgIHZpZXdEaW1lbnNpb24odmlld1R5cGUsIGRpbWVuc2lvbikge1xuICAgICAgICBjb25zdCB2aWV3UHJvcCA9IGRpbWVuc2lvbiA9PT0gJ2hlaWdodCcgPyAnVmlld0hlaWdodCcgOiAnVmlld1dpZHRoJztcbiAgICAgICAgc3dpdGNoICh2aWV3VHlwZSkge1xuICAgICAgICAgICAgY2FzZSBDYWxlbmRhclZpZXdFbnVtLm1vbnRoOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzW2Btb250aCR7dmlld1Byb3B9YF07XG4gICAgICAgICAgICBjYXNlIENhbGVuZGFyVmlld0VudW0ueWVhcjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1tgeWVhciR7dmlld1Byb3B9YF07XG4gICAgICAgICAgICBjYXNlIENhbGVuZGFyVmlld0VudW0uZGVjYWRlOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzW2BkZWNhZGUke3ZpZXdQcm9wfWBdO1xuICAgICAgICAgICAgY2FzZSBDYWxlbmRhclZpZXdFbnVtLmNlbnR1cnk6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNbYGNlbnR1cnkke3ZpZXdQcm9wfWBdO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBiYXRjaChjb250ZW50RWxlbWVudCwgYWN0aW9uKSB7XG4gICAgICAgIGlmICghaXNQcmVzZW50KHRoaXMuaG9zdENvbnRhaW5lcikpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBob3N0Q2xvbmUgPSB0aGlzLmhvc3RDb250YWluZXIuY2xvbmVOb2RlKCk7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoaG9zdENsb25lKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGFwcGVuZGVkQ29udGVudCA9IGhvc3RDbG9uZS5hcHBlbmRDaGlsZChjb250ZW50RWxlbWVudCk7XG4gICAgICAgICAgICBhY3Rpb24oYXBwZW5kZWRDb250ZW50KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChob3N0Q2xvbmUpO1xuICAgICAgICB9XG4gICAgfVxufTtcbkNhbGVuZGFyRE9NU2VydmljZSA9IF9fZGVjb3JhdGUoW1xuICAgIEluamVjdGFibGUoKVxuXSwgQ2FsZW5kYXJET01TZXJ2aWNlKTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IHVwZGF0ZSA9IChhcnIsIGlkeCwgdmFsdWUpID0+IChbXG4gICAgLi4uYXJyLnNsaWNlKDAsIGlkeCArIDEpLFxuICAgIC4uLihhcnIuc2xpY2UoaWR4ICsgMSkubWFwKHggPT4geCArIHZhbHVlKSlcbl0pO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIFJvd0hlaWdodFNlcnZpY2Uge1xuICAgIGNvbnN0cnVjdG9yKHRvdGFsID0gMCwgcm93SGVpZ2h0LCBkZXRhaWxSb3dIZWlnaHQpIHtcbiAgICAgICAgdGhpcy50b3RhbCA9IHRvdGFsO1xuICAgICAgICB0aGlzLnJvd0hlaWdodCA9IHJvd0hlaWdodDtcbiAgICAgICAgdGhpcy5kZXRhaWxSb3dIZWlnaHQgPSBkZXRhaWxSb3dIZWlnaHQ7XG4gICAgICAgIHRoaXMub2Zmc2V0cyA9IFtdO1xuICAgICAgICB0aGlzLmhlaWdodHMgPSBbXTtcbiAgICAgICAgbGV0IGFnZyA9IDA7XG4gICAgICAgIGZvciAobGV0IGlkeCA9IDA7IGlkeCA8IHRvdGFsOyBpZHgrKykge1xuICAgICAgICAgICAgdGhpcy5vZmZzZXRzLnB1c2goYWdnKTtcbiAgICAgICAgICAgIGFnZyArPSByb3dIZWlnaHQ7XG4gICAgICAgICAgICB0aGlzLmhlaWdodHMucHVzaChyb3dIZWlnaHQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhlaWdodChyb3dJbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5oZWlnaHRzW3Jvd0luZGV4XTtcbiAgICB9XG4gICAgZXhwYW5kRGV0YWlsKHJvd0luZGV4KSB7XG4gICAgICAgIGlmICh0aGlzLmhlaWdodChyb3dJbmRleCkgPT09IHRoaXMucm93SGVpZ2h0KSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVJvd0hlaWdodChyb3dJbmRleCwgdGhpcy5kZXRhaWxSb3dIZWlnaHQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbGxhcHNlRGV0YWlsKHJvd0luZGV4KSB7XG4gICAgICAgIGlmICh0aGlzLmhlaWdodChyb3dJbmRleCkgPiB0aGlzLnJvd0hlaWdodCkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVSb3dIZWlnaHQocm93SW5kZXgsIHRoaXMuZGV0YWlsUm93SGVpZ2h0ICogLTEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGluZGV4KHBvc2l0aW9uKSB7XG4gICAgICAgIGlmIChwb3NpdGlvbiA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5vZmZzZXRzLnJlZHVjZSgocHJldiwgY3VycmVudCwgaWR4KSA9PiB7XG4gICAgICAgICAgICBpZiAocHJldiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByZXY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjdXJyZW50ID09PSBwb3NpdGlvbikge1xuICAgICAgICAgICAgICAgIHJldHVybiBpZHg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjdXJyZW50ID4gcG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWR4IC0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH0sIHVuZGVmaW5lZCk7IC8vIHRzbGludDpkaXNhYmxlLWxpbmU6YWxpZ25cbiAgICAgICAgcmV0dXJuIHJlc3VsdCA9PT0gdW5kZWZpbmVkID8gdGhpcy50b3RhbCAtIDEgOiByZXN1bHQ7XG4gICAgfVxuICAgIG9mZnNldChyb3dJbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vZmZzZXRzW3Jvd0luZGV4XTtcbiAgICB9XG4gICAgdG90YWxIZWlnaHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhlaWdodHMucmVkdWNlKChwcmV2LCBjdXJyKSA9PiBwcmV2ICsgY3VyciwgMCk7XG4gICAgfVxuICAgIHVwZGF0ZVJvd0hlaWdodChyb3dJbmRleCwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5oZWlnaHRzW3Jvd0luZGV4XSArPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5vZmZzZXRzID0gdXBkYXRlKHRoaXMub2Zmc2V0cywgcm93SW5kZXgsIHZhbHVlKTtcbiAgICB9XG59XG5cbmNvbnN0IG5vcm1hbGl6ZSA9IHggPT4gTWF0aC5tYXgoeCwgMCk7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgU2Nyb2xsQWN0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihvZmZzZXQpIHtcbiAgICAgICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgfVxufVxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIFBhZ2VBY3Rpb24ge1xuICAgIGNvbnN0cnVjdG9yKHNraXApIHtcbiAgICAgICAgdGhpcy5za2lwID0gc2tpcDtcbiAgICB9XG59XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgU2Nyb2xsZXJTZXJ2aWNlIHtcbiAgICBjb25zdHJ1Y3RvcihzY3JvbGxPYnNlcnZhYmxlKSB7XG4gICAgICAgIHRoaXMuc2Nyb2xsT2JzZXJ2YWJsZSA9IHNjcm9sbE9ic2VydmFibGU7XG4gICAgICAgIHRoaXMuZmlyc3RMb2FkZWQgPSAwO1xuICAgICAgICB0aGlzLmJvdHRvbU9mZnNldCA9IDA7XG4gICAgICAgIHRoaXMudG9wT2Zmc2V0ID0gMDtcbiAgICB9XG4gICAgY3JlYXRlKHJvd0hlaWdodFNlcnZpY2UsIHNraXAsIHRha2UsIHRvdGFsLCB0b3BPZmZzZXQgPSAwLCBib3R0b21PZmZzZXQgPSAwLCBkaXJlY3Rpb24gPSAndmVydGljYWwnKSB7XG4gICAgICAgIHRoaXMucm93SGVpZ2h0U2VydmljZSA9IHJvd0hlaWdodFNlcnZpY2U7XG4gICAgICAgIHRoaXMuZmlyc3RMb2FkZWQgPSBza2lwO1xuICAgICAgICB0aGlzLmxhc3RMb2FkZWQgPSBza2lwICsgdGFrZTtcbiAgICAgICAgdGhpcy50YWtlID0gdGFrZTtcbiAgICAgICAgdGhpcy50b3RhbCA9IHRvdGFsO1xuICAgICAgICB0aGlzLmxhc3RTY3JvbGwgPSAwO1xuICAgICAgICB0aGlzLnRvcE9mZnNldCA9IHRvcE9mZnNldDtcbiAgICAgICAgdGhpcy5ib3R0b21PZmZzZXQgPSBib3R0b21PZmZzZXQ7XG4gICAgICAgIHRoaXMuZGlyZWN0aW9uID0gZGlyZWN0aW9uO1xuICAgICAgICBjb25zdCBzdWJqZWN0ID0gbmV3IFJlcGxheVN1YmplY3QoMik7XG4gICAgICAgIGNvbnN0IG9mZnNldEJ1ZmZlclJvd3MgPSB0aGlzLnJvd3NGb3JIZWlnaHQodG9wT2Zmc2V0KTtcbiAgICAgICAgY29uc3Qgc2tpcFdpdGhPZmZzZXQgPSBub3JtYWxpemUoc2tpcCAtIG9mZnNldEJ1ZmZlclJvd3MpO1xuICAgICAgICBzdWJqZWN0Lm5leHQobmV3IFNjcm9sbEFjdGlvbih0aGlzLnJvd09mZnNldChza2lwV2l0aE9mZnNldCkpKTtcbiAgICAgICAgaWYgKG9mZnNldEJ1ZmZlclJvd3MpIHtcbiAgICAgICAgICAgIHN1YmplY3QubmV4dChuZXcgUGFnZUFjdGlvbihza2lwV2l0aE9mZnNldCkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9uID0gbmV3IE9ic2VydmFibGUob2JzZXJ2ZXIgPT4ge1xuICAgICAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxTdWJzY3JpcHRpb24gPSB0aGlzLnNjcm9sbE9ic2VydmFibGUuc3Vic2NyaWJlKHggPT4gdGhpcy5vblNjcm9sbCh4LCBvYnNlcnZlcikpO1xuICAgICAgICB9KS5zdWJzY3JpYmUoKHgpID0+IHN1YmplY3QubmV4dCh4KSk7XG4gICAgICAgIHJldHVybiBzdWJqZWN0O1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIGlmICh0aGlzLnN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgdGhpcy5zdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBvblNjcm9sbCh7IHNjcm9sbExlZnQsIHNjcm9sbFRvcCwgb2Zmc2V0SGVpZ2h0LCBvZmZzZXRXaWR0aCB9LCBvYnNlcnZlcikge1xuICAgICAgICBjb25zdCBzY3JvbGxQb3NpdGlvbiA9IHRoaXMuZGlyZWN0aW9uID09PSAndmVydGljYWwnID8gc2Nyb2xsVG9wIDogc2Nyb2xsTGVmdDtcbiAgICAgICAgY29uc3Qgb2Zmc2V0U2l6ZSA9IHRoaXMuZGlyZWN0aW9uID09PSAndmVydGljYWwnID8gb2Zmc2V0SGVpZ2h0IDogb2Zmc2V0V2lkdGg7XG4gICAgICAgIGlmICh0aGlzLmxhc3RTY3JvbGwgPT09IHNjcm9sbFBvc2l0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXAgPSB0aGlzLmxhc3RTY3JvbGwgPj0gc2Nyb2xsUG9zaXRpb247XG4gICAgICAgIHRoaXMubGFzdFNjcm9sbCA9IHNjcm9sbFBvc2l0aW9uO1xuICAgICAgICBjb25zdCBmaXJzdEl0ZW1JbmRleCA9IHRoaXMucm93SGVpZ2h0U2VydmljZS5pbmRleChub3JtYWxpemUoc2Nyb2xsUG9zaXRpb24gLSB0aGlzLnRvcE9mZnNldCkpO1xuICAgICAgICBjb25zdCBsYXN0SXRlbUluZGV4ID0gdGhpcy5yb3dIZWlnaHRTZXJ2aWNlLmluZGV4KG5vcm1hbGl6ZShzY3JvbGxQb3NpdGlvbiArIG9mZnNldFNpemUgLSB0aGlzLmJvdHRvbU9mZnNldCkpO1xuICAgICAgICBpZiAoIXVwICYmIGxhc3RJdGVtSW5kZXggPj0gdGhpcy5sYXN0TG9hZGVkICYmIHRoaXMubGFzdExvYWRlZCA8IHRoaXMudG90YWwpIHtcbiAgICAgICAgICAgIHRoaXMuZmlyc3RMb2FkZWQgPSBmaXJzdEl0ZW1JbmRleDtcbiAgICAgICAgICAgIG9ic2VydmVyLm5leHQobmV3IFNjcm9sbEFjdGlvbih0aGlzLnJvd09mZnNldChmaXJzdEl0ZW1JbmRleCkpKTtcbiAgICAgICAgICAgIHRoaXMubGFzdExvYWRlZCA9IE1hdGgubWluKHRoaXMuZmlyc3RMb2FkZWQgKyB0aGlzLnRha2UsIHRoaXMudG90YWwpO1xuICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dChuZXcgUGFnZUFjdGlvbih0aGlzLmZpcnN0TG9hZGVkKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVwICYmIGZpcnN0SXRlbUluZGV4IDw9IHRoaXMuZmlyc3RMb2FkZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IG5vblZpc2libGVCdWZmZXIgPSBNYXRoLmZsb29yKHRoaXMudGFrZSAqIDAuMyk7XG4gICAgICAgICAgICB0aGlzLmZpcnN0TG9hZGVkID0gbm9ybWFsaXplKGZpcnN0SXRlbUluZGV4IC0gbm9uVmlzaWJsZUJ1ZmZlcik7XG4gICAgICAgICAgICBvYnNlcnZlci5uZXh0KG5ldyBTY3JvbGxBY3Rpb24odGhpcy5yb3dPZmZzZXQodGhpcy5maXJzdExvYWRlZCkpKTtcbiAgICAgICAgICAgIHRoaXMubGFzdExvYWRlZCA9IE1hdGgubWluKHRoaXMuZmlyc3RMb2FkZWQgKyB0aGlzLnRha2UsIHRoaXMudG90YWwpO1xuICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dChuZXcgUGFnZUFjdGlvbih0aGlzLmZpcnN0TG9hZGVkKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcm93T2Zmc2V0KGluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJvd0hlaWdodFNlcnZpY2Uub2Zmc2V0KGluZGV4KSArIHRoaXMudG9wT2Zmc2V0O1xuICAgIH1cbiAgICByb3dzRm9ySGVpZ2h0KGhlaWdodCkge1xuICAgICAgICByZXR1cm4gTWF0aC5jZWlsKGhlaWdodCAvIHRoaXMucm93SGVpZ2h0U2VydmljZS5oZWlnaHQoMCkpO1xuICAgIH1cbiAgICB1bnN1YnNjcmliZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuc2Nyb2xsU3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbFN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxTdWJzY3JpcHRpb24gPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgU0NST0xMRVJfRkFDVE9SWV9UT0tFTiA9IG5ldyBJbmplY3Rpb25Ub2tlbignZGF0ZWlucHV0cy1zY3JvbGwtc2VydmljZS1mYWN0b3J5Jyk7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuZnVuY3Rpb24gREVGQVVMVF9TQ1JPTExFUl9GQUNUT1JZKG9ic2VydmFibGUpIHtcbiAgICByZXR1cm4gbmV3IFNjcm9sbGVyU2VydmljZShvYnNlcnZhYmxlKTtcbn1cbi8qKlxuICogQGhpZGRlblxuICovXG52YXIgU2Nyb2xsRGlyZWN0aW9uO1xuKGZ1bmN0aW9uIChTY3JvbGxEaXJlY3Rpb24pIHtcbiAgICBTY3JvbGxEaXJlY3Rpb25bU2Nyb2xsRGlyZWN0aW9uW1wiQmFja3dhcmRcIl0gPSAwXSA9IFwiQmFja3dhcmRcIjtcbiAgICBTY3JvbGxEaXJlY3Rpb25bU2Nyb2xsRGlyZWN0aW9uW1wiRm9yd2FyZFwiXSA9IDFdID0gXCJGb3J3YXJkXCI7XG59KShTY3JvbGxEaXJlY3Rpb24gfHwgKFNjcm9sbERpcmVjdGlvbiA9IHt9KSk7XG5jb25zdCBGUkFNRV9EVVJBVElPTiA9IDE3O1xuY29uc3Qgc2Nyb2xsTW9kaWZpZXJzID0ge1xuICAgIFtTY3JvbGxEaXJlY3Rpb24uRm9yd2FyZF06IChzdGVwKSA9PiB2YWx1ZSA9PiB2YWx1ZSArIHN0ZXAsXG4gICAgW1Njcm9sbERpcmVjdGlvbi5CYWNrd2FyZF06IChzdGVwKSA9PiB2YWx1ZSA9PiB2YWx1ZSAtIHN0ZXBcbn07XG5jb25zdCBzY3JvbGxOb3JtYWxpemVycyA9IHtcbiAgICBbU2Nyb2xsRGlyZWN0aW9uLkZvcndhcmRdOiAoZW5kKSA9PiB2YWx1ZSA9PiBNYXRoLm1pbih2YWx1ZSwgZW5kKSxcbiAgICBbU2Nyb2xsRGlyZWN0aW9uLkJhY2t3YXJkXTogKGVuZCkgPT4gdmFsdWUgPT4gTWF0aC5tYXgodmFsdWUsIGVuZClcbn07XG5jb25zdCBzY3JvbGxWYWxpZGF0b3JzID0ge1xuICAgIFtTY3JvbGxEaXJlY3Rpb24uRm9yd2FyZF06IGVuZCA9PiBzdGFydCA9PiBzdGFydCA8IGVuZCxcbiAgICBbU2Nyb2xsRGlyZWN0aW9uLkJhY2t3YXJkXTogZW5kID0+IHN0YXJ0ID0+IHN0YXJ0ID4gZW5kXG59O1xuY29uc3QgZGlmZmVyZW5jZVRvU2Nyb2xsID0gKHNjcm9sbFRvcCwgc3RhdGljT2Zmc2V0LCBtYXhTY3JvbGxEaWZmZXJlbmNlKSA9PiB7XG4gICAgcmV0dXJuIE1hdGgubWluKE1hdGguYWJzKHN0YXRpY09mZnNldCAtIHNjcm9sbFRvcCksIG1heFNjcm9sbERpZmZlcmVuY2UpO1xufTtcbi8qKlxuICogQGhpZGRlblxuICovXG5sZXQgVmlydHVhbGl6YXRpb25Db21wb25lbnQgPSBjbGFzcyBWaXJ0dWFsaXphdGlvbkNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3Ioc2Nyb2xsZXJGYWN0b3J5LCBjb250YWluZXIsIHJlbmRlcmVyLCB6b25lKSB7XG4gICAgICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgICAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgICAgIHRoaXMuem9uZSA9IHpvbmU7XG4gICAgICAgIHRoaXMuZGlyZWN0aW9uID0gJ3ZlcnRpY2FsJztcbiAgICAgICAgdGhpcy5pdGVtSGVpZ2h0ID0gMTtcbiAgICAgICAgdGhpcy5pdGVtV2lkdGggPSAxO1xuICAgICAgICB0aGlzLnRvcE9mZnNldCA9IDA7XG4gICAgICAgIHRoaXMuYm90dG9tT2Zmc2V0ID0gMDtcbiAgICAgICAgdGhpcy5tYXhTY3JvbGxEaWZmZXJlbmNlID0gMTAwO1xuICAgICAgICB0aGlzLnNjcm9sbE9mZnNldFNpemUgPSAwO1xuICAgICAgICB0aGlzLnNjcm9sbER1cmF0aW9uID0gMTUwO1xuICAgICAgICB0aGlzLmFjdGl2ZUluZGV4Q2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLnBhZ2VDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuc2Nyb2xsQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLndyYXBwZXJDbGFzc2VzID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5yZXNvbHZlZFByb21pc2UgPSBQcm9taXNlLnJlc29sdmUobnVsbCk7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hlciA9IG5ldyBTdWJqZWN0KCk7XG4gICAgICAgIHRoaXMuc2Nyb2xsZXIgPSBzY3JvbGxlckZhY3RvcnkodGhpcy5kaXNwYXRjaGVyKTtcbiAgICB9XG4gICAgZ2V0IGhvcml6b250YWxDbGFzcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlyZWN0aW9uID09PSAnaG9yaXpvbnRhbCc7XG4gICAgfVxuICAgIGdldCB0b3RhbFZlcnRleExlbmd0aCgpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBgJHt0aGlzLnRvdGFsU2l6ZX1weGA7XG4gICAgICAgIHJldHVybiB0aGlzLmRpcmVjdGlvbiA9PT0gJ3ZlcnRpY2FsJyA/IHsgaGVpZ2h0OiB2YWx1ZSB9IDogeyB3aWR0aDogdmFsdWUgfTtcbiAgICB9XG4gICAgZ2V0IGNvbnRhaW5lck9mZnNldFNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldENvbnRhaW5lclByb3BlcnR5KHRoaXMuZGlyZWN0aW9uID09PSAndmVydGljYWwnID8gJ29mZnNldEhlaWdodCcgOiAnb2Zmc2V0V2lkdGgnKTtcbiAgICB9XG4gICAgZ2V0IGNvbnRhaW5lclNjcm9sbFNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldENvbnRhaW5lclByb3BlcnR5KHRoaXMuZGlyZWN0aW9uID09PSAndmVydGljYWwnID8gJ3Njcm9sbEhlaWdodCcgOiAnc2Nyb2xsV2lkdGgnKTtcbiAgICB9XG4gICAgZ2V0IGNvbnRhaW5lclNjcm9sbFBvc2l0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRDb250YWluZXJQcm9wZXJ0eSh0aGlzLmRpcmVjdGlvbiA9PT0gJ3ZlcnRpY2FsJyA/ICdzY3JvbGxUb3AnIDogJ3Njcm9sbExlZnQnKTtcbiAgICB9XG4gICAgbmdPbkNoYW5nZXMoY2hhbmdlcykge1xuICAgICAgICBpZiAoY2hhbmdlcy5kaXJlY3Rpb24gfHwgY2hhbmdlcy50YWtlIHx8IGNoYW5nZXMudG90YWwpIHtcbiAgICAgICAgICAgIHRoaXMuaW5pdFNlcnZpY2VzKCk7XG4gICAgICAgICAgICB0aGlzLnRvdGFsU2l6ZSA9IHRoaXMucm93SGVpZ2h0U2VydmljZS50b3RhbEhlaWdodCgpICsgdGhpcy5ib3R0b21PZmZzZXQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbmdPbkluaXQoKSB7XG4gICAgICAgIGlmICghdGhpcy5yb3dIZWlnaHRTZXJ2aWNlKSB7XG4gICAgICAgICAgICB0aGlzLnJvd0hlaWdodFNlcnZpY2UgPSB0aGlzLmNyZWF0ZVJvd0hlaWdodFNlcnZpY2UoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBuZ0FmdGVyVmlld0luaXQoKSB7XG4gICAgICAgIHRoaXMuem9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lclNjcm9sbFN1YnNjcmlwdGlvbiA9IHRoaXMuc2Nyb2xsJCgpXG4gICAgICAgICAgICAgICAgLnBpcGUobWFwKChldmVudCkgPT4gZXZlbnQudGFyZ2V0KSlcbiAgICAgICAgICAgICAgICAuc3Vic2NyaWJlKHQgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hlci5uZXh0KHQpO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdEFjdGl2ZUluZGV4KCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICBpZiAodGhpcy5jb250YWluZXJTY3JvbGxTdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyU2Nyb2xsU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc2Nyb2xsU3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbFN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmFuaW1hdGlvblN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgdGhpcy5hbmltYXRpb25TdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRDb250YWluZXJQcm9wZXJ0eShwcm9wZXJ0eU5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGFpbmVyLm5hdGl2ZUVsZW1lbnRbcHJvcGVydHlOYW1lXTtcbiAgICB9XG4gICAgYWN0aXZlSW5kZXgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLml0ZW1JbmRleChNYXRoLmNlaWwodGhpcy5jb250YWluZXJTY3JvbGxQb3NpdGlvbikpOyAvL2hhbmRsZSBzdWJwaXhlbGluZ1xuICAgIH1cbiAgICBpdGVtSW5kZXgob2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJvd0hlaWdodFNlcnZpY2UuaW5kZXgob2Zmc2V0KTtcbiAgICB9XG4gICAgaXRlbU9mZnNldChpbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yb3dIZWlnaHRTZXJ2aWNlLm9mZnNldChpbmRleCk7XG4gICAgfVxuICAgIGlzSW5kZXhWaXNpYmxlKGluZGV4KSB7XG4gICAgICAgIGlmICghdGhpcy5yb3dIZWlnaHRTZXJ2aWNlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29udGFpbmVyVG9wID0gdGhpcy5jb250YWluZXJTY3JvbGxQb3NpdGlvbjtcbiAgICAgICAgY29uc3QgY29udGFpbmVyQm90dG9tID0gY29udGFpbmVyVG9wICsgdGhpcy5jb250YWluZXJPZmZzZXRTaXplO1xuICAgICAgICBjb25zdCB0b3AgPSB0aGlzLnJvd0hlaWdodFNlcnZpY2Uub2Zmc2V0KGluZGV4KTtcbiAgICAgICAgY29uc3QgYm90dG9tID0gdG9wICsgdGhpcy5yb3dIZWlnaHRTZXJ2aWNlLmhlaWdodChpbmRleCk7XG4gICAgICAgIHJldHVybiB0b3AgPj0gY29udGFpbmVyVG9wICYmIGJvdHRvbSA8PSBjb250YWluZXJCb3R0b207XG4gICAgfVxuICAgIGlzTGlzdFNjcm9sbGVkKGluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRhaW5lclNjcm9sbFBvc2l0aW9uICE9PSB0aGlzLnJvd0hlaWdodFNlcnZpY2Uub2Zmc2V0KGluZGV4KTtcbiAgICB9XG4gICAgc2Nyb2xsVG8odmFsdWUpIHtcbiAgICAgICAgY29uc3Qgc2Nyb2xsUHJvcGVydHkgPSB0aGlzLmRpcmVjdGlvbiA9PT0gXCJ2ZXJ0aWNhbFwiID8gJ3Njcm9sbFRvcCcgOiAnc2Nyb2xsTGVmdCc7XG4gICAgICAgIHRoaXMucmVuZGVyZXIuc2V0UHJvcGVydHkodGhpcy5jb250YWluZXIubmF0aXZlRWxlbWVudCwgc2Nyb2xsUHJvcGVydHksIHZhbHVlKTtcbiAgICB9XG4gICAgc2Nyb2xsVG9JbmRleChpbmRleCkge1xuICAgICAgICAvL1hYWDogc2Nyb2xsaW5nIHdpdGggdGljayBpcyByZXF1aXJlZCB0byBwcmV2ZW50IGxpc3QganVtcCBpbiBDaHJvbWUuXG4gICAgICAgIC8vT3JpZ2luYWwgaXNzdWU6IGZvY3VzIGZpcnN0IGRheSBpbiB0aGUgbW9udGggYW5kIHByZXNzIExFRlQgYXJyb3cuXG4gICAgICAgIC8vTm90aWNlIGhvdyB0aGUgdmlldyBqdW1wcyBvbiBldmVyeSBkYXkgY2hhbmdlLlxuICAgICAgICAvL1xuICAgICAgICB0aGlzLnpvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5yZXNvbHZlZFByb21pc2UudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5zY3JvbGxUbyh0aGlzLnJvd0hlaWdodFNlcnZpY2Uub2Zmc2V0KGluZGV4KSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNjcm9sbFRvQm90dG9tKCkge1xuICAgICAgICB0aGlzLnNjcm9sbFRvKHRoaXMudG90YWxTaXplKTtcbiAgICB9XG4gICAgYW5pbWF0ZVRvSW5kZXgoaW5kZXgpIHtcbiAgICAgICAgaWYgKHRoaXMuYW5pbWF0aW9uU3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmFuaW1hdGlvblN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGluZGV4T2Zmc2V0ID0gdGhpcy5yb3dIZWlnaHRTZXJ2aWNlLm9mZnNldChpbmRleCk7XG4gICAgICAgIGNvbnN0IGRpcmVjdGlvbiA9IHRoaXMuZ2V0Q29udGFpbmVyU2Nyb2xsRGlyZWN0aW9uKGluZGV4T2Zmc2V0KTtcbiAgICAgICAgY29uc3QgeyBzdGFydCwgZW5kIH0gPSB0aGlzLnNjcm9sbFJhbmdlKGluZGV4T2Zmc2V0LCBkaXJlY3Rpb24pO1xuICAgICAgICBpZiAoc3RhcnQgPT09IGVuZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0ZXAgPSB0aGlzLnNjcm9sbFN0ZXAoc3RhcnQsIGVuZCk7XG4gICAgICAgIGNvbnN0IG1vZGlmeVNjcm9sbCA9IHNjcm9sbE1vZGlmaWVyc1tkaXJlY3Rpb25dKHN0ZXApO1xuICAgICAgICBjb25zdCBub3JtYWxpemVTY3JvbGwgPSBzY3JvbGxOb3JtYWxpemVyc1tkaXJlY3Rpb25dKGVuZCk7XG4gICAgICAgIGNvbnN0IGlzU2Nyb2xsVmFsaWQgPSBzY3JvbGxWYWxpZGF0b3JzW2RpcmVjdGlvbl0obW9kaWZ5U2Nyb2xsKGVuZCkpO1xuICAgICAgICB0aGlzLnpvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5hbmltYXRpb25TdWJzY3JpcHRpb24gPVxuICAgICAgICAgICAgICAgIGNvbWJpbmVMYXRlc3Qob2Yoc3RhcnQpLCBpbnRlcnZhbCgwLCBhbmltYXRpb25GcmFtZVNjaGVkdWxlcikpLnBpcGUobWFwKHN0cmVhbSA9PiBzdHJlYW1bMF0pLCBzY2FuKG1vZGlmeVNjcm9sbCksIHRha2VXaGlsZShpc1Njcm9sbFZhbGlkKSwgbWFwKG5vcm1hbGl6ZVNjcm9sbCkpLnN1YnNjcmliZSgoeCkgPT4gdGhpcy5zY3JvbGxUbyh4KSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzY3JvbGxSYW5nZShpbmRleE9mZnNldCwgZGlyZWN0aW9uKSB7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lclNjcm9sbCA9IHRoaXMuY29udGFpbmVyU2Nyb2xsUG9zaXRpb247XG4gICAgICAgIGlmIChwYXJzZUludChpbmRleE9mZnNldCwgMTApID09PSBwYXJzZUludChjb250YWluZXJTY3JvbGwsIDEwKSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgc3RhcnQ6IGluZGV4T2Zmc2V0LCBlbmQ6IGluZGV4T2Zmc2V0IH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWF4U2Nyb2xsID0gdGhpcy5jb250YWluZXJNYXhTY3JvbGwoKTtcbiAgICAgICAgY29uc3Qgc2lnbiA9IGRpcmVjdGlvbiA9PT0gU2Nyb2xsRGlyZWN0aW9uLkJhY2t3YXJkID8gMSA6IC0xO1xuICAgICAgICBjb25zdCBkaWZmZXJlbmNlID0gZGlmZmVyZW5jZVRvU2Nyb2xsKGNvbnRhaW5lclNjcm9sbCwgaW5kZXhPZmZzZXQsIHRoaXMubWF4U2Nyb2xsRGlmZmVyZW5jZSk7XG4gICAgICAgIGNvbnN0IGVuZCA9IE1hdGgubWluKGluZGV4T2Zmc2V0LCBtYXhTY3JvbGwpO1xuICAgICAgICBjb25zdCBzdGFydCA9IE1hdGgubWluKE1hdGgubWF4KGVuZCArIChzaWduICogZGlmZmVyZW5jZSksIDApLCBtYXhTY3JvbGwpO1xuICAgICAgICByZXR1cm4geyBzdGFydCwgZW5kIH07XG4gICAgfVxuICAgIHNjcm9sbFN0ZXAoc3RhcnQsIGVuZCkge1xuICAgICAgICByZXR1cm4gTWF0aC5hYnMoZW5kIC0gc3RhcnQpIC8gKHRoaXMuc2Nyb2xsRHVyYXRpb24gLyBGUkFNRV9EVVJBVElPTik7XG4gICAgfVxuICAgIHNjcm9sbCQoKSB7XG4gICAgICAgIHJldHVybiBpc0RvY3VtZW50QXZhaWxhYmxlKCkgPyBmcm9tRXZlbnQodGhpcy5jb250YWluZXIubmF0aXZlRWxlbWVudCwgJ3Njcm9sbCcpIDogRU1QVFk7XG4gICAgfVxuICAgIGluaXRTZXJ2aWNlcygpIHtcbiAgICAgICAgdGhpcy5yb3dIZWlnaHRTZXJ2aWNlID0gdGhpcy5jcmVhdGVSb3dIZWlnaHRTZXJ2aWNlKCk7XG4gICAgICAgIGlmICh0aGlzLnNjcm9sbFN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNjcm9sbFN1YnNjcmlwdGlvbiA9IHRoaXMuc2Nyb2xsZXJcbiAgICAgICAgICAgIC5jcmVhdGUodGhpcy5yb3dIZWlnaHRTZXJ2aWNlLCB0aGlzLnNraXAsIHRoaXMudGFrZSwgdGhpcy50b3RhbCwgdGhpcy50b3BPZmZzZXQsIHRoaXMuc2Nyb2xsT2Zmc2V0U2l6ZSwgdGhpcy5kaXJlY3Rpb24pXG4gICAgICAgICAgICAuc3Vic2NyaWJlKCh4KSA9PiB7XG4gICAgICAgICAgICBpZiAoeCBpbnN0YW5jZW9mIFBhZ2VBY3Rpb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhZ2VDaGFuZ2UuZW1pdCh4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsQ2hhbmdlLmVtaXQoeCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjcmVhdGVSb3dIZWlnaHRTZXJ2aWNlKCkge1xuICAgICAgICBjb25zdCBkaW1lbnNpb24gPSB0aGlzLmRpcmVjdGlvbiA9PT0gJ3ZlcnRpY2FsJyA/IHRoaXMuaXRlbUhlaWdodCA6IHRoaXMuaXRlbVdpZHRoO1xuICAgICAgICByZXR1cm4gbmV3IFJvd0hlaWdodFNlcnZpY2UodGhpcy50b3RhbCwgZGltZW5zaW9uLCAwKTtcbiAgICB9XG4gICAgZW1pdEFjdGl2ZUluZGV4KCkge1xuICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMucm93SGVpZ2h0U2VydmljZS5pbmRleCh0aGlzLmNvbnRhaW5lclNjcm9sbFBvc2l0aW9uIC0gdGhpcy50b3BPZmZzZXQpO1xuICAgICAgICBpZiAodGhpcy5sYXN0QWN0aXZlSW5kZXggIT09IGluZGV4KSB7XG4gICAgICAgICAgICB0aGlzLmxhc3RBY3RpdmVJbmRleCA9IGluZGV4O1xuICAgICAgICAgICAgdGhpcy5hY3RpdmVJbmRleENoYW5nZS5lbWl0KGluZGV4KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb250YWluZXJNYXhTY3JvbGwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRhaW5lclNjcm9sbFNpemUgLSB0aGlzLmNvbnRhaW5lck9mZnNldFNpemU7XG4gICAgfVxuICAgIGdldENvbnRhaW5lclNjcm9sbERpcmVjdGlvbihpbmRleE9mZnNldCkge1xuICAgICAgICByZXR1cm4gaW5kZXhPZmZzZXQgPCB0aGlzLmNvbnRhaW5lclNjcm9sbFBvc2l0aW9uID8gU2Nyb2xsRGlyZWN0aW9uLkJhY2t3YXJkIDogU2Nyb2xsRGlyZWN0aW9uLkZvcndhcmQ7XG4gICAgfVxufTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFZpcnR1YWxpemF0aW9uQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkaXJlY3Rpb25cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIFZpcnR1YWxpemF0aW9uQ29tcG9uZW50LnByb3RvdHlwZSwgXCJpdGVtSGVpZ2h0XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBWaXJ0dWFsaXphdGlvbkNvbXBvbmVudC5wcm90b3R5cGUsIFwiaXRlbVdpZHRoXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBWaXJ0dWFsaXphdGlvbkNvbXBvbmVudC5wcm90b3R5cGUsIFwidG9wT2Zmc2V0XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBWaXJ0dWFsaXphdGlvbkNvbXBvbmVudC5wcm90b3R5cGUsIFwiYm90dG9tT2Zmc2V0XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBWaXJ0dWFsaXphdGlvbkNvbXBvbmVudC5wcm90b3R5cGUsIFwibWF4U2Nyb2xsRGlmZmVyZW5jZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgVmlydHVhbGl6YXRpb25Db21wb25lbnQucHJvdG90eXBlLCBcInNjcm9sbE9mZnNldFNpemVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIFZpcnR1YWxpemF0aW9uQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzY3JvbGxEdXJhdGlvblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgVmlydHVhbGl6YXRpb25Db21wb25lbnQucHJvdG90eXBlLCBcInNraXBcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIFZpcnR1YWxpemF0aW9uQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0YWtlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBWaXJ0dWFsaXphdGlvbkNvbXBvbmVudC5wcm90b3R5cGUsIFwidG90YWxcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIE91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXG5dLCBWaXJ0dWFsaXphdGlvbkNvbXBvbmVudC5wcm90b3R5cGUsIFwiYWN0aXZlSW5kZXhDaGFuZ2VcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIE91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXG5dLCBWaXJ0dWFsaXphdGlvbkNvbXBvbmVudC5wcm90b3R5cGUsIFwicGFnZUNoYW5nZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbl0sIFZpcnR1YWxpemF0aW9uQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzY3JvbGxDaGFuZ2VcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5rLWZsZXgnKSxcbiAgICBIb3N0QmluZGluZygnY2xhc3Muay1jb250ZW50JyksXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLmstY2FsZW5kYXItY29udGVudCcpLFxuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5rLXNjcm9sbGFibGUnKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIFZpcnR1YWxpemF0aW9uQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ3cmFwcGVyQ2xhc3Nlc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLmstc2Nyb2xsYWJsZS1ob3Jpem9udGFsJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIFZpcnR1YWxpemF0aW9uQ29tcG9uZW50LnByb3RvdHlwZSwgXCJob3Jpem9udGFsQ2xhc3NcIiwgbnVsbCk7XG5WaXJ0dWFsaXphdGlvbkNvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIHByb3ZpZGVyczogW3tcbiAgICAgICAgICAgICAgICBwcm92aWRlOiBTQ1JPTExFUl9GQUNUT1JZX1RPS0VOLFxuICAgICAgICAgICAgICAgIHVzZVZhbHVlOiBERUZBVUxUX1NDUk9MTEVSX0ZBQ1RPUllcbiAgICAgICAgICAgIH1dLFxuICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLXZpcnR1YWxpemF0aW9uJyxcbiAgICAgICAgdGVtcGxhdGU6IGBcbiAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XG4gICAgPGRpdlxuICAgICAgICBjbGFzcz1cImstc2Nyb2xsYWJsZS1wbGFjZWhvbGRlclwiXG4gICAgICAgIFtjbGFzcy5rLXNjcm9sbGFibGUtaG9yaXpvbnRhbC1wbGFjZWhvbGRlcl09XCJkaXJlY3Rpb24gPT09ICdob3Jpem9udGFsJ1wiXG4gICAgICAgIFtuZ1N0eWxlXT1cInRvdGFsVmVydGV4TGVuZ3RoXCJcbiAgICA+PC9kaXY+XG4gIGBcbiAgICB9KSxcbiAgICBfX3BhcmFtKDAsIEluamVjdChTQ1JPTExFUl9GQUNUT1JZX1RPS0VOKSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtPYmplY3QsIEVsZW1lbnRSZWYsXG4gICAgICAgIFJlbmRlcmVyMixcbiAgICAgICAgTmdab25lXSlcbl0sIFZpcnR1YWxpemF0aW9uQ29tcG9uZW50KTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGNsb3Nlc3RJblNjb3BlID0gKG5vZGUsIHByZWRpY2F0ZSwgc2NvcGUpID0+IHtcbiAgICB3aGlsZSAobm9kZSAmJiBub2RlICE9PSBzY29wZSAmJiAhcHJlZGljYXRlKG5vZGUpKSB7XG4gICAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgfVxuICAgIGlmIChub2RlICE9PSBzY29wZSkge1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG59O1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGNsb3Nlc3QgPSAobm9kZSwgcHJlZGljYXRlKSA9PiB7XG4gICAgd2hpbGUgKG5vZGUgJiYgIXByZWRpY2F0ZShub2RlKSkge1xuICAgICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbn07XG5cbmNvbnN0IElURU1TX0NPVU5UID0gMzA7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xubGV0IE5hdmlnYXRpb25Db21wb25lbnQgPSBjbGFzcyBOYXZpZ2F0aW9uQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcihidXMsIGRvbSwgaW50bCwgY2RyLCByZW5kZXJlcikge1xuICAgICAgICB0aGlzLmJ1cyA9IGJ1cztcbiAgICAgICAgdGhpcy5kb20gPSBkb207XG4gICAgICAgIHRoaXMuaW50bCA9IGludGw7XG4gICAgICAgIHRoaXMuY2RyID0gY2RyO1xuICAgICAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgICAgIHRoaXMubWluID0gbmV3IERhdGUoTUlOX0RBVEUpO1xuICAgICAgICB0aGlzLm1heCA9IG5ldyBEYXRlKE1BWF9EQVRFKTtcbiAgICAgICAgdGhpcy5mb2N1c2VkRGF0ZSA9IG5ldyBEYXRlKCk7XG4gICAgICAgIHRoaXMudmFsdWVDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMucGFnZUNoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5kYXRlcyA9IFtdO1xuICAgICAgICB0aGlzLnRha2UgPSBJVEVNU19DT1VOVDtcbiAgICAgICAgdGhpcy5pbmRleFRvU2Nyb2xsID0gLTE7XG4gICAgfVxuICAgIGdldCBnZXRDb21wb25lbnRDbGFzcygpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIG5nT25Jbml0KCkge1xuICAgICAgICB0aGlzLmRvbS5lbnN1cmVIZWlnaHRzKCk7XG4gICAgICAgIGNvbnN0IGNhbGVuZGFySGVpZ2h0ID0gdGhpcy5kb20uY2FsZW5kYXJIZWlnaHQ7XG4gICAgICAgIHRoaXMuaXRlbUhlaWdodCA9IHRoaXMuZG9tLm5hdmlnYXRpb25JdGVtSGVpZ2h0O1xuICAgICAgICB0aGlzLm1heFZpZXdIZWlnaHQgPSB0aGlzLmRvbS5tb250aFZpZXdIZWlnaHQ7XG4gICAgICAgIHRoaXMudG9wT2Zmc2V0ID0gKGNhbGVuZGFySGVpZ2h0IC0gdGhpcy5pdGVtSGVpZ2h0KSAvIDI7XG4gICAgICAgIHRoaXMuYm90dG9tT2Zmc2V0ID0gY2FsZW5kYXJIZWlnaHQgLSB0aGlzLml0ZW1IZWlnaHQ7XG4gICAgICAgIHRoaXMuaW50bFN1YnNjcmlwdGlvbiA9IHRoaXMuaW50bC5jaGFuZ2VzLnN1YnNjcmliZSh0aGlzLmludGxDaGFuZ2UuYmluZCh0aGlzKSk7XG4gICAgfVxuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXMpIHtcbiAgICAgICAgdGhpcy5zZXJ2aWNlID0gdGhpcy5idXMuc2VydmljZSh0aGlzLmFjdGl2ZVZpZXcpO1xuICAgICAgICBpZiAoIXRoaXMuc2VydmljZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWN0aXZlVmlld1ZhbHVlID0gQ2FsZW5kYXJWaWV3RW51bVt0aGlzLmFjdGl2ZVZpZXddO1xuICAgICAgICBjb25zdCB2aWV3RGF0ZSA9IGRhdGVJblJhbmdlKHRoaXMuZm9jdXNlZERhdGUsIHRoaXMubWluLCB0aGlzLm1heCk7XG4gICAgICAgIGNvbnN0IHRvdGFsID0gdGhpcy5zZXJ2aWNlLnRvdGFsKHRoaXMubWluLCB0aGlzLm1heCk7XG4gICAgICAgIGNvbnN0IHRvdGFsQ2hhbmdlZCA9IHRoaXMudG90YWwgJiYgdGhpcy50b3RhbCAhPT0gdG90YWw7XG4gICAgICAgIHRoaXMuc2tpcCA9IHRoaXMuc2VydmljZS5za2lwKHZpZXdEYXRlLCB0aGlzLm1pbik7XG4gICAgICAgIHRoaXMudG90YWwgPSB0b3RhbDtcbiAgICAgICAgaWYgKHRvdGFsQ2hhbmdlZCB8fCAhdGhpcy5zZXJ2aWNlLmlzSW5BcnJheSh2aWV3RGF0ZSwgdGhpcy5kYXRlcykpIHtcbiAgICAgICAgICAgIHRoaXMuZGF0ZXMgPSB0aGlzLnNlcnZpY2UuZGF0ZXNMaXN0KHZpZXdEYXRlLCB0aGlzLmdldFRha2UodGhpcy5za2lwKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEhY2hhbmdlcy5mb2N1c2VkRGF0ZSB8fCB0b3RhbENoYW5nZWQpIHtcbiAgICAgICAgICAgIHRoaXMuaW5kZXhUb1Njcm9sbCA9IHRoaXMuc2VydmljZS5za2lwKHRoaXMuZm9jdXNlZERhdGUsIHRoaXMubWluKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgaWYgKHRoaXMuaW50bFN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgdGhpcy5pbnRsU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbmdBZnRlclZpZXdJbml0KCkge1xuICAgICAgICBpZiAodGhpcy5pbmRleFRvU2Nyb2xsID09PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudmlydHVhbGl6YXRpb24uc2Nyb2xsVG9JbmRleCh0aGlzLmluZGV4VG9TY3JvbGwpO1xuICAgICAgICB0aGlzLmluZGV4VG9TY3JvbGwgPSAtMTtcbiAgICB9XG4gICAgbmdBZnRlclZpZXdDaGVja2VkKCkge1xuICAgICAgICBpZiAodGhpcy5pbmRleFRvU2Nyb2xsID09PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudmlydHVhbGl6YXRpb24uc2Nyb2xsVG9JbmRleCh0aGlzLmluZGV4VG9TY3JvbGwpO1xuICAgICAgICB0aGlzLmluZGV4VG9TY3JvbGwgPSAtMTtcbiAgICB9XG4gICAgb25QYWdlQ2hhbmdlKHsgc2tpcCB9KSB7XG4gICAgICAgIHRoaXMuZGF0ZXMgPSB0aGlzLnNlcnZpY2UuZGF0ZXNMaXN0KHRoaXMuc2VydmljZS5hZGRUb0RhdGUodGhpcy5taW4sIHNraXApLCB0aGlzLmdldFRha2Uoc2tpcCkpO1xuICAgICAgICB0aGlzLnBhZ2VDaGFuZ2UuZW1pdCgpO1xuICAgIH1cbiAgICBzY3JvbGxDaGFuZ2UoeyBvZmZzZXQgfSkge1xuICAgICAgICBjb25zdCBlbCA9IHRoaXMubGlzdC5uYXRpdmVFbGVtZW50O1xuICAgICAgICBjb25zdCB0cmFuc2xhdGUgPSBgdHJhbnNsYXRlWSgke29mZnNldH1weClgO1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnNldFN0eWxlKGVsLCAndHJhbnNmb3JtJywgdHJhbnNsYXRlKTtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRTdHlsZShlbCwgJy1tcy10cmFuc2Zvcm0nLCB0cmFuc2xhdGUpO1xuICAgIH1cbiAgICBoYW5kbGVEYXRlQ2hhbmdlKGFyZ3MpIHtcbiAgICAgICAgY29uc3QgaXRlbSA9IGNsb3Nlc3RJblNjb3BlKGFyZ3MudGFyZ2V0LCBub2RlID0+IG5vZGUuaGFzQXR0cmlidXRlKCdkYXRhLWRhdGUtaW5kZXgnKSwgdGhpcy5saXN0Lm5hdGl2ZUVsZW1lbnQpO1xuICAgICAgICBpZiAoaXRlbSkge1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBwYXJzZUludChpdGVtLmdldEF0dHJpYnV0ZSgnZGF0YS1kYXRlLWluZGV4JyksIDEwKTtcbiAgICAgICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHRoaXMuZGF0ZXNbaW5kZXhdO1xuICAgICAgICAgICAgdGhpcy52YWx1ZUNoYW5nZS5lbWl0KGNsb25lRGF0ZShjYW5kaWRhdGUpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRUYWtlKHNraXApIHtcbiAgICAgICAgcmV0dXJuIE1hdGgubWluKHRoaXMudG90YWwgLSBza2lwLCB0aGlzLnRha2UpO1xuICAgIH1cbiAgICBpbnRsQ2hhbmdlKCkge1xuICAgICAgICBpZiAodGhpcy5hY3RpdmVWaWV3ID09PSBDYWxlbmRhclZpZXdFbnVtLm1vbnRoKSB7XG4gICAgICAgICAgICB0aGlzLmNkci5tYXJrRm9yQ2hlY2soKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBOYXZpZ2F0aW9uQ29tcG9uZW50LnByb3RvdHlwZSwgXCJhY3RpdmVWaWV3XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBEYXRlKVxuXSwgTmF2aWdhdGlvbkNvbXBvbmVudC5wcm90b3R5cGUsIFwibWluXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBEYXRlKVxuXSwgTmF2aWdhdGlvbkNvbXBvbmVudC5wcm90b3R5cGUsIFwibWF4XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBEYXRlKVxuXSwgTmF2aWdhdGlvbkNvbXBvbmVudC5wcm90b3R5cGUsIFwiZm9jdXNlZERhdGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFRlbXBsYXRlUmVmKVxuXSwgTmF2aWdhdGlvbkNvbXBvbmVudC5wcm90b3R5cGUsIFwidGVtcGxhdGVSZWZcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIE91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXG5dLCBOYXZpZ2F0aW9uQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ2YWx1ZUNoYW5nZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbl0sIE5hdmlnYXRpb25Db21wb25lbnQucHJvdG90eXBlLCBcInBhZ2VDaGFuZ2VcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIFZpZXdDaGlsZChWaXJ0dWFsaXphdGlvbkNvbXBvbmVudCwgeyBzdGF0aWM6IGZhbHNlIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBWaXJ0dWFsaXphdGlvbkNvbXBvbmVudClcbl0sIE5hdmlnYXRpb25Db21wb25lbnQucHJvdG90eXBlLCBcInZpcnR1YWxpemF0aW9uXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBWaWV3Q2hpbGQoJ2xpc3QnLCB7IHN0YXRpYzogdHJ1ZSB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRWxlbWVudFJlZilcbl0sIE5hdmlnYXRpb25Db21wb25lbnQucHJvdG90eXBlLCBcImxpc3RcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RCaW5kaW5nKFwiY2xhc3Muay1jYWxlbmRhci1uYXZpZ2F0aW9uXCIpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBOYXZpZ2F0aW9uQ29tcG9uZW50LnByb3RvdHlwZSwgXCJnZXRDb21wb25lbnRDbGFzc1wiLCBudWxsKTtcbk5hdmlnYXRpb25Db21wb25lbnQgPSBfX2RlY29yYXRlKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1jYWxlbmRhci1uYXZpZ2F0aW9uJyxcbiAgICAgICAgdGVtcGxhdGU6IGBcbiAgICA8c3BhbiBjbGFzcz1cImstY2FsZW5kYXItbmF2aWdhdGlvbi1oaWdobGlnaHRcIj48L3NwYW4+XG4gICAgPGtlbmRvLXZpcnR1YWxpemF0aW9uXG4gICAgICAgIFtza2lwXT1cInNraXBcIlxuICAgICAgICBbdGFrZV09XCJ0YWtlXCJcbiAgICAgICAgW3RvdGFsXT1cInRvdGFsXCJcbiAgICAgICAgW2l0ZW1IZWlnaHRdPVwiaXRlbUhlaWdodFwiXG4gICAgICAgIFt0b3BPZmZzZXRdPVwidG9wT2Zmc2V0XCJcbiAgICAgICAgW2JvdHRvbU9mZnNldF09XCJib3R0b21PZmZzZXRcIlxuICAgICAgICBbbWF4U2Nyb2xsRGlmZmVyZW5jZV09XCJtYXhWaWV3SGVpZ2h0XCJcbiAgICAgICAgKHBhZ2VDaGFuZ2UpPVwib25QYWdlQ2hhbmdlKCRldmVudClcIlxuICAgICAgICAoc2Nyb2xsQ2hhbmdlKT1cInNjcm9sbENoYW5nZSgkZXZlbnQpXCJcbiAgICA+XG4gICAgICAgIDx1bCAjbGlzdCBjbGFzcz1cImstcmVzZXRcIiBba2VuZG9FdmVudHNPdXRzaWRlQW5ndWxhcl09XCJ7IGNsaWNrOiBoYW5kbGVEYXRlQ2hhbmdlIH1cIiBbc2NvcGVdPVwidGhpc1wiPlxuICAgICAgICAgICAgPGxpICprRm9yPVwibGV0IGRhdGUgb2YgZGF0ZXM7IGxldCBpbmRleD1pbmRleFwiIFthdHRyLmRhdGEtZGF0ZS1pbmRleF09XCJpbmRleFwiPlxuICAgICAgICAgICAgICAgIDxzcGFuIFtjbGFzcy5rLWNhbGVuZGFyLW5hdmlnYXRpb24tbWFya2VyXT1cInNlcnZpY2UuaXNSYW5nZVN0YXJ0KGRhdGUpXCI+XG4gICAgICAgICAgICAgICAgICAgIDxuZy10ZW1wbGF0ZSBbbmdJZl09XCIhdGVtcGxhdGVSZWZcIj57e3NlcnZpY2UubmF2aWdhdGlvblRpdGxlKGRhdGUpfX08L25nLXRlbXBsYXRlPlxuICAgICAgICAgICAgICAgICAgICA8bmctdGVtcGxhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgIFtuZ0lmXT1cInRlbXBsYXRlUmVmXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIFtuZ1RlbXBsYXRlT3V0bGV0XT1cInRlbXBsYXRlUmVmXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIFtuZ1RlbXBsYXRlT3V0bGV0Q29udGV4dF09XCJ7ICRpbXBsaWNpdDogc2VydmljZS5uYXZpZ2F0aW9uVGl0bGUoZGF0ZSksIGFjdGl2ZVZpZXc6IGFjdGl2ZVZpZXdWYWx1ZSwgZGF0ZTogZGF0ZSB9XCJcbiAgICAgICAgICAgICAgICAgICAgPjwvbmctdGVtcGxhdGU+XG4gICAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgPC9saT5cbiAgICAgICAgPC91bD5cbiAgICA8L2tlbmRvLXZpcnR1YWxpemF0aW9uPlxuICBgXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtCdXNWaWV3U2VydmljZSxcbiAgICAgICAgQ2FsZW5kYXJET01TZXJ2aWNlLFxuICAgICAgICBJbnRsU2VydmljZSxcbiAgICAgICAgQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gICAgICAgIFJlbmRlcmVyMl0pXG5dLCBOYXZpZ2F0aW9uQ29tcG9uZW50KTtcblxuY29uc3QgVklFV1NfQ09VTlQgPSA1O1xuY29uc3QgaXNFcXVhbE1vbnRoWWVhciA9IChkYXRlMSwgZGF0ZTIpID0+IChkYXRlMSAmJiBkYXRlMiAmJlxuICAgIGRhdGUxLmdldEZ1bGxZZWFyKCkgPT09IGRhdGUyLmdldEZ1bGxZZWFyKCkgJiZcbiAgICBkYXRlMS5nZXRNb250aCgpID09PSBkYXRlMi5nZXRNb250aCgpKTtcbi8qKlxuICogQGhpZGRlblxuICovXG5sZXQgVmlld0xpc3RDb21wb25lbnQgPSBjbGFzcyBWaWV3TGlzdENvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoYnVzLCBjZHIsIGludGwsIGRvbSwgcmVuZGVyZXIpIHtcbiAgICAgICAgdGhpcy5idXMgPSBidXM7XG4gICAgICAgIHRoaXMuY2RyID0gY2RyO1xuICAgICAgICB0aGlzLmludGwgPSBpbnRsO1xuICAgICAgICB0aGlzLmRvbSA9IGRvbTtcbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgICAgICB0aGlzLmlzQWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5taW4gPSBuZXcgRGF0ZShNSU5fREFURSk7XG4gICAgICAgIHRoaXMubWF4ID0gbmV3IERhdGUoTUFYX0RBVEUpO1xuICAgICAgICB0aGlzLnNlbGVjdGVkRGF0ZXMgPSBbXTtcbiAgICAgICAgdGhpcy5jZWxsQ2xpY2sgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMud2Vla051bWJlckNlbGxDbGljayA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5hY3RpdmVEYXRlQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLnRvZGF5QnV0dG9uQ2xpY2sgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMucGFnZUNoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5nZXRDb21wb25lbnRDbGFzcyA9IHRydWU7XG4gICAgICAgIHRoaXMuZGF0ZXMgPSBbXTtcbiAgICAgICAgdGhpcy5jb2xzID0gW107XG4gICAgICAgIHRoaXMud2Vla05hbWVzID0gW107XG4gICAgICAgIHRoaXMudGFrZSA9IFZJRVdTX0NPVU5UO1xuICAgICAgICB0aGlzLmFuaW1hdGVUb0luZGV4ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5pbmRleFRvU2Nyb2xsID0gLTE7XG4gICAgICAgIHRoaXMubWluVmlld3NUb1JlbmRlciA9IDE7XG4gICAgfVxuICAgIGdldCB3ZWVrTnVtYmVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaG93V2Vla051bWJlcnMgJiYgdGhpcy5pc01vbnRoVmlldygpO1xuICAgIH1cbiAgICBzZXQgd2Vla051bWJlcihzaG93V2Vla051bWJlcnMpIHtcbiAgICAgICAgdGhpcy5zaG93V2Vla051bWJlcnMgPSBzaG93V2Vla051bWJlcnM7XG4gICAgfVxuICAgIGdldCBnZXRDb21wb25lbnRNb250aENsYXNzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hY3RpdmVWaWV3ID09PSBDYWxlbmRhclZpZXdFbnVtLm1vbnRoO1xuICAgIH1cbiAgICBnZXQgZ2V0Q29tcG9uZW50WWVhckNsYXNzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hY3RpdmVWaWV3ID09PSBDYWxlbmRhclZpZXdFbnVtLnllYXI7XG4gICAgfVxuICAgIGdldCBnZXRDb21wb25lbnREZWNhZGVDbGFzcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWN0aXZlVmlldyA9PT0gQ2FsZW5kYXJWaWV3RW51bS5kZWNhZGU7XG4gICAgfVxuICAgIGdldCBnZXRDb21wb25lbnRDZW50dXJ5Q2xhc3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFjdGl2ZVZpZXcgPT09IENhbGVuZGFyVmlld0VudW0uY2VudHVyeTtcbiAgICB9XG4gICAgbmdPbkluaXQoKSB7XG4gICAgICAgIHRoaXMud2Vla05hbWVzID0gdGhpcy5nZXRXZWVrTmFtZXMoKTtcbiAgICAgICAgdGhpcy5ib3R0b21PZmZzZXQgPSB0aGlzLmdldEJvdHRvbU9mZnNldCgpO1xuICAgICAgICB0aGlzLnZpZXdPZmZzZXQgPSAtMSAqIHRoaXMuZG9tLmhlYWRlckhlaWdodDtcbiAgICAgICAgdGhpcy52aWV3SGVpZ2h0ID0gdGhpcy5kb20udmlld0hlaWdodCh0aGlzLmFjdGl2ZVZpZXcpO1xuICAgICAgICB0aGlzLmludGxTdWJzY3JpcHRpb24gPSB0aGlzLmludGwuY2hhbmdlcy5zdWJzY3JpYmUodGhpcy5pbnRsQ2hhbmdlLmJpbmQodGhpcykpO1xuICAgIH1cbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzKSB7XG4gICAgICAgIHRoaXMuc2VydmljZSA9IHRoaXMuYnVzLnNlcnZpY2UodGhpcy5hY3RpdmVWaWV3KTtcbiAgICAgICAgaWYgKCF0aGlzLnNlcnZpY2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbHMgPSBuZXcgQXJyYXkodGhpcy5zZXJ2aWNlLnJvd0xlbmd0aCh7IHByZXBlbmRDZWxsOiB0aGlzLndlZWtOdW1iZXIgfSkpLmZpbGwoJycpO1xuICAgICAgICB0aGlzLmNvbFdpZHRoID0gTWF0aC5yb3VuZCgxMDAgLyB0aGlzLmNvbHMubGVuZ3RoKTtcbiAgICAgICAgdGhpcy53ZWVrTmFtZXMgPSBoYXNDaGFuZ2UoY2hhbmdlcywgJ3dlZWtOdW1iZXInKSAmJiB0aGlzLndlZWtOdW1iZXIgPyB0aGlzLmdldFdlZWtOYW1lcygpIDogdGhpcy53ZWVrTmFtZXM7XG4gICAgICAgIGNvbnN0IGFjdGl2ZVZpZXdDaGFuZ2VkID0gaGFzQ2hhbmdlKGNoYW5nZXMsICdhY3RpdmVWaWV3Jyk7XG4gICAgICAgIGNvbnN0IGZvY3VzZWREYXRlID0gdGhpcy5mb2N1c2VkRGF0ZTtcbiAgICAgICAgY29uc3Qgdmlld0RhdGUgPSBkYXRlSW5SYW5nZSh0aGlzLnNlcnZpY2Uudmlld0RhdGUoZm9jdXNlZERhdGUsIHRoaXMubWF4LCB0aGlzLm1pblZpZXdzVG9SZW5kZXIpLCB0aGlzLm1pbiwgdGhpcy5tYXgpO1xuICAgICAgICBjb25zdCB0b3RhbCA9IHRoaXMuc2VydmljZS50b3RhbCh0aGlzLm1pbiwgdGhpcy5tYXgpO1xuICAgICAgICBjb25zdCB0b3RhbENoYW5nZWQgPSB0aGlzLnRvdGFsICYmIHRoaXMudG90YWwgIT09IHRvdGFsO1xuICAgICAgICBjb25zdCBnZW5lcmF0ZURhdGVzID0gdG90YWxDaGFuZ2VkIHx8ICF0aGlzLnNlcnZpY2UuaXNJbkFycmF5KGZvY3VzZWREYXRlLCB0aGlzLmRhdGVzKTtcbiAgICAgICAgdGhpcy5za2lwID0gdGhpcy5zZXJ2aWNlLnNraXAodmlld0RhdGUsIHRoaXMubWluKTtcbiAgICAgICAgdGhpcy50b3RhbCA9IHRvdGFsO1xuICAgICAgICB0aGlzLmFuaW1hdGVUb0luZGV4ID0gIWFjdGl2ZVZpZXdDaGFuZ2VkO1xuICAgICAgICB0aGlzLmJvdHRvbU9mZnNldCA9IHRoaXMuZ2V0Qm90dG9tT2Zmc2V0KCk7XG4gICAgICAgIHRoaXMudmlld0hlaWdodCA9IHRoaXMuZG9tLnZpZXdIZWlnaHQodGhpcy5hY3RpdmVWaWV3KTtcbiAgICAgICAgaWYgKGdlbmVyYXRlRGF0ZXMpIHtcbiAgICAgICAgICAgIHRoaXMuZGF0ZXMgPSB0aGlzLnNlcnZpY2UuZGF0ZXNMaXN0KHZpZXdEYXRlLCB0aGlzLmdldFRha2UodGhpcy5za2lwKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc0VxdWFsTW9udGhZZWFyKHRoaXMuYWN0aXZlRGF0ZSwgZm9jdXNlZERhdGUpKSB7XG4gICAgICAgICAgICB0aGlzLmFjdGl2ZURhdGUgPSBjbG9uZURhdGUoZm9jdXNlZERhdGUpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVwZGF0ZUluZGV4ID0gaGFzQ2hhbmdlKGNoYW5nZXMsICdmb2N1c2VkRGF0ZScpIHx8IGFjdGl2ZVZpZXdDaGFuZ2VkO1xuICAgICAgICBpZiAoZ2VuZXJhdGVEYXRlcyB8fCB1cGRhdGVJbmRleCB8fCB0aGlzLnZpcnR1YWxpemF0aW9uLmlzSW5kZXhWaXNpYmxlKHRoaXMuc2tpcCkpIHtcbiAgICAgICAgICAgIHRoaXMuaW5kZXhUb1Njcm9sbCA9IHRoaXMuc2VydmljZS5za2lwKGZvY3VzZWREYXRlLCB0aGlzLm1pbik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIGlmICh0aGlzLmludGxTdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuaW50bFN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG5nQWZ0ZXJWaWV3SW5pdCgpIHtcbiAgICAgICAgaWYgKHRoaXMuaW5kZXhUb1Njcm9sbCA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnZpcnR1YWxpemF0aW9uLnNjcm9sbFRvSW5kZXgodGhpcy5pbmRleFRvU2Nyb2xsKTtcbiAgICAgICAgdGhpcy5pbmRleFRvU2Nyb2xsID0gLTE7XG4gICAgfVxuICAgIG5nQWZ0ZXJWaWV3Q2hlY2tlZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuaW5kZXhUb1Njcm9sbCA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnZpcnR1YWxpemF0aW9uW3RoaXMuYW5pbWF0ZVRvSW5kZXggPyAnYW5pbWF0ZVRvSW5kZXgnIDogJ3Njcm9sbFRvSW5kZXgnXSh0aGlzLmluZGV4VG9TY3JvbGwpO1xuICAgICAgICB0aGlzLmFuaW1hdGVUb0luZGV4ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5pbmRleFRvU2Nyb2xsID0gLTE7XG4gICAgfVxuICAgIG9uUGFnZUNoYW5nZSh7IHNraXAgfSkge1xuICAgICAgICB0aGlzLmRhdGVzID0gdGhpcy5zZXJ2aWNlLmRhdGVzTGlzdCh0aGlzLnNlcnZpY2UuYWRkVG9EYXRlKHRoaXMubWluLCBza2lwKSwgdGhpcy5nZXRUYWtlKHNraXApKTtcbiAgICAgICAgdGhpcy5wYWdlQ2hhbmdlLmVtaXQoKTtcbiAgICB9XG4gICAgc2Nyb2xsQ2hhbmdlKHsgb2Zmc2V0IH0pIHtcbiAgICAgICAgY29uc3QgZWwgPSB0aGlzLmxpc3QubmF0aXZlRWxlbWVudDtcbiAgICAgICAgY29uc3QgdHJhbnNsYXRlID0gYHRyYW5zbGF0ZVkoJHtvZmZzZXR9cHgpYDtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRTdHlsZShlbCwgJ3RyYW5zZm9ybScsIHRyYW5zbGF0ZSk7XG4gICAgICAgIHRoaXMucmVuZGVyZXIuc2V0U3R5bGUoZWwsICctbXMtdHJhbnNmb3JtJywgdHJhbnNsYXRlKTtcbiAgICB9XG4gICAgc2V0QWN0aXZlRGF0ZShpbmRleCkge1xuICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSB0aGlzLnNlcnZpY2UuYWRkVG9EYXRlKHRoaXMubWluLCBpbmRleCk7XG4gICAgICAgIHRoaXMuYWN0aXZlRGF0ZSA9IGNhbmRpZGF0ZTtcbiAgICAgICAgdGhpcy5hY3RpdmVEYXRlQ2hhbmdlLmVtaXQoY2FuZGlkYXRlKTtcbiAgICAgICAgdGhpcy5jZHIuZGV0ZWN0Q2hhbmdlcygpO1xuICAgIH1cbiAgICBpc01vbnRoVmlldygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWN0aXZlVmlldyA9PT0gQ2FsZW5kYXJWaWV3RW51bS5tb250aDtcbiAgICB9XG4gICAgaXNTY3JvbGxlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlydHVhbGl6YXRpb24uaXNMaXN0U2Nyb2xsZWQodGhpcy5zZXJ2aWNlLnNraXAodGhpcy5mb2N1c2VkRGF0ZSwgdGhpcy5taW4pKTtcbiAgICB9XG4gICAgZ2V0Qm90dG9tT2Zmc2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRTY3JvbGxhYmxlSGVpZ2h0KCkgLSB0aGlzLmRvbS52aWV3SGVpZ2h0KHRoaXMuYWN0aXZlVmlldyk7XG4gICAgfVxuICAgIGdldFNjcm9sbGFibGVIZWlnaHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFjdGl2ZVZpZXcgPT09IENhbGVuZGFyVmlld0VudW0ubW9udGggP1xuICAgICAgICAgICAgdGhpcy5kb20uc2Nyb2xsYWJsZUNvbnRlbnRIZWlnaHQgOlxuICAgICAgICAgICAgdGhpcy5kb20uc2Nyb2xsYWJsZVllYXJDb250ZW50SGVpZ2h0O1xuICAgIH1cbiAgICBnZXRUYWtlKHNraXApIHtcbiAgICAgICAgcmV0dXJuIE1hdGgubWluKHRoaXMudG90YWwgLSBza2lwLCB0aGlzLnRha2UpO1xuICAgIH1cbiAgICBnZXRXZWVrTmFtZXMoKSB7XG4gICAgICAgIGNvbnN0IHdlZWtOYW1lcyA9IHNoaWZ0V2Vla05hbWVzKHRoaXMuaW50bC5kYXRlRm9ybWF0TmFtZXMoeyBuYW1lVHlwZTogJ3Nob3J0JywgdHlwZTogJ2RheXMnIH0pLCB0aGlzLmludGwuZmlyc3REYXkoKSk7XG4gICAgICAgIHJldHVybiB0aGlzLndlZWtOdW1iZXIgPyBbJyddLmNvbmNhdCh3ZWVrTmFtZXMpIDogd2Vla05hbWVzO1xuICAgIH1cbiAgICBpbnRsQ2hhbmdlKCkge1xuICAgICAgICB0aGlzLndlZWtOYW1lcyA9IHRoaXMuZ2V0V2Vla05hbWVzKCk7XG4gICAgICAgIGlmICh0aGlzLmlzTW9udGhWaWV3KCkpIHtcbiAgICAgICAgICAgIHRoaXMuY2RyLm1hcmtGb3JDaGVjaygpO1xuICAgICAgICB9XG4gICAgfVxufTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFRlbXBsYXRlUmVmKVxuXSwgVmlld0xpc3RDb21wb25lbnQucHJvdG90eXBlLCBcImNlbGxUZW1wbGF0ZVJlZlwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgVGVtcGxhdGVSZWYpXG5dLCBWaWV3TGlzdENvbXBvbmVudC5wcm90b3R5cGUsIFwid2Vla051bWJlclRlbXBsYXRlUmVmXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBUZW1wbGF0ZVJlZilcbl0sIFZpZXdMaXN0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJoZWFkZXJUaXRsZVRlbXBsYXRlUmVmXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBWaWV3TGlzdENvbXBvbmVudC5wcm90b3R5cGUsIFwiYWN0aXZlVmlld1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgVmlld0xpc3RDb21wb25lbnQucHJvdG90eXBlLCBcImNlbGxVSURcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIERhdGUpXG5dLCBWaWV3TGlzdENvbXBvbmVudC5wcm90b3R5cGUsIFwiZm9jdXNlZERhdGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBWaWV3TGlzdENvbXBvbmVudC5wcm90b3R5cGUsIFwiaXNBY3RpdmVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIERhdGUpXG5dLCBWaWV3TGlzdENvbXBvbmVudC5wcm90b3R5cGUsIFwibWluXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBEYXRlKVxuXSwgVmlld0xpc3RDb21wb25lbnQucHJvdG90eXBlLCBcIm1heFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpXG5dLCBWaWV3TGlzdENvbXBvbmVudC5wcm90b3R5cGUsIFwic2VsZWN0ZWREYXRlc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtCb29sZWFuXSlcbl0sIFZpZXdMaXN0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJ3ZWVrTnVtYmVyXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbl0sIFZpZXdMaXN0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJjZWxsQ2xpY2tcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIE91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXG5dLCBWaWV3TGlzdENvbXBvbmVudC5wcm90b3R5cGUsIFwid2Vla051bWJlckNlbGxDbGlja1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbl0sIFZpZXdMaXN0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJhY3RpdmVEYXRlQ2hhbmdlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBPdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxuXSwgVmlld0xpc3RDb21wb25lbnQucHJvdG90eXBlLCBcInRvZGF5QnV0dG9uQ2xpY2tcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIE91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXG5dLCBWaWV3TGlzdENvbXBvbmVudC5wcm90b3R5cGUsIFwicGFnZUNoYW5nZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgVmlld0NoaWxkKFZpcnR1YWxpemF0aW9uQ29tcG9uZW50LCB7IHN0YXRpYzogZmFsc2UgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFZpcnR1YWxpemF0aW9uQ29tcG9uZW50KVxuXSwgVmlld0xpc3RDb21wb25lbnQucHJvdG90eXBlLCBcInZpcnR1YWxpemF0aW9uXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBWaWV3Q2hpbGQoJ2xpc3QnLCB7IHN0YXRpYzogdHJ1ZSB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRWxlbWVudFJlZilcbl0sIFZpZXdMaXN0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJsaXN0XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBIb3N0QmluZGluZyhcImNsYXNzLmstdnN0YWNrXCIpLFxuICAgIEhvc3RCaW5kaW5nKFwiY2xhc3Muay1jYWxlbmRhci12aWV3XCIpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgVmlld0xpc3RDb21wb25lbnQucHJvdG90eXBlLCBcImdldENvbXBvbmVudENsYXNzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBIb3N0QmluZGluZyhcImNsYXNzLmstY2FsZW5kYXItbW9udGh2aWV3XCIpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBWaWV3TGlzdENvbXBvbmVudC5wcm90b3R5cGUsIFwiZ2V0Q29tcG9uZW50TW9udGhDbGFzc1wiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RCaW5kaW5nKFwiY2xhc3Muay1jYWxlbmRhci15ZWFydmlld1wiKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgVmlld0xpc3RDb21wb25lbnQucHJvdG90eXBlLCBcImdldENvbXBvbmVudFllYXJDbGFzc1wiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RCaW5kaW5nKFwiY2xhc3Muay1jYWxlbmRhci1kZWNhZGV2aWV3XCIpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBWaWV3TGlzdENvbXBvbmVudC5wcm90b3R5cGUsIFwiZ2V0Q29tcG9uZW50RGVjYWRlQ2xhc3NcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBIb3N0QmluZGluZyhcImNsYXNzLmstY2FsZW5kYXItY2VudHVyeXZpZXdcIiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIFZpZXdMaXN0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJnZXRDb21wb25lbnRDZW50dXJ5Q2xhc3NcIiwgbnVsbCk7XG5WaWV3TGlzdENvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLWNhbGVuZGFyLXZpZXdsaXN0JyxcbiAgICAgICAgdGVtcGxhdGU6IGBcbiAgICA8a2VuZG8tY2FsZW5kYXItaGVhZGVyXG4gICAgICAgIFtjdXJyZW50RGF0ZV09XCJhY3RpdmVEYXRlXCJcbiAgICAgICAgW21pbl09XCJtaW5cIlxuICAgICAgICBbbWF4XT1cIm1heFwiXG4gICAgICAgIFthY3RpdmVWaWV3XT1cImFjdGl2ZVZpZXdcIlxuICAgICAgICBbdGVtcGxhdGVSZWZdPVwiaGVhZGVyVGl0bGVUZW1wbGF0ZVJlZlwiXG4gICAgICAgICh0b2RheUJ1dHRvbkNsaWNrKT1cInRvZGF5QnV0dG9uQ2xpY2suZW1pdCgkZXZlbnQpXCJcbiAgICA+XG4gICAgPC9rZW5kby1jYWxlbmRhci1oZWFkZXI+XG4gICAgPHRhYmxlIGNsYXNzPVwiay1jYWxlbmRhci13ZWVrZGF5cyBrLWNhbGVuZGFyLXRhYmxlXCIgc3R5bGU9XCJ0YWJsZS1sYXlvdXQ6IGF1dG87XCIgKm5nSWY9XCJpc01vbnRoVmlldygpXCI+XG4gICAgICAgIDx0aGVhZCBjbGFzcz1cImstY2FsZW5kYXItdGhlYWRcIj5cbiAgICAgICAgICAgIDx0ciBjbGFzcz1cImstY2FsZW5kYXItdHJcIj5cbiAgICAgICAgICAgICAgICA8dGggY2xhc3M9XCJrLWNhbGVuZGFyLXRoXCIgKm5nRm9yPVwibGV0IG5hbWUgb2Ygd2Vla05hbWVzXCIgW3N0eWxlLndpZHRoLiVdPVwiY29sV2lkdGhcIj57e25hbWV9fTwvdGg+XG4gICAgICAgICAgICA8L3RyPlxuICAgICAgICA8L3RoZWFkPlxuICAgIDwvdGFibGU+XG4gICAgPGtlbmRvLXZpcnR1YWxpemF0aW9uXG4gICAgICAgIFt0YWJpbmRleF09XCItMVwiXG4gICAgICAgIFtza2lwXT1cInNraXBcIlxuICAgICAgICBbdGFrZV09XCJ0YWtlXCJcbiAgICAgICAgW3RvdGFsXT1cInRvdGFsXCJcbiAgICAgICAgW2l0ZW1IZWlnaHRdPVwidmlld0hlaWdodFwiXG4gICAgICAgIFt0b3BPZmZzZXRdPVwidmlld09mZnNldFwiXG4gICAgICAgIFtib3R0b21PZmZzZXRdPVwiYm90dG9tT2Zmc2V0XCJcbiAgICAgICAgW3Njcm9sbE9mZnNldFNpemVdPVwidmlld09mZnNldFwiXG4gICAgICAgIFttYXhTY3JvbGxEaWZmZXJlbmNlXT1cInZpZXdIZWlnaHRcIlxuICAgICAgICAocGFnZUNoYW5nZSk9XCJvblBhZ2VDaGFuZ2UoJGV2ZW50KVwiXG4gICAgICAgIChzY3JvbGxDaGFuZ2UpPVwic2Nyb2xsQ2hhbmdlKCRldmVudClcIlxuICAgICAgICAoYWN0aXZlSW5kZXhDaGFuZ2UpPVwic2V0QWN0aXZlRGF0ZSgkZXZlbnQpXCJcbiAgICAgICAgPlxuICAgICAgICA8dGFibGUgY2xhc3M9XCJrLWNhbGVuZGFyLXRhYmxlXCIgI2xpc3Q+XG4gICAgICAgICAgICA8Y29sZ3JvdXA+PGNvbCAqbmdGb3I9XCJsZXQgXyBvZiBjb2xzXCIgLz48L2NvbGdyb3VwPlxuXG4gICAgICAgICAgICA8dGJvZHkgY2xhc3M9XCJrLWNhbGVuZGFyLXRib2R5XCJcbiAgICAgICAgICAgICAgICAgICAqa0Zvcj1cImxldCBkYXRlIG9mIGRhdGVzXCJcbiAgICAgICAgICAgICAgICAgICBrZW5kb0NhbGVuZGFyVmlld1xuICAgICAgICAgICAgICAgICAgIHJvbGU9XCJyb3dncm91cFwiXG4gICAgICAgICAgICAgICAgICAgW2FjdGl2ZVZpZXddPVwiYWN0aXZlVmlld1wiXG4gICAgICAgICAgICAgICAgICAgW2lzQWN0aXZlXT1cImlzQWN0aXZlXCJcbiAgICAgICAgICAgICAgICAgICBbbWluXT1cIm1pblwiIFttYXhdPVwibWF4XCJcbiAgICAgICAgICAgICAgICAgICBbY2VsbFVJRF09XCJjZWxsVUlEXCJcbiAgICAgICAgICAgICAgICAgICBbZm9jdXNlZERhdGVdPVwiZm9jdXNlZERhdGVcIlxuICAgICAgICAgICAgICAgICAgIFtzZWxlY3RlZERhdGVzXT1cInNlbGVjdGVkRGF0ZXNcIlxuICAgICAgICAgICAgICAgICAgIFt3ZWVrTnVtYmVyXT1cIndlZWtOdW1iZXJcIlxuICAgICAgICAgICAgICAgICAgIFt0ZW1wbGF0ZVJlZl09XCJjZWxsVGVtcGxhdGVSZWZcIlxuICAgICAgICAgICAgICAgICAgIFt3ZWVrTnVtYmVyVGVtcGxhdGVSZWZdPVwid2Vla051bWJlclRlbXBsYXRlUmVmXCJcbiAgICAgICAgICAgICAgICAgICBbdmlld0RhdGVdPVwiZGF0ZVwiXG4gICAgICAgICAgICAgICAgICAgKGNlbGxDbGljayk9XCJjZWxsQ2xpY2suZW1pdCgkZXZlbnQpXCJcbiAgICAgICAgICAgICAgICAgICAod2Vla051bWJlckNlbGxDbGljayk9XCJ3ZWVrTnVtYmVyQ2VsbENsaWNrLmVtaXQoJGV2ZW50KVwiXG4gICAgICAgICAgICA+PC90Ym9keT5cbiAgICAgICAgPC90YWJsZT5cbiAgICA8L2tlbmRvLXZpcnR1YWxpemF0aW9uPlxuICBgXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtCdXNWaWV3U2VydmljZSxcbiAgICAgICAgQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gICAgICAgIEludGxTZXJ2aWNlLFxuICAgICAgICBDYWxlbmRhckRPTVNlcnZpY2UsXG4gICAgICAgIFJlbmRlcmVyMl0pXG5dLCBWaWV3TGlzdENvbXBvbmVudCk7XG5cbmNvbnN0IEtFWV9UT19BQ1RJT04gPSB7XG4gICAgJzMzJzogQWN0aW9uLlByZXZWaWV3LFxuICAgICczNCc6IEFjdGlvbi5OZXh0VmlldyxcbiAgICAnMzUnOiBBY3Rpb24uTGFzdEluVmlldyxcbiAgICAnMzYnOiBBY3Rpb24uRmlyc3RJblZpZXcsXG4gICAgJzM3JzogQWN0aW9uLkxlZnQsXG4gICAgJzM4JzogQWN0aW9uLlVwLFxuICAgICczOSc6IEFjdGlvbi5SaWdodCxcbiAgICAnNDAnOiBBY3Rpb24uRG93bixcbiAgICAnbWV0YSszOCc6IEFjdGlvbi5VcHBlclZpZXcsXG4gICAgJ21ldGErNDAnOiBBY3Rpb24uTG93ZXJWaWV3XG59O1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmxldCBOYXZpZ2F0aW9uU2VydmljZSA9IGNsYXNzIE5hdmlnYXRpb25TZXJ2aWNlIHtcbiAgICBjb25zdHJ1Y3RvcihidXMpIHtcbiAgICAgICAgdGhpcy5idXMgPSBidXM7XG4gICAgfVxuICAgIGFjdGlvbihldmVudCkge1xuICAgICAgICBjb25zdCBhY3Rpb24gPSBgJHtldmVudC5jdHJsS2V5IHx8IGV2ZW50Lm1ldGFLZXkgPyAnbWV0YSsnIDogJyd9JHtldmVudC5rZXlDb2RlfWA7XG4gICAgICAgIHJldHVybiBLRVlfVE9fQUNUSU9OW2FjdGlvbl07XG4gICAgfVxuICAgIG1vdmUodmFsdWUsIGFjdGlvbiwgYWN0aXZlVmlldykge1xuICAgICAgICBjb25zdCBzZXJ2aWNlID0gdGhpcy5idXMuc2VydmljZShhY3RpdmVWaWV3KTtcbiAgICAgICAgaWYgKCFzZXJ2aWNlKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFjdGlvbiA9PT0gQWN0aW9uLlVwcGVyVmlldyAmJiB0aGlzLmJ1cy5jYW5Nb3ZlVXAoYWN0aXZlVmlldykpIHtcbiAgICAgICAgICAgIHRoaXMuYnVzLm1vdmVVcChhY3RpdmVWaWV3KTtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWN0aW9uID09PSBBY3Rpb24uTG93ZXJWaWV3ICYmIHRoaXMuYnVzLmNhbk1vdmVEb3duKGFjdGl2ZVZpZXcpKSB7XG4gICAgICAgICAgICB0aGlzLmJ1cy5tb3ZlRG93bihhY3RpdmVWaWV3KTtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VydmljZS5tb3ZlKHZhbHVlLCBhY3Rpb24pO1xuICAgIH1cbn07XG5OYXZpZ2F0aW9uU2VydmljZSA9IF9fZGVjb3JhdGUoW1xuICAgIEluamVjdGFibGUoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0J1c1ZpZXdTZXJ2aWNlXSlcbl0sIE5hdmlnYXRpb25TZXJ2aWNlKTtcblxuY29uc3Qgbm9vcCQxID0gKCkgPT4gZmFsc2U7XG5jb25zdCBESVNBQkxFRF9EQVRFU19ET0NfTElOSyA9ICdodHRwczovL3d3dy50ZWxlcmlrLmNvbS9rZW5kby1hbmd1bGFyLXVpL2NvbXBvbmVudHMvZGF0ZWlucHV0cy9jYWxlbmRhci9kaXNhYmxlZC1kYXRlcy8nO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmxldCBEaXNhYmxlZERhdGVzU2VydmljZSA9IGNsYXNzIERpc2FibGVkRGF0ZXNTZXJ2aWNlIHtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbWl0cyBldmVyeSB0aW1lIHRoZSBgaXNEYXRlRGlzYWJsZWRgIG1ldGhvZCBjaGFuZ2VzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jaGFuZ2VzID0gbmV3IFN1YmplY3QoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJhc2VkIG9uIHRoZSB1c2VyLWRlZmluZWQgYGRpc2FibGVkRGF0ZXNgIGlucHV0IGV2YWx1YXRlcyBpZiB0aGUgZGF0ZSBpcyBkaXNhYmxlZC5cbiAgICAgICAgICogSWYgbm90IHNldCwgcmV0dXJucyBgZmFsc2VgLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pc0RhdGVEaXNhYmxlZCA9IG5vb3AkMTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29uZmlndXJlcyB0aGUgYGlzRGF0ZURpc2FibGVkYCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqICogSWYgYSBmdW5jdGlvbiBpcyBwcm92aWRlZCwgdXNlcyBpdCBhcy1pcyBhbmQgcGFzc2VzIGVhY2ggZGF0ZSB0byBpdCBmb3IgZXZhbHVhdGlvbi5cbiAgICAgKiBUaGUgdGltZSBwYXJ0IGlzIHNldCB0byBgbWlkbmlnaHRgLlxuICAgICAqICogSWYgYSBgRGF0ZVtdYCBpcyBwcm92aWRlZCwgY3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgY2hlY2tzIHRoZSB0YXJnZXRlZCBkYXRlIGFnYWluc3RcbiAgICAgKiB0aGUgbGlzdGVkIGRhdGVzIGFuZCwgaWYgdGhlIHRhcmdldGVkIGRhdGUgaXMgbGlzdGVkLCBtYXJrcyBpdCBhcyBkaXNhYmxlZC5cbiAgICAgKiAqIElmIGEgYERheVtdYCBpcyBwcm92aWRlZCwgY3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgZXZhbHVhdGVzIHRoZSBwcm92aWRlZCBkYXlzIG9mIHRoZVxuICAgICAqIHdlZWsgYXMgZGlzYWJsZWQuXG4gICAgICovXG4gICAgaW5pdGlhbGl6ZShkaXNhYmxlZERhdGVzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZGlzYWJsZWREYXRlcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhpcy5pc0RhdGVEaXNhYmxlZCA9IChkYXRlKSA9PiBkaXNhYmxlZERhdGVzKGdldERhdGUoZGF0ZSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzTnVtYmVyQXJyYXkoZGlzYWJsZWREYXRlcykpIHtcbiAgICAgICAgICAgIGNvbnN0IGRpc2FibGVkV2Vla0RheXMgPSBuZXcgU2V0KGRpc2FibGVkRGF0ZXMpO1xuICAgICAgICAgICAgdGhpcy5pc0RhdGVEaXNhYmxlZCA9IChkYXRlKSA9PiBkaXNhYmxlZFdlZWtEYXlzLmhhcyhkYXRlLmdldERheSgpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc0RhdGVBcnJheShkaXNhYmxlZERhdGVzKSkge1xuICAgICAgICAgICAgY29uc3Qgbm9ybWFsaXplZERpc2FibGVkRGF0ZXMgPSBuZXcgU2V0KGRpc2FibGVkRGF0ZXMubWFwKGRhdGUgPT4gZ2V0RGF0ZShkYXRlKS5nZXRUaW1lKCkpKTtcbiAgICAgICAgICAgIHRoaXMuaXNEYXRlRGlzYWJsZWQgPSAoZGF0ZSkgPT4gbm9ybWFsaXplZERpc2FibGVkRGF0ZXMuaGFzKGdldERhdGUoZGF0ZSkuZ2V0VGltZSgpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaXNEYXRlRGlzYWJsZWQgPSBub29wJDE7XG4gICAgICAgICAgICB0aGlzLm5vdGlmeUludmFsaWRJbnB1dChkaXNhYmxlZERhdGVzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5vdGlmeVNlcnZpY2VDaGFuZ2UoKTtcbiAgICB9XG4gICAgbm90aWZ5SW52YWxpZElucHV0KGRpc2FibGVkRGF0ZXMpIHtcbiAgICAgICAgaWYgKGlzUHJlc2VudChkaXNhYmxlZERhdGVzKSAmJiBpc0Rldk1vZGUoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgJ2Rpc2FibGVkRGF0ZXMnIHZhbHVlIHNob3VsZCBiZSBhIGZ1bmN0aW9uLCBhIERheSBhcnJheSBvciBhIERhdGUgYXJyYXkuIENoZWNrICR7RElTQUJMRURfREFURVNfRE9DX0xJTkt9IGZvciBtb3JlIGluZm9ybWF0aW9uLmApO1xuICAgICAgICB9XG4gICAgfVxuICAgIG5vdGlmeVNlcnZpY2VDaGFuZ2UoKSB7XG4gICAgICAgIHRoaXMuY2hhbmdlcy5uZXh0KCk7XG4gICAgfVxufTtcbkRpc2FibGVkRGF0ZXNTZXJ2aWNlID0gX19kZWNvcmF0ZShbXG4gICAgSW5qZWN0YWJsZSgpXG5dLCBEaXNhYmxlZERhdGVzU2VydmljZSk7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5sZXQgU2VsZWN0aW9uU2VydmljZSA9IGNsYXNzIFNlbGVjdGlvblNlcnZpY2Uge1xuICAgIGNvbnN0cnVjdG9yKGJ1cykge1xuICAgICAgICB0aGlzLmJ1cyA9IGJ1cztcbiAgICB9XG4gICAgcGVyZm9ybVNlbGVjdGlvbihhcmdzKSB7XG4gICAgICAgIGxldCB7IGRhdGUsIG1vZGlmaWVycywgc2VsZWN0aW9uTW9kZSwgYWN0aXZlVmlld0VudW0sIHJhbmdlUGl2b3QgfSA9IGFyZ3M7XG4gICAgICAgIGxldCBzZWxlY3RlZERhdGVzID0gYXJncy5zZWxlY3RlZERhdGVzLnNsaWNlKCk7XG4gICAgICAgIGlmIChzZWxlY3Rpb25Nb2RlID09PSAnbXVsdGlwbGUnKSB7XG4gICAgICAgICAgICBpZiAobW9kaWZpZXJzLmN0cmxLZXkgfHwgbW9kaWZpZXJzLm1ldGFLZXkpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc0RhdGVTZWxlY3RlZChzZWxlY3RlZERhdGVzLCBkYXRlKSkge1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZERhdGVzID0gc2VsZWN0ZWREYXRlcy5maWx0ZXIoaXRlbSA9PiAhaXNFcXVhbChpdGVtLCBkYXRlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZERhdGVzLnB1c2goZGF0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJhbmdlUGl2b3QgPSBkYXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobW9kaWZpZXJzLnNoaWZ0S2V5KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgW3N0YXJ0LCBlbmRdID0gc29ydERhdGVzKFtyYW5nZVBpdm90IHx8IGRhdGUsIGRhdGVdKTtcbiAgICAgICAgICAgICAgICBzZWxlY3RlZERhdGVzID0gdGhpcy5idXMuc2VydmljZShhY3RpdmVWaWV3RW51bSkuZGF0ZVJhbmdlKHN0YXJ0LCBlbmQpO1xuICAgICAgICAgICAgICAgIHJhbmdlUGl2b3QgPSBkYXRlID4gc2VsZWN0ZWREYXRlc1swXSA/IHNlbGVjdGVkRGF0ZXNbMF0gOiBsYXN0KHNlbGVjdGVkRGF0ZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0ZWREYXRlcyA9IFtkYXRlXTtcbiAgICAgICAgICAgICAgICByYW5nZVBpdm90ID0gZGF0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNlbGVjdGVkRGF0ZXMgPSBbZGF0ZV07XG4gICAgICAgICAgICByYW5nZVBpdm90ID0gZGF0ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBzZWxlY3RlZERhdGVzLCByYW5nZVBpdm90IH07XG4gICAgfVxuICAgIGlzRGF0ZVNlbGVjdGVkKHNlbGVjdGVkRGF0ZXMsIGRhdGUpIHtcbiAgICAgICAgcmV0dXJuIHNlbGVjdGVkRGF0ZXMuc29tZShpdGVtID0+IGlzRXF1YWwoaXRlbSwgZGF0ZSkpO1xuICAgIH1cbn07XG5TZWxlY3Rpb25TZXJ2aWNlID0gX19kZWNvcmF0ZShbXG4gICAgSW5qZWN0YWJsZSgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQnVzVmlld1NlcnZpY2VdKVxuXSwgU2VsZWN0aW9uU2VydmljZSk7XG5cbmNvbnN0IGRpdmlkZUJ5TWFnbml0dWRlID0gKG1hZ25pdHVkZSkgPT4geCA9PiBNYXRoLmZsb29yKHggLyBtYWduaXR1ZGUpO1xuY29uc3QgcG93ZXJCeU1hZ25pdHVkZSA9IChtYWduaXR1ZGUpID0+IHggPT4geCAqIG1hZ25pdHVkZTtcbi8qKlxuICogQGhpZGRlblxuICovXG5sZXQgU2Nyb2xsU3luY1NlcnZpY2UgPSBjbGFzcyBTY3JvbGxTeW5jU2VydmljZSB7XG4gICAgY29uc3RydWN0b3IoZG9tLCB6b25lKSB7XG4gICAgICAgIHRoaXMuZG9tID0gZG9tO1xuICAgICAgICB0aGlzLnpvbmUgPSB6b25lO1xuICAgIH1cbiAgICBjb25maWd1cmUoYWN0aXZlVmlldykge1xuICAgICAgICBjb25zdCBtYWduaXR1ZGUgPSBNYXRoLm1heCh0aGlzLmRvbS52aWV3SGVpZ2h0KGFjdGl2ZVZpZXcpIC8gdGhpcy5kb20ubmF2aWdhdGlvbkl0ZW1IZWlnaHQsIDEpO1xuICAgICAgICB0aGlzLmRpdmlkZUJ5TWFnbml0dWRlID0gZGl2aWRlQnlNYWduaXR1ZGUobWFnbml0dWRlKTtcbiAgICAgICAgdGhpcy5wb3dlckJ5TWFnbml0dWRlID0gcG93ZXJCeU1hZ25pdHVkZShtYWduaXR1ZGUpO1xuICAgIH1cbiAgICBzeW5jKG5hdmlnYXRvciwgdmlldykge1xuICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIGlmICghbmF2aWdhdG9yIHx8ICF2aWV3KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5uYXZpZ2F0b3IgPSBuYXZpZ2F0b3I7XG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgIHRoaXMuem9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XG4gICAgICAgICAgICBsZXQgbmF2U2Nyb2xsZWQsIG1vbnRoU2Nyb2xsZWQ7XG4gICAgICAgICAgICB0aGlzLm5hdlN1YnNjcmlwdGlvbiA9IG5hdmlnYXRvci5zY3JvbGwkKClcbiAgICAgICAgICAgICAgICAuc3Vic2NyaWJlKChlKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKG1vbnRoU2Nyb2xsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbW9udGhTY3JvbGxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5hdlNjcm9sbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbFNpYmxpbmdPZihlLnRhcmdldCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMudmlld1N1YnNjcmlwdGlvbiA9IHZpZXcuc2Nyb2xsJCgpXG4gICAgICAgICAgICAgICAgLnN1YnNjcmliZSgoZSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChuYXZTY3JvbGxlZCkge1xuICAgICAgICAgICAgICAgICAgICBuYXZTY3JvbGxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1vbnRoU2Nyb2xsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsU2libGluZ09mKGUudGFyZ2V0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc2Nyb2xsU2libGluZ09mKHNjcm9sbGVkRWxlbWVudCkge1xuICAgICAgICBjb25zdCBjb21wb25lbnQgPSB0aGlzLnNpYmxpbmdDb21wb25lbnQoc2Nyb2xsZWRFbGVtZW50KTtcbiAgICAgICAgY29uc3Qgc2Nyb2xsVG9wID0gdGhpcy5jYWxjdWxhdGVTY3JvbGwoY29tcG9uZW50LCBzY3JvbGxlZEVsZW1lbnQuc2Nyb2xsVG9wKTtcbiAgICAgICAgY29tcG9uZW50LnNjcm9sbFRvKHNjcm9sbFRvcCk7XG4gICAgfVxuICAgIHNpYmxpbmdDb21wb25lbnQoc2Nyb2xsYWJsZUVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmF2aWdhdG9yLmNvbnRhaW5lci5uYXRpdmVFbGVtZW50ID09PSBzY3JvbGxhYmxlRWxlbWVudCA/IHRoaXMudmlldyA6IHRoaXMubmF2aWdhdG9yO1xuICAgIH1cbiAgICBjYWxjdWxhdGVTY3JvbGwoY29tcG9uZW50LCBzY3JvbGxUb3ApIHtcbiAgICAgICAgY29uc3QgbW9kaWZpZXIgPSBjb21wb25lbnQgPT09IHRoaXMubmF2aWdhdG9yID8gdGhpcy5kaXZpZGVCeU1hZ25pdHVkZSA6IHRoaXMucG93ZXJCeU1hZ25pdHVkZTtcbiAgICAgICAgcmV0dXJuIG1vZGlmaWVyKHNjcm9sbFRvcCk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICB9XG4gICAgdW5zdWJzY3JpYmUoKSB7XG4gICAgICAgIGlmICh0aGlzLm5hdlN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgdGhpcy5uYXZTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy52aWV3U3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLnZpZXdTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5TY3JvbGxTeW5jU2VydmljZSA9IF9fZGVjb3JhdGUoW1xuICAgIEluamVjdGFibGUoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0NhbGVuZGFyRE9NU2VydmljZSwgTmdab25lXSlcbl0sIFNjcm9sbFN5bmNTZXJ2aWNlKTtcblxuLyoqXG4gKiBVc2VkIGZvciByZW5kZXJpbmcgdGhlIGNlbGwgY29udGVudCBvZiB0aGUgQ2FsZW5kYXIuIFRvIGRlZmluZSB0aGUgY2VsbCB0ZW1wbGF0ZSwgbmVzdCBhbiBgPG5nLXRlbXBsYXRlPmAgdGFnXG4gKiB3aXRoIHRoZSBga2VuZG9DYWxlbmRhckNlbGxUZW1wbGF0ZWAgZGlyZWN0aXZlIGluc2lkZSB0aGUgY29tcG9uZW50IHRhZy4gVGhlIHRlbXBsYXRlIGNvbnRleHQgaXMgc2V0IHRvIHRoZVxuICogY3VycmVudCBjb21wb25lbnQuIFRvIGdldCBhIHJlZmVyZW5jZSB0byB0aGUgY3VycmVudCBkYXRlLCB1c2UgdGhlIGBsZXQtZGF0ZWAgZGlyZWN0aXZlLiBUbyBwcm92aWRlIG1vcmUgZGV0YWlsc1xuICogYWJvdXQgdGhlIGN1cnJlbnQgY2VsbCwgZ2V0IGEgcmVmZXJlbmNlIHRvIHRoZSBjdXJyZW50IGBjZWxsQ29udGV4dGAgYnkgdXNpbmcgdGhlIGBsZXQtY2VsbENvbnRleHRgIGRpcmVjdGl2ZS5cbiAqXG4gKiBGb3IgbW9yZSBleGFtcGxlcywgcmVmZXIgdG8gdGhlIGFydGljbGUgb24gW3RlbXBsYXRlc10oeyUgc2x1ZyB0ZW1wbGF0ZXNfY2FsZW5kYXIgJX0pLlxuICpcbiAqID4gYGtlbmRvQ2FsZW5kYXJDZWxsVGVtcGxhdGVgIGlzIGVxdWl2YWxlbnQgdG9cbiAqID4gW2BrZW5kb0NhbGVuZGFyTW9udGhDZWxsVGVtcGxhdGVgXSh7JSBzbHVnIGFwaV9kYXRlaW5wdXRzX21vbnRoY2VsbHRlbXBsYXRlZGlyZWN0aXZlICV9KS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIF9AQ29tcG9uZW50KHtcbiAqIHNlbGVjdG9yOiAnbXktYXBwJyxcbiAqIHN0eWxlczogWycuY3VzdG9tIHsgY29sb3I6IHJlZDsgfSddLFxuICogdGVtcGxhdGU6IGBcbiAqICA8a2VuZG8tY2FsZW5kYXI+XG4gKiAgICA8bmctdGVtcGxhdGUga2VuZG9DYWxlbmRhckNlbGxUZW1wbGF0ZSBsZXQtZGF0ZT5cbiAqICAgICAgPHNwYW4gY2xhc3M9XCJjdXN0b21cIj57e2RhdGUuZ2V0RGF0ZSgpfX08L3NwYW4+XG4gKiAgICA8L25nLXRlbXBsYXRlPlxuICogIDwva2VuZG8tY2FsZW5kYXI+XG4gKiBgXG4gKiB9KVxuICogZXhwb3J0IGNsYXNzIEFwcENvbXBvbmVudCB7IH1cbiAqIGBgYFxuICovXG5sZXQgQ2VsbFRlbXBsYXRlRGlyZWN0aXZlID0gY2xhc3MgQ2VsbFRlbXBsYXRlRGlyZWN0aXZlIHtcbiAgICBjb25zdHJ1Y3Rvcih0ZW1wbGF0ZVJlZikge1xuICAgICAgICB0aGlzLnRlbXBsYXRlUmVmID0gdGVtcGxhdGVSZWY7XG4gICAgfVxufTtcbkNlbGxUZW1wbGF0ZURpcmVjdGl2ZSA9IF9fZGVjb3JhdGUoW1xuICAgIERpcmVjdGl2ZSh7XG4gICAgICAgIHNlbGVjdG9yOiAnW2tlbmRvQ2FsZW5kYXJDZWxsVGVtcGxhdGVdJ1xuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbVGVtcGxhdGVSZWZdKVxuXSwgQ2VsbFRlbXBsYXRlRGlyZWN0aXZlKTtcblxuLyoqXG4gKiBVc2VkIGZvciByZW5kZXJpbmcgdGhlIG1vbnRoIGNlbGwgY29udGVudCBvZiB0aGUgQ2FsZW5kYXIuIFRvIGRlZmluZSB0aGUgbW9udGggY2VsbCB0ZW1wbGF0ZSwgbmVzdCBhbiBgPG5nLXRlbXBsYXRlPmAgdGFnXG4gKiB3aXRoIHRoZSBga2VuZG9DYWxlbmRhck1vbnRoQ2VsbFRlbXBsYXRlYCBkaXJlY3RpdmUgaW5zaWRlIHRoZSBjb21wb25lbnQgdGFnLiBUaGUgdGVtcGxhdGUgY29udGV4dCBpcyBzZXQgdG8gdGhlIGN1cnJlbnRcbiAqIGNvbXBvbmVudC4gVG8gZ2V0IGEgcmVmZXJlbmNlIHRvIHRoZSBjdXJyZW50IGRhdGUsIHVzZSB0aGUgYGxldC1kYXRlYCBkaXJlY3RpdmUuIFRvIHByb3ZpZGUgbW9yZSBkZXRhaWxzIGFib3V0IHRoZSBjdXJyZW50XG4gKiBtb250aCBjZWxsLCBnZXQgYSByZWZlcmVuY2UgdG8gdGhlIGN1cnJlbnQgYGNlbGxDb250ZXh0YCBieSB1c2luZyB0aGUgYGxldC1jZWxsQ29udGV4dGAgZGlyZWN0aXZlLlxuICpcbiAqIEZvciBtb3JlIGV4YW1wbGVzLCByZWZlciB0byB0aGUgYXJ0aWNsZSBvbiBbdGVtcGxhdGVzXSh7JSBzbHVnIHRlbXBsYXRlc19jYWxlbmRhciAlfSkuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBfQENvbXBvbmVudCh7XG4gKiBzZWxlY3RvcjogJ215LWFwcCcsXG4gKiBzdHlsZXM6IFsnLmN1c3RvbSB7IGNvbG9yOiByZWQ7IH0nXSxcbiAqIHRlbXBsYXRlOiBgXG4gKiAgPGtlbmRvLWNhbGVuZGFyPlxuICogICAgPG5nLXRlbXBsYXRlIGtlbmRvQ2FsZW5kYXJNb250aENlbGxUZW1wbGF0ZSBsZXQtY29udGV4dD1cImNlbGxDb250ZXh0XCI+XG4gKiAgICAgIDxzcGFuIGNsYXNzPVwiY3VzdG9tXCI+e3tjb250ZXh0LmZvcm1hdHRlZFZhbHVlfX08L3NwYW4+XG4gKiAgICA8L25nLXRlbXBsYXRlPlxuICogIDwva2VuZG8tY2FsZW5kYXI+XG4gKiBgXG4gKiB9KVxuICogZXhwb3J0IGNsYXNzIEFwcENvbXBvbmVudCB7IH1cbiAqIGBgYFxuICovXG5sZXQgTW9udGhDZWxsVGVtcGxhdGVEaXJlY3RpdmUgPSBjbGFzcyBNb250aENlbGxUZW1wbGF0ZURpcmVjdGl2ZSB7XG4gICAgY29uc3RydWN0b3IodGVtcGxhdGVSZWYpIHtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZVJlZiA9IHRlbXBsYXRlUmVmO1xuICAgIH1cbn07XG5Nb250aENlbGxUZW1wbGF0ZURpcmVjdGl2ZSA9IF9fZGVjb3JhdGUoW1xuICAgIERpcmVjdGl2ZSh7XG4gICAgICAgIHNlbGVjdG9yOiAnW2tlbmRvQ2FsZW5kYXJNb250aENlbGxUZW1wbGF0ZV0nXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtUZW1wbGF0ZVJlZl0pXG5dLCBNb250aENlbGxUZW1wbGF0ZURpcmVjdGl2ZSk7XG5cbi8qKlxuICogVXNlZCBmb3IgcmVuZGVyaW5nIHRoZSB5ZWFyIGNlbGwgY29udGVudCBvZiB0aGUgQ2FsZW5kYXIuIFRvIGRlZmluZSB0aGUgeWVhciBjZWxsIHRlbXBsYXRlLCBuZXN0IGFuXG4gKiBgPG5nLXRlbXBsYXRlPmAgdGFnIHdpdGggdGhlIGBrZW5kb0NhbGVuZGFyWWVhckNlbGxUZW1wbGF0ZWAgZGlyZWN0aXZlIGluc2lkZSB0aGUgY29tcG9uZW50IHRhZy5cbiAqIFRoZSB0ZW1wbGF0ZSBjb250ZXh0IGlzIHNldCB0byB0aGUgY3VycmVudCBjb21wb25lbnQuIFRvIGdldCBhIHJlZmVyZW5jZSB0byB0aGUgY3VycmVudCBkYXRlLCB1c2VcbiAqIHRoZSBgbGV0LWRhdGVgIGRpcmVjdGl2ZS4gVG8gcHJvdmlkZSBtb3JlIGRldGFpbHMgYWJvdXQgdGhlIGN1cnJlbnQgeWVhciBjZWxsLCBnZXQgYSByZWZlcmVuY2UgdG8gdGhlXG4gKiBjdXJyZW50IGBjZWxsQ29udGV4dGAgYnkgdXNpbmcgdGhlIGBsZXQtY2VsbENvbnRleHRgIGRpcmVjdGl2ZS5cbiAqXG4gKiBGb3IgbW9yZSBleGFtcGxlcywgcmVmZXIgdG8gdGhlIGFydGljbGUgb24gW3RlbXBsYXRlc10oeyUgc2x1ZyB0ZW1wbGF0ZXNfY2FsZW5kYXIgJX0pLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogX0BDb21wb25lbnQoe1xuICogc2VsZWN0b3I6ICdteS1hcHAnLFxuICogc3R5bGVzOiBbJy5jdXN0b20geyBjb2xvcjogcmVkOyB9J10sXG4gKiB0ZW1wbGF0ZTogYFxuICogIDxrZW5kby1jYWxlbmRhciBbYWN0aXZlVmlld109XCJhY3RpdmVWaWV3XCI+XG4gKiAgICA8bmctdGVtcGxhdGUga2VuZG9DYWxlbmRhclllYXJDZWxsVGVtcGxhdGUgbGV0LWNvbnRleHQ9XCJjZWxsQ29udGV4dFwiPlxuICogICAgICA8c3BhbiBjbGFzcz1cImN1c3RvbVwiPnt7Y29udGV4dC5mb3JtYXR0ZWRWYWx1ZX19PC9zcGFuPlxuICogICAgPC9uZy10ZW1wbGF0ZT5cbiAqICA8L2tlbmRvLWNhbGVuZGFyPlxuICogYFxuICogfSlcbiAqIGV4cG9ydCBjbGFzcyBBcHBDb21wb25lbnQge1xuICogIHB1YmxpYyBhY3RpdmVWaWV3OiBDYWxlbmRhclZpZXcgPSAneWVhcic7XG4gKiB9XG4gKiBgYGBcbiAqL1xubGV0IFllYXJDZWxsVGVtcGxhdGVEaXJlY3RpdmUgPSBjbGFzcyBZZWFyQ2VsbFRlbXBsYXRlRGlyZWN0aXZlIHtcbiAgICBjb25zdHJ1Y3Rvcih0ZW1wbGF0ZVJlZikge1xuICAgICAgICB0aGlzLnRlbXBsYXRlUmVmID0gdGVtcGxhdGVSZWY7XG4gICAgfVxufTtcblllYXJDZWxsVGVtcGxhdGVEaXJlY3RpdmUgPSBfX2RlY29yYXRlKFtcbiAgICBEaXJlY3RpdmUoe1xuICAgICAgICBzZWxlY3RvcjogJ1trZW5kb0NhbGVuZGFyWWVhckNlbGxUZW1wbGF0ZV0nXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtUZW1wbGF0ZVJlZl0pXG5dLCBZZWFyQ2VsbFRlbXBsYXRlRGlyZWN0aXZlKTtcblxuLyoqXG4gKiBVc2VkIGZvciByZW5kZXJpbmcgdGhlIGRlY2FkZSBjZWxsIGNvbnRlbnQgb2YgdGhlIENhbGVuZGFyLiBUbyBkZWZpbmUgdGhlIGRlY2FkZSBjZWxsIHRlbXBsYXRlLCBuZXN0IGFuIGA8bmctdGVtcGxhdGU+YFxuICogdGFnIHdpdGggdGhlIGBrZW5kb0NhbGVuZGFyRGVjYWRlQ2VsbFRlbXBsYXRlYCBkaXJlY3RpdmUgaW5zaWRlIHRoZSBjb21wb25lbnQgdGFnLiBUaGUgdGVtcGxhdGUgY29udGV4dCBpcyBzZXQgdG8gdGhlXG4gKiBjdXJyZW50IGNvbXBvbmVudC4gVG8gZ2V0IGEgcmVmZXJlbmNlIHRvIHRoZSBjdXJyZW50IGRhdGUsIHVzZSB0aGUgYGxldC1kYXRlYCBkaXJlY3RpdmUuIFRvIHByb3ZpZGUgbW9yZSBkZXRhaWxzIGFib3V0XG4gKiB0aGUgY3VycmVudCBkZWNhZGUgY2VsbCwgZ2V0IGEgcmVmZXJlbmNlIHRvIHRoZSBjdXJyZW50IGBjZWxsQ29udGV4dGAgYnkgdXNpbmcgdGhlIGBsZXQtY2VsbENvbnRleHRgIGRpcmVjdGl2ZS5cbiAqXG4gKiBGb3IgbW9yZSBleGFtcGxlcywgcmVmZXIgdG8gdGhlIGFydGljbGUgb24gW3RlbXBsYXRlc10oeyUgc2x1ZyB0ZW1wbGF0ZXNfY2FsZW5kYXIgJX0pLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogX0BDb21wb25lbnQoe1xuICogc2VsZWN0b3I6ICdteS1hcHAnLFxuICogc3R5bGVzOiBbJy5jdXN0b20geyBjb2xvcjogcmVkOyB9J10sXG4gKiB0ZW1wbGF0ZTogYFxuICogIDxrZW5kby1jYWxlbmRhciBbYWN0aXZlVmlld109XCJhY3RpdmVWaWV3XCI+XG4gKiAgICA8bmctdGVtcGxhdGUga2VuZG9DYWxlbmRhckRlY2FkZUNlbGxUZW1wbGF0ZSBsZXQtY29udGV4dD1cImNlbGxDb250ZXh0XCI+XG4gKiAgICAgIDxzcGFuIGNsYXNzPVwiY3VzdG9tXCI+e3tjb250ZXh0LmZvcm1hdHRlZFZhbHVlfX08L3NwYW4+XG4gKiAgICA8L25nLXRlbXBsYXRlPlxuICogIDwva2VuZG8tY2FsZW5kYXI+XG4gKiBgXG4gKiB9KVxuICogZXhwb3J0IGNsYXNzIEFwcENvbXBvbmVudCB7XG4gKiAgcHVibGljIGFjdGl2ZVZpZXc6IENhbGVuZGFyVmlldyA9ICdkZWNhZGUnO1xuICogfVxuICogYGBgXG4gKi9cbmxldCBEZWNhZGVDZWxsVGVtcGxhdGVEaXJlY3RpdmUgPSBjbGFzcyBEZWNhZGVDZWxsVGVtcGxhdGVEaXJlY3RpdmUge1xuICAgIGNvbnN0cnVjdG9yKHRlbXBsYXRlUmVmKSB7XG4gICAgICAgIHRoaXMudGVtcGxhdGVSZWYgPSB0ZW1wbGF0ZVJlZjtcbiAgICB9XG59O1xuRGVjYWRlQ2VsbFRlbXBsYXRlRGlyZWN0aXZlID0gX19kZWNvcmF0ZShbXG4gICAgRGlyZWN0aXZlKHtcbiAgICAgICAgc2VsZWN0b3I6ICdba2VuZG9DYWxlbmRhckRlY2FkZUNlbGxUZW1wbGF0ZV0nXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtUZW1wbGF0ZVJlZl0pXG5dLCBEZWNhZGVDZWxsVGVtcGxhdGVEaXJlY3RpdmUpO1xuXG4vKipcbiAqIFVzZWQgZm9yIHJlbmRlcmluZyB0aGUgY2VudHVyeSBjZWxsIGNvbnRlbnQgb2YgdGhlIENhbGVuZGFyLiBUbyBkZWZpbmUgdGhlIGNlbnR1cnkgY2VsbCB0ZW1wbGF0ZSwgbmVzdCBhbiBgPG5nLXRlbXBsYXRlPmBcbiAqIHRhZyB3aXRoIHRoZSBga2VuZG9DYWxlbmRhckNlbnR1cnlDZWxsVGVtcGxhdGVgIGRpcmVjdGl2ZSBpbnNpZGUgdGhlIGNvbXBvbmVudCB0YWcuIFRoZSB0ZW1wbGF0ZSBjb250ZXh0IGlzIHNldCB0byB0aGVcbiAqIGN1cnJlbnQgY29tcG9uZW50LiBUbyBnZXQgYSByZWZlcmVuY2UgdG8gdGhlIGN1cnJlbnQgZGF0ZSwgdXNlIHRoZSBgbGV0LWRhdGVgIGRpcmVjdGl2ZS4gVG8gcHJvdmlkZSBtb3JlIGRldGFpbHMgYWJvdXRcbiAqIHRoZSBjdXJyZW50IGNlbnR1cnkgY2VsbCwgZ2V0IGEgcmVmZXJlbmNlIHRvIHRoZSBjdXJyZW50IGBjZWxsQ29udGV4dGAgYnkgdXNpbmcgdGhlIGBsZXQtY2VsbENvbnRleHRgIGRpcmVjdGl2ZS5cbiAqXG4gKiBGb3IgbW9yZSBleGFtcGxlcywgcmVmZXIgdG8gdGhlIGFydGljbGUgb24gW3RlbXBsYXRlc10oeyUgc2x1ZyB0ZW1wbGF0ZXNfY2FsZW5kYXIgJX0pLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogX0BDb21wb25lbnQoe1xuICogc2VsZWN0b3I6ICdteS1hcHAnLFxuICogc3R5bGVzOiBbJy5jdXN0b20geyBjb2xvcjogcmVkOyB9J10sXG4gKiB0ZW1wbGF0ZTogYFxuICogIDxrZW5kby1jYWxlbmRhciBbYWN0aXZlVmlld109XCJhY3RpdmVWaWV3XCI+XG4gKiAgICA8bmctdGVtcGxhdGUga2VuZG9DYWxlbmRhckNlbnR1cnlDZWxsVGVtcGxhdGUgbGV0LWNvbnRleHQ9XCJjZWxsQ29udGV4dFwiPlxuICogICAgICA8c3BhbiBjbGFzcz1cImN1c3RvbVwiPnt7Y29udGV4dC5mb3JtYXR0ZWRWYWx1ZX19PC9zcGFuPlxuICogICAgPC9uZy10ZW1wbGF0ZT5cbiAqICA8L2tlbmRvLWNhbGVuZGFyPlxuICogYFxuICogfSlcbiAqIGV4cG9ydCBjbGFzcyBBcHBDb21wb25lbnQge1xuICogIHB1YmxpYyBhY3RpdmVWaWV3OiBDYWxlbmRhclZpZXcgPSAnY2VudHVyeSc7XG4gKiB9XG4gKiBgYGBcbiAqL1xubGV0IENlbnR1cnlDZWxsVGVtcGxhdGVEaXJlY3RpdmUgPSBjbGFzcyBDZW50dXJ5Q2VsbFRlbXBsYXRlRGlyZWN0aXZlIHtcbiAgICBjb25zdHJ1Y3Rvcih0ZW1wbGF0ZVJlZikge1xuICAgICAgICB0aGlzLnRlbXBsYXRlUmVmID0gdGVtcGxhdGVSZWY7XG4gICAgfVxufTtcbkNlbnR1cnlDZWxsVGVtcGxhdGVEaXJlY3RpdmUgPSBfX2RlY29yYXRlKFtcbiAgICBEaXJlY3RpdmUoe1xuICAgICAgICBzZWxlY3RvcjogJ1trZW5kb0NhbGVuZGFyQ2VudHVyeUNlbGxUZW1wbGF0ZV0nXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtUZW1wbGF0ZVJlZl0pXG5dLCBDZW50dXJ5Q2VsbFRlbXBsYXRlRGlyZWN0aXZlKTtcblxuLyoqXG4gKiBVc2VkIGZvciByZW5kZXJpbmcgdGhlIHdlZWsgbnVtYmVyIGNlbGwgY29udGVudCBpbiB0aGUgbW9udGggdmlldyBvZiB0aGUgQ2FsZW5kYXIuIFRvIGRlZmluZSB0aGUgbW9udGggd2VlayBudW1iZXIgY2VsbCB0ZW1wbGF0ZSxcbiAqIG5lc3QgYW4gYDxuZy10ZW1wbGF0ZT5gIHRhZyB3aXRoIHRoZSBga2VuZG9DYWxlbmRhcldlZWtOdW1iZXJDZWxsVGVtcGxhdGVgIGRpcmVjdGl2ZSBpbnNpZGUgdGhlIGNvbXBvbmVudCB0YWcuIFRoZSB0ZW1wbGF0ZVxuICogY29udGV4dCBpcyBzZXQgdG8gdGhlIGN1cnJlbnQgY29tcG9uZW50LiBUbyBnZXQgYSByZWZlcmVuY2UgdG8gdGhlIGN1cnJlbnQgZGF0ZSwgdXNlIHRoZSBgbGV0LWRhdGVgIGRpcmVjdGl2ZS4gVG8gcHJvdmlkZSBtb3JlXG4gKiBkZXRhaWxzIGFib3V0IHRoZSBjdXJyZW50IHdlZWsgbnVtYmVyIGNlbGwsIGdldCBhIHJlZmVyZW5jZSB0byB0aGUgY3VycmVudCBgY2VsbENvbnRleHRgIGJ5IHVzaW5nIHRoZSBgbGV0LWNlbGxDb250ZXh0YCBkaXJlY3RpdmUuXG4gKlxuICogRm9yIG1vcmUgZXhhbXBsZXMsIHJlZmVyIHRvIHRoZSBhcnRpY2xlIG9uIFt0ZW1wbGF0ZXNdKHslIHNsdWcgdGVtcGxhdGVzX2NhbGVuZGFyICV9KS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIF9AQ29tcG9uZW50KHtcbiAqIHNlbGVjdG9yOiAnbXktYXBwJyxcbiAqIHN0eWxlczogWycuY3VzdG9tIHsgY29sb3I6IHJlZDsgfSddLFxuICogdGVtcGxhdGU6IGBcbiAqICA8a2VuZG8tY2FsZW5kYXIgW3dlZWtOdW1iZXJdPVwidHJ1ZVwiPlxuICogICAgPG5nLXRlbXBsYXRlIGtlbmRvQ2FsZW5kYXJXZWVrTnVtYmVyQ2VsbFRlbXBsYXRlIGxldC1jb250ZXh0PVwiY2VsbENvbnRleHRcIj5cbiAqICAgICAgPHNwYW4gY2xhc3M9XCJjdXN0b21cIj57e2NvbnRleHQuZm9ybWF0dGVkVmFsdWV9fTwvc3Bhbj5cbiAqICAgIDwvbmctdGVtcGxhdGU+XG4gKiAgPC9rZW5kby1jYWxlbmRhcj5cbiAqIGBcbiAqIH0pXG4gKiBleHBvcnQgY2xhc3MgQXBwQ29tcG9uZW50IHsgfVxuICogYGBgXG4gKi9cbmxldCBXZWVrTnVtYmVyQ2VsbFRlbXBsYXRlRGlyZWN0aXZlID0gY2xhc3MgV2Vla051bWJlckNlbGxUZW1wbGF0ZURpcmVjdGl2ZSB7XG4gICAgY29uc3RydWN0b3IodGVtcGxhdGVSZWYpIHtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZVJlZiA9IHRlbXBsYXRlUmVmO1xuICAgIH1cbn07XG5XZWVrTnVtYmVyQ2VsbFRlbXBsYXRlRGlyZWN0aXZlID0gX19kZWNvcmF0ZShbXG4gICAgRGlyZWN0aXZlKHtcbiAgICAgICAgc2VsZWN0b3I6ICdba2VuZG9DYWxlbmRhcldlZWtOdW1iZXJDZWxsVGVtcGxhdGVdJ1xuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbVGVtcGxhdGVSZWZdKVxuXSwgV2Vla051bWJlckNlbGxUZW1wbGF0ZURpcmVjdGl2ZSk7XG5cbi8qKlxuICogVXNlZCBmb3IgcmVuZGVyaW5nIHRoZSBoZWFkZXIgdGl0bGUgb2YgdGhlIENhbGVuZGFyLiBUbyBkZWZpbmUgdGhlIGhlYWRlciB0aXRsZSB0ZW1wbGF0ZSwgbmVzdCBhbiBgPG5nLXRlbXBsYXRlPmAgdGFnXG4gKiB3aXRoIHRoZSBga2VuZG9DYWxlbmRhckhlYWRlclRpdGxlVGVtcGxhdGVgIGRpcmVjdGl2ZSBpbnNpZGUgdGhlIGNvbXBvbmVudCB0YWcuIFRoZSB0ZW1wbGF0ZSBjb250ZXh0IGlzIHNldCB0byB0aGVcbiAqIGN1cnJlbnQgY29tcG9uZW50LiBUbyBnZXQgYSByZWZlcmVuY2UgdG8gdGhlIGN1cnJlbnQgdGl0bGUsIHVzZSB0aGUgYGxldC10aXRsZWAgZGlyZWN0aXZlLiBUbyBwcm92aWRlIG1vcmUgZGV0YWlscyBhYm91dFxuICogdGhlIGN1cnJlbnQgdGl0bGUsIGdldCBhIHJlZmVyZW5jZSB0byB0aGUgY3VycmVudCBgZGF0ZWAgYnkgdXNpbmcgdGhlIGBsZXQtZGF0ZWAgZGlyZWN0aXZlIG9yIGdldCBhIHJlZmVyZW5jZSB0byB0aGVcbiAqIGN1cnJlbnQgYWN0aXZlIHZpZXcgIGJ5IHVzaW5nIHRoZSBgbGV0LWFjdGl2ZVZpZXdgIGRpcmVjdGl2ZS5cbiAqXG4gKiBGb3IgbW9yZSBleGFtcGxlcywgcmVmZXIgdG8gdGhlIGFydGljbGUgb24gW3RlbXBsYXRlc10oeyUgc2x1ZyB0ZW1wbGF0ZXNfY2FsZW5kYXIgJX0pLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogX0BDb21wb25lbnQoe1xuICogc2VsZWN0b3I6ICdteS1hcHAnLFxuICogc3R5bGVzOiBbJy5jdXN0b20geyBjb2xvcjogcmVkOyB9J10sXG4gKiB0ZW1wbGF0ZTogYFxuICogIDxrZW5kby1jYWxlbmRhcj5cbiAqICAgIDxuZy10ZW1wbGF0ZSBrZW5kb0NhbGVuZGFySGVhZGVyVGl0bGVUZW1wbGF0ZSBsZXQtdGl0bGU+XG4gKiAgICAgIDxzcGFuIGNsYXNzPVwiY3VzdG9tXCI+e3t0aXRsZX19PC9zcGFuPlxuICogICAgPC9uZy10ZW1wbGF0ZT5cbiAqICA8L2tlbmRvLWNhbGVuZGFyPlxuICogYFxuICogfSlcbiAqIGV4cG9ydCBjbGFzcyBBcHBDb21wb25lbnQgeyB9XG4gKiBgYGBcbiAqL1xubGV0IEhlYWRlclRpdGxlVGVtcGxhdGVEaXJlY3RpdmUgPSBjbGFzcyBIZWFkZXJUaXRsZVRlbXBsYXRlRGlyZWN0aXZlIHtcbiAgICBjb25zdHJ1Y3Rvcih0ZW1wbGF0ZVJlZikge1xuICAgICAgICB0aGlzLnRlbXBsYXRlUmVmID0gdGVtcGxhdGVSZWY7XG4gICAgfVxufTtcbkhlYWRlclRpdGxlVGVtcGxhdGVEaXJlY3RpdmUgPSBfX2RlY29yYXRlKFtcbiAgICBEaXJlY3RpdmUoe1xuICAgICAgICBzZWxlY3RvcjogJ1trZW5kb0NhbGVuZGFySGVhZGVyVGl0bGVUZW1wbGF0ZV0nXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtUZW1wbGF0ZVJlZl0pXG5dLCBIZWFkZXJUaXRsZVRlbXBsYXRlRGlyZWN0aXZlKTtcblxuLyoqXG4gKiBVc2VkIGZvciByZW5kZXJpbmcgdGhlIG5hdmlnYXRpb24gaXRlbSBvZiB0aGUgQ2FsZW5kYXIuIFRvIGRlZmluZSB0aGUgbmF2aWdhdGlvbiBpdGVtIHRlbXBsYXRlLCBuZXN0IGFuIGA8bmctdGVtcGxhdGU+YFxuICogdGFnIHdpdGggdGhlIGBrZW5kb0NhbGVuZGFyTmF2aWdhdGlvbkl0ZW1UZW1wbGF0ZWAgZGlyZWN0aXZlIGluc2lkZSB0aGUgY29tcG9uZW50IHRhZy4gVGhlIHRlbXBsYXRlIGNvbnRleHQgaXMgc2V0IHRvIHRoZVxuICogY3VycmVudCBjb21wb25lbnQuIFRvIGdldCBhIHJlZmVyZW5jZSB0byB0aGUgY3VycmVudCBpdGVtIHZhbHVlLCB1c2UgdGhlIGBsZXQtdGl0bGVgIGRpcmVjdGl2ZS4gVG8gcHJvdmlkZSBtb3JlIGRldGFpbHNcbiAqIGFib3V0IHRoZSBjdXJyZW50IHRpdGxlLCBnZXQgYSByZWZlcmVuY2UgdG8gdGhlIGN1cnJlbnQgYGRhdGVgIGJ5IHVzaW5nIHRoZSBgbGV0LWRhdGU9J2RhdGUnYCBkaXJlY3RpdmUgb3IgZ2V0IGEgcmVmZXJlbmNlXG4gKiB0byB0aGUgY3VycmVudCBhY3RpdmUgdmlldyBieSB1c2luZyB0aGUgYGxldC1hY3RpdmVWaWV3PSdhY3RpdmVWaWV3J2AgZGlyZWN0aXZlLlxuICpcbiAqIEZvciBtb3JlIGV4YW1wbGVzLCByZWZlciB0byB0aGUgYXJ0aWNsZSBvbiBbdGVtcGxhdGVzXSh7JSBzbHVnIHRlbXBsYXRlc19jYWxlbmRhciAlfSkuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBfQENvbXBvbmVudCh7XG4gKiBzZWxlY3RvcjogJ215LWFwcCcsXG4gKiBzdHlsZXM6IFsnLmN1c3RvbSB7IGNvbG9yOiByZWQ7IH0nXSxcbiAqIHRlbXBsYXRlOiBgXG4gKiAgPGtlbmRvLWNhbGVuZGFyPlxuICogICAgPG5nLXRlbXBsYXRlIGtlbmRvQ2FsZW5kYXJOYXZpZ2F0aW9uSXRlbVRlbXBsYXRlIGxldC10aXRsZT5cbiAqICAgICAgPHNwYW4gY2xhc3M9XCJjdXN0b21cIj57e3RpdGxlfX08L3NwYW4+XG4gKiAgICA8L25nLXRlbXBsYXRlPlxuICogIDwva2VuZG8tY2FsZW5kYXI+XG4gKiBgXG4gKiB9KVxuICogZXhwb3J0IGNsYXNzIEFwcENvbXBvbmVudCB7IH1cbiAqIGBgYFxuICovXG5sZXQgTmF2aWdhdGlvbkl0ZW1UZW1wbGF0ZURpcmVjdGl2ZSA9IGNsYXNzIE5hdmlnYXRpb25JdGVtVGVtcGxhdGVEaXJlY3RpdmUge1xuICAgIGNvbnN0cnVjdG9yKHRlbXBsYXRlUmVmKSB7XG4gICAgICAgIHRoaXMudGVtcGxhdGVSZWYgPSB0ZW1wbGF0ZVJlZjtcbiAgICB9XG59O1xuTmF2aWdhdGlvbkl0ZW1UZW1wbGF0ZURpcmVjdGl2ZSA9IF9fZGVjb3JhdGUoW1xuICAgIERpcmVjdGl2ZSh7XG4gICAgICAgIHNlbGVjdG9yOiAnW2tlbmRvQ2FsZW5kYXJOYXZpZ2F0aW9uSXRlbVRlbXBsYXRlXSdcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW1RlbXBsYXRlUmVmXSlcbl0sIE5hdmlnYXRpb25JdGVtVGVtcGxhdGVEaXJlY3RpdmUpO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgUGlja2VyU2VydmljZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMub25Gb2N1cyA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5vbkJsdXIgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuc2FtZURhdGVTZWxlY3RlZCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5kYXRlQ29tcGxldGVuZXNzQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IG1pblZhbGlkYXRvciA9IChtaW5WYWx1ZSkgPT4ge1xuICAgIHJldHVybiAoY29udHJvbCkgPT4ge1xuICAgICAgICBjb25zdCBlcnIgPSB7XG4gICAgICAgICAgICBtaW5FcnJvcjoge1xuICAgICAgICAgICAgICAgIG1pblZhbHVlOiBtaW5WYWx1ZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogY29udHJvbC52YWx1ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBpZiAoIW1pblZhbHVlIHx8ICFjb250cm9sLnZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29udHJvbC52YWx1ZSA8IG1pblZhbHVlID8gZXJyIDogbnVsbDtcbiAgICB9O1xufTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IG1heFZhbGlkYXRvciA9IChtYXhWYWx1ZSkgPT4ge1xuICAgIHJldHVybiAoY29udHJvbCkgPT4ge1xuICAgICAgICBjb25zdCBlcnIgPSB7XG4gICAgICAgICAgICBtYXhFcnJvcjoge1xuICAgICAgICAgICAgICAgIG1heFZhbHVlOiBtYXhWYWx1ZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogY29udHJvbC52YWx1ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBpZiAoIW1heFZhbHVlIHx8ICFjb250cm9sLnZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29udHJvbC52YWx1ZSA+IG1heFZhbHVlID8gZXJyIDogbnVsbDtcbiAgICB9O1xufTtcblxuY29uc3QgQk9UVE9NX1ZJRVdfRE9DX0xJTksgPSAnaHR0cDovL3d3dy50ZWxlcmlrLmNvbS9rZW5kby1hbmd1bGFyLXVpL2NvbXBvbmVudHMvZGF0ZWlucHV0cy9hcGkvQ2FsZW5kYXJDb21wb25lbnQvI3RvYy1ib3R0b212aWV3JztcbmNvbnN0IFRPUF9WSUVXX0RPQ19MSU5LID0gJ2h0dHA6Ly93d3cudGVsZXJpay5jb20va2VuZG8tYW5ndWxhci11aS9jb21wb25lbnRzL2RhdGVpbnB1dHMvYXBpL0NhbGVuZGFyQ29tcG9uZW50LyN0b2MtdG9wdmlldyc7XG5jb25zdCBNSU5fRE9DX0xJTksgPSAnaHR0cDovL3d3dy50ZWxlcmlrLmNvbS9rZW5kby1hbmd1bGFyLXVpL2NvbXBvbmVudHMvZGF0ZWlucHV0cy9hcGkvQ2FsZW5kYXJDb21wb25lbnQvI3RvYy1taW4nO1xuY29uc3QgTUFYX0RPQ19MSU5LID0gJ2h0dHA6Ly93d3cudGVsZXJpay5jb20va2VuZG8tYW5ndWxhci11aS9jb21wb25lbnRzL2RhdGVpbnB1dHMvYXBpL0NhbGVuZGFyQ29tcG9uZW50LyN0b2MtbWF4JztcbmNvbnN0IFZBTFVFX0RPQ19MSU5LID0gJ2h0dHA6Ly93d3cudGVsZXJpay5jb20va2VuZG8tYW5ndWxhci11aS9jb21wb25lbnRzL2RhdGVpbnB1dHMvY2FsZW5kYXIvI3RvYy11c2luZy13aXRoLWpzb24nO1xuY29uc3QgdmlydHVhbGl6YXRpb25Qcm9wID0geCA9PiB4ID8geC52aXJ0dWFsaXphdGlvbiA6IG51bGw7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgQ0FMRU5EQVJfVkFMVUVfQUNDRVNTT1IgPSB7XG4gICAgbXVsdGk6IHRydWUsXG4gICAgcHJvdmlkZTogTkdfVkFMVUVfQUNDRVNTT1IsXG4gICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gQ2FsZW5kYXJDb21wb25lbnQpIC8vdHNsaW50OmRpc2FibGUtbGluZTpuby11c2UtYmVmb3JlLWRlY2xhcmVcbn07XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgQ0FMRU5EQVJfUkFOR0VfVkFMSURBVE9SUyA9IHtcbiAgICBtdWx0aTogdHJ1ZSxcbiAgICBwcm92aWRlOiBOR19WQUxJREFUT1JTLFxuICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IENhbGVuZGFyQ29tcG9uZW50KSAvL3RzbGludDpkaXNhYmxlLWxpbmU6bm8tdXNlLWJlZm9yZS1kZWNsYXJlXG59O1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IEtFTkRPX0lOUFVUX1BST1ZJREVSID0ge1xuICAgIHByb3ZpZGU6IEtlbmRvSW5wdXQsXG4gICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gQ2FsZW5kYXJDb21wb25lbnQpIC8vdHNsaW50OmRpc2FibGUtbGluZTpuby11c2UtYmVmb3JlLWRlY2xhcmVcbn07XG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIFtLZW5kbyBVSSBDYWxlbmRhciBjb21wb25lbnQgZm9yIEFuZ3VsYXJdKHslIHNsdWcgb3ZlcnZpZXdfY2FsZW5kYXIgJX0jdG9jLWJhc2ljLXVzYWdlKS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIF9AQ29tcG9uZW50KHtcbiAqIHNlbGVjdG9yOiAnbXktYXBwJyxcbiAqIHRlbXBsYXRlOiBgXG4gKiAgPGtlbmRvLWNhbGVuZGFyPjwva2VuZG8tY2FsZW5kYXI+XG4gKiBgXG4gKiB9KVxuICogZXhwb3J0IGNsYXNzIEFwcENvbXBvbmVudCB7IH1cbiAqIGBgYFxuICovXG5sZXQgQ2FsZW5kYXJDb21wb25lbnQgPSBjbGFzcyBDYWxlbmRhckNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoYnVzLCBkb20sIGVsZW1lbnQsIG5hdmlnYXRvciwgcmVuZGVyZXIsIGNkciwgbmdab25lLCBpbmplY3Rvciwgc2Nyb2xsU3luY1NlcnZpY2UsIGRpc2FibGVkRGF0ZXNTZXJ2aWNlLCBsb2NhbGl6YXRpb24sIHNlbGVjdGlvblNlcnZpY2UsIHBpY2tlclNlcnZpY2UpIHtcbiAgICAgICAgdGhpcy5idXMgPSBidXM7XG4gICAgICAgIHRoaXMuZG9tID0gZG9tO1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICB0aGlzLm5hdmlnYXRvciA9IG5hdmlnYXRvcjtcbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgICAgICB0aGlzLmNkciA9IGNkcjtcbiAgICAgICAgdGhpcy5uZ1pvbmUgPSBuZ1pvbmU7XG4gICAgICAgIHRoaXMuaW5qZWN0b3IgPSBpbmplY3RvcjtcbiAgICAgICAgdGhpcy5zY3JvbGxTeW5jU2VydmljZSA9IHNjcm9sbFN5bmNTZXJ2aWNlO1xuICAgICAgICB0aGlzLmRpc2FibGVkRGF0ZXNTZXJ2aWNlID0gZGlzYWJsZWREYXRlc1NlcnZpY2U7XG4gICAgICAgIHRoaXMubG9jYWxpemF0aW9uID0gbG9jYWxpemF0aW9uO1xuICAgICAgICB0aGlzLnNlbGVjdGlvblNlcnZpY2UgPSBzZWxlY3Rpb25TZXJ2aWNlO1xuICAgICAgICB0aGlzLnBpY2tlclNlcnZpY2UgPSBwaWNrZXJTZXJ2aWNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogQGhpZGRlblxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pZCA9IGd1aWQoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERldGVybWluZXMgd2hldGhlciB0aGUgYnVpbHQtaW4gbWluIG9yIG1heCB2YWxpZGF0b3JzIGFyZSBlbmZvcmNlZCB3aGVuIHZhbGlkYXRpbmcgYSBmb3JtLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yYW5nZVZhbGlkYXRpb24gPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgdGhlIENhbGVuZGFyIHNlbGVjdGlvbiBtb2RlXG4gICAgICAgICAqIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgbXVsdGlwbGVfc2VsZWN0aW9uX2NhbGVuZGFyICV9KSkuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSBhdmFpbGFibGUgdmFsdWVzIGFyZTpcbiAgICAgICAgICogKiBgc2luZ2xlYCAoZGVmYXVsdClcbiAgICAgICAgICogKiBgbXVsdGlwbGVgXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNlbGVjdGlvbiA9ICdzaW5nbGUnO1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0cyBvciBnZXRzIHRoZSBgZGlzYWJsZWRgIHByb3BlcnR5IG9mIHRoZSBDYWxlbmRhciBhbmRcbiAgICAgICAgICogZGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBjb21wb25lbnQgaXMgYWN0aXZlXG4gICAgICAgICAqIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgZGlzYWJsZWRfY2FsZW5kYXIgJX0pKS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgb3IgZ2V0cyB0aGUgYHRhYmluZGV4YCBwcm9wZXJ0eSBvZiB0aGUgQ2FsZW5kYXIuIEJhc2VkIG9uIHRoZVxuICAgICAgICAgKiBbSFRNTCBgdGFiaW5kZXhgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVE1ML0dsb2JhbF9hdHRyaWJ1dGVzL3RhYmluZGV4KSBiZWhhdmlvcixcbiAgICAgICAgICogaXQgZGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBjb21wb25lbnQgaXMgZm9jdXNhYmxlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50YWJpbmRleCA9IDA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXRzIG9yIGdldHMgdGhlIGBuYXZpZ2F0aW9uYCBwcm9wZXJ0eSBvZiB0aGUgQ2FsZW5kYXJcbiAgICAgICAgICogYW5kIGRldGVybWluZXMgd2hldGhlciB0aGUgbmF2aWdhdGlvbiBzaWRlLWJhciB3aWxsIGJlIGRpc3BsYXllZFxuICAgICAgICAgKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIHNpZGViYXJfY2FsZW5kYXIgJX0pKS5cbiAgICAgICAgICogQXBwbGllcyB0byB0aGUgW2BpbmZpbml0ZWBdKHslIHNsdWcgYXBpX2RhdGVpbnB1dHNfY2FsZW5kYXJjb21wb25lbnQgJX0jdG9jLXR5cGUpIENhbGVuZGFyIG9ubHkuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm5hdmlnYXRpb24gPSB0cnVlO1xuICAgICAgICAvKipcbiAgICAgICAgICogRGVmaW5lcyB0aGUgYWN0aXZlIHZpZXcgdGhhdCB0aGUgQ2FsZW5kYXIgaW5pdGlhbGx5IHJlbmRlcnNcbiAgICAgICAgICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBhY3RpdmV2aWV3X2NhbGVuZGFyICV9KSkuXG4gICAgICAgICAqIEJ5IGRlZmF1bHQsIHRoZSBhY3RpdmUgdmlldyBpcyBgbW9udGhgLlxuICAgICAgICAgKlxuICAgICAgICAgKiA+IFlvdSBoYXZlIHRvIHNldCBgYWN0aXZlVmlld2Agd2l0aGluIHRoZSBgdG9wVmlld2AtYGJvdHRvbVZpZXdgIHJhbmdlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hY3RpdmVWaWV3ID0gQ2FsZW5kYXJWaWV3RW51bVtDYWxlbmRhclZpZXdFbnVtLm1vbnRoXTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlZmluZXMgdGhlIGJvdHRvbW1vc3QgdmlldyB0byB3aGljaCB0aGUgdXNlciBjYW4gbmF2aWdhdGVcbiAgICAgICAgICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBkYXRlc19jYWxlbmRhciAlfSN0b2MtcGFydGlhbC1kYXRlcykpLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5ib3R0b21WaWV3ID0gQ2FsZW5kYXJWaWV3RW51bVtDYWxlbmRhclZpZXdFbnVtLm1vbnRoXTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlZmluZXMgdGhlIHRvcG1vc3QgdmlldyB0byB3aGljaCB0aGUgdXNlciBjYW4gbmF2aWdhdGVcbiAgICAgICAgICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBzaWRlYmFyX2NhbGVuZGFyICV9I3RvYy1wYXJ0aWFsLWRhdGVzKSkuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRvcFZpZXcgPSBDYWxlbmRhclZpZXdFbnVtW0NhbGVuZGFyVmlld0VudW0uY2VudHVyeV07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgdG8gZW5hYmxlIGFuaW1hdGlvbiB3aGVuIG5hdmlnYXRpbmcgdG8gcHJldmlvdXMvbmV4dCB2aWV3LlxuICAgICAgICAgKiBBcHBsaWVzIHRvIHRoZSBbYGNsYXNzaWNgXSh7JSBzbHVnIGFwaV9kYXRlaW5wdXRzX2NhbGVuZGFyY29tcG9uZW50ICV9I3RvYy10eXBlKSBDYWxlbmRhciBvbmx5LlxuICAgICAgICAgKlxuICAgICAgICAgKiA+IFRoaXMgZmVhdHVyZSB1c2VzIHRoZSBbV2ViIEFuaW1hdGlvbnMgQVBJXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvV2ViX0FuaW1hdGlvbnNfQVBJKS4gSW4gb3JkZXIgdG8gcnVuIHRoZSBhbmltYXRpb24gaW4gYnJvd3NlcnMgdGhhdCBkbyBub3Qgc3VwcG9ydCBpdCwgeW91IG5lZWQgdGhlIGB3ZWItYW5pbWF0aW9ucy1qc2AgcG9seWZpbGwuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmFuaW1hdGVOYXZpZ2F0aW9uID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgdG8gZGlzcGxheSBhIHdlZWsgbnVtYmVyIGNvbHVtbiBpbiB0aGUgYG1vbnRoYCB2aWV3XG4gICAgICAgICAqIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgd2Vla251bWNvbHVtbl9jYWxlbmRhciAlfSkpLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy53ZWVrTnVtYmVyID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyB3aGVuIHRoZSBhY3RpdmUgdmlldyBpcyBjaGFuZ2VkXG4gICAgICAgICAqIChbbW9yZSBpbmZvcm1hdGlvbiBhbmQgZXhhbXBsZV0oeyUgc2x1ZyBvdmVydmlld19jYWxlbmRhciAlfSN0b2MtZXZlbnRzKSkuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmFjdGl2ZVZpZXdDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyB3aGVuIHRoZSBhY3RpdmUgdmlldyBkYXRlIGlzIGNoYW5nZWRcbiAgICAgICAgICogKFttb3JlIGluZm9ybWF0aW9uIGFuZCBleGFtcGxlXSh7JSBzbHVnIG92ZXJ2aWV3X2NhbGVuZGFyICV9I3RvYy1ldmVudHMpKS5cbiAgICAgICAgICogQXBwbGllcyB0byB0aGUgW2BpbmZpbml0ZWBdKHslIHNsdWcgYXBpX2RhdGVpbnB1dHNfY2FsZW5kYXJjb21wb25lbnQgJX0jdG9jLXR5cGUpIENhbGVuZGFyIG9ubHkuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmFjdGl2ZVZpZXdEYXRlQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgd2hlbiB0aGUgdmFsdWUgaXMgY2hhbmdlZFxuICAgICAgICAgKiAoW21vcmUgaW5mb3JtYXRpb24gYW5kIGV4YW1wbGVdKHslIHNsdWcgb3ZlcnZpZXdfY2FsZW5kYXIgJX0jdG9jLWV2ZW50cykpLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy52YWx1ZUNoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5pc0FjdGl2ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNlbGxVSUQgPSBndWlkKCk7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWREYXRlcyA9IFtdO1xuICAgICAgICB0aGlzLl9taW4gPSBuZXcgRGF0ZShNSU5fREFURSk7XG4gICAgICAgIHRoaXMuX21heCA9IG5ldyBEYXRlKE1BWF9EQVRFKTtcbiAgICAgICAgdGhpcy5fZm9jdXNlZERhdGUgPSBnZXRUb2RheSgpO1xuICAgICAgICB0aGlzLm9uQ29udHJvbENoYW5nZSA9IG5vb3A7XG4gICAgICAgIHRoaXMub25Db250cm9sVG91Y2hlZCA9IG5vb3A7XG4gICAgICAgIHRoaXMub25WYWxpZGF0b3JDaGFuZ2UgPSBub29wO1xuICAgICAgICB0aGlzLm1pblZhbGlkYXRlRm4gPSBub29wO1xuICAgICAgICB0aGlzLm1heFZhbGlkYXRlRm4gPSBub29wO1xuICAgICAgICB0aGlzLnN5bmNOYXZpZ2F0aW9uID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fdHlwZSA9ICdpbmZpbml0ZSc7XG4gICAgICAgIHRoaXMuZG9tRXZlbnRzID0gW107XG4gICAgICAgIHRoaXMucmVzb2x2ZWRQcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKG51bGwpO1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgICAgICB2YWxpZGF0ZVBhY2thZ2UocGFja2FnZU1ldGFkYXRhKTtcbiAgICAgICAgdGhpcy5zZXRDbGFzc2VzKGVsZW1lbnQubmF0aXZlRWxlbWVudCk7XG4gICAgICAgIGlmICh0aGlzLnBpY2tlclNlcnZpY2UpIHtcbiAgICAgICAgICAgIHRoaXMucGlja2VyU2VydmljZS5jYWxlbmRhciA9IHRoaXM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBvciBnZXRzIHRoZSBgZm9jdXNlZERhdGVgIHByb3BlcnR5IG9mIHRoZSBDYWxlbmRhciBhbmRcbiAgICAgKiBkZWZpbmVzIHRoZSBmb2N1c2VkIGRhdGUgb2YgdGhlIGNvbXBvbmVudFxuICAgICAqIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgZGF0ZXNfY2FsZW5kYXIgJX0jdG9jLWZvY3VzZWQtZGF0ZXMpKS5cbiAgICAgKlxuICAgICAqID4gSWYgdGhlIENhbGVuZGFyIGlzIG91dCBvZiB0aGUgbWluIG9yIG1heCByYW5nZSwgaXQgbm9ybWFsaXplcyB0aGUgZGVmaW5lZCBgZm9jdXNlZERhdGVgLlxuICAgICAqL1xuICAgIHNldCBmb2N1c2VkRGF0ZShmb2N1c2VkRGF0ZSkge1xuICAgICAgICB0aGlzLl9mb2N1c2VkRGF0ZSA9IGZvY3VzZWREYXRlIHx8IGdldFRvZGF5KCk7XG4gICAgICAgIHRoaXMuc2V0QXJpYUFjdGl2ZWRlc2NlbmRhbnQoKTtcbiAgICB9XG4gICAgZ2V0IGZvY3VzZWREYXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZm9jdXNlZERhdGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgb3IgZ2V0cyB0aGUgYG1pbmAgcHJvcGVydHkgb2YgdGhlIENhbGVuZGFyIGFuZFxuICAgICAqIGRlZmluZXMgdGhlIG1pbmltdW0gYWxsb3dlZCBkYXRlIHZhbHVlXG4gICAgICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBkYXRlcmFuZ2VzX2NhbGVuZGFyICV9KSkuXG4gICAgICogQnkgZGVmYXVsdCwgdGhlIGBtaW5gIHZhbHVlIGlzIGAxOTAwLTEtMWAuXG4gICAgICovXG4gICAgc2V0IG1pbihtaW4pIHtcbiAgICAgICAgdGhpcy5fbWluID0gbWluIHx8IG5ldyBEYXRlKE1JTl9EQVRFKTtcbiAgICB9XG4gICAgZ2V0IG1pbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21pbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBvciBnZXRzIHRoZSBgbWF4YCBwcm9wZXJ0eSBvZiB0aGUgQ2FsZW5kYXIgYW5kXG4gICAgICogZGVmaW5lcyB0aGUgbWF4aW11bSBhbGxvd2VkIGRhdGUgdmFsdWVcbiAgICAgKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGRhdGVyYW5nZXNfY2FsZW5kYXIgJX0pKS5cbiAgICAgKiBCeSBkZWZhdWx0LCB0aGUgYG1heGAgdmFsdWUgaXMgYDIwOTktMTItMzFgLlxuICAgICAqL1xuICAgIHNldCBtYXgobWF4KSB7XG4gICAgICAgIHRoaXMuX21heCA9IG1heCB8fCBuZXcgRGF0ZShNQVhfREFURSk7XG4gICAgfVxuICAgIGdldCBtYXgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tYXg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgb3IgZ2V0cyB0aGUgYHZhbHVlYCBwcm9wZXJ0eSBvZiB0aGUgQ2FsZW5kYXIgYW5kIGRlZmluZXMgdGhlIHNlbGVjdGVkIHZhbHVlIG9mIHRoZSBjb21wb25lbnQuXG4gICAgICpcbiAgICAgKiA+IFRoZSBgdmFsdWVgIGhhcyB0byBiZSBhIHZhbGlkXG4gICAgICogW0phdmFTY3JpcHQgYERhdGVgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9EYXRlKVxuICAgICAqIGluc3RhbmNlIHdoZW4gaW4gYHNpbmdsZWAgc2VsZWN0aW9uIG1vZGUgb3IgYW4gYXJyYXkgb2YgdmFsaWQgSmF2YVNjcmlwdCBEYXRlIGluc3RhbmNlcyB3aGVuIGluIGBtdWx0aXBsZWAgc2VsZWN0aW9uIG1vZGUuXG4gICAgICovXG4gICAgZ2V0IHZhbHVlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmFsdWU7XG4gICAgfVxuICAgIHNldCB2YWx1ZShjYW5kaWRhdGUpIHtcbiAgICAgICAgdGhpcy52ZXJpZnlWYWx1ZShjYW5kaWRhdGUpO1xuICAgICAgICB0aGlzLl92YWx1ZSA9IEFycmF5LmlzQXJyYXkoY2FuZGlkYXRlKSA/XG4gICAgICAgICAgICBjYW5kaWRhdGUuZmlsdGVyKGRhdGUgPT4gaXNQcmVzZW50KGRhdGUpKS5tYXAoZWxlbWVudCA9PiBjbG9uZURhdGUoZWxlbWVudCkpIDpcbiAgICAgICAgICAgIGNsb25lRGF0ZShjYW5kaWRhdGUpO1xuICAgICAgICBjb25zdCBzZWxlY3Rpb24gPSBbXS5jb25jYXQoY2FuZGlkYXRlKS5maWx0ZXIoZGF0ZSA9PiBpc1ByZXNlbnQoZGF0ZSkpLm1hcChkYXRlID0+IGNsb25lRGF0ZShkYXRlKSk7XG4gICAgICAgIGlmICghYXJlRGF0ZXNFcXVhbChzZWxlY3Rpb24sIHRoaXMuc2VsZWN0ZWREYXRlcykpIHtcbiAgICAgICAgICAgIGNvbnN0IGxhc3RTZWxlY3RlZCA9IGxhc3Qoc2VsZWN0aW9uKTtcbiAgICAgICAgICAgIHRoaXMucmFuZ2VQaXZvdCA9IGNsb25lRGF0ZShsYXN0U2VsZWN0ZWQpO1xuICAgICAgICAgICAgdGhpcy5mb2N1c2VkRGF0ZSA9IGNsb25lRGF0ZShsYXN0U2VsZWN0ZWQpIHx8IHRoaXMuZm9jdXNlZERhdGU7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGVkRGF0ZXMgPSBzZWxlY3Rpb247XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHNldCB0YWJJbmRleCh0YWJJbmRleCkge1xuICAgICAgICB0aGlzLnRhYmluZGV4ID0gdGFiSW5kZXg7XG4gICAgfVxuICAgIGdldCB0YWJJbmRleCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGFiaW5kZXg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGRhdGVzIG9mIHRoZSBDYWxlbmRhciB0aGF0IHdpbGwgYmUgZGlzYWJsZWRcbiAgICAgKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGRpc2FibGVkX2RhdGVzX2NhbGVuZGFyICV9KSkuXG4gICAgICovXG4gICAgc2V0IGRpc2FibGVkRGF0ZXModmFsdWUpIHtcbiAgICAgICAgdGhpcy5kaXNhYmxlZERhdGVzU2VydmljZS5pbml0aWFsaXplKHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3BlY2lmaWVzIHRoZSBDYWxlbmRhciB0eXBlLlxuICAgICAqXG4gICAgICogVGhlIHBvc3NpYmxlIHZhbHVlcyBhcmU6XG4gICAgICogLSBgaW5maW5pdGVgIChkZWZhdWx0KVxuICAgICAqIC0gYGNsYXNzaWNgXG4gICAgICpcbiAgICAgKi9cbiAgICBzZXQgdHlwZSh0eXBlKSB7XG4gICAgICAgIHRoaXMucmVuZGVyZXIucmVtb3ZlQ2xhc3ModGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQsIGBrLWNhbGVuZGFyLSR7dGhpcy50eXBlfWApO1xuICAgICAgICB0aGlzLnJlbmRlcmVyLmFkZENsYXNzKHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LCBgay1jYWxlbmRhci0ke3R5cGV9YCk7XG4gICAgICAgIHRoaXMuX3R5cGUgPSB0eXBlO1xuICAgIH1cbiAgICBnZXQgdHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3R5cGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBzZXQgY2VsbFRlbXBsYXRlUmVmKHRlbXBsYXRlKSB7XG4gICAgICAgIHRoaXMuY2VsbFRlbXBsYXRlID0gdGVtcGxhdGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBzZXQgbW9udGhDZWxsVGVtcGxhdGVSZWYodGVtcGxhdGUpIHtcbiAgICAgICAgdGhpcy5tb250aENlbGxUZW1wbGF0ZSA9IHRlbXBsYXRlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgc2V0IHllYXJDZWxsVGVtcGxhdGVSZWYodGVtcGxhdGUpIHtcbiAgICAgICAgdGhpcy55ZWFyQ2VsbFRlbXBsYXRlID0gdGVtcGxhdGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBzZXQgZGVjYWRlQ2VsbFRlbXBsYXRlUmVmKHRlbXBsYXRlKSB7XG4gICAgICAgIHRoaXMuZGVjYWRlQ2VsbFRlbXBsYXRlID0gdGVtcGxhdGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBzZXQgY2VudHVyeUNlbGxUZW1wbGF0ZVJlZih0ZW1wbGF0ZSkge1xuICAgICAgICB0aGlzLmNlbnR1cnlDZWxsVGVtcGxhdGUgPSB0ZW1wbGF0ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHNldCB3ZWVrTnVtYmVyVGVtcGxhdGVSZWYodGVtcGxhdGUpIHtcbiAgICAgICAgdGhpcy53ZWVrTnVtYmVyVGVtcGxhdGUgPSB0ZW1wbGF0ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHNldCBoZWFkZXJUaXRsZVRlbXBsYXRlUmVmKHRlbXBsYXRlKSB7XG4gICAgICAgIHRoaXMuaGVhZGVyVGl0bGVUZW1wbGF0ZSA9IHRlbXBsYXRlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgc2V0IG5hdmlnYXRpb25JdGVtVGVtcGxhdGVSZWYodGVtcGxhdGUpIHtcbiAgICAgICAgdGhpcy5uYXZpZ2F0aW9uSXRlbVRlbXBsYXRlID0gdGVtcGxhdGU7XG4gICAgfVxuICAgIGdldCBhY3RpdmVWaWV3RW51bSgpIHtcbiAgICAgICAgY29uc3QgYWN0aXZlVmlldyA9IENhbGVuZGFyVmlld0VudW1bdGhpcy5hY3RpdmVWaWV3XTtcbiAgICAgICAgcmV0dXJuIGFjdGl2ZVZpZXcgPCB0aGlzLmJvdHRvbVZpZXdFbnVtID8gdGhpcy5ib3R0b21WaWV3RW51bSA6IGFjdGl2ZVZpZXc7XG4gICAgfVxuICAgIGdldCBib3R0b21WaWV3RW51bSgpIHtcbiAgICAgICAgcmV0dXJuIENhbGVuZGFyVmlld0VudW1bdGhpcy5ib3R0b21WaWV3XTtcbiAgICB9XG4gICAgZ2V0IHRvcFZpZXdFbnVtKCkge1xuICAgICAgICByZXR1cm4gQ2FsZW5kYXJWaWV3RW51bVt0aGlzLnRvcFZpZXddO1xuICAgIH1cbiAgICBnZXQgd2lkZ2V0SWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlkO1xuICAgIH1cbiAgICBnZXQgd2lkZ2V0Um9sZSgpIHtcbiAgICAgICAgcmV0dXJuICdncmlkJztcbiAgICB9XG4gICAgZ2V0IGNhbGVuZGFyVGFiSW5kZXgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRpc2FibGVkID8gdW5kZWZpbmVkIDogdGhpcy50YWJJbmRleDtcbiAgICB9XG4gICAgZ2V0IGFyaWFEaXNhYmxlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlzYWJsZWQ7XG4gICAgfVxuICAgIG5nT25Jbml0KCkge1xuICAgICAgICB0aGlzLmRvbS5jYWxjdWxhdGVIZWlnaHRzKHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50KTtcbiAgICAgICAgdGhpcy5zY3JvbGxTeW5jU2VydmljZS5jb25maWd1cmUodGhpcy5hY3RpdmVWaWV3RW51bSk7XG4gICAgICAgIHRoaXMubG9jYWxpemF0aW9uQ2hhbmdlU3Vic2NyaXB0aW9uID0gdGhpcy5sb2NhbGl6YXRpb24uY2hhbmdlcy5zdWJzY3JpYmUoKCkgPT4gdGhpcy5jZHIubWFya0ZvckNoZWNrKCkpO1xuICAgICAgICB0aGlzLnZpZXdDaGFuZ2VTdWJzY3JpcHRpb24gPSB0aGlzLmJ1cy52aWV3Q2hhbmdlZC5zdWJzY3JpYmUoKHsgdmlldyB9KSA9PiB0aGlzLmhhbmRsZUFjdGl2ZVZpZXdDaGFuZ2UoQ2FsZW5kYXJWaWV3RW51bVt2aWV3XSkpO1xuICAgICAgICB0aGlzLmNvbnRyb2wgPSB0aGlzLmluamVjdG9yLmdldChOZ0NvbnRyb2wsIG51bGwpO1xuICAgICAgICBpZiAodGhpcy5lbGVtZW50KSB7XG4gICAgICAgICAgICB0aGlzLm5nWm9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5iaW5kRXZlbnRzKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzKSB7XG4gICAgICAgIHRoaXMudmVyaWZ5Q2hhbmdlcygpO1xuICAgICAgICB0aGlzLmJ1cy5jb25maWd1cmUodGhpcy5ib3R0b21WaWV3RW51bSwgdGhpcy50b3BWaWV3RW51bSk7XG4gICAgICAgIHRoaXMuc2Nyb2xsU3luY1NlcnZpY2UuY29uZmlndXJlKHRoaXMuYWN0aXZlVmlld0VudW0pO1xuICAgICAgICBpZiAoaGFzRXhpc3RpbmdWYWx1ZShjaGFuZ2VzLCAnZm9jdXNlZERhdGUnKSkge1xuICAgICAgICAgICAgY29uc3QgZm9jdXNlZERhdGUgPSBjaGFuZ2VzLmZvY3VzZWREYXRlLmN1cnJlbnRWYWx1ZTtcbiAgICAgICAgICAgIHRoaXMuZm9jdXNlZERhdGUgPSBkYXRlSW5SYW5nZShmb2N1c2VkRGF0ZSwgdGhpcy5taW4sIHRoaXMubWF4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhbmdlcy5uYXZpZ2F0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLnN5bmNOYXZpZ2F0aW9uID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhbmdlcy5taW4gfHwgY2hhbmdlcy5tYXggfHwgY2hhbmdlcy5yYW5nZVZhbGlkYXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMubWluVmFsaWRhdGVGbiA9IHRoaXMucmFuZ2VWYWxpZGF0aW9uID8gbWluVmFsaWRhdG9yKHRoaXMubWluKSA6IG5vb3A7XG4gICAgICAgICAgICB0aGlzLm1heFZhbGlkYXRlRm4gPSB0aGlzLnJhbmdlVmFsaWRhdGlvbiA/IG1heFZhbGlkYXRvcih0aGlzLm1heCkgOiBub29wO1xuICAgICAgICAgICAgdGhpcy5vblZhbGlkYXRvckNoYW5nZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG5nQWZ0ZXJWaWV3SW5pdCgpIHtcbiAgICAgICAgdGhpcy5zZXRBcmlhQWN0aXZlZGVzY2VuZGFudCgpO1xuICAgIH1cbiAgICBuZ0FmdGVyVmlld0NoZWNrZWQoKSB7XG4gICAgICAgIGlmICghdGhpcy5zeW5jTmF2aWdhdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3luY05hdmlnYXRpb24gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zY3JvbGxTeW5jU2VydmljZS5zeW5jKHZpcnR1YWxpemF0aW9uUHJvcCh0aGlzLm5hdmlnYXRpb25WaWV3KSwgdmlydHVhbGl6YXRpb25Qcm9wKHRoaXMubW9udGhWaWV3KSk7XG4gICAgfVxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICB0aGlzLnNjcm9sbFN5bmNTZXJ2aWNlLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy52aWV3Q2hhbmdlU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIHRoaXMuZG9tRXZlbnRzLmZvckVhY2godW5iaW5kQ2FsbGJhY2sgPT4gdW5iaW5kQ2FsbGJhY2soKSk7XG4gICAgICAgIGlmICh0aGlzLnBpY2tlclNlcnZpY2UpIHtcbiAgICAgICAgICAgIHRoaXMucGlja2VyU2VydmljZS5jYWxlbmRhciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucGFnZUNoYW5nZVN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgdGhpcy5wYWdlQ2hhbmdlU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubG9jYWxpemF0aW9uQ2hhbmdlU3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmxvY2FsaXphdGlvbkNoYW5nZVN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIG9uUmVzaXplKCkge1xuICAgICAgICB0aGlzLmZvY3VzZWREYXRlID0gbmV3IERhdGUodGhpcy5mb2N1c2VkRGF0ZSk7XG4gICAgICAgIHRoaXMuY2RyLmRldGVjdENoYW5nZXMoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRm9jdXNlcyB0aGUgaG9zdCBlbGVtZW50IG9mIHRoZSBDYWxlbmRhci5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiBfQENvbXBvbmVudCh7XG4gICAgICogc2VsZWN0b3I6ICdteS1hcHAnLFxuICAgICAqIHRlbXBsYXRlOiBgXG4gICAgICogIDxidXR0b24gKGNsaWNrKT1cImNhbGVuZGFyLmZvY3VzKClcIj5Gb2N1cyBjYWxlbmRhcjwvYnV0dG9uPlxuICAgICAqICA8a2VuZG8tY2FsZW5kYXIgI2NhbGVuZGFyPjwva2VuZG8tY2FsZW5kYXI+XG4gICAgICogYFxuICAgICAqIH0pXG4gICAgICogZXhwb3J0IGNsYXNzIEFwcENvbXBvbmVudCB7IH1cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBmb2N1cygpIHtcbiAgICAgICAgaWYgKCF0aGlzLmVsZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudC5mb2N1cygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBCbHVycyB0aGUgQ2FsZW5kYXIgY29tcG9uZW50LlxuICAgICAqL1xuICAgIGJsdXIoKSB7XG4gICAgICAgIGlmICghdGhpcy5lbGVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQuYmx1cigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgY29udGFpbnNFbGVtZW50KGVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIEJvb2xlYW4oY2xvc2VzdChlbGVtZW50LCBub2RlID0+IG5vZGUgPT09IHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBoYW5kbGVOYXZpZ2F0aW9uKGNhbmRpZGF0ZSkge1xuICAgICAgICBpZiAodGhpcy5kaXNhYmxlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZvY3VzVGFyZ2V0ID0gY2FuZGlkYXRlID8gbmV3IERhdGUoY2xvbmVEYXRlKGNhbmRpZGF0ZSkuc2V0RGF0ZSgxKSkgOiB0aGlzLmZvY3VzZWREYXRlO1xuICAgICAgICB0aGlzLmZvY3VzZWREYXRlID0gZGF0ZUluUmFuZ2UoZm9jdXNUYXJnZXQsIHRoaXMubWluLCB0aGlzLm1heCk7XG4gICAgICAgIHRoaXMuZGV0ZWN0Q2hhbmdlcygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgb25QYWdlQ2hhbmdlKCkge1xuICAgICAgICBpZiAoIU5nWm9uZS5pc0luQW5ndWxhclpvbmUoKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucGFnZUNoYW5nZVN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgICAgIHRoaXMucGFnZUNoYW5nZVN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5wYWdlQ2hhbmdlU3Vic2NyaXB0aW9uID0gZnJvbSh0aGlzLnJlc29sdmVkUHJvbWlzZSlcbiAgICAgICAgICAgICAgICAuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmRldGVjdENoYW5nZXMoKTsgLy8gcmVxdWlyZXMgem9uZSBpZiB0ZW1wbGF0ZXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBoYW5kbGVNdWx0aVZpZXdDYWxlbmRhclZhbHVlQ2hhbmdlKGRhdGUsIGZvY3VzZWREYXRlKSB7XG4gICAgICAgIGNvbnN0IHNlbGVjdGVkRGF0ZXMgPSBBcnJheS5pc0FycmF5KGRhdGUpID8gZGF0ZSA6IFtkYXRlXTtcbiAgICAgICAgdGhpcy5oYW5kbGVEYXRlQ2hhbmdlKHsgc2VsZWN0ZWREYXRlcywgZm9jdXNlZERhdGUgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBoYW5kbGVEYXRlQ2hhbmdlKGFyZ3MpIHtcbiAgICAgICAgY29uc3Qgc2VsZWN0ZWREYXRlcyA9IEFycmF5LmlzQXJyYXkoYXJncy5zZWxlY3RlZERhdGVzKSA/IGFyZ3Muc2VsZWN0ZWREYXRlcyA6IFthcmdzLnNlbGVjdGVkRGF0ZXNdO1xuICAgICAgICBjb25zdCBjYW5OYXZpZ2F0ZURvd24gPSB0aGlzLmJ1cy5jYW5Nb3ZlRG93bih0aGlzLmFjdGl2ZVZpZXdFbnVtKTtcbiAgICAgICAgY29uc3QgYXZhaWxhYmxlRGF0ZXMgPSBzZWxlY3RlZERhdGVzLmZpbHRlcihkYXRlID0+ICF0aGlzLmRpc2FibGVkRGF0ZXNTZXJ2aWNlLmlzRGF0ZURpc2FibGVkKGRhdGUpKTtcbiAgICAgICAgdGhpcy5mb2N1c2VkRGF0ZSA9IGFyZ3MuZm9jdXNlZERhdGUgfHwgdGhpcy5mb2N1c2VkRGF0ZTtcbiAgICAgICAgaWYgKHRoaXMuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNhbk5hdmlnYXRlRG93biAmJiBhcmVEYXRlc0VxdWFsKGF2YWlsYWJsZURhdGVzLCB0aGlzLnNlbGVjdGVkRGF0ZXMpKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXRTYW1lRGF0ZSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjYW5OYXZpZ2F0ZURvd24pIHtcbiAgICAgICAgICAgIHRoaXMuYnVzLm1vdmVEb3duKHRoaXMuYWN0aXZlVmlld0VudW0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmRpc2FibGVkRGF0ZXNTZXJ2aWNlLmlzRGF0ZURpc2FibGVkKHRoaXMuZm9jdXNlZERhdGUpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5uZ1pvbmUucnVuKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWREYXRlcyA9IGF2YWlsYWJsZURhdGVzLm1hcChkYXRlID0+IGNsb25lRGF0ZShkYXRlKSk7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gdGhpcy5wYXJzZVNlbGVjdGlvblRvVmFsdWUoYXZhaWxhYmxlRGF0ZXMpO1xuICAgICAgICAgICAgdGhpcy5vbkNvbnRyb2xDaGFuZ2UodGhpcy5wYXJzZVNlbGVjdGlvblRvVmFsdWUoYXZhaWxhYmxlRGF0ZXMpKTtcbiAgICAgICAgICAgIHRoaXMudmFsdWVDaGFuZ2UuZW1pdCh0aGlzLnBhcnNlU2VsZWN0aW9uVG9WYWx1ZShhdmFpbGFibGVEYXRlcykpO1xuICAgICAgICAgICAgdGhpcy5jZHIubWFya0ZvckNoZWNrKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgd3JpdGVWYWx1ZShjYW5kaWRhdGUpIHtcbiAgICAgICAgdGhpcy52ZXJpZnlWYWx1ZShjYW5kaWRhdGUpO1xuICAgICAgICB0aGlzLnZhbHVlID0gY2FuZGlkYXRlO1xuICAgICAgICB0aGlzLmNkci5tYXJrRm9yQ2hlY2soKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHJlZ2lzdGVyT25DaGFuZ2UoZm4pIHtcbiAgICAgICAgdGhpcy5vbkNvbnRyb2xDaGFuZ2UgPSBmbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHJlZ2lzdGVyT25Ub3VjaGVkKGZuKSB7XG4gICAgICAgIHRoaXMub25Db250cm9sVG91Y2hlZCA9IGZuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgc2V0RGlzYWJsZWRTdGF0ZShpc0Rpc2FibGVkKSB7XG4gICAgICAgIHRoaXMuZGlzYWJsZWQgPSBpc0Rpc2FibGVkO1xuICAgICAgICB0aGlzLmNkci5tYXJrRm9yQ2hlY2soKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHZhbGlkYXRlKGNvbnRyb2wpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWluVmFsaWRhdGVGbihjb250cm9sKSB8fCB0aGlzLm1heFZhbGlkYXRlRm4oY29udHJvbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICByZWdpc3Rlck9uVmFsaWRhdG9yQ2hhbmdlKGZuKSB7XG4gICAgICAgIHRoaXMub25WYWxpZGF0b3JDaGFuZ2UgPSBmbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGFjdGl2ZUNlbGxUZW1wbGF0ZSgpIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLmFjdGl2ZVZpZXdFbnVtKSB7XG4gICAgICAgICAgICBjYXNlIENhbGVuZGFyVmlld0VudW0ubW9udGg6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubW9udGhDZWxsVGVtcGxhdGUgfHwgdGhpcy5jZWxsVGVtcGxhdGU7XG4gICAgICAgICAgICBjYXNlIENhbGVuZGFyVmlld0VudW0ueWVhcjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy55ZWFyQ2VsbFRlbXBsYXRlO1xuICAgICAgICAgICAgY2FzZSBDYWxlbmRhclZpZXdFbnVtLmRlY2FkZTpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kZWNhZGVDZWxsVGVtcGxhdGU7XG4gICAgICAgICAgICBjYXNlIENhbGVuZGFyVmlld0VudW0uY2VudHVyeTpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jZW50dXJ5Q2VsbFRlbXBsYXRlO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZW1pdEV2ZW50KGVtaXR0ZXIsIGFyZ3MpIHtcbiAgICAgICAgaWYgKGhhc09ic2VydmVycyhlbWl0dGVyKSkge1xuICAgICAgICAgICAgdGhpcy5uZ1pvbmUucnVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICBlbWl0dGVyLmVtaXQoYXJncyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgaGFuZGxlQWN0aXZlVmlld0NoYW5nZSh2aWV3KSB7XG4gICAgICAgIHRoaXMuYWN0aXZlVmlldyA9IHZpZXc7XG4gICAgICAgIHRoaXMuZW1pdEV2ZW50KHRoaXMuYWN0aXZlVmlld0NoYW5nZSwgdmlldyk7XG4gICAgICAgIGlmICh0aGlzLnR5cGUgPT09ICdpbmZpbml0ZScpIHtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsU3luY1NlcnZpY2UuY29uZmlndXJlKHRoaXMuYWN0aXZlVmlld0VudW0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGV0ZWN0Q2hhbmdlcygpOyAvLyByZXF1aXJlcyB6b25lIGlmIHRlbXBsYXRlc1xuICAgIH1cbiAgICBoYW5kbGVDZWxsQ2xpY2soeyBkYXRlLCBtb2RpZmllcnMgfSkge1xuICAgICAgICB0aGlzLnBlcmZvcm1TZWxlY3Rpb24oZGF0ZSwgbW9kaWZpZXJzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGhhbmRsZVdlZWtOdW1iZXJDbGljayhkYXRlcykge1xuICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb24gPT09ICdzaW5nbGUnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5uZ1pvbmUucnVuKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlRGF0ZUNoYW5nZSh7XG4gICAgICAgICAgICAgICAgc2VsZWN0ZWREYXRlczogZGF0ZXMsXG4gICAgICAgICAgICAgICAgZm9jdXNlZERhdGU6IGxhc3QoZGF0ZXMpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNldENsYXNzZXMoZWxlbWVudCkge1xuICAgICAgICB0aGlzLnJlbmRlcmVyLmFkZENsYXNzKGVsZW1lbnQsICdrLXdpZGdldCcpO1xuICAgICAgICB0aGlzLnJlbmRlcmVyLmFkZENsYXNzKGVsZW1lbnQsICdrLWNhbGVuZGFyJyk7XG4gICAgICAgIHRoaXMucmVuZGVyZXIuYWRkQ2xhc3MoZWxlbWVudCwgYGstY2FsZW5kYXItJHt0aGlzLnR5cGV9YCk7XG4gICAgfVxuICAgIHZlcmlmeUNoYW5nZXMoKSB7XG4gICAgICAgIGlmICghaXNEZXZNb2RlKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5taW4gPiB0aGlzLm1heCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgbWF4IHZhbHVlIHNob3VsZCBiZSBiaWdnZXIgdGhhbiB0aGUgbWluLiBTZWUgJHtNSU5fRE9DX0xJTkt9IGFuZCAke01BWF9ET0NfTElOS30uYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuYm90dG9tVmlld0VudW0gPiB0aGlzLnRvcFZpZXdFbnVtKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSB0b3BWaWV3IHNob3VsZCBiZSBncmVhdGVyIHRoYW4gYm90dG9tVmlldy4gU2VlICR7Qk9UVE9NX1ZJRVdfRE9DX0xJTkt9IGFuZCAke1RPUF9WSUVXX0RPQ19MSU5LfS5gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2ZXJpZnlWYWx1ZShjYW5kaWRhdGUpIHtcbiAgICAgICAgaWYgKCFpc0Rldk1vZGUoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbiA9PT0gJ3NpbmdsZScgJiYgY2FuZGlkYXRlICYmICEoY2FuZGlkYXRlIGluc3RhbmNlb2YgRGF0ZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlICd2YWx1ZScgc2hvdWxkIGJlIGEgdmFsaWQgSmF2YVNjcmlwdCBEYXRlIGluc3RhbmNlLiBDaGVjayAke1ZBTFVFX0RPQ19MSU5LfSBmb3IgcG9zc2libGUgcmVzb2x1dGlvbi5gKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnNlbGVjdGlvbiA9PT0gJ211bHRpcGxlJyAmJiBjYW5kaWRhdGUgJiYgQXJyYXkuaXNBcnJheShjYW5kaWRhdGUpKSB7XG4gICAgICAgICAgICBjb25zdCBvbmx5RGF0ZXMgPSBjYW5kaWRhdGUuZXZlcnkodmFsdWUgPT4gdmFsdWUgaW5zdGFuY2VvZiBEYXRlKTtcbiAgICAgICAgICAgIGlmICghb25seURhdGVzKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgJ3ZhbHVlJyBzaG91bGQgYmUgYW4gYXJyYXkgb2YgdmFsaWQgSmF2YVNjcmlwdCBEYXRlIGluc3RhbmNlcy4gQ2hlY2sgJHtWQUxVRV9ET0NfTElOS30gZm9yIHBvc3NpYmxlIHJlc29sdXRpb24uYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYmluZEV2ZW50cygpIHtcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50O1xuICAgICAgICB0aGlzLmRvbUV2ZW50cy5wdXNoKHRoaXMucmVuZGVyZXIubGlzdGVuKGVsZW1lbnQsICdibHVyJywgdGhpcy5oYW5kbGVCbHVyLmJpbmQodGhpcykpLCB0aGlzLnJlbmRlcmVyLmxpc3RlbihlbGVtZW50LCAnZm9jdXMnLCB0aGlzLmhhbmRsZUZvY3VzLmJpbmQodGhpcykpLCB0aGlzLnJlbmRlcmVyLmxpc3RlbihlbGVtZW50LCAnbW91c2Vkb3duJywgcHJldmVudERlZmF1bHQpLCB0aGlzLnJlbmRlcmVyLmxpc3RlbihlbGVtZW50LCAnY2xpY2snLCB0aGlzLmhhbmRsZUNvbXBvbmVudENsaWNrLmJpbmQodGhpcykpLCB0aGlzLnJlbmRlcmVyLmxpc3RlbihlbGVtZW50LCAna2V5ZG93bicsIHRoaXMuaGFuZGxlS2V5ZG93bi5iaW5kKHRoaXMpKSk7XG4gICAgfVxuICAgIGVtaXRCbHVyKGFyZ3MpIHtcbiAgICAgICAgaWYgKHRoaXMucGlja2VyU2VydmljZSkge1xuICAgICAgICAgICAgdGhpcy5waWNrZXJTZXJ2aWNlLm9uQmx1ci5lbWl0KGFyZ3MpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVtaXRGb2N1cygpIHtcbiAgICAgICAgaWYgKHRoaXMucGlja2VyU2VydmljZSkge1xuICAgICAgICAgICAgdGhpcy5waWNrZXJTZXJ2aWNlLm9uRm9jdXMuZW1pdCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhbmRsZUJsdXIoYXJncykge1xuICAgICAgICB0aGlzLmlzQWN0aXZlID0gZmFsc2U7XG4gICAgICAgIC8vIHRoZSBpbmplY3RvciBjYW4gZ2V0IHRoZSBOZ0NvbnRyb2wgaW5zdGFuY2Ugb2YgdGhlIHBhcmVudCBjb21wb25lbnQgKGZvciBleGFtcGxlLCB0aGUgRGF0ZVRpbWVQaWNrZXIpXG4gICAgICAgIC8vIGFuZCBlbnRlcnMgdGhlIHpvbmUgZm9yIG5vIHJlYXNvbiBiZWNhdXNlIHRoZSBwYXJlbnQgY29tcG9uZW50IGlzIHN0aWxsIHVudG91Y2hlZFxuICAgICAgICBpZiAoIXRoaXMucGlja2VyU2VydmljZSAmJiByZXF1aXJlc1pvbmVPbkJsdXIodGhpcy5jb250cm9sKSkge1xuICAgICAgICAgICAgdGhpcy5uZ1pvbmUucnVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLm9uQ29udHJvbFRvdWNoZWQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXRCbHVyKGFyZ3MpO1xuICAgICAgICAgICAgICAgIHRoaXMuY2RyLm1hcmtGb3JDaGVjaygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmVtaXRCbHVyKGFyZ3MpO1xuICAgICAgICAgICAgdGhpcy5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaGFuZGxlRm9jdXMoKSB7XG4gICAgICAgIHRoaXMuaXNBY3RpdmUgPSB0cnVlO1xuICAgICAgICBpZiAoIU5nWm9uZS5pc0luQW5ndWxhclpvbmUoKSkge1xuICAgICAgICAgICAgdGhpcy5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbWl0Rm9jdXMoKTtcbiAgICB9XG4gICAgaGFuZGxlQ29tcG9uZW50Q2xpY2soKSB7XG4gICAgICAgIGlmICghdGhpcy5pc0FjdGl2ZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gJ2luZmluaXRlJyAmJiB0aGlzLm1vbnRoVmlldy5pc1Njcm9sbGVkKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZvY3VzZWREYXRlID0gY2xvbmVEYXRlKHRoaXMuZm9jdXNlZERhdGUpOyAvL1hYWDogZm9yY2VzIGNoYW5nZSBkZXRlY3RcbiAgICAgICAgICAgICAgICB0aGlzLmRldGVjdENoYW5nZXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZm9jdXMoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBoYW5kbGVLZXlkb3duKGFyZ3MpIHtcbiAgICAgICAgLy8gcmVzZXJ2ZSB0aGUgYWx0ICsgYXJyb3cga2V5IGNvbW1hbmRzIGZvciB0aGUgcGlja2VyXG4gICAgICAgIGNvbnN0IGFycm93S2V5UHJlc3NlZCA9IFtLZXlzLkFycm93VXAsIEtleXMuQXJyb3dSaWdodCwgS2V5cy5BcnJvd0Rvd24sIEtleXMuQXJyb3dMZWZ0XS5pbmRleE9mKGFyZ3Mua2V5Q29kZSkgIT09IC0xO1xuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMucGlja2VyU2VydmljZSkgJiYgYXJyb3dLZXlQcmVzc2VkICYmIGFyZ3MuYWx0S2V5KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gZGF0ZUluUmFuZ2UodGhpcy5uYXZpZ2F0b3IubW92ZSh0aGlzLmZvY3VzZWREYXRlLCB0aGlzLm5hdmlnYXRvci5hY3Rpb24oYXJncyksIHRoaXMuYWN0aXZlVmlld0VudW0pLCB0aGlzLm1pbiwgdGhpcy5tYXgpO1xuICAgICAgICBpZiAoIWlzRXF1YWwodGhpcy5mb2N1c2VkRGF0ZSwgY2FuZGlkYXRlKSkge1xuICAgICAgICAgICAgdGhpcy5mb2N1c2VkRGF0ZSA9IGNhbmRpZGF0ZTtcbiAgICAgICAgICAgIHRoaXMuZGV0ZWN0Q2hhbmdlcygpO1xuICAgICAgICAgICAgYXJncy5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhcmdzLmtleUNvZGUgPT09IEtleXMuRW50ZXIpIHtcbiAgICAgICAgICAgIHRoaXMucGVyZm9ybVNlbGVjdGlvbih0aGlzLmZvY3VzZWREYXRlLCBhcmdzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkZXRlY3RDaGFuZ2VzKCkge1xuICAgICAgICBpZiAoIXRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgICAgICB0aGlzLmNkci5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZW1pdFNhbWVEYXRlKCkge1xuICAgICAgICBpZiAodGhpcy5waWNrZXJTZXJ2aWNlKSB7XG4gICAgICAgICAgICB0aGlzLnBpY2tlclNlcnZpY2Uuc2FtZURhdGVTZWxlY3RlZC5lbWl0KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0QXJpYUFjdGl2ZWRlc2NlbmRhbnQoKSB7XG4gICAgICAgIGlmICghaXNQcmVzZW50KHRoaXMuZWxlbWVudCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmb2N1c2VkQ2VsbElkID0gdGhpcy5jZWxsVUlEICsgdGhpcy5mb2N1c2VkRGF0ZS5nZXRUaW1lKCk7XG4gICAgICAgIHRoaXMucmVuZGVyZXIuc2V0QXR0cmlidXRlKHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LCAnYXJpYS1hY3RpdmVkZXNjZW5kYW50JywgZm9jdXNlZENlbGxJZCk7XG4gICAgfVxuICAgIHBhcnNlU2VsZWN0aW9uVG9WYWx1ZShzZWxlY3Rpb24pIHtcbiAgICAgICAgc2VsZWN0aW9uID0gc2VsZWN0aW9uIHx8IFtdO1xuICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3Rpb24gPT09ICdzaW5nbGUnID8gY2xvbmVEYXRlKGxhc3Qoc2VsZWN0aW9uKSkgOiBzZWxlY3Rpb24ubWFwKGRhdGUgPT4gY2xvbmVEYXRlKGRhdGUpKTtcbiAgICB9XG4gICAgcGVyZm9ybVNlbGVjdGlvbihkYXRlLCBzZWxlY3Rpb25Nb2RpZmllcnMpIHtcbiAgICAgICAgY29uc3Qgc2VsZWN0aW9uID0gdGhpcy5zZWxlY3Rpb25TZXJ2aWNlLnBlcmZvcm1TZWxlY3Rpb24oe1xuICAgICAgICAgICAgZGF0ZTogZGF0ZSxcbiAgICAgICAgICAgIG1vZGlmaWVyczogc2VsZWN0aW9uTW9kaWZpZXJzLFxuICAgICAgICAgICAgc2VsZWN0aW9uTW9kZTogdGhpcy5zZWxlY3Rpb24sXG4gICAgICAgICAgICBhY3RpdmVWaWV3RW51bTogdGhpcy5hY3RpdmVWaWV3RW51bSxcbiAgICAgICAgICAgIHJhbmdlUGl2b3Q6IHRoaXMucmFuZ2VQaXZvdCxcbiAgICAgICAgICAgIHNlbGVjdGVkRGF0ZXM6IHRoaXMuc2VsZWN0ZWREYXRlc1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yYW5nZVBpdm90ID0gc2VsZWN0aW9uLnJhbmdlUGl2b3Q7XG4gICAgICAgIHRoaXMuaGFuZGxlRGF0ZUNoYW5nZSh7XG4gICAgICAgICAgICBzZWxlY3RlZERhdGVzOiBzZWxlY3Rpb24uc2VsZWN0ZWREYXRlcyxcbiAgICAgICAgICAgIGZvY3VzZWREYXRlOiBkYXRlXG4gICAgICAgIH0pO1xuICAgIH1cbn07XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBDYWxlbmRhckNvbXBvbmVudC5wcm90b3R5cGUsIFwiaWRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIERhdGUpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbRGF0ZV0pXG5dLCBDYWxlbmRhckNvbXBvbmVudC5wcm90b3R5cGUsIFwiZm9jdXNlZERhdGVcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBEYXRlKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0RhdGVdKVxuXSwgQ2FsZW5kYXJDb21wb25lbnQucHJvdG90eXBlLCBcIm1pblwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIERhdGUpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbRGF0ZV0pXG5dLCBDYWxlbmRhckNvbXBvbmVudC5wcm90b3R5cGUsIFwibWF4XCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIENhbGVuZGFyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJyYW5nZVZhbGlkYXRpb25cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIENhbGVuZGFyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzZWxlY3Rpb25cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtPYmplY3RdKVxuXSwgQ2FsZW5kYXJDb21wb25lbnQucHJvdG90eXBlLCBcInZhbHVlXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIENhbGVuZGFyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkaXNhYmxlZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgQ2FsZW5kYXJDb21wb25lbnQucHJvdG90eXBlLCBcInRhYmluZGV4XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbTnVtYmVyXSlcbl0sIENhbGVuZGFyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0YWJJbmRleFwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtPYmplY3RdKVxuXSwgQ2FsZW5kYXJDb21wb25lbnQucHJvdG90eXBlLCBcImRpc2FibGVkRGF0ZXNcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgQ2FsZW5kYXJDb21wb25lbnQucHJvdG90eXBlLCBcIm5hdmlnYXRpb25cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIENhbGVuZGFyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJhY3RpdmVWaWV3XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBDYWxlbmRhckNvbXBvbmVudC5wcm90b3R5cGUsIFwiYm90dG9tVmlld1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgQ2FsZW5kYXJDb21wb25lbnQucHJvdG90eXBlLCBcInRvcFZpZXdcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtTdHJpbmddKVxuXSwgQ2FsZW5kYXJDb21wb25lbnQucHJvdG90eXBlLCBcInR5cGVcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgQ2FsZW5kYXJDb21wb25lbnQucHJvdG90eXBlLCBcImFuaW1hdGVOYXZpZ2F0aW9uXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5rLXdlZWstbnVtYmVyJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBDYWxlbmRhckNvbXBvbmVudC5wcm90b3R5cGUsIFwid2Vla051bWJlclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbl0sIENhbGVuZGFyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJhY3RpdmVWaWV3Q2hhbmdlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBPdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxuXSwgQ2FsZW5kYXJDb21wb25lbnQucHJvdG90eXBlLCBcImFjdGl2ZVZpZXdEYXRlQ2hhbmdlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBPdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxuXSwgQ2FsZW5kYXJDb21wb25lbnQucHJvdG90eXBlLCBcInZhbHVlQ2hhbmdlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBDb250ZW50Q2hpbGQoQ2VsbFRlbXBsYXRlRGlyZWN0aXZlLCB7IHN0YXRpYzogdHJ1ZSB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQ2VsbFRlbXBsYXRlRGlyZWN0aXZlKVxuXSwgQ2FsZW5kYXJDb21wb25lbnQucHJvdG90eXBlLCBcImNlbGxUZW1wbGF0ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoJ2NlbGxUZW1wbGF0ZScpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBDZWxsVGVtcGxhdGVEaXJlY3RpdmUpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQ2VsbFRlbXBsYXRlRGlyZWN0aXZlXSlcbl0sIENhbGVuZGFyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJjZWxsVGVtcGxhdGVSZWZcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBDb250ZW50Q2hpbGQoTW9udGhDZWxsVGVtcGxhdGVEaXJlY3RpdmUsIHsgc3RhdGljOiB0cnVlIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBNb250aENlbGxUZW1wbGF0ZURpcmVjdGl2ZSlcbl0sIENhbGVuZGFyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJtb250aENlbGxUZW1wbGF0ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoJ21vbnRoQ2VsbFRlbXBsYXRlJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE1vbnRoQ2VsbFRlbXBsYXRlRGlyZWN0aXZlKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW01vbnRoQ2VsbFRlbXBsYXRlRGlyZWN0aXZlXSlcbl0sIENhbGVuZGFyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJtb250aENlbGxUZW1wbGF0ZVJlZlwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIENvbnRlbnRDaGlsZChZZWFyQ2VsbFRlbXBsYXRlRGlyZWN0aXZlLCB7IHN0YXRpYzogdHJ1ZSB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgWWVhckNlbGxUZW1wbGF0ZURpcmVjdGl2ZSlcbl0sIENhbGVuZGFyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ5ZWFyQ2VsbFRlbXBsYXRlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgneWVhckNlbGxUZW1wbGF0ZScpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBZZWFyQ2VsbFRlbXBsYXRlRGlyZWN0aXZlKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW1llYXJDZWxsVGVtcGxhdGVEaXJlY3RpdmVdKVxuXSwgQ2FsZW5kYXJDb21wb25lbnQucHJvdG90eXBlLCBcInllYXJDZWxsVGVtcGxhdGVSZWZcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBDb250ZW50Q2hpbGQoRGVjYWRlQ2VsbFRlbXBsYXRlRGlyZWN0aXZlLCB7IHN0YXRpYzogdHJ1ZSB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRGVjYWRlQ2VsbFRlbXBsYXRlRGlyZWN0aXZlKVxuXSwgQ2FsZW5kYXJDb21wb25lbnQucHJvdG90eXBlLCBcImRlY2FkZUNlbGxUZW1wbGF0ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoJ2RlY2FkZUNlbGxUZW1wbGF0ZScpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBEZWNhZGVDZWxsVGVtcGxhdGVEaXJlY3RpdmUpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbRGVjYWRlQ2VsbFRlbXBsYXRlRGlyZWN0aXZlXSlcbl0sIENhbGVuZGFyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkZWNhZGVDZWxsVGVtcGxhdGVSZWZcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBDb250ZW50Q2hpbGQoQ2VudHVyeUNlbGxUZW1wbGF0ZURpcmVjdGl2ZSwgeyBzdGF0aWM6IHRydWUgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIENlbnR1cnlDZWxsVGVtcGxhdGVEaXJlY3RpdmUpXG5dLCBDYWxlbmRhckNvbXBvbmVudC5wcm90b3R5cGUsIFwiY2VudHVyeUNlbGxUZW1wbGF0ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoJ2NlbnR1cnlDZWxsVGVtcGxhdGUnKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQ2VudHVyeUNlbGxUZW1wbGF0ZURpcmVjdGl2ZSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtDZW50dXJ5Q2VsbFRlbXBsYXRlRGlyZWN0aXZlXSlcbl0sIENhbGVuZGFyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJjZW50dXJ5Q2VsbFRlbXBsYXRlUmVmXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgQ29udGVudENoaWxkKFdlZWtOdW1iZXJDZWxsVGVtcGxhdGVEaXJlY3RpdmUsIHsgc3RhdGljOiB0cnVlIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBXZWVrTnVtYmVyQ2VsbFRlbXBsYXRlRGlyZWN0aXZlKVxuXSwgQ2FsZW5kYXJDb21wb25lbnQucHJvdG90eXBlLCBcIndlZWtOdW1iZXJUZW1wbGF0ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoJ3dlZWtOdW1iZXJUZW1wbGF0ZScpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBXZWVrTnVtYmVyQ2VsbFRlbXBsYXRlRGlyZWN0aXZlKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW1dlZWtOdW1iZXJDZWxsVGVtcGxhdGVEaXJlY3RpdmVdKVxuXSwgQ2FsZW5kYXJDb21wb25lbnQucHJvdG90eXBlLCBcIndlZWtOdW1iZXJUZW1wbGF0ZVJlZlwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIENvbnRlbnRDaGlsZChIZWFkZXJUaXRsZVRlbXBsYXRlRGlyZWN0aXZlLCB7IHN0YXRpYzogdHJ1ZSB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgSGVhZGVyVGl0bGVUZW1wbGF0ZURpcmVjdGl2ZSlcbl0sIENhbGVuZGFyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJoZWFkZXJUaXRsZVRlbXBsYXRlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgnaGVhZGVyVGl0bGVUZW1wbGF0ZScpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBIZWFkZXJUaXRsZVRlbXBsYXRlRGlyZWN0aXZlKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0hlYWRlclRpdGxlVGVtcGxhdGVEaXJlY3RpdmVdKVxuXSwgQ2FsZW5kYXJDb21wb25lbnQucHJvdG90eXBlLCBcImhlYWRlclRpdGxlVGVtcGxhdGVSZWZcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBDb250ZW50Q2hpbGQoTmF2aWdhdGlvbkl0ZW1UZW1wbGF0ZURpcmVjdGl2ZSwgeyBzdGF0aWM6IHRydWUgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE5hdmlnYXRpb25JdGVtVGVtcGxhdGVEaXJlY3RpdmUpXG5dLCBDYWxlbmRhckNvbXBvbmVudC5wcm90b3R5cGUsIFwibmF2aWdhdGlvbkl0ZW1UZW1wbGF0ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoJ25hdmlnYXRpb25JdGVtVGVtcGxhdGUnKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTmF2aWdhdGlvbkl0ZW1UZW1wbGF0ZURpcmVjdGl2ZSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtOYXZpZ2F0aW9uSXRlbVRlbXBsYXRlRGlyZWN0aXZlXSlcbl0sIENhbGVuZGFyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJuYXZpZ2F0aW9uSXRlbVRlbXBsYXRlUmVmXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgVmlld0NoaWxkKE5hdmlnYXRpb25Db21wb25lbnQsIHsgc3RhdGljOiBmYWxzZSB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTmF2aWdhdGlvbkNvbXBvbmVudClcbl0sIENhbGVuZGFyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJuYXZpZ2F0aW9uVmlld1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgVmlld0NoaWxkKFZpZXdMaXN0Q29tcG9uZW50LCB7IHN0YXRpYzogZmFsc2UgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFZpZXdMaXN0Q29tcG9uZW50KVxuXSwgQ2FsZW5kYXJDb21wb25lbnQucHJvdG90eXBlLCBcIm1vbnRoVmlld1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSG9zdEJpbmRpbmcoJ2F0dHIuaWQnKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBDYWxlbmRhckNvbXBvbmVudC5wcm90b3R5cGUsIFwid2lkZ2V0SWRcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBIb3N0QmluZGluZygnYXR0ci5yb2xlJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgQ2FsZW5kYXJDb21wb25lbnQucHJvdG90eXBlLCBcIndpZGdldFJvbGVcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBIb3N0QmluZGluZygnYXR0ci50YWJpbmRleCcpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIENhbGVuZGFyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJjYWxlbmRhclRhYkluZGV4XCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSG9zdEJpbmRpbmcoJ2F0dHIuYXJpYS1kaXNhYmxlZCcpLFxuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5rLXN0YXRlLWRpc2FibGVkJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIENhbGVuZGFyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJhcmlhRGlzYWJsZWRcIiwgbnVsbCk7XG5DYWxlbmRhckNvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICBleHBvcnRBczogJ2tlbmRvLWNhbGVuZGFyJyxcbiAgICAgICAgcHJvdmlkZXJzOiBbXG4gICAgICAgICAgICBCdXNWaWV3U2VydmljZSxcbiAgICAgICAgICAgIENBTEVOREFSX1ZBTFVFX0FDQ0VTU09SLFxuICAgICAgICAgICAgQ0FMRU5EQVJfUkFOR0VfVkFMSURBVE9SUyxcbiAgICAgICAgICAgIEtFTkRPX0lOUFVUX1BST1ZJREVSLFxuICAgICAgICAgICAgTG9jYWxpemF0aW9uU2VydmljZSxcbiAgICAgICAgICAgIERpc2FibGVkRGF0ZXNTZXJ2aWNlLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHByb3ZpZGU6IEwxME5fUFJFRklYLFxuICAgICAgICAgICAgICAgIHVzZVZhbHVlOiAna2VuZG8uY2FsZW5kYXInXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgTmF2aWdhdGlvblNlcnZpY2UsXG4gICAgICAgICAgICBTY3JvbGxTeW5jU2VydmljZSxcbiAgICAgICAgICAgIFNlbGVjdGlvblNlcnZpY2VcbiAgICAgICAgXSxcbiAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1jYWxlbmRhcicsXG4gICAgICAgIHRlbXBsYXRlOiBgXG4gICAgPG5nLWNvbnRhaW5lciBrZW5kb0NhbGVuZGFyTG9jYWxpemVkTWVzc2FnZXNcbiAgICAgICAgaTE4bi10b2RheT1cImtlbmRvLmNhbGVuZGFyLnRvZGF5fFRoZSBsYWJlbCBmb3IgdGhlIHRvZGF5IGJ1dHRvbiBpbiB0aGUgY2FsZW5kYXIgaGVhZGVyXCJcbiAgICAgICAgdG9kYXk9XCJUb2RheVwiXG5cbiAgICAgICAgaTE4bi1wcmV2QnV0dG9uVGl0bGU9XCJrZW5kby5jYWxlbmRhci5wcmV2QnV0dG9uVGl0bGV8VGhlIHRpdGxlIG9mIHRoZSBwcmV2aW91cyBidXR0b24gaW4gdGhlIENsYXNzaWMgY2FsZW5kYXJcIlxuICAgICAgICBwcmV2QnV0dG9uVGl0bGU9XCJOYXZpZ2F0ZSB0byBwcmV2aW91cyB2aWV3XCJcblxuICAgICAgICBpMThuLW5leHRCdXR0b25UaXRsZT1cImtlbmRvLmNhbGVuZGFyLm5leHRCdXR0b25UaXRsZXxUaGUgdGl0bGUgb2YgdGhlIG5leHQgYnV0dG9uIGluIHRoZSBDbGFzc2ljIGNhbGVuZGFyXCJcbiAgICAgICAgbmV4dEJ1dHRvblRpdGxlPVwiTmF2aWdhdGUgdG8gbmV4dCB2aWV3XCJcbiAgICA+XG4gICAgPC9uZy1jb250YWluZXI+XG4gICAgPG5nLWNvbnRhaW5lciAqbmdJZj1cInR5cGUgPT09ICdpbmZpbml0ZSdcIj5cbiAgICAgICAgPGtlbmRvLWNhbGVuZGFyLW5hdmlnYXRpb25cbiAgICAgICAgICAgICpuZ0lmPVwibmF2aWdhdGlvblwiXG4gICAgICAgICAgICBbYWN0aXZlVmlld109XCJhY3RpdmVWaWV3RW51bVwiXG4gICAgICAgICAgICBbZm9jdXNlZERhdGVdPVwiZm9jdXNlZERhdGVcIlxuICAgICAgICAgICAgW21pbl09XCJtaW5cIlxuICAgICAgICAgICAgW21heF09XCJtYXhcIlxuICAgICAgICAgICAgW3RlbXBsYXRlUmVmXT1cIm5hdmlnYXRpb25JdGVtVGVtcGxhdGU/LnRlbXBsYXRlUmVmXCJcbiAgICAgICAgICAgICh2YWx1ZUNoYW5nZSk9XCJoYW5kbGVOYXZpZ2F0aW9uKCRldmVudClcIlxuICAgICAgICAgICAgKHBhZ2VDaGFuZ2UpPVwib25QYWdlQ2hhbmdlKClcIlxuICAgICAgICA+XG4gICAgICAgIDwva2VuZG8tY2FsZW5kYXItbmF2aWdhdGlvbj5cbiAgICAgICAgPGtlbmRvLWNhbGVuZGFyLXZpZXdsaXN0XG4gICAgICAgICAgICBbYWN0aXZlVmlld109XCJhY3RpdmVWaWV3RW51bVwiXG4gICAgICAgICAgICBbaXNBY3RpdmVdPVwiaXNBY3RpdmVcIlxuICAgICAgICAgICAgW2NlbGxUZW1wbGF0ZVJlZl09XCJhY3RpdmVDZWxsVGVtcGxhdGUoKT8udGVtcGxhdGVSZWZcIlxuICAgICAgICAgICAgW2hlYWRlclRpdGxlVGVtcGxhdGVSZWZdPVwiaGVhZGVyVGl0bGVUZW1wbGF0ZT8udGVtcGxhdGVSZWZcIlxuICAgICAgICAgICAgW3dlZWtOdW1iZXJUZW1wbGF0ZVJlZl09XCJ3ZWVrTnVtYmVyVGVtcGxhdGU/LnRlbXBsYXRlUmVmXCJcbiAgICAgICAgICAgIFtjZWxsVUlEXT1cImNlbGxVSURcIlxuICAgICAgICAgICAgW21pbl09XCJtaW5cIlxuICAgICAgICAgICAgW21heF09XCJtYXhcIlxuICAgICAgICAgICAgW2ZvY3VzZWREYXRlXT1cImZvY3VzZWREYXRlXCJcbiAgICAgICAgICAgIFt3ZWVrTnVtYmVyXT1cIndlZWtOdW1iZXJcIlxuICAgICAgICAgICAgW3NlbGVjdGVkRGF0ZXNdPVwic2VsZWN0ZWREYXRlc1wiXG4gICAgICAgICAgICAodG9kYXlCdXR0b25DbGljayk9XCJoYW5kbGVEYXRlQ2hhbmdlKHtcbiAgICAgICAgICAgICAgICBzZWxlY3RlZERhdGVzOiBbJGV2ZW50XSxcbiAgICAgICAgICAgICAgICBmb2N1c2VkRGF0ZTogJGV2ZW50XG4gICAgICAgICAgICB9KVwiXG4gICAgICAgICAgICAoY2VsbENsaWNrKT1cImhhbmRsZUNlbGxDbGljaygkZXZlbnQpXCJcbiAgICAgICAgICAgICh3ZWVrTnVtYmVyQ2VsbENsaWNrKT1cImhhbmRsZVdlZWtOdW1iZXJDbGljaygkZXZlbnQpXCJcbiAgICAgICAgICAgIChhY3RpdmVEYXRlQ2hhbmdlKT1cImVtaXRFdmVudChhY3RpdmVWaWV3RGF0ZUNoYW5nZSwgJGV2ZW50KVwiXG4gICAgICAgICAgICAocGFnZUNoYW5nZSk9XCJvblBhZ2VDaGFuZ2UoKVwiXG4gICAgICAgID5cbiAgICAgICAgPC9rZW5kby1jYWxlbmRhci12aWV3bGlzdD5cbiAgICAgICAgPGtlbmRvLXJlc2l6ZS1zZW5zb3IgKHJlc2l6ZSk9XCJvblJlc2l6ZSgpXCI+PC9rZW5kby1yZXNpemUtc2Vuc29yPlxuICAgIDwvbmctY29udGFpbmVyPlxuICAgIDxuZy1jb250YWluZXIgKm5nSWY9XCJ0eXBlID09PSAnY2xhc3NpYydcIj5cbiAgICAgICAgPGtlbmRvLW11bHRpdmlld2NhbGVuZGFyXG4gICAgICAgICAgICAjbXVsdGl2aWV3Y2FsZW5kYXJcbiAgICAgICAgICAgIFt2aWV3c109XCIxXCJcbiAgICAgICAgICAgIFttaW5dPVwibWluXCJcbiAgICAgICAgICAgIFttYXhdPVwibWF4XCJcbiAgICAgICAgICAgIFtpc0FjdGl2ZV09XCJpc0FjdGl2ZVwiXG4gICAgICAgICAgICBbYWN0aXZlVmlld109XCJhY3RpdmVWaWV3XCJcbiAgICAgICAgICAgIFtib3R0b21WaWV3XT1cImJvdHRvbVZpZXdcIlxuICAgICAgICAgICAgW3RvcFZpZXddPVwidG9wVmlld1wiXG4gICAgICAgICAgICBbd2Vla051bWJlcl09XCJ3ZWVrTnVtYmVyXCJcbiAgICAgICAgICAgIFthbmltYXRlTmF2aWdhdGlvbl09XCJhbmltYXRlTmF2aWdhdGlvblwiXG4gICAgICAgICAgICBbY2VsbFRlbXBsYXRlXT1cImFjdGl2ZUNlbGxUZW1wbGF0ZSgpXCJcbiAgICAgICAgICAgIFttb250aENlbGxUZW1wbGF0ZV09XCJtb250aENlbGxUZW1wbGF0ZVwiXG4gICAgICAgICAgICBbeWVhckNlbGxUZW1wbGF0ZV09XCJ5ZWFyQ2VsbFRlbXBsYXRlXCJcbiAgICAgICAgICAgIFtkZWNhZGVDZWxsVGVtcGxhdGVdPVwiZGVjYWRlQ2VsbFRlbXBsYXRlXCJcbiAgICAgICAgICAgIFtjZW50dXJ5Q2VsbFRlbXBsYXRlXT1cImNlbnR1cnlDZWxsVGVtcGxhdGVcIlxuICAgICAgICAgICAgW2hlYWRlclRpdGxlVGVtcGxhdGVdPVwiaGVhZGVyVGl0bGVUZW1wbGF0ZVwiXG4gICAgICAgICAgICBbd2Vla051bWJlclRlbXBsYXRlXT1cIndlZWtOdW1iZXJUZW1wbGF0ZVwiXG4gICAgICAgICAgICBbZm9jdXNlZERhdGVdPVwiZm9jdXNlZERhdGVcIlxuICAgICAgICAgICAgW3NlbGVjdGlvbl09XCJzZWxlY3Rpb25cIlxuICAgICAgICAgICAgW3ZhbHVlXT1cInZhbHVlXCJcbiAgICAgICAgICAgIFtkaXNhYmxlZERhdGVzXT1cImRpc2FibGVkRGF0ZXNcIlxuICAgICAgICAgICAgKGFjdGl2ZVZpZXdDaGFuZ2UpPVwiaGFuZGxlQWN0aXZlVmlld0NoYW5nZSgkZXZlbnQpXCJcbiAgICAgICAgICAgICh2YWx1ZUNoYW5nZSk9XCJoYW5kbGVNdWx0aVZpZXdDYWxlbmRhclZhbHVlQ2hhbmdlKCRldmVudCwgbXVsdGl2aWV3Y2FsZW5kYXIuZm9jdXNlZERhdGUpXCJcbiAgICAgICAgPlxuICAgICAgICAgICAgPGtlbmRvLW11bHRpdmlld2NhbGVuZGFyLW1lc3NhZ2VzXG4gICAgICAgICAgICAgICAgW3RvZGF5XT1cImxvY2FsaXphdGlvbi5nZXQoJ3RvZGF5JylcIlxuICAgICAgICAgICAgICAgIFtwcmV2QnV0dG9uVGl0bGVdPVwibG9jYWxpemF0aW9uLmdldCgncHJldkJ1dHRvblRpdGxlJylcIlxuICAgICAgICAgICAgICAgIFtuZXh0QnV0dG9uVGl0bGVdPVwibG9jYWxpemF0aW9uLmdldCgnbmV4dEJ1dHRvblRpdGxlJylcIlxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgPC9rZW5kby1tdWx0aXZpZXdjYWxlbmRhci1tZXNzYWdlcz5cbiAgICAgICAgPC9rZW5kby1tdWx0aXZpZXdjYWxlbmRhcj5cbiAgICA8L25nLWNvbnRhaW5lcj5cbiAgYFxuICAgIH0pLFxuICAgIF9fcGFyYW0oMTIsIE9wdGlvbmFsKCkpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQnVzVmlld1NlcnZpY2UsXG4gICAgICAgIENhbGVuZGFyRE9NU2VydmljZSxcbiAgICAgICAgRWxlbWVudFJlZixcbiAgICAgICAgTmF2aWdhdGlvblNlcnZpY2UsXG4gICAgICAgIFJlbmRlcmVyMixcbiAgICAgICAgQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gICAgICAgIE5nWm9uZSxcbiAgICAgICAgSW5qZWN0b3IsXG4gICAgICAgIFNjcm9sbFN5bmNTZXJ2aWNlLFxuICAgICAgICBEaXNhYmxlZERhdGVzU2VydmljZSxcbiAgICAgICAgTG9jYWxpemF0aW9uU2VydmljZSxcbiAgICAgICAgU2VsZWN0aW9uU2VydmljZSxcbiAgICAgICAgUGlja2VyU2VydmljZV0pXG5dLCBDYWxlbmRhckNvbXBvbmVudCk7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBpbmNvbXBsZXRlRGF0ZVZhbGlkYXRvciA9ICgpID0+IHtcbiAgICByZXR1cm4gKGNvbnRyb2wsIGluY29tcGxldGUpID0+IHtcbiAgICAgICAgaWYgKCFpc1ByZXNlbnQoY29udHJvbC52YWx1ZSkgJiYgaW5jb21wbGV0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgaW5jb21wbGV0ZURhdGU6IHRydWUgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbn07XG5cbi8qKlxuICogQGhpZGRlblxuICovXG52YXIgQXJyb3c7XG4oZnVuY3Rpb24gKEFycm93KSB7XG4gICAgQXJyb3dbQXJyb3dbXCJVcFwiXSA9IDBdID0gXCJVcFwiO1xuICAgIEFycm93W0Fycm93W1wiRG93blwiXSA9IDFdID0gXCJEb3duXCI7XG4gICAgQXJyb3dbQXJyb3dbXCJOb25lXCJdID0gMl0gPSBcIk5vbmVcIjtcbn0pKEFycm93IHx8IChBcnJvdyA9IHt9KSk7XG5cbnZhciBEYXRlSW5wdXRDb21wb25lbnRfMTtcbmNvbnN0IE1JTl9ET0NfTElOSyQxID0gJ2h0dHA6Ly93d3cudGVsZXJpay5jb20va2VuZG8tYW5ndWxhci11aS9jb21wb25lbnRzL2RhdGVpbnB1dHMvYXBpL0RhdGVJbnB1dENvbXBvbmVudC8jdG9jLW1pbic7XG5jb25zdCBNQVhfRE9DX0xJTkskMSA9ICdodHRwOi8vd3d3LnRlbGVyaWsuY29tL2tlbmRvLWFuZ3VsYXItdWkvY29tcG9uZW50cy9kYXRlaW5wdXRzL2FwaS9EYXRlSW5wdXRDb21wb25lbnQvI3RvYy1tYXgnO1xuY29uc3QgVkFMVUVfRE9DX0xJTkskMSA9ICdodHRwOi8vd3d3LnRlbGVyaWsuY29tL2tlbmRvLWFuZ3VsYXItdWkvY29tcG9uZW50cy9kYXRlaW5wdXRzL2RhdGVpbnB1dC8jdG9jLXVzaW5nLXdpdGgtanNvbic7XG5jb25zdCBEQVRFX1BBUlRfUkVHRVhQID0gL3llYXJ8bW9udGh8PGRheT4vO1xuY29uc3QgVElNRV9QQVJUX1JFR0VYUCA9IC9ob3VyfG1pbnV0ZXxzZWNvbmR8bWlsbGlzZWNvbmQvO1xuY29uc3QgU0hPUlRfUEFUVEVSTl9MRU5HVEhfUkVHRVhQID0gL2R8TXxIfGh8bXxzLztcbmNvbnN0IFRXT19ESUdJVF9ZRUFSX01BWCA9IDY4O1xuY29uc3QgUFJFVklPVVNfQ0VOVFVSWV9CQVNFID0gMTkwMDtcbmNvbnN0IENVUlJFTlRfQ0VOVFVSWV9CQVNFID0gMjAwMDtcbmNvbnN0IERFRkFVTFRfRk9STUFUID0gJ2QnO1xuY29uc3QgcGFkWmVybyA9IChsZW5ndGgpID0+IG5ldyBBcnJheShNYXRoLm1heChsZW5ndGgsIDApKS5maWxsKCcwJykuam9pbignJyk7XG5jb25zdCB1bnBhZFplcm8gPSAodmFsdWUpID0+IHZhbHVlLnJlcGxhY2UoL14wKi8sICcnKTtcbmNsYXNzIE1hc2sge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnN5bWJvbHMgPSBcIlwiO1xuICAgIH1cbn1cbmNsYXNzIEtlbmRvRGF0ZSB7XG4gICAgY29uc3RydWN0b3IoaW50bCwgZm9ybWF0UGxhY2Vob2xkZXIsIGZvcm1hdCwgdmFsdWUsIHR3b0RpZ2l0WWVhck1heCA9IFRXT19ESUdJVF9ZRUFSX01BWCkge1xuICAgICAgICB0aGlzLmludGwgPSBpbnRsO1xuICAgICAgICB0aGlzLmZvcm1hdFBsYWNlaG9sZGVyID0gZm9ybWF0UGxhY2Vob2xkZXI7XG4gICAgICAgIHRoaXMuZm9ybWF0ID0gZm9ybWF0O1xuICAgICAgICB0aGlzLnR3b0RpZ2l0WWVhck1heCA9IHR3b0RpZ2l0WWVhck1heDtcbiAgICAgICAgdGhpcy55ZWFyID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5tb250aCA9IHRydWU7XG4gICAgICAgIHRoaXMuZGF0ZSA9IHRydWU7XG4gICAgICAgIHRoaXMuaG91cnMgPSB0cnVlO1xuICAgICAgICB0aGlzLm1pbnV0ZXMgPSB0cnVlO1xuICAgICAgICB0aGlzLnNlY29uZHMgPSB0cnVlO1xuICAgICAgICB0aGlzLm1pbGxpc2Vjb25kcyA9IHRydWU7XG4gICAgICAgIHRoaXMubGVhZGluZ1plcm8gPSBudWxsO1xuICAgICAgICB0aGlzLm1vbnRoTmFtZXMgPSBudWxsO1xuICAgICAgICB0aGlzLnR5cGVkTW9udGhQYXJ0ID0gXCJcIjtcbiAgICAgICAgdGhpcy52YWx1ZSA9IGdldERhdGUobmV3IERhdGUoKSk7XG4gICAgICAgIHRoaXMua25vd25QYXJ0cyA9IFwiYWRIaG1Nc1NFeVwiO1xuICAgICAgICB0aGlzLnN5bWJvbHMgPSB7XG4gICAgICAgICAgICBcIkVcIjogXCJFXCIsXG4gICAgICAgICAgICBcIkhcIjogXCJIXCIsXG4gICAgICAgICAgICBcIk1cIjogXCJNXCIsXG4gICAgICAgICAgICBcImFcIjogXCJhXCIsXG4gICAgICAgICAgICBcImRcIjogXCJkXCIsXG4gICAgICAgICAgICBcImhcIjogXCJoXCIsXG4gICAgICAgICAgICBcIm1cIjogXCJtXCIsXG4gICAgICAgICAgICBcInNcIjogXCJzXCIsXG4gICAgICAgICAgICBcIlNcIjogXCJTXCIsXG4gICAgICAgICAgICBcInlcIjogXCJ5XCJcbiAgICAgICAgfTtcbiAgICAgICAgdmFsaWRhdGVQYWNrYWdlKHBhY2thZ2VNZXRhZGF0YSk7XG4gICAgICAgIHRoaXMubW9udGhOYW1lcyA9IHRoaXMuYWxsRm9ybWF0ZWRNb250aHMoKTtcbiAgICAgICAgdGhpcy5kYXlQZXJpb2RzID0gdGhpcy5hbGxEYXlQZXJpb2RzKCk7XG4gICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSBnZXREYXRlKG5ldyBEYXRlKCkpO1xuICAgICAgICAgICAgY29uc3Qgc2FtcGxlRm9ybWF0ID0gdGhpcy5kYXRlRm9ybWF0U3RyaW5nKHRoaXMudmFsdWUsIHRoaXMuZm9ybWF0KS5zeW1ib2xzO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzYW1wbGVGb3JtYXQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldEV4aXN0aW5nKHNhbXBsZUZvcm1hdFtpXSwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IGNsb25lRGF0ZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaGFzVmFsdWUoKSB7XG4gICAgICAgIGNvbnN0IHByZWQgPSAoYSwgcCkgPT4gYSB8fCBwLnR5cGUgIT09ICdsaXRlcmFsJyAmJiBwLnR5cGUgIT09ICdkYXlwZXJpb2QnICYmIHRoaXMuZ2V0RXhpc3RpbmcocC5wYXR0ZXJuWzBdKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50bC5zcGxpdERhdGVGb3JtYXQodGhpcy5mb3JtYXQpLnJlZHVjZShwcmVkLCBmYWxzZSk7XG4gICAgfVxuICAgIHNob3VsZE5vcm1hbGl6ZUNlbnR1cnkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmludGwuc3BsaXREYXRlRm9ybWF0KHRoaXMuZm9ybWF0KS5zb21lKHBhcnQgPT4gcGFydC5wYXR0ZXJuID09PSAneXknKTtcbiAgICB9XG4gICAgZ2V0RGF0ZU9iamVjdCgpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmtub3duUGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5nZXRFeGlzdGluZyh0aGlzLmtub3duUGFydHNbaV0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNsb25lRGF0ZSh0aGlzLnZhbHVlKTtcbiAgICB9XG4gICAgZ2V0VGV4dEFuZEZvcm1hdChmb3JtYXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWVyZ2UodGhpcy5pbnRsLmZvcm1hdERhdGUodGhpcy52YWx1ZSwgZm9ybWF0KSwgdGhpcy5kYXRlRm9ybWF0U3RyaW5nKHRoaXMudmFsdWUsIGZvcm1hdCkpO1xuICAgIH1cbiAgICBnZXRFeGlzdGluZyhzeW1ib2wpIHtcbiAgICAgICAgc3dpdGNoIChzeW1ib2wpIHtcbiAgICAgICAgICAgIGNhc2UgXCJ5XCI6IHJldHVybiB0aGlzLnllYXI7XG4gICAgICAgICAgICBjYXNlIFwiTVwiOlxuICAgICAgICAgICAgY2FzZSBcIkxcIjogcmV0dXJuIHRoaXMubW9udGg7XG4gICAgICAgICAgICBjYXNlIFwiZFwiOiByZXR1cm4gdGhpcy5kYXRlO1xuICAgICAgICAgICAgY2FzZSBcIkVcIjogcmV0dXJuIHRoaXMuZGF0ZSAmJiB0aGlzLm1vbnRoICYmIHRoaXMueWVhcjtcbiAgICAgICAgICAgIGNhc2UgXCJoXCI6XG4gICAgICAgICAgICBjYXNlIFwiSFwiOiByZXR1cm4gdGhpcy5ob3VycztcbiAgICAgICAgICAgIGNhc2UgXCJtXCI6IHJldHVybiB0aGlzLm1pbnV0ZXM7XG4gICAgICAgICAgICBjYXNlIFwic1wiOiByZXR1cm4gdGhpcy5zZWNvbmRzO1xuICAgICAgICAgICAgY2FzZSBcIlNcIjogcmV0dXJuIHRoaXMubWlsbGlzZWNvbmRzO1xuICAgICAgICAgICAgZGVmYXVsdDogcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0RXhpc3Rpbmcoc3ltYm9sLCB2YWx1ZSkge1xuICAgICAgICBzd2l0Y2ggKHN5bWJvbCkge1xuICAgICAgICAgICAgY2FzZSBcInlcIjpcbiAgICAgICAgICAgICAgICB0aGlzLnllYXIgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWUuc2V0RnVsbFllYXIoMjAwMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrOyAvL2FsbG93IDIvMjkgZGF0ZXNcbiAgICAgICAgICAgIGNhc2UgXCJNXCI6XG4gICAgICAgICAgICAgICAgdGhpcy5tb250aCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZS5zZXRNb250aCgwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7IC8vbWFrZSBzdXJlIHlvdSBjYW4gdHlwZSAzMSBhdCBkYXkgcGFydFxuICAgICAgICAgICAgY2FzZSBcImRcIjpcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJoXCI6XG4gICAgICAgICAgICBjYXNlIFwiSFwiOlxuICAgICAgICAgICAgICAgIHRoaXMuaG91cnMgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJtXCI6XG4gICAgICAgICAgICAgICAgdGhpcy5taW51dGVzID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwic1wiOlxuICAgICAgICAgICAgICAgIHRoaXMuc2Vjb25kcyA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIlNcIjpcbiAgICAgICAgICAgICAgICB0aGlzLm1pbGxpc2Vjb25kcyA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDogcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuICAgIG1vZGlmeVBhcnQoc3ltYm9sLCBvZmZzZXQpIHtcbiAgICAgICAgbGV0IG5ld1ZhbHVlID0gY2xvbmVEYXRlKHRoaXMudmFsdWUpO1xuICAgICAgICBzd2l0Y2ggKHN5bWJvbCkge1xuICAgICAgICAgICAgY2FzZSBcInlcIjpcbiAgICAgICAgICAgICAgICBuZXdWYWx1ZS5zZXRGdWxsWWVhcihuZXdWYWx1ZS5nZXRGdWxsWWVhcigpICsgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJNXCI6XG4gICAgICAgICAgICAgICAgbmV3VmFsdWUgPSBhZGRNb250aHModGhpcy52YWx1ZSwgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJkXCI6XG4gICAgICAgICAgICBjYXNlIFwiRVwiOlxuICAgICAgICAgICAgICAgIG5ld1ZhbHVlLnNldERhdGUobmV3VmFsdWUuZ2V0RGF0ZSgpICsgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJoXCI6XG4gICAgICAgICAgICBjYXNlIFwiSFwiOlxuICAgICAgICAgICAgICAgIG5ld1ZhbHVlLnNldEhvdXJzKG5ld1ZhbHVlLmdldEhvdXJzKCkgKyBvZmZzZXQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIm1cIjpcbiAgICAgICAgICAgICAgICBuZXdWYWx1ZS5zZXRNaW51dGVzKG5ld1ZhbHVlLmdldE1pbnV0ZXMoKSArIG9mZnNldCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwic1wiOlxuICAgICAgICAgICAgICAgIG5ld1ZhbHVlLnNldFNlY29uZHMobmV3VmFsdWUuZ2V0U2Vjb25kcygpICsgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJTXCI6XG4gICAgICAgICAgICAgICAgbmV3VmFsdWUuc2V0TWlsbGlzZWNvbmRzKG5ld1ZhbHVlLmdldE1pbGxpc2Vjb25kcygpICsgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJhXCI6XG4gICAgICAgICAgICAgICAgbmV3VmFsdWUuc2V0SG91cnMobmV3VmFsdWUuZ2V0SG91cnMoKSArICgxMiAqIG9mZnNldCkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDogYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc2hvdWxkTm9ybWFsaXplQ2VudHVyeSgpKSB7XG4gICAgICAgICAgICBuZXdWYWx1ZSA9IHRoaXMubm9ybWFsaXplQ2VudHVyeShuZXdWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5ld1ZhbHVlLmdldEZ1bGxZZWFyKCkgPiAwKSB7XG4gICAgICAgICAgICB0aGlzLnNldEV4aXN0aW5nKHN5bWJvbCwgdHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gbmV3VmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcGFyc2VQYXJ0KHN5bWJvbCwgY3VycmVudENoYXIsIHJlc2V0U2VnbWVudFZhbHVlKSB7XG4gICAgICAgIGlmICghY3VycmVudENoYXIpIHtcbiAgICAgICAgICAgIHRoaXMucmVzZXRMZWFkaW5nWmVybygpO1xuICAgICAgICAgICAgdGhpcy5zZXRFeGlzdGluZyhzeW1ib2wsIGZhbHNlKTtcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBudWxsLCBzd2l0Y2hUb05leHQ6IGZhbHNlIH07XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGJhc2VEYXRlID0gdGhpcy5pbnRsLmZvcm1hdERhdGUodGhpcy52YWx1ZSwgdGhpcy5mb3JtYXQpO1xuICAgICAgICBsZXQgZGF0ZVBhcnRzID0gdGhpcy5kYXRlRm9ybWF0U3RyaW5nKHRoaXMudmFsdWUsIHRoaXMuZm9ybWF0KTtcbiAgICAgICAgbGV0IGJhc2VGb3JtYXQgPSBkYXRlUGFydHMuc3ltYm9scztcbiAgICAgICAgbGV0IHJlcGxhY2VkID0gZmFsc2U7XG4gICAgICAgIGxldCBwcmVmaXggPSBcIlwiO1xuICAgICAgICBsZXQgY3VycmVudCA9IFwiXCI7XG4gICAgICAgIGxldCBzdWZmaXggPSBcIlwiO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJhc2VEYXRlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoYmFzZUZvcm1hdFtpXSA9PT0gc3ltYm9sKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudCArPSB0aGlzLmdldEV4aXN0aW5nKHN5bWJvbCkgPyBiYXNlRGF0ZVtpXSA6IFwiMFwiO1xuICAgICAgICAgICAgICAgIHJlcGxhY2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFyZXBsYWNlZCkge1xuICAgICAgICAgICAgICAgIHByZWZpeCArPSBiYXNlRGF0ZVtpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHN1ZmZpeCArPSBiYXNlRGF0ZVtpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgY3VycmVudE1heExlbmd0aCA9IGN1cnJlbnQubGVuZ3RoIC0gMztcbiAgICAgICAgbGV0IHBhcnNlZERhdGUgPSBudWxsO1xuICAgICAgICBjb25zdCBtb250aCA9IHRoaXMubWF0Y2hNb250aChjdXJyZW50Q2hhcik7XG4gICAgICAgIGNvbnN0IGRheVBlcmlvZCA9IHRoaXMubWF0Y2hEYXlQZXJpb2QoY3VycmVudENoYXIsIHN5bWJvbCk7XG4gICAgICAgIGNvbnN0IGlzWmVyb0N1cnJlbnRDaGFyID0gY3VycmVudENoYXIgPT09ICcwJztcbiAgICAgICAgY29uc3QgbGVhZGluZ1plcm8gPSAodGhpcy5sZWFkaW5nWmVybyB8fCB7fSlbc3ltYm9sXSB8fCAwO1xuICAgICAgICBpZiAoaXNaZXJvQ3VycmVudENoYXIpIHtcbiAgICAgICAgICAgIGxldCB2YWx1ZU51bWJlciA9IHBhcnNlSW50KHJlc2V0U2VnbWVudFZhbHVlID8gY3VycmVudENoYXIgOiBjdXJyZW50ICsgY3VycmVudENoYXIsIDEwKTtcbiAgICAgICAgICAgIGlmICh2YWx1ZU51bWJlciA9PT0gMCAmJiAhdGhpcy5pc0FiYnJNb250aChkYXRlUGFydHMucGFydE1hcCwgc3ltYm9sKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5jcmVtZW50TGVhZGluZ1plcm8oc3ltYm9sKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucmVzZXRMZWFkaW5nWmVybygpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSBNYXRoLm1heCgwLCBjdXJyZW50TWF4TGVuZ3RoKTsgaSA8PSBjdXJyZW50Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgbWlkZGxlID0gcmVzZXRTZWdtZW50VmFsdWUgPyBjdXJyZW50Q2hhciA6IChjdXJyZW50LnN1YnN0cmluZyhpKSArIGN1cnJlbnRDaGFyKTtcbiAgICAgICAgICAgIGlmIChzeW1ib2wgPT09IFwiU1wiICYmIHJlc2V0U2VnbWVudFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIFwiU1wiIHBhcnNlciBpbiBpbnRsIHBhcnNlcyBcIjFcIiBhcyAxMDBtcyBpbiBvcmRlciB0byBoYW5kbGUgSVNPU3RyaW5nIGRhdGVzIGNvcnJlY3RseSwgc28gdG8gZ2V0IDFtcywgd2UgbmVlZCB0byBwYXNzIFwiMDAxXCJcbiAgICAgICAgICAgICAgICBjb25zdCBwYWRkaW5nID0gbXNQYWRkaW5nRnJvbUZvcm1hdChiYXNlRm9ybWF0KTtcbiAgICAgICAgICAgICAgICBtaWRkbGUgPSBwYWRkaW5nICsgbWlkZGxlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IG1pZGRsZU51bWJlciA9IHBhcnNlSW50KG1pZGRsZSwgMTApO1xuICAgICAgICAgICAgcGFyc2VkRGF0ZSA9IHRoaXMuaW50bC5wYXJzZURhdGUocHJlZml4ICsgbWlkZGxlICsgc3VmZml4LCB0aGlzLmZvcm1hdCk7XG4gICAgICAgICAgICBpZiAoIXBhcnNlZERhdGUgJiYgIWlzTmFOKG1pZGRsZU51bWJlcikgJiYgIWlzTmFOKHBhcnNlSW50KGN1cnJlbnRDaGFyLCAxMCkpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN5bWJvbCA9PT0gJ00nICYmICFtb250aCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtb250aE51bWJlciA9IG1pZGRsZU51bWJlciAtIDE7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtb250aE51bWJlciA+IC0xICYmIG1vbnRoTnVtYmVyIDwgMTIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlZERhdGUgPSBjbG9uZURhdGUodGhpcy52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZWREYXRlLnNldE1vbnRoKG1vbnRoTnVtYmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJzZWREYXRlLmdldE1vbnRoKCkgIT09IG1vbnRoTnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VkRGF0ZSA9IGxhc3REYXlPZk1vbnRoKGFkZE1vbnRocyhwYXJzZWREYXRlLCAtMSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzeW1ib2wgPT09ICd5Jykge1xuICAgICAgICAgICAgICAgICAgICBwYXJzZWREYXRlID0gY3JlYXRlRGF0ZShwYXJzZUludChtaWRkbGUsIDEwKSwgdGhpcy5tb250aCA/IHRoaXMudmFsdWUuZ2V0TW9udGgoKSA6IDAsIHRoaXMuZGF0ZSA/IHRoaXMudmFsdWUuZ2V0RGF0ZSgpIDogMSwgdGhpcy5ob3VycyA/IHRoaXMudmFsdWUuZ2V0SG91cnMoKSA6IDAsIHRoaXMubWludXRlcyA/IHRoaXMudmFsdWUuZ2V0TWludXRlcygpIDogMCwgdGhpcy5zZWNvbmRzID8gdGhpcy52YWx1ZS5nZXRTZWNvbmRzKCkgOiAwLCB0aGlzLm1pbGxpc2Vjb25kcyA/IHRoaXMudmFsdWUuZ2V0TWlsbGlzZWNvbmRzKCkgOiAwKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZGF0ZSAmJiBwYXJzZWREYXRlLmdldERhdGUoKSAhPT0gdGhpcy52YWx1ZS5nZXREYXRlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlZERhdGUgPSBsYXN0RGF5T2ZNb250aChhZGRNb250aHMocGFyc2VkRGF0ZSwgLTEpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXJzZWREYXRlKSB7XG4gICAgICAgICAgICAgICAgLy9tb3ZlIHRvIG5leHQgc2VnbWVudCBpZiB0aGUgcGFydCB3aWxsIG92ZXJmbG93IHdpdGggbmV4dCBjaGFyXG4gICAgICAgICAgICAgICAgLy93aGVuIHN0YXJ0IGZyb20gZW1wdHkgZGF0ZSAoMDEsIHRoZW4gMDEwKSwgcGFkZGVkIHplcm9zIHNob3VsZCBiZSB0cmltbWVkXG4gICAgICAgICAgICAgICAgY29uc3QgcGF0dGVyblZhbHVlID0gdGhpcy5wYXJ0UGF0dGVybihkYXRlUGFydHMucGFydE1hcCwgc3ltYm9sKS5wYXR0ZXJuO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBlZWtEYXRlID0gdGhpcy5pbnRsLnBhcnNlRGF0ZShgJHtwcmVmaXh9JHt0aGlzLnBlZWsobWlkZGxlLCBwYXR0ZXJuVmFsdWUpfSR7c3VmZml4fWAsIHRoaXMuZm9ybWF0KTtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXR0ZXJuTGVuZ3RoID0gdGhpcy5wYXR0ZXJuTGVuZ3RoKHBhdHRlcm5WYWx1ZSkgfHwgcGF0dGVyblZhbHVlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXR0ZXJuU2F0aXNmaWVkID0gKGxlYWRpbmdaZXJvICsgKHVucGFkWmVybyhtaWRkbGUpIHx8IGN1cnJlbnRDaGFyKS5sZW5ndGgpID49IHBhdHRlcm5MZW5ndGg7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3dpdGNoVG9OZXh0ID0gcGVla0RhdGUgPT09IG51bGwgfHwgcGF0dGVyblNhdGlzZmllZDtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zaG91bGROb3JtYWxpemVDZW50dXJ5KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VkRGF0ZSA9IHRoaXMubm9ybWFsaXplQ2VudHVyeShwYXJzZWREYXRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHBhcnNlZERhdGU7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRFeGlzdGluZyhzeW1ib2wsIHRydWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiB0aGlzLnZhbHVlLCBzd2l0Y2hUb05leHQ6IHN3aXRjaFRvTmV4dCB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChtb250aCkge1xuICAgICAgICAgICAgcGFyc2VkRGF0ZSA9IHRoaXMuaW50bC5wYXJzZURhdGUocHJlZml4ICsgbW9udGggKyBzdWZmaXgsIHRoaXMuZm9ybWF0KTtcbiAgICAgICAgICAgIGlmIChwYXJzZWREYXRlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHBhcnNlZERhdGU7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRFeGlzdGluZyhzeW1ib2wsIHRydWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiB0aGlzLnZhbHVlLCBzd2l0Y2hUb05leHQ6IGZhbHNlIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRheVBlcmlvZCkge1xuICAgICAgICAgICAgcGFyc2VkRGF0ZSA9IHRoaXMuaW50bC5wYXJzZURhdGUocHJlZml4ICsgZGF5UGVyaW9kICsgc3VmZml4LCB0aGlzLmZvcm1hdCk7XG4gICAgICAgICAgICBpZiAocGFyc2VkRGF0ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSBwYXJzZWREYXRlO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiB0aGlzLnZhbHVlLCBzd2l0Y2hUb05leHQ6IHRydWUgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNaZXJvQ3VycmVudENoYXIpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0RXhpc3Rpbmcoc3ltYm9sLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG51bGwsIHN3aXRjaFRvTmV4dDogZmFsc2UgfTtcbiAgICB9XG4gICAgcmVzZXRMZWFkaW5nWmVybygpIHtcbiAgICAgICAgY29uc3QgaGFzTGVhZGluZ1plcm8gPSB0aGlzLmxlYWRpbmdaZXJvICE9PSBudWxsO1xuICAgICAgICB0aGlzLnNldExlYWRpbmdaZXJvKG51bGwpO1xuICAgICAgICByZXR1cm4gaGFzTGVhZGluZ1plcm87XG4gICAgfVxuICAgIHNldExlYWRpbmdaZXJvKGxlYWRpbmdaZXJvKSB7XG4gICAgICAgIHRoaXMubGVhZGluZ1plcm8gPSBsZWFkaW5nWmVybztcbiAgICB9XG4gICAgbm9ybWFsaXplQ2VudHVyeShkYXRlKSB7XG4gICAgICAgIGlmICghaXNQcmVzZW50KGRhdGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0d29EaWdpdFllYXIgPSBjcm9wVHdvRGlnaXRZZWFyKGRhdGUpO1xuICAgICAgICBjb25zdCBjZW50dXJ5QmFzZSA9IHRoaXMuZ2V0Tm9ybWFsaXplZENlbnR1cnlCYXNlKHR3b0RpZ2l0WWVhcik7XG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZWREYXRlID0gc2V0WWVhcnMoZGF0ZSwgY2VudHVyeUJhc2UgKyB0d29EaWdpdFllYXIpO1xuICAgICAgICByZXR1cm4gbm9ybWFsaXplZERhdGU7XG4gICAgfVxuICAgIGluY3JlbWVudExlYWRpbmdaZXJvKHN5bWJvbCkge1xuICAgICAgICBjb25zdCBsZWFkaW5nWmVybyA9IHRoaXMubGVhZGluZ1plcm8gfHwge307XG4gICAgICAgIGxlYWRpbmdaZXJvW3N5bWJvbF0gPSAobGVhZGluZ1plcm9bc3ltYm9sXSB8fCAwKSArIDE7XG4gICAgICAgIHRoaXMubGVhZGluZ1plcm8gPSBsZWFkaW5nWmVybztcbiAgICB9XG4gICAgaXNBYmJyTW9udGgocGFydHMsIHN5bWJvbCkge1xuICAgICAgICBjb25zdCBwYXR0ZXJuID0gdGhpcy5wYXJ0UGF0dGVybihwYXJ0cywgc3ltYm9sKTtcbiAgICAgICAgcmV0dXJuIHBhdHRlcm4udHlwZSA9PT0gJ21vbnRoJyAmJiBwYXR0ZXJuLm5hbWVzO1xuICAgIH1cbiAgICBwYXJ0UGF0dGVybihwYXJ0cywgc3ltYm9sKSB7XG4gICAgICAgIHJldHVybiBwYXJ0cy5maWx0ZXIoKHBhcnQpID0+IHBhcnQucGF0dGVybi5pbmRleE9mKHN5bWJvbCkgIT09IC0xKVswXTtcbiAgICB9XG4gICAgcGVlayh2YWx1ZSwgcGF0dGVybikge1xuICAgICAgICBjb25zdCBwZWVrVmFsdWUgPSB1bnBhZFplcm8odmFsdWUpICsgJzAnO1xuICAgICAgICByZXR1cm4gcGFkWmVybyhwYXR0ZXJuLmxlbmd0aCAtIHBlZWtWYWx1ZS5sZW5ndGgpICsgcGVla1ZhbHVlO1xuICAgIH1cbiAgICBtYXRjaE1vbnRoKHR5cGVkQ2hhcikge1xuICAgICAgICB0aGlzLnR5cGVkTW9udGhQYXJ0ICs9IHR5cGVkQ2hhci50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAoIXRoaXMubW9udGhOYW1lcykge1xuICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKHRoaXMudHlwZWRNb250aFBhcnQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm1vbnRoTmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5tb250aE5hbWVzW2ldLnRvTG93ZXJDYXNlKCkuaW5kZXhPZih0aGlzLnR5cGVkTW9udGhQYXJ0KSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5tb250aE5hbWVzW2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG1vbnRoQXNOdW0gPSBwYXJzZUludCh0aGlzLnR5cGVkTW9udGhQYXJ0LCAxMCk7XG4gICAgICAgICAgICBpZiAobW9udGhBc051bSA+PSAxICYmIG1vbnRoQXNOdW0gPD0gMTIgJiYgbW9udGhBc051bS50b1N0cmluZygpID09PSB0aGlzLnR5cGVkTW9udGhQYXJ0IC8qZW5zdXJlIHRoZXkgZXhhY3QgbWF0Y2gqLykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm1vbnRoTmFtZXNbbW9udGhBc051bSAtIDFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy50eXBlZE1vbnRoUGFydCA9IHRoaXMudHlwZWRNb250aFBhcnQuc3Vic3RyaW5nKDEsIHRoaXMudHlwZWRNb250aFBhcnQubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG4gICAgbWF0Y2hEYXlQZXJpb2QodHlwZWRDaGFyLCBzeW1ib2wpIHtcbiAgICAgICAgY29uc3QgbG93ZXJDaGFydCA9IFN0cmluZyh0eXBlZENoYXIpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmIChzeW1ib2wgPT09ICdhJyAmJiB0aGlzLmRheVBlcmlvZHMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRheVBlcmlvZHMuYW0udG9Mb3dlckNhc2UoKS5zdGFydHNXaXRoKGxvd2VyQ2hhcnQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF5UGVyaW9kcy5hbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuZGF5UGVyaW9kcy5wbS50b0xvd2VyQ2FzZSgpLnN0YXJ0c1dpdGgobG93ZXJDaGFydCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kYXlQZXJpb2RzLnBtO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgYWxsRm9ybWF0ZWRNb250aHMoKSB7XG4gICAgICAgIGNvbnN0IGRhdGVGb3JtYXRQYXJ0cyA9IHRoaXMuaW50bC5zcGxpdERhdGVGb3JtYXQodGhpcy5mb3JtYXQpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGVGb3JtYXRQYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGRhdGVGb3JtYXRQYXJ0c1tpXS50eXBlID09PSBcIm1vbnRoXCIgJiYgZGF0ZUZvcm1hdFBhcnRzW2ldLm5hbWVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW50bC5kYXRlRm9ybWF0TmFtZXMoZGF0ZUZvcm1hdFBhcnRzW2ldLm5hbWVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgYWxsRGF5UGVyaW9kcygpIHtcbiAgICAgICAgY29uc3QgZGF0ZUZvcm1hdFBhcnRzID0gdGhpcy5pbnRsLnNwbGl0RGF0ZUZvcm1hdCh0aGlzLmZvcm1hdCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0ZUZvcm1hdFBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoZGF0ZUZvcm1hdFBhcnRzW2ldLnR5cGUgPT09IFwiZGF5cGVyaW9kXCIgJiYgZGF0ZUZvcm1hdFBhcnRzW2ldLm5hbWVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW50bC5kYXRlRm9ybWF0TmFtZXMoZGF0ZUZvcm1hdFBhcnRzW2ldLm5hbWVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcGF0dGVybkxlbmd0aChwYXR0ZXJuKSB7XG4gICAgICAgIGlmIChwYXR0ZXJuWzBdID09PSAneScpIHtcbiAgICAgICAgICAgIHJldHVybiA0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChTSE9SVF9QQVRURVJOX0xFTkdUSF9SRUdFWFAudGVzdChwYXR0ZXJuKSkge1xuICAgICAgICAgICAgcmV0dXJuIDI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIC8vVE9ETzogUkVNT1ZFIVxuICAgIGRhdGVGb3JtYXRTdHJpbmcoZGF0ZSwgZm9ybWF0KSB7XG4gICAgICAgIGNvbnN0IGRhdGVGb3JtYXRQYXJ0cyA9IHRoaXMuaW50bC5zcGxpdERhdGVGb3JtYXQoZm9ybWF0KTtcbiAgICAgICAgY29uc3QgcGFydHMgPSBbXTtcbiAgICAgICAgY29uc3QgcGFydE1hcCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGVGb3JtYXRQYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHBhcnRMZW5ndGggPSB0aGlzLmludGwuZm9ybWF0RGF0ZShkYXRlLCB7IHBhdHRlcm46IGRhdGVGb3JtYXRQYXJ0c1tpXS5wYXR0ZXJuIH0pLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlIChwYXJ0TGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHBhcnRzLnB1c2godGhpcy5zeW1ib2xzW2RhdGVGb3JtYXRQYXJ0c1tpXS5wYXR0ZXJuWzBdXSB8fCBcIl9cIik7XG4gICAgICAgICAgICAgICAgcGFydE1hcC5wdXNoKGRhdGVGb3JtYXRQYXJ0c1tpXSk7XG4gICAgICAgICAgICAgICAgcGFydExlbmd0aC0tO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJldHVyblZhbHVlID0gbmV3IE1hc2soKTtcbiAgICAgICAgcmV0dXJuVmFsdWUuc3ltYm9scyA9IHBhcnRzLmpvaW4oXCJcIik7XG4gICAgICAgIHJldHVyblZhbHVlLnBhcnRNYXAgPSBwYXJ0TWFwO1xuICAgICAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG4gICAgfVxuICAgIG1lcmdlKHRleHQsIG1hc2spIHtcbiAgICAgICAgLy8gSW1wb3J0YW50OiByaWdodCB0byBsZWZ0LlxuICAgICAgICBsZXQgcmVzdWx0VGV4dCA9IFwiXCI7XG4gICAgICAgIGxldCByZXN1bHRGb3JtYXQgPSBcIlwiO1xuICAgICAgICBsZXQgZm9ybWF0ID0gbWFzay5zeW1ib2xzO1xuICAgICAgICBmb3IgKGxldCByID0gZm9ybWF0Lmxlbmd0aCAtIDE7IHIgPj0gMDsgci0tKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5rbm93blBhcnRzLmluZGV4T2YoZm9ybWF0W3JdKSA9PT0gLTEgfHwgdGhpcy5nZXRFeGlzdGluZyhmb3JtYXRbcl0pKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0VGV4dCA9IHRleHRbcl0gKyByZXN1bHRUZXh0O1xuICAgICAgICAgICAgICAgIHJlc3VsdEZvcm1hdCA9IGZvcm1hdFtyXSArIHJlc3VsdEZvcm1hdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRTeW1ib2wgPSBmb3JtYXRbcl07XG4gICAgICAgICAgICAgICAgd2hpbGUgKHIgPj0gMCAmJiBjdXJyZW50U3ltYm9sID09PSBmb3JtYXRbcl0pIHtcbiAgICAgICAgICAgICAgICAgICAgci0tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByKys7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubGVhZGluZ1plcm8gJiYgdGhpcy5sZWFkaW5nWmVyb1tjdXJyZW50U3ltYm9sXSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRUZXh0ID0gJzAnICsgcmVzdWx0VGV4dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFRleHQgPSB0aGlzLmRhdGVGaWVsZE5hbWUobWFzay5wYXJ0TWFwW3JdKSArIHJlc3VsdFRleHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHdoaWxlIChyZXN1bHRGb3JtYXQubGVuZ3RoIDwgcmVzdWx0VGV4dC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0Rm9ybWF0ID0gZm9ybWF0W3JdICsgcmVzdWx0Rm9ybWF0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW3Jlc3VsdFRleHQsIHJlc3VsdEZvcm1hdF07XG4gICAgfVxuICAgIGRhdGVGaWVsZE5hbWUocGFydCkge1xuICAgICAgICBjb25zdCBmb3JtYXRQbGFjZWhvbGRlciA9IHRoaXMuZm9ybWF0UGxhY2Vob2xkZXIgfHwgJ3dpZGUnO1xuICAgICAgICBpZiAoZm9ybWF0UGxhY2Vob2xkZXJbcGFydC50eXBlXSkge1xuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdFBsYWNlaG9sZGVyW3BhcnQudHlwZV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZvcm1hdFBsYWNlaG9sZGVyID09PSAnZm9ybWF0UGF0dGVybicpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJ0LnBhdHRlcm47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuaW50bC5kYXRlRmllbGROYW1lKE9iamVjdC5hc3NpZ24ocGFydCwgeyBuYW1lVHlwZTogZm9ybWF0UGxhY2Vob2xkZXIgfSkpO1xuICAgIH1cbiAgICBnZXROb3JtYWxpemVkQ2VudHVyeUJhc2UodHdvRGlnaXRZZWFyKSB7XG4gICAgICAgIHJldHVybiB0d29EaWdpdFllYXIgPiB0aGlzLnR3b0RpZ2l0WWVhck1heCA/XG4gICAgICAgICAgICBQUkVWSU9VU19DRU5UVVJZX0JBU0UgOlxuICAgICAgICAgICAgQ1VSUkVOVF9DRU5UVVJZX0JBU0U7XG4gICAgfVxufVxuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBbS2VuZG8gVUkgRGF0ZUlucHV0IGNvbXBvbmVudCBmb3IgQW5ndWxhcl0oeyUgc2x1ZyBvdmVydmlld19kYXRlaW5wdXQgJX0jdG9jLWJhc2ljLXVzYWdlKS5cbiAqL1xubGV0IERhdGVJbnB1dENvbXBvbmVudCA9IERhdGVJbnB1dENvbXBvbmVudF8xID0gY2xhc3MgRGF0ZUlucHV0Q29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcihjZHIsIGludGwsIHJlbmRlcmVyLCBlbGVtZW50LCBuZ1pvbmUsIGluamVjdG9yLCBsb2NhbGl6YXRpb24sIHBpY2tlclNlcnZpY2UpIHtcbiAgICAgICAgdGhpcy5jZHIgPSBjZHI7XG4gICAgICAgIHRoaXMuaW50bCA9IGludGw7XG4gICAgICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICAgICAgdGhpcy5uZ1pvbmUgPSBuZ1pvbmU7XG4gICAgICAgIHRoaXMuaW5qZWN0b3IgPSBpbmplY3RvcjtcbiAgICAgICAgdGhpcy5sb2NhbGl6YXRpb24gPSBsb2NhbGl6YXRpb247XG4gICAgICAgIHRoaXMucGlja2VyU2VydmljZSA9IHBpY2tlclNlcnZpY2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaGlkZGVuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmZvY3VzYWJsZUlkID0gYGstJHtndWlkKCl9YDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgb3IgZ2V0cyB0aGUgYGRpc2FibGVkYCBwcm9wZXJ0eSBvZiB0aGUgRGF0ZUlucHV0IGFuZFxuICAgICAgICAgKiBkZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGNvbXBvbmVudCBpcyBhY3RpdmVcbiAgICAgICAgICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBkaXNhYmxlZF9kYXRlaW5wdXQgJX0pKS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgb3IgZ2V0cyB0aGUgcmVhZC1vbmx5IHN0YXRlIG9mIHRoZSBEYXRlSW5wdXRcbiAgICAgICAgICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyByZWFkb25seV9kYXRlaW5wdXQgJX0pKS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVhZG9ubHkgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgdGhlIHRpdGxlIG9mIHRoZSBpbnB1dCBlbGVtZW50IG9mIHRoZSBEYXRlSW5wdXQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRpdGxlID0gXCJcIjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgb3IgZ2V0cyB0aGUgYHRhYkluZGV4YCBwcm9wZXJ0eSBvZiB0aGUgRGF0ZUlucHV0LlxuICAgICAgICAgKiAuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRhYmluZGV4ID0gMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBoaWRkZW5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucm9sZSA9ICdzcGluYnV0dG9uJztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBoaWRkZW5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYXJpYVJlYWRPbmx5ID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVjaWZpZXMgdGhlIGRhdGUgZm9ybWF0IHRoYXQgaXMgdXNlZCB0byBkaXNwbGF5IHRoZSBpbnB1dCB2YWx1ZVxuICAgICAgICAgKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGZvcm1hdHNfZGF0ZWlucHV0ICV9KSkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEZvcm1hdCB2YWx1ZSBvcHRpb25zOlxuICAgICAgICAgKiAtIGBzdHJpbmdgIC0gUHJvdmlkZSBhIGBzdHJpbmdgIGlmIGEgc2luZ2xlIGZvcm1hdCBpcyBnb2luZyB0byBiZSB1c2VkIHJlZ2FyZGxlc3Mgd2hldGhlciB0aGUgaW5wdXQgaXMgZm9jdXNlZCBvciBibHVycmVkLlxuICAgICAgICAgKiAtIFtgRm9ybWF0U2V0dGluZ3NgXSh7JSBzbHVnIGFwaV9kYXRlaW5wdXRzX2Zvcm1hdHNldHRpbmdzICV9KSAtIFRvIGRpc3BsYXkgZGlmZmVyZW50IGZvcm1hdHMgd2hlbiB0aGUgY29tcG9uZW50IGlzIGZvY3VzZWQgb3IgYmx1cnJlZCwgcHJvdmlkZSBhIHNldHRpbmdzIG9iamVjdCB3aXRoIHNwZWNpZmllZCBgaW5wdXRGb3JtYXRgIGFuZCBgZGlzcGxheUZvcm1hdGAgdmFsdWVzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5mb3JtYXQgPSBERUZBVUxUX0ZPUk1BVDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZmllcyB0aGUgaGludCB0aGUgRGF0ZUlucHV0IGRpc3BsYXlzIHdoZW4gaXRzIHZhbHVlIGlzIGBudWxsYC5cbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBhcnRpY2xlIG9uXG4gICAgICAgICAqIFtwbGFjZWhvbGRlcnNdKHslIHNsdWcgcGxhY2Vob2xkZXJzX2RhdGVpbnB1dCAlfSkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIGBgYHRzXG4gICAgICAgICAqIF9AQ29tcG9uZW50KHtcbiAgICAgICAgICogc2VsZWN0b3I6ICdteS1hcHAnLFxuICAgICAgICAgKiB0ZW1wbGF0ZTogYFxuICAgICAgICAgKiAgPGtlbmRvLWRhdGVpbnB1dCBwbGFjZWhvbGRlcj1cIkVudGVyIGJpcnRoIGRhdGUuLi5cIj48L2tlbmRvLWRhdGVpbnB1dD5cbiAgICAgICAgICogYFxuICAgICAgICAgKiB9KVxuICAgICAgICAgKiBleHBvcnQgY2xhc3MgQXBwQ29tcG9uZW50IHsgfVxuICAgICAgICAgKiBgYGBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucGxhY2Vob2xkZXIgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ29uZmlndXJlcyB0aGUgaW5jcmVtZW50YWwgc3RlcHMgb2YgdGhlIERhdGVJbnB1dC5cbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBhcnRpY2xlIG9uXG4gICAgICAgICAqIFtpbmNyZW1lbnRhbCBzdGVwc10oeyUgc2x1ZyBpbmNyZW1lbnRhbHN0ZXBzX2RhdGVpbnB1dCAlfSkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIGBgYHRzXG4gICAgICAgICAqIF9AQ29tcG9uZW50KHtcbiAgICAgICAgICogc2VsZWN0b3I6ICdteS1hcHAnLFxuICAgICAgICAgKiB0ZW1wbGF0ZTogYFxuICAgICAgICAgKiAgPGtlbmRvLWRhdGVpbnB1dCBbc3RlcHNdPVwic3RlcHNcIj48L2tlbmRvLWRhdGVpbnB1dD5cbiAgICAgICAgICogYFxuICAgICAgICAgKiB9KVxuICAgICAgICAgKiBleHBvcnQgY2xhc3MgQXBwQ29tcG9uZW50IHtcbiAgICAgICAgICogICBwdWJsaWMgc3RlcHMgPSB7IHllYXI6IDEwLCBtb250aDogMSwgZGF5OiA1IH07XG4gICAgICAgICAqIH1cbiAgICAgICAgICogYGBgXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0ZXBzID0ge307XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGJ1aWx0LWluIG1pbiBvciBtYXggdmFsaWRhdG9ycyBhcmUgdG8gYmUgZW5mb3JjZWQgd2hlbiBhIGZvcm0gaXMgYmVpbmcgdmFsaWRhdGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yYW5nZVZhbGlkYXRpb24gPSB0cnVlO1xuICAgICAgICAvKipcbiAgICAgICAgICogQGhpZGRlblxuICAgICAgICAgKiBCYXNlZCBvbiB0aGUgbWluIGFuZCBtYXggdmFsdWVzLCBzcGVjaWZpZXMgd2hldGhlciB0aGUgdmFsdWUgd2lsbCBiZSBhdXRvLWNvcnJlY3RlZCB3aGlsZSB0eXBpbmcuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmF1dG9Db3JyZWN0ID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGJ1aWx0LWluIHZhbGlkYXRpb24gZm9yIGluY29tcGxldGUgZGF0ZXMgaXMgdG8gYmUgZW5mb3JjZWQgd2hlbiBhIGZvcm0gaXMgYmVpbmcgdmFsaWRhdGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pbmNvbXBsZXRlRGF0ZVZhbGlkYXRpb24gPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBtYXhpbXVtIHllYXIgdG8gYXNzdW1lIHRvIGJlIGZyb20gdGhlIGN1cnJlbnQgY2VudHVyeSB3aGVuIHR5cGluZyB0d28tZGlnaXQgeWVhciB2YWx1ZVxuICAgICAgICAgKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGZvcm1hdHNfZGF0ZWlucHV0ICV9I3RvYy10d28tZGlnaXQteWVhci1mb3JtYXQpKS5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhlIGRlZmF1bHQgdmFsdWUgaXMgNjgsIGluZGljYXRpbmcgdGhhdCB0eXBpbmcgYW55IHZhbHVlIGxlc3MgdGhhbiA2OVxuICAgICAgICAgKiB3aWxsIGJlIGFzc3VtZWQgdG8gYmUgMjB4eCwgd2hpbGUgNjkgYW5kIGxhcmdlciB3aWxsIGJlIGFzc3VtZWQgdG8gYmUgMTl4eC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudHdvRGlnaXRZZWFyTWF4ID0gVFdPX0RJR0lUX1lFQVJfTUFYO1xuICAgICAgICAvKipcbiAgICAgICAgICogU3BlY2lmaWVzIHdoZXRoZXIgdGhlICoqVXAqKiBhbmQgKipEb3duKiogc3BpbiBidXR0b25zIHdpbGwgYmUgcmVuZGVyZWQuXG4gICAgICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgYXJ0aWNsZSBvblxuICAgICAgICAgKiBbc3Bpbm5lciBidXR0b25zXSh7JSBzbHVnIHNwaW5idXR0b25zX2RhdGVpbnB1dCAlfSkuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNwaW5uZXJzID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaGlkZGVuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmlzUG9wdXBPcGVuID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaGlkZGVuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmhhc1BvcHVwID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyBlYWNoIHRpbWUgdGhlIHVzZXIgc2VsZWN0cyBhIG5ldyB2YWx1ZS5cbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBzZWN0aW9uIG9uXG4gICAgICAgICAqIFtldmVudHNdKHslIHNsdWcgb3ZlcnZpZXdfZGF0ZWlucHV0ICV9I3RvYy1ldmVudHMpLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy52YWx1ZUNoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBoaWRkZW5cbiAgICAgICAgICogRmlyZXMgZWFjaCB0aW1lIHRoZSB1c2VyIHNlbGVjdHMgYSBuZXcgdmFsdWUuXG4gICAgICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgc2VjdGlvbiBvblxuICAgICAgICAgKiBbZXZlbnRzXSh7JSBzbHVnIG92ZXJ2aWV3X2RhdGVpbnB1dCAlfSN0b2MtZXZlbnRzKS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudmFsdWVVcGRhdGUgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyBlYWNoIHRpbWUgdGhlIHVzZXIgZm9jdXNlcyB0aGUgaW5wdXQgZWxlbWVudC5cbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBzZWN0aW9uIG9uXG4gICAgICAgICAqIFtldmVudHNdKHslIHNsdWcgb3ZlcnZpZXdfZGF0ZWlucHV0ICV9I3RvYy1ldmVudHMpLlxuICAgICAgICAgKlxuICAgICAgICAgKiA+IFRvIHdpcmUgdGhlIGV2ZW50IHByb2dyYW1tYXRpY2FsbHksIHVzZSB0aGUgYG9uRm9jdXNgIHByb3BlcnR5LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiBgYGB0c1xuICAgICAgICAgKiBfQENvbXBvbmVudCh7XG4gICAgICAgICAqIHNlbGVjdG9yOiAnbXktYXBwJyxcbiAgICAgICAgICogdGVtcGxhdGU6IGBcbiAgICAgICAgICogIDxrZW5kby1kYXRlaW5wdXQgKGZvY3VzKT1cImhhbmRsZUZvY3VzKClcIj48L2tlbmRvLWRhdGVpbnB1dD5cbiAgICAgICAgICogYFxuICAgICAgICAgKiB9KVxuICAgICAgICAgKiBleHBvcnQgY2xhc3MgQXBwQ29tcG9uZW50IHtcbiAgICAgICAgICogICBwdWJsaWMgaGFuZGxlRm9jdXMoKTogdm9pZCB7XG4gICAgICAgICAqICAgICAgY29uc29sZS5sb2coXCJDb21wb25lbnQgaXMgZm9jdXNlZFwiKTtcbiAgICAgICAgICogICB9XG4gICAgICAgICAqIH1cbiAgICAgICAgICogYGBgXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9uRm9jdXMgPSBuZXcgRXZlbnRFbWl0dGVyKCk7IC8vdHNsaW50OmRpc2FibGUtbGluZTpuby1vdXRwdXQtcmVuYW1lXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyBlYWNoIHRpbWUgdGhlIGlucHV0IGVsZW1lbnQgZ2V0cyBibHVycmVkLlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIHNlY3Rpb24gb25cbiAgICAgICAgICogW2V2ZW50c10oeyUgc2x1ZyBvdmVydmlld19kYXRlaW5wdXQgJX0jdG9jLWV2ZW50cykuXG4gICAgICAgICAqXG4gICAgICAgICAqID4gVG8gd2lyZSB0aGUgZXZlbnQgcHJvZ3JhbW1hdGljYWxseSwgdXNlIHRoZSBgb25CbHVyYCBwcm9wZXJ0eS5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogYGBgdHNcbiAgICAgICAgICogX0BDb21wb25lbnQoe1xuICAgICAgICAgKiBzZWxlY3RvcjogJ215LWFwcCcsXG4gICAgICAgICAqIHRlbXBsYXRlOiBgXG4gICAgICAgICAqICA8a2VuZG8tZGF0ZWlucHV0IChibHVyKT1cImhhbmRsZUJsdXIoKVwiPjwva2VuZG8tZGF0ZWlucHV0PlxuICAgICAgICAgKiBgXG4gICAgICAgICAqIH0pXG4gICAgICAgICAqIGV4cG9ydCBjbGFzcyBBcHBDb21wb25lbnQge1xuICAgICAgICAgKiAgIHB1YmxpYyBoYW5kbGVCbHVyKCk6IHZvaWQge1xuICAgICAgICAgKiAgICAgIGNvbnNvbGUubG9nKFwiQ29tcG9uZW50IGlzIGJsdXJyZWRcIik7XG4gICAgICAgICAqICAgfVxuICAgICAgICAgKiB9XG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vbkJsdXIgPSBuZXcgRXZlbnRFbWl0dGVyKCk7IC8vdHNsaW50OmRpc2FibGUtbGluZTpuby1vdXRwdXQtcmVuYW1lXG4gICAgICAgIHRoaXMuYXJyb3cgPSBBcnJvdztcbiAgICAgICAgdGhpcy5hcnJvd0RpcmVjdGlvbiA9IEFycm93Lk5vbmU7XG4gICAgICAgIHRoaXMuZm9ybWF0U2VjdGlvbnMgPSB7IGRhdGU6IGZhbHNlLCB0aW1lOiBmYWxzZSB9O1xuICAgICAgICB0aGlzLmhhc01vdXNlZG93biA9IGZhbHNlO1xuICAgICAgICB0aGlzLmZvY3VzZWRQcmlvclRvTW91c2Vkb3duID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaGlkZGVuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmlzRGF0ZUluY29tcGxldGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jdXJyZW50VmFsdWUgPSBcIlwiO1xuICAgICAgICB0aGlzLmN1cnJlbnRGb3JtYXQgPSBcIlwiO1xuICAgICAgICB0aGlzLmJhY2tzcGFjZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnJlc2V0U2VnbWVudFZhbHVlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5taW5WYWxpZGF0b3IgPSBub29wO1xuICAgICAgICB0aGlzLm1heFZhbGlkYXRvciA9IG5vb3A7XG4gICAgICAgIHRoaXMuaW5jb21wbGV0ZVZhbGlkYXRvciA9IG5vb3A7XG4gICAgICAgIHRoaXMuX3ZhbHVlID0gbnVsbDtcbiAgICAgICAgdGhpcy5fYWN0aXZlID0gZmFsc2U7XG4gICAgICAgIHRoaXMua2VuZG9EYXRlID0gbnVsbDtcbiAgICAgICAgdGhpcy5wYXN0ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRvbUV2ZW50cyA9IFtdO1xuICAgICAgICB0aGlzLm9uQ29udHJvbENoYW5nZSA9IG5vb3A7XG4gICAgICAgIHRoaXMub25Db250cm9sVG91Y2hlZCA9IG5vb3A7XG4gICAgICAgIHRoaXMub25WYWxpZGF0b3JDaGFuZ2UgPSBub29wO1xuICAgICAgICB0aGlzLnN5bWJvbHNNYXAgPSB0aGlzLmRhdGVTeW1ib2xNYXAoKTtcbiAgICAgICAgdGhpcy51cGRhdGVGb3JtYXRTZWN0aW9ucygpO1xuICAgICAgICBpZiAodGhpcy5waWNrZXJTZXJ2aWNlKSB7XG4gICAgICAgICAgICB0aGlzLnBpY2tlclNlcnZpY2UuaW5wdXQgPSB0aGlzO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBzZXQgdGFiSW5kZXgodGFiSW5kZXgpIHtcbiAgICAgICAgdGhpcy50YWJpbmRleCA9IHRhYkluZGV4O1xuICAgIH1cbiAgICBnZXQgdGFiSW5kZXgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRhYmluZGV4O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTcGVjaWZpZXMgdGhlIHZhbHVlIG9mIHRoZSBEYXRlSW5wdXQgY29tcG9uZW50LlxuICAgICAqXG4gICAgICogPiBUaGUgYHZhbHVlYCBoYXMgdG8gYmUgYSB2YWxpZCBbSmF2YVNjcmlwdCBgRGF0ZWBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0RhdGUpIGluc3RhbmNlLlxuICAgICAqL1xuICAgIHNldCB2YWx1ZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLnZlcmlmeVZhbHVlKHZhbHVlKTtcbiAgICAgICAgaWYgKHRoaXMuYXV0b0NvcnJlY3QgJiYgIWlzSW5SYW5nZSh2YWx1ZSwgdGhpcy5taW4sIHRoaXMubWF4KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ZhbHVlID0gY2xvbmVEYXRlKHZhbHVlKTtcbiAgICAgICAgdGhpcy52YWx1ZVVwZGF0ZS5lbWl0KGNsb25lRGF0ZSh2YWx1ZSkpO1xuICAgIH1cbiAgICBnZXQgdmFsdWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl92YWx1ZTtcbiAgICB9XG4gICAgZ2V0IHdyYXBwZXJDbGFzcygpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGdldCBkaXNhYmxlZENsYXNzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kaXNhYmxlZDtcbiAgICB9XG4gICAgZ2V0IGlucHV0RWxlbWVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0ZUlucHV0ID8gdGhpcy5kYXRlSW5wdXQubmF0aXZlRWxlbWVudCA6IG51bGw7XG4gICAgfVxuICAgIGdldCBpbnB1dFZhbHVlKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuaW5wdXRFbGVtZW50IHx8IHt9KS52YWx1ZSB8fCAnJztcbiAgICB9XG4gICAgZ2V0IGlzQWN0aXZlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWN0aXZlO1xuICAgIH1cbiAgICBzZXQgaXNBY3RpdmUodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fYWN0aXZlID0gdmFsdWU7XG4gICAgICAgIGlmICghdGhpcy53cmFwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1ByZXNlbnQodGhpcy5waWNrZXJTZXJ2aWNlKSkge1xuICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IHRoaXMud3JhcC5uYXRpdmVFbGVtZW50O1xuICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5hZGRDbGFzcyhlbGVtZW50LCAnay1zdGF0ZS1mb2N1c2VkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnJlbW92ZUNsYXNzKGVsZW1lbnQsICdrLXN0YXRlLWZvY3VzZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgaW5wdXRGb3JtYXQoKSB7XG4gICAgICAgIGlmICghdGhpcy5mb3JtYXQpIHtcbiAgICAgICAgICAgIHJldHVybiBERUZBVUxUX0ZPUk1BVDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHRoaXMuZm9ybWF0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0LmlucHV0Rm9ybWF0O1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBkaXNwbGF5Rm9ybWF0KCkge1xuICAgICAgICBpZiAoIXRoaXMuZm9ybWF0KSB7XG4gICAgICAgICAgICByZXR1cm4gREVGQVVMVF9GT1JNQVQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmZvcm1hdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZvcm1hdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZvcm1hdC5kaXNwbGF5Rm9ybWF0O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBVc2VkIGJ5IHRoZSBUZXh0Qm94Q29udGFpbmVyIHRvIGRldGVybWluZSBpZiB0aGUgY29tcG9uZW50IGlzIGVtcHR5XG4gICAgICovXG4gICAgaXNFbXB0eSgpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLmN1cnJlbnRWYWx1ZSB8fCAhU3RyaW5nKHRoaXMuY3VycmVudFZhbHVlKS50cmltKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBjb250YWluc0VsZW1lbnQoZWxlbWVudCkge1xuICAgICAgICByZXR1cm4gQm9vbGVhbihjbG9zZXN0KGVsZW1lbnQsIG5vZGUgPT4gbm9kZSA9PT0gdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXMpIHtcbiAgICAgICAgdGhpcy52ZXJpZnlSYW5nZSgpO1xuICAgICAgICBpZiAoY2hhbmdlcy5taW4gfHwgY2hhbmdlcy5tYXggfHwgY2hhbmdlcy5yYW5nZVZhbGlkYXRpb24gfHwgY2hhbmdlcy5pbmNvbXBsZXRlRGF0ZVZhbGlkYXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMubWluVmFsaWRhdG9yID0gdGhpcy5yYW5nZVZhbGlkYXRpb24gPyBtaW5WYWxpZGF0b3IodGhpcy5taW4pIDogbm9vcDtcbiAgICAgICAgICAgIHRoaXMubWF4VmFsaWRhdG9yID0gdGhpcy5yYW5nZVZhbGlkYXRpb24gPyBtYXhWYWxpZGF0b3IodGhpcy5tYXgpIDogbm9vcDtcbiAgICAgICAgICAgIHRoaXMuaW5jb21wbGV0ZVZhbGlkYXRvciA9IHRoaXMuaW5jb21wbGV0ZURhdGVWYWxpZGF0aW9uID8gaW5jb21wbGV0ZURhdGVWYWxpZGF0b3IoKSA6IG5vb3A7XG4gICAgICAgICAgICB0aGlzLm9uVmFsaWRhdG9yQ2hhbmdlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYW5nZXMuZm9ybWF0KSB7XG4gICAgICAgICAgICB0aGlzLnN5bWJvbHNNYXAgPSB0aGlzLmRhdGVTeW1ib2xNYXAoKTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlRm9ybWF0U2VjdGlvbnMoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpc0VxdWFsVG9LZW5kb0RhdGUgPSB0aGlzLmtlbmRvRGF0ZSAmJiBpc0VxdWFsKHRoaXMudmFsdWUsIHRoaXMua2VuZG9EYXRlLmdldERhdGVPYmplY3QoKSk7XG4gICAgICAgIGlmIChjaGFuZ2VzLmZvcm1hdCB8fCAhaXNFcXVhbFRvS2VuZG9EYXRlIHx8IGNoYW5nZXMucGxhY2Vob2xkZXIpIHtcbiAgICAgICAgICAgIHRoaXMua2VuZG9EYXRlID0gdGhpcy5nZXRLZW5kb0RhdGUodGhpcy52YWx1ZSk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUVsZW1lbnRWYWx1ZSh0aGlzLmlzQWN0aXZlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgaWYgKHRoaXMuaW50bFN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgdGhpcy5pbnRsU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucGlja2VyU2VydmljZSkge1xuICAgICAgICAgICAgdGhpcy5waWNrZXJTZXJ2aWNlLmlucHV0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRvbUV2ZW50cy5mb3JFYWNoKHVuYmluZENhbGxiYWNrID0+IHVuYmluZENhbGxiYWNrKCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgdmFsaWRhdGUoY29udHJvbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taW5WYWxpZGF0b3IoY29udHJvbCkgfHwgdGhpcy5tYXhWYWxpZGF0b3IoY29udHJvbCkgfHwgdGhpcy5pbmNvbXBsZXRlVmFsaWRhdG9yKGNvbnRyb2wsIHRoaXMuaXNEYXRlSW5jb21wbGV0ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICByZWdpc3Rlck9uVmFsaWRhdG9yQ2hhbmdlKGZuKSB7XG4gICAgICAgIHRoaXMub25WYWxpZGF0b3JDaGFuZ2UgPSBmbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIG5nT25Jbml0KCkge1xuICAgICAgICB0aGlzLmtlbmRvRGF0ZSA9IHRoaXMuZ2V0S2VuZG9EYXRlKHRoaXMudmFsdWUpO1xuICAgICAgICB0aGlzLnVwZGF0ZUVsZW1lbnRWYWx1ZSgpO1xuICAgICAgICB0aGlzLmludGxTdWJzY3JpcHRpb24gPSB0aGlzLmludGwuY2hhbmdlcy5zdWJzY3JpYmUodGhpcy5pbnRsQ2hhbmdlLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLm5nQ29udHJvbCA9IHRoaXMuaW5qZWN0b3IuZ2V0KE5nQ29udHJvbCwgbnVsbCk7XG4gICAgICAgIGlmICh0aGlzLmVsZW1lbnQpIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIucmVtb3ZlQXR0cmlidXRlKHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LCAndGFiaW5kZXgnKTtcbiAgICAgICAgICAgIHRoaXMubmdab25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmJpbmRFdmVudHMoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBzZXREaXNhYmxlZFN0YXRlKGlzRGlzYWJsZWQpIHtcbiAgICAgICAgdGhpcy5kaXNhYmxlZCA9IGlzRGlzYWJsZWQ7XG4gICAgICAgIHRoaXMuY2RyLm1hcmtGb3JDaGVjaygpO1xuICAgIH1cbiAgICAvL25nTW9kZWwgYmluZGluZ1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICB3cml0ZVZhbHVlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMudmVyaWZ5VmFsdWUodmFsdWUpO1xuICAgICAgICB0aGlzLmtlbmRvRGF0ZSA9IHRoaXMuZ2V0S2VuZG9EYXRlKHZhbHVlKTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IGNsb25lRGF0ZSh2YWx1ZSk7XG4gICAgICAgIHRoaXMudXBkYXRlRWxlbWVudFZhbHVlKHRoaXMuaXNBY3RpdmUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgdHJpZ2dlckNoYW5nZSgpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLmtlbmRvRGF0ZS5nZXREYXRlT2JqZWN0KCk7XG4gICAgICAgIGlmICgrdmFsdWUgIT09ICt0aGlzLnZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gY2xvbmVEYXRlKHZhbHVlKTtcbiAgICAgICAgICAgIHRoaXMubm90aWZ5KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIG5vdGlmeSgpIHtcbiAgICAgICAgdGhpcy5uZ1pvbmUucnVuKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMub25Db250cm9sQ2hhbmdlKGNsb25lRGF0ZSh0aGlzLnZhbHVlKSk7XG4gICAgICAgICAgICB0aGlzLnZhbHVlQ2hhbmdlLmVtaXQoY2xvbmVEYXRlKHRoaXMudmFsdWUpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICByZWdpc3Rlck9uQ2hhbmdlKGZuKSB7XG4gICAgICAgIHRoaXMub25Db250cm9sQ2hhbmdlID0gZm47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICByZWdpc3Rlck9uVG91Y2hlZChmbikge1xuICAgICAgICB0aGlzLm9uQ29udHJvbFRvdWNoZWQgPSBmbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRm9jdXNlcyB0aGUgRGF0ZUlucHV0IGNvbXBvbmVudC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiBfQENvbXBvbmVudCh7XG4gICAgICogc2VsZWN0b3I6ICdteS1hcHAnLFxuICAgICAqIHRlbXBsYXRlOiBgXG4gICAgICogIDxidXR0b24gKGNsaWNrKT1cImRhdGVpbnB1dC5mb2N1cygpXCI+Rm9jdXMgZGF0ZSBpbnB1dDwvYnV0dG9uPlxuICAgICAqICA8a2VuZG8tZGF0ZWlucHV0ICNkYXRlaW5wdXQ+PC9rZW5kby1kYXRlaW5wdXQ+XG4gICAgICogYFxuICAgICAqIH0pXG4gICAgICogZXhwb3J0IGNsYXNzIEFwcENvbXBvbmVudCB7IH1cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBmb2N1cygpIHtcbiAgICAgICAgY29uc3QgaW5wdXQgPSB0aGlzLmlucHV0RWxlbWVudDtcbiAgICAgICAgaWYgKGlucHV0KSB7XG4gICAgICAgICAgICBpbnB1dC5mb2N1cygpO1xuICAgICAgICAgICAgdGhpcy5zZWxlY3REYXRlU2VnbWVudCh0aGlzLmN1cnJlbnRGb3JtYXRbMF0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJsdXJzIHRoZSBEYXRlSW5wdXQgY29tcG9uZW50LlxuICAgICAqL1xuICAgIGJsdXIoKSB7XG4gICAgICAgIGNvbnN0IGlucHV0ID0gdGhpcy5pbnB1dEVsZW1lbnQ7XG4gICAgICAgIGlmIChpbnB1dCkge1xuICAgICAgICAgICAgaW5wdXQuYmx1cigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBoYW5kbGVCdXR0b25DbGljayhvZmZzZXQpIHtcbiAgICAgICAgdGhpcy5hcnJvd0RpcmVjdGlvbiA9IEFycm93Lk5vbmU7XG4gICAgICAgIHRoaXMubW9kaWZ5RGF0ZVNlZ21lbnRWYWx1ZShvZmZzZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgbW9kaWZ5RGF0ZVNlZ21lbnRWYWx1ZShvZmZzZXQpIHtcbiAgICAgICAgY29uc3QgY2FyZXQgPSB0aGlzLmNhcmV0KCk7XG4gICAgICAgIGNvbnN0IHN5bWJvbCA9IHRoaXMuY3VycmVudEZvcm1hdFtjYXJldFswXV07XG4gICAgICAgIGxldCBzdGVwID0gKHRoaXMuc3RlcHMgfHwge30pW3RoaXMuc3ltYm9sc01hcFtzeW1ib2xdXSB8fCAxO1xuICAgICAgICBpZiAoc3ltYm9sID09PSBcIlNcIiAmJiAhdGhpcy5zdGVwcy5taWxsaXNlY29uZCkge1xuICAgICAgICAgICAgY29uc3QgbXNEaWdpdHMgPSBtaWxsaXNlY29uZERpZ2l0c0luRm9ybWF0KHRoaXMuaW5wdXRGb3JtYXQpO1xuICAgICAgICAgICAgc3RlcCA9IG1pbGxpc2Vjb25kU3RlcEZvcihtc0RpZ2l0cyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5rZW5kb0RhdGUubW9kaWZ5UGFydChzeW1ib2wsIG9mZnNldCAqIHN0ZXApO1xuICAgICAgICB0aGlzLnB1dERhdGVJblJhbmdlKCk7XG4gICAgICAgIHRoaXMudXBkYXRlRWxlbWVudFZhbHVlKHRoaXMuaXNBY3RpdmUpO1xuICAgICAgICB0aGlzLnRyaWdnZXJDaGFuZ2UoKTtcbiAgICAgICAgdGhpcy5zZWxlY3REYXRlU2VnbWVudChzeW1ib2wpO1xuICAgICAgICB0aGlzLnVwZGF0ZUluY29tcGxldGVWYWxpZGF0aW9uU3RhdHVzKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBzd2l0Y2hEYXRlU2VnbWVudChvZmZzZXQpIHtcbiAgICAgICAgY29uc3QgY2FyZXQgPSB0aGlzLmNhcmV0KCk7XG4gICAgICAgIGlmICh0aGlzLmtlbmRvRGF0ZS5yZXNldExlYWRpbmdaZXJvKCkpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlRWxlbWVudFZhbHVlKHRoaXMuaXNBY3RpdmUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjYXJldFswXSA8IGNhcmV0WzFdICYmIHRoaXMuY3VycmVudEZvcm1hdFtjYXJldFswXV0gIT09IHRoaXMuY3VycmVudEZvcm1hdFtjYXJldFsxXSAtIDFdKSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdE5lYXJlc3RTZWdtZW50KG9mZnNldCA+IDAgPyBjYXJldFswXSA6IGNhcmV0WzFdIC0gMSk7XG4gICAgICAgICAgICB0aGlzLnJlc2V0U2VnbWVudFZhbHVlID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByZXZpb3VzRm9ybWF0U3ltYm9sID0gdGhpcy5jdXJyZW50Rm9ybWF0W2NhcmV0WzBdXTtcbiAgICAgICAgbGV0IGEgPSBjYXJldFswXSArIG9mZnNldDtcbiAgICAgICAgd2hpbGUgKGEgPiAwICYmIGEgPCB0aGlzLmN1cnJlbnRGb3JtYXQubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50Rm9ybWF0W2FdICE9PSBwcmV2aW91c0Zvcm1hdFN5bWJvbCAmJlxuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudEZvcm1hdFthXSAhPT0gXCJfXCIpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGEgKz0gb2Zmc2V0O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRGb3JtYXRbYV0gPT09IFwiX1wiKSB7XG4gICAgICAgICAgICAvL3RoZXJlIGlzIG5vdCBrbm93biBzeW1ib2wgZm91bmRcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgYiA9IGE7XG4gICAgICAgIHdoaWxlIChiID49IDAgJiYgYiA8IHRoaXMuY3VycmVudEZvcm1hdC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnRGb3JtYXRbYl0gIT09IHRoaXMuY3VycmVudEZvcm1hdFthXSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYiArPSBvZmZzZXQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGEgPiBiICYmIChiICsgMSAhPT0gY2FyZXRbMF0gfHwgYSArIDEgIT09IGNhcmV0WzFdKSkge1xuICAgICAgICAgICAgdGhpcy5jYXJldChiICsgMSwgYSArIDEpO1xuICAgICAgICAgICAgdGhpcy5yZXNldFNlZ21lbnRWYWx1ZSA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhIDwgYiAmJiAoYSAhPT0gY2FyZXRbMF0gfHwgYiAhPT0gY2FyZXRbMV0pKSB7XG4gICAgICAgICAgICB0aGlzLmNhcmV0KGEsIGIpO1xuICAgICAgICAgICAgdGhpcy5yZXNldFNlZ21lbnRWYWx1ZSA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBzZWxlY3REYXRlU2VnbWVudChzeW1ib2wpIHtcbiAgICAgICAgbGV0IGJlZ2luID0gLTE7XG4gICAgICAgIGxldCBlbmQgPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY3VycmVudEZvcm1hdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudEZvcm1hdFtpXSA9PT0gc3ltYm9sKSB7XG4gICAgICAgICAgICAgICAgZW5kID0gaSArIDE7XG4gICAgICAgICAgICAgICAgaWYgKGJlZ2luID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBiZWdpbiA9IGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChiZWdpbiA8IDApIHtcbiAgICAgICAgICAgIGJlZ2luID0gMDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNhcmV0KDAsIDApO1xuICAgICAgICB0aGlzLmNhcmV0KGJlZ2luLCBlbmQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgaGFuZGxlQ2xpY2soKSB7XG4gICAgICAgIHRoaXMuaGFzTW91c2Vkb3duID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLmlzQWN0aXZlKSB7XG4gICAgICAgICAgICBjb25zdCBzZWxlY3Rpb25QcmVzZW50ID0gdGhpcy5pbnB1dEVsZW1lbnQuc2VsZWN0aW9uU3RhcnQgIT09IHRoaXMuaW5wdXRFbGVtZW50LnNlbGVjdGlvbkVuZDtcbiAgICAgICAgICAgIGNvbnN0IHBsYWNlaG9sZGVyVG9nZ2xlZCA9IGlzUHJlc2VudCh0aGlzLnBsYWNlaG9sZGVyKSAmJiAhdGhpcy5rZW5kb0RhdGUuaGFzVmFsdWUoKSAmJiAhdGhpcy5mb2N1c2VkUHJpb3JUb01vdXNlZG93bjtcbiAgICAgICAgICAgIC8vIGZvY3VzIGZpcnN0IHNlZ21lbnQgaWYgdGhlIHVzZXIgaGFzbid0IHNlbGVjdGVkIHNvbWV0aGluZyBkdXJpbmcgbW91c2Vkb3duIGFuZCBpZiB0aGUgcGxhY2Vob2xkZXIgd2FzIGp1c3QgdG9nZ2xlZFxuICAgICAgICAgICAgY29uc3Qgc2VsZWN0Rmlyc3RTZWdtZW50ID0gIXNlbGVjdGlvblByZXNlbnQgJiYgcGxhY2Vob2xkZXJUb2dnbGVkO1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBzZWxlY3RGaXJzdFNlZ21lbnQgPyAwIDogdGhpcy5jYXJldCgpWzBdO1xuICAgICAgICAgICAgdGhpcy5zZWxlY3ROZWFyZXN0U2VnbWVudChpbmRleCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGhhbmRsZURyYWdBbmREcm9wKGFyZ3MpIHtcbiAgICAgICAgYXJncy5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgaGFuZGxlTW91c2Vkb3duKCkge1xuICAgICAgICB0aGlzLmhhc01vdXNlZG93biA9IHRydWU7XG4gICAgICAgIHRoaXMuZm9jdXNlZFByaW9yVG9Nb3VzZWRvd24gPSB0aGlzLmlzQWN0aXZlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgaGFuZGxlRm9jdXMoYXJncykge1xuICAgICAgICB0aGlzLmlzQWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy51cGRhdGVFbGVtZW50VmFsdWUoKTtcbiAgICAgICAgaWYgKCF0aGlzLmhhc01vdXNlZG93bikge1xuICAgICAgICAgICAgdGhpcy5jYXJldCgwLCB0aGlzLmlucHV0VmFsdWUubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmhhc01vdXNlZG93biA9IGZhbHNlO1xuICAgICAgICBpZiAoaGFzT2JzZXJ2ZXJzKHRoaXMub25Gb2N1cykpIHtcbiAgICAgICAgICAgIHRoaXMubmdab25lLnJ1bigoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0Rm9jdXMoYXJncyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdEZvY3VzKGFyZ3MpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBoYW5kbGVCbHVyKGFyZ3MpIHtcbiAgICAgICAgdGhpcy5pc0FjdGl2ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnJlc2V0U2VnbWVudFZhbHVlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5rZW5kb0RhdGUucmVzZXRMZWFkaW5nWmVybygpO1xuICAgICAgICB0aGlzLnVwZGF0ZUVsZW1lbnRWYWx1ZSgpO1xuICAgICAgICBpZiAoaGFzT2JzZXJ2ZXJzKHRoaXMub25CbHVyKSB8fCByZXF1aXJlc1pvbmVPbkJsdXIodGhpcy5uZ0NvbnRyb2wpKSB7XG4gICAgICAgICAgICB0aGlzLm5nWm9uZS5ydW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMub25Db250cm9sVG91Y2hlZCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdEJsdXIoYXJncyk7XG4gICAgICAgICAgICAgICAgdGhpcy5jZHIubWFya0ZvckNoZWNrKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdEJsdXIoYXJncyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0S2VuZG9EYXRlKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IHsgbGVhZGluZ1plcm8gfSA9ICh0aGlzLmtlbmRvRGF0ZSB8fCB7fSkgfHwgbnVsbDtcbiAgICAgICAgY29uc3Qga2VuZG9EYXRlID0gbmV3IEtlbmRvRGF0ZSh0aGlzLmludGwsIHRoaXMuZm9ybWF0UGxhY2Vob2xkZXIsIHRoaXMuaW5wdXRGb3JtYXQsIHZhbHVlLCB0aGlzLnR3b0RpZ2l0WWVhck1heCk7XG4gICAgICAgIGtlbmRvRGF0ZS5zZXRMZWFkaW5nWmVybyh0aGlzLmlzQWN0aXZlID8gbGVhZGluZ1plcm8gOiBudWxsKTtcbiAgICAgICAgcmV0dXJuIGtlbmRvRGF0ZTtcbiAgICB9XG4gICAgZGF0ZVN5bWJvbE1hcCgpIHtcbiAgICAgICAgY29uc3QgcmVkdWNlciA9IChtYXAkJDEsIHBhcnQpID0+IHtcbiAgICAgICAgICAgIG1hcCQkMVtwYXJ0LnBhdHRlcm5bMF1dID0gcGFydC50eXBlO1xuICAgICAgICAgICAgcmV0dXJuIG1hcCQkMTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50bC5zcGxpdERhdGVGb3JtYXQodGhpcy5pbnB1dEZvcm1hdCkucmVkdWNlKHJlZHVjZXIsIHt9KTtcbiAgICB9XG4gICAgdXBkYXRlRWxlbWVudFZhbHVlKGlzQWN0aXZlKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5jYXJldCgpWzBdOyAvL1hYWDogZ2V0IGNhcmV0IHBvc2l0aW9uIGJlZm9yZSBpbnB1dCBpcyB1cGRhdGVkXG4gICAgICAgIGNvbnN0IGZvcm1hdCA9IHRoaXMuaXNBY3RpdmUgPyB0aGlzLmlucHV0Rm9ybWF0IDogdGhpcy5kaXNwbGF5Rm9ybWF0O1xuICAgICAgICBjb25zdCB0ZXh0cyA9IHRoaXMua2VuZG9EYXRlLmdldFRleHRBbmRGb3JtYXQoZm9ybWF0KTtcbiAgICAgICAgY29uc3Qgc2hvd1BsYWNlaG9sZGVyID0gIXRoaXMuaXNBY3RpdmUgJiYgaXNQcmVzZW50KHRoaXMucGxhY2Vob2xkZXIpICYmICF0aGlzLmtlbmRvRGF0ZS5oYXNWYWx1ZSgpO1xuICAgICAgICBjb25zdCBpbnB1dCA9IHRoaXMuaW5wdXRFbGVtZW50O1xuICAgICAgICB0aGlzLmN1cnJlbnRGb3JtYXQgPSB0ZXh0c1sxXTtcbiAgICAgICAgdGhpcy5jdXJyZW50VmFsdWUgPSAhc2hvd1BsYWNlaG9sZGVyID8gdGV4dHNbMF0gOiAnJztcbiAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRQcm9wZXJ0eShpbnB1dCwgXCJ2YWx1ZVwiLCB0aGlzLmN1cnJlbnRWYWx1ZSk7XG4gICAgICAgIGlmIChpbnB1dC5wbGFjZWhvbGRlciAhPT0gdGhpcy5wbGFjZWhvbGRlcikge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRQcm9wZXJ0eShpbnB1dCwgXCJwbGFjZWhvbGRlclwiLCB0aGlzLnBsYWNlaG9sZGVyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNBY3RpdmUpIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0TmVhcmVzdFNlZ21lbnQoc3RhcnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhcmV0KHN0YXJ0LCBlbmQgPSBzdGFydCkge1xuICAgICAgICBjb25zdCBpc1Bvc2l0aW9uID0gc3RhcnQgIT09IHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IHJldHVyblZhbHVlID0gW3N0YXJ0LCBzdGFydF07XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLmlucHV0RWxlbWVudDtcbiAgICAgICAgaWYgKGlzUG9zaXRpb24gJiYgKHRoaXMuZGlzYWJsZWQgfHwgdGhpcy5yZWFkb25seSkpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChlbGVtZW50LnNlbGVjdGlvblN0YXJ0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNQb3NpdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNEb2N1bWVudEF2YWlsYWJsZSgpICYmIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgIT09IGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuZm9jdXMoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LnNldFNlbGVjdGlvblJhbmdlKHN0YXJ0LCBlbmQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm5WYWx1ZSA9IFtlbGVtZW50LnNlbGVjdGlvblN0YXJ0LCBlbGVtZW50LnNlbGVjdGlvbkVuZF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVyblZhbHVlID0gW107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldHVyblZhbHVlO1xuICAgIH1cbiAgICBzZWxlY3ROZWFyZXN0U2VnbWVudChpbmRleCkge1xuICAgICAgICAvLyBGaW5kcyB0aGUgbmVhcmVzdCAoaW4gYm90aCBkaXJlY3Rpb25zKSBrbm93biBwYXJ0LlxuICAgICAgICBmb3IgKGxldCBpID0gaW5kZXgsIGogPSBpbmRleCAtIDE7IGkgPCB0aGlzLmN1cnJlbnRGb3JtYXQubGVuZ3RoIHx8IGogPj0gMDsgaSsrLCBqLS0pIHtcbiAgICAgICAgICAgIGlmIChpIDwgdGhpcy5jdXJyZW50Rm9ybWF0Lmxlbmd0aCAmJiB0aGlzLmN1cnJlbnRGb3JtYXRbaV0gIT09IFwiX1wiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3REYXRlU2VnbWVudCh0aGlzLmN1cnJlbnRGb3JtYXRbaV0pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChqID49IDAgJiYgdGhpcy5jdXJyZW50Rm9ybWF0W2pdICE9PSBcIl9cIikge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0RGF0ZVNlZ21lbnQodGhpcy5jdXJyZW50Rm9ybWF0W2pdKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmVyaWZ5UmFuZ2UoKSB7XG4gICAgICAgIGlmICghaXNEZXZNb2RlKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVmFsaWRSYW5nZSh0aGlzLm1pbiwgdGhpcy5tYXgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBtYXggdmFsdWUgc2hvdWxkIGJlIGJpZ2dlciB0aGFuIHRoZSBtaW4uIFNlZSAke01JTl9ET0NfTElOSyQxfSBhbmQgJHtNQVhfRE9DX0xJTkskMX0uYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmVyaWZ5VmFsdWUodmFsdWUpIHtcbiAgICAgICAgaWYgKCFpc0Rldk1vZGUoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSAmJiAhKHZhbHVlIGluc3RhbmNlb2YgRGF0ZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlICd2YWx1ZScgc2hvdWxkIGJlIGEgdmFsaWQgSmF2YVNjcmlwdCBEYXRlIGluc3RhbmNlLiBDaGVjayAke1ZBTFVFX0RPQ19MSU5LJDF9IGZvciBwb3NzaWJsZSByZXNvbHV0aW9uLmApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHB1dERhdGVJblJhbmdlKCkge1xuICAgICAgICBjb25zdCBjdXJyZW50RGF0ZSA9IHRoaXMua2VuZG9EYXRlLmdldERhdGVPYmplY3QoKTtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gZGF0ZUluUmFuZ2UoY3VycmVudERhdGUsIHRoaXMubWluLCB0aGlzLm1heCk7XG4gICAgICAgIGlmICh0aGlzLmF1dG9Db3JyZWN0ICYmICFpc0VxdWFsKGN1cnJlbnREYXRlLCBjYW5kaWRhdGUpKSB7XG4gICAgICAgICAgICB0aGlzLmtlbmRvRGF0ZSA9IHRoaXMuZ2V0S2VuZG9EYXRlKGNhbmRpZGF0ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlRm9ybWF0U2VjdGlvbnMoKSB7XG4gICAgICAgIHRoaXMuZm9ybWF0U2VjdGlvbnMgPSB0aGlzLmludGwuc3BsaXREYXRlRm9ybWF0KHRoaXMuaW5wdXRGb3JtYXQpXG4gICAgICAgICAgICAucmVkdWNlKCh7IGRhdGUsIHRpbWUgfSwgcCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBkYXRlOiBkYXRlIHx8IERBVEVfUEFSVF9SRUdFWFAudGVzdChwLnR5cGUpLFxuICAgICAgICAgICAgICAgIHRpbWU6IHRpbWUgfHwgVElNRV9QQVJUX1JFR0VYUC50ZXN0KHAudHlwZSlcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sIHsgZGF0ZTogZmFsc2UsIHRpbWU6IGZhbHNlIH0pO1xuICAgIH1cbiAgICBpbnRsQ2hhbmdlKCkge1xuICAgICAgICB0aGlzLnVwZGF0ZUZvcm1hdFNlY3Rpb25zKCk7XG4gICAgICAgIHRoaXMua2VuZG9EYXRlID0gdGhpcy5nZXRLZW5kb0RhdGUodGhpcy52YWx1ZSk7XG4gICAgICAgIHRoaXMudXBkYXRlRWxlbWVudFZhbHVlKHRoaXMuaXNBY3RpdmUpO1xuICAgIH1cbiAgICB1cGRhdGVPblBhc3RlKCkge1xuICAgICAgICBsZXQgdmFsdWUgPSB0aGlzLmludGwucGFyc2VEYXRlKHRoaXMuaW5wdXRWYWx1ZSwgdGhpcy5pbnB1dEZvcm1hdCkgfHwgdGhpcy52YWx1ZTtcbiAgICAgICAgaWYgKGlzUHJlc2VudCh2YWx1ZSkgJiYgdGhpcy5rZW5kb0RhdGUuc2hvdWxkTm9ybWFsaXplQ2VudHVyeSgpKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHRoaXMua2VuZG9EYXRlLm5vcm1hbGl6ZUNlbnR1cnkodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5vdGlmeSA9ICt2YWx1ZSAhPT0gK3RoaXMudmFsdWU7XG4gICAgICAgIHRoaXMud3JpdGVWYWx1ZSh2YWx1ZSk7XG4gICAgICAgIGlmIChub3RpZnkpIHtcbiAgICAgICAgICAgIHRoaXMubm90aWZ5KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYmluZEV2ZW50cygpIHtcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50O1xuICAgICAgICBjb25zdCBtb3VzZXdoZWVsSGFuZGxlciA9IHRoaXMuaGFuZGxlTW91c2VXaGVlbC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmRvbUV2ZW50cy5wdXNoKHRoaXMucmVuZGVyZXIubGlzdGVuKGVsZW1lbnQsICdET01Nb3VzZVNjcm9sbCcsIG1vdXNld2hlZWxIYW5kbGVyKSwgdGhpcy5yZW5kZXJlci5saXN0ZW4oZWxlbWVudCwgJ21vdXNld2hlZWwnLCBtb3VzZXdoZWVsSGFuZGxlciksIHRoaXMucmVuZGVyZXIubGlzdGVuKGVsZW1lbnQsICdrZXlkb3duJywgdGhpcy5oYW5kbGVLZXlkb3duLmJpbmQodGhpcykpLCB0aGlzLnJlbmRlcmVyLmxpc3RlbihlbGVtZW50LCAncGFzdGUnLCB0aGlzLmhhbmRsZVBhc3RlLmJpbmQodGhpcykpLCB0aGlzLnJlbmRlcmVyLmxpc3RlbihlbGVtZW50LCAnaW5wdXQnLCB0aGlzLmhhbmRsZUlucHV0LmJpbmQodGhpcykpKTtcbiAgICB9XG4gICAgaGFuZGxlTW91c2VXaGVlbChldmVudCkge1xuICAgICAgICBpZiAodGhpcy5kaXNhYmxlZCB8fCB0aGlzLnJlYWRvbmx5IHx8ICF0aGlzLmlzQWN0aXZlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLyogdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOmRlcHJlY2F0aW9uICovXG4gICAgICAgIGV2ZW50ID0gd2luZG93LmV2ZW50IHx8IGV2ZW50O1xuICAgICAgICBpZiAoZXZlbnQuc2hpZnRLZXkpIHtcbiAgICAgICAgICAgIHRoaXMuc3dpdGNoRGF0ZVNlZ21lbnQoKGV2ZW50LndoZWVsRGVsdGEgfHwgLWV2ZW50LmRldGFpbCkgPiAwID8gLTEgOiAxKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubW9kaWZ5RGF0ZVNlZ21lbnRWYWx1ZSgoZXZlbnQud2hlZWxEZWx0YSB8fCAtZXZlbnQuZGV0YWlsKSA+IDAgPyAxIDogLTEpO1xuICAgICAgICB9XG4gICAgICAgIGV2ZW50LnJldHVyblZhbHVlID0gZmFsc2U7XG4gICAgICAgIGlmIChldmVudC5wcmV2ZW50RGVmYXVsdCkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXZlbnQuc3RvcFByb3BhZ2F0aW9uKSB7XG4gICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBoYW5kbGVQYXN0ZSgpIHtcbiAgICAgICAgdGhpcy5wYXN0ZSA9IHRydWU7XG4gICAgfVxuICAgIGhhbmRsZUtleWRvd24oZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuZGlzYWJsZWQgfHwgdGhpcy5yZWFkb25seSB8fCBldmVudC5hbHRLZXkgfHwgZXZlbnQuY3RybEtleSB8fCBldmVudC5tZXRhS2V5KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV2ZW50LmtleUNvZGUgPT09IEtleXMuVGFiKSB7XG4gICAgICAgICAgICBjb25zdCBtb3ZlZCA9IHRoaXMuc3dpdGNoRGF0ZVNlZ21lbnQoZXZlbnQuc2hpZnRLZXkgPyAtMSA6IDEpO1xuICAgICAgICAgICAgaWYgKG1vdmVkKSB7XG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PT0gS2V5cy5CYWNrc3BhY2UpIHtcbiAgICAgICAgICAgIHRoaXMuYmFja3NwYWNlID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKGV2ZW50LmtleUNvZGUpIHtcbiAgICAgICAgICAgIGNhc2UgS2V5cy5BcnJvd0Rvd246XG4gICAgICAgICAgICAgICAgdGhpcy5tb2RpZnlEYXRlU2VnbWVudFZhbHVlKC0xKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgS2V5cy5BcnJvd1VwOlxuICAgICAgICAgICAgICAgIHRoaXMubW9kaWZ5RGF0ZVNlZ21lbnRWYWx1ZSgxKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgS2V5cy5BcnJvd1JpZ2h0OlxuICAgICAgICAgICAgICAgIHRoaXMuc3dpdGNoRGF0ZVNlZ21lbnQoMSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEtleXMuQXJyb3dMZWZ0OlxuICAgICAgICAgICAgICAgIHRoaXMuc3dpdGNoRGF0ZVNlZ21lbnQoLTEpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBLZXlzLkhvbWU6XG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3ROZWFyZXN0U2VnbWVudCgwKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgS2V5cy5FbmQ6XG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3ROZWFyZXN0U2VnbWVudCh0aGlzLmlucHV0VmFsdWUubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuOyAvL3NraXAgdGhlIHByZXZlbnREZWZhdWx0IGlmIHdlIGRpZG4ndCBoYW5kbGVkIHRoZSBrZXlDb2RlXG4gICAgICAgIH1cbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gICAgaGFuZGxlSW5wdXQoKSB7XG4gICAgICAgIGlmICh0aGlzLmRpc2FibGVkIHx8IHRoaXMucmVhZG9ubHkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wYXN0ZSkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVPblBhc3RlKCk7XG4gICAgICAgICAgICB0aGlzLnBhc3RlID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGlmZiA9IGFwcHJveGltYXRlU3RyaW5nTWF0Y2hpbmcodGhpcy5jdXJyZW50VmFsdWUsIHRoaXMuY3VycmVudEZvcm1hdCwgdGhpcy5pbnB1dFZhbHVlLCB0aGlzLmNhcmV0KClbMF0pO1xuICAgICAgICBjb25zdCBuYXZpZ2F0aW9uT25seSA9IChkaWZmLmxlbmd0aCA9PT0gMSAmJiBkaWZmWzBdWzFdID09PSBcIl9cIik7XG4gICAgICAgIGxldCBzd2l0Y2hQYXJ0ID0gZmFsc2U7XG4gICAgICAgIGlmICghbmF2aWdhdGlvbk9ubHkpIHtcbiAgICAgICAgICAgIGxldCBwYXJzZWRQYXJ0O1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkaWZmLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcGFyc2VkUGFydCA9IHRoaXMua2VuZG9EYXRlLnBhcnNlUGFydChkaWZmW2ldWzBdLCBkaWZmW2ldWzFdLCB0aGlzLnJlc2V0U2VnbWVudFZhbHVlKTtcbiAgICAgICAgICAgICAgICBzd2l0Y2hQYXJ0ID0gcGFyc2VkUGFydC5zd2l0Y2hUb05leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSB0aGlzLmtlbmRvRGF0ZS5nZXREYXRlT2JqZWN0KCk7XG4gICAgICAgICAgICBpZiAodGhpcy52YWx1ZSAmJiBjYW5kaWRhdGUgJiYgIXRoaXMuZm9ybWF0U2VjdGlvbnMuZGF0ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMua2VuZG9EYXRlID0gdGhpcy5nZXRLZW5kb0RhdGUoc2V0VGltZSh0aGlzLnZhbHVlLCBjYW5kaWRhdGUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlc2V0U2VnbWVudFZhbHVlID0gZmFsc2U7XG4gICAgICAgIHRoaXMucHV0RGF0ZUluUmFuZ2UoKTtcbiAgICAgICAgdGhpcy51cGRhdGVFbGVtZW50VmFsdWUodGhpcy5pc0FjdGl2ZSk7XG4gICAgICAgIHRoaXMudHJpZ2dlckNoYW5nZSgpO1xuICAgICAgICB0aGlzLnVwZGF0ZUluY29tcGxldGVWYWxpZGF0aW9uU3RhdHVzKCk7XG4gICAgICAgIGlmIChkaWZmLmxlbmd0aCAmJiBkaWZmWzBdWzBdICE9PSBcIl9cIikge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3REYXRlU2VnbWVudChkaWZmWzBdWzBdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3dpdGNoUGFydCB8fCBuYXZpZ2F0aW9uT25seSkge1xuICAgICAgICAgICAgdGhpcy5zd2l0Y2hEYXRlU2VnbWVudCgxKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5iYWNrc3BhY2UpIHtcbiAgICAgICAgICAgIHRoaXMuc3dpdGNoRGF0ZVNlZ21lbnQoLTEpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYmFja3NwYWNlID0gZmFsc2U7XG4gICAgfVxuICAgIGVtaXRGb2N1cyhhcmdzKSB7XG4gICAgICAgIHRoaXMub25Gb2N1cy5lbWl0KCk7XG4gICAgICAgIGlmICh0aGlzLnBpY2tlclNlcnZpY2UpIHtcbiAgICAgICAgICAgIHRoaXMucGlja2VyU2VydmljZS5vbkZvY3VzLmVtaXQoYXJncyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZW1pdEJsdXIoYXJncykge1xuICAgICAgICB0aGlzLm9uQmx1ci5lbWl0KCk7XG4gICAgICAgIGlmICh0aGlzLnBpY2tlclNlcnZpY2UpIHtcbiAgICAgICAgICAgIHRoaXMucGlja2VyU2VydmljZS5vbkJsdXIuZW1pdChhcmdzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGVJbmNvbXBsZXRlVmFsaWRhdGlvblN0YXR1cygpIHtcbiAgICAgICAgY29uc3QgcHJldmlvdXNWYWx1ZSA9IHRoaXMuaXNEYXRlSW5jb21wbGV0ZTtcbiAgICAgICAgdGhpcy5pc0RhdGVJbmNvbXBsZXRlID0gdGhpcy5rZW5kb0RhdGUuaGFzVmFsdWUoKSAmJiB0aGlzLnZhbHVlID09PSBudWxsO1xuICAgICAgICBpZiAocHJldmlvdXNWYWx1ZSA9PT0gdGhpcy5pc0RhdGVJbmNvbXBsZXRlIHx8ICF0aGlzLmluY29tcGxldGVEYXRlVmFsaWRhdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5uZ0NvbnRyb2wpICYmICFpc1ByZXNlbnQodGhpcy5waWNrZXJTZXJ2aWNlKSkge1xuICAgICAgICAgICAgdGhpcy5jZHIubWFya0ZvckNoZWNrKCk7XG4gICAgICAgICAgICB0aGlzLm5nWm9uZS5ydW4oKCkgPT4gdGhpcy5vblZhbGlkYXRvckNoYW5nZSgpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc1ByZXNlbnQodGhpcy5waWNrZXJTZXJ2aWNlKSkge1xuICAgICAgICAgICAgdGhpcy5waWNrZXJTZXJ2aWNlLmRhdGVDb21wbGV0ZW5lc3NDaGFuZ2UuZW1pdCgpO1xuICAgICAgICB9XG4gICAgfVxufTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIERhdGVJbnB1dENvbXBvbmVudC5wcm90b3R5cGUsIFwiZm9jdXNhYmxlSWRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBEYXRlSW5wdXRDb21wb25lbnQucHJvdG90eXBlLCBcImRpc2FibGVkXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgRGF0ZUlucHV0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJyZWFkb25seVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgRGF0ZUlucHV0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJ0aXRsZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgRGF0ZUlucHV0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJ0YWJpbmRleFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgRGF0ZUlucHV0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJyb2xlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgRGF0ZUlucHV0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJhcmlhUmVhZE9ubHlcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlciksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtOdW1iZXJdKVxuXSwgRGF0ZUlucHV0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJ0YWJJbmRleFwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIERhdGVJbnB1dENvbXBvbmVudC5wcm90b3R5cGUsIFwiZm9ybWF0XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBEYXRlSW5wdXRDb21wb25lbnQucHJvdG90eXBlLCBcImZvcm1hdFBsYWNlaG9sZGVyXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBEYXRlSW5wdXRDb21wb25lbnQucHJvdG90eXBlLCBcInBsYWNlaG9sZGVyXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBEYXRlSW5wdXRDb21wb25lbnQucHJvdG90eXBlLCBcInN0ZXBzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBEYXRlKVxuXSwgRGF0ZUlucHV0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJtYXhcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIERhdGUpXG5dLCBEYXRlSW5wdXRDb21wb25lbnQucHJvdG90eXBlLCBcIm1pblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIERhdGVJbnB1dENvbXBvbmVudC5wcm90b3R5cGUsIFwicmFuZ2VWYWxpZGF0aW9uXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgRGF0ZUlucHV0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJhdXRvQ29ycmVjdFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIERhdGVJbnB1dENvbXBvbmVudC5wcm90b3R5cGUsIFwiaW5jb21wbGV0ZURhdGVWYWxpZGF0aW9uXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBEYXRlSW5wdXRDb21wb25lbnQucHJvdG90eXBlLCBcInR3b0RpZ2l0WWVhck1heFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRGF0ZSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtEYXRlXSlcbl0sIERhdGVJbnB1dENvbXBvbmVudC5wcm90b3R5cGUsIFwidmFsdWVcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgRGF0ZUlucHV0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJzcGlubmVyc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIERhdGVJbnB1dENvbXBvbmVudC5wcm90b3R5cGUsIFwiaXNQb3B1cE9wZW5cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBEYXRlSW5wdXRDb21wb25lbnQucHJvdG90eXBlLCBcImhhc1BvcHVwXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBPdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxuXSwgRGF0ZUlucHV0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJ2YWx1ZUNoYW5nZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbl0sIERhdGVJbnB1dENvbXBvbmVudC5wcm90b3R5cGUsIFwidmFsdWVVcGRhdGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIE91dHB1dCgnZm9jdXMnKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxuXSwgRGF0ZUlucHV0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJvbkZvY3VzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBPdXRwdXQoJ2JsdXInKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxuXSwgRGF0ZUlucHV0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJvbkJsdXJcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIFZpZXdDaGlsZCgnZGF0ZUlucHV0JywgeyBzdGF0aWM6IHRydWUgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEVsZW1lbnRSZWYpXG5dLCBEYXRlSW5wdXRDb21wb25lbnQucHJvdG90eXBlLCBcImRhdGVJbnB1dFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgVmlld0NoaWxkKCd3cmFwJywgeyBzdGF0aWM6IGZhbHNlIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFbGVtZW50UmVmKVxuXSwgRGF0ZUlucHV0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJ3cmFwXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBIb3N0QmluZGluZygnY2xhc3Muay13aWRnZXQnKSxcbiAgICBIb3N0QmluZGluZygnY2xhc3Muay1kYXRlaW5wdXQnKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgRGF0ZUlucHV0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJ3cmFwcGVyQ2xhc3NcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBIb3N0QmluZGluZygnY2xhc3Muay1zdGF0ZS1kaXNhYmxlZCcpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBEYXRlSW5wdXRDb21wb25lbnQucHJvdG90eXBlLCBcImRpc2FibGVkQ2xhc3NcIiwgbnVsbCk7XG5EYXRlSW5wdXRDb21wb25lbnQgPSBEYXRlSW5wdXRDb21wb25lbnRfMSA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICBleHBvcnRBczogJ2tlbmRvLWRhdGVpbnB1dCcsXG4gICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAgeyBwcm92aWRlOiBOR19WQUxVRV9BQ0NFU1NPUiwgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gRGF0ZUlucHV0Q29tcG9uZW50XzEpLCBtdWx0aTogdHJ1ZSB9LFxuICAgICAgICAgICAgeyBwcm92aWRlOiBOR19WQUxJREFUT1JTLCB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBEYXRlSW5wdXRDb21wb25lbnRfMSksIG11bHRpOiB0cnVlIH0sXG4gICAgICAgICAgICB7IHByb3ZpZGU6IEwxME5fUFJFRklYLCB1c2VWYWx1ZTogJ2tlbmRvLmRhdGVpbnB1dCcgfSxcbiAgICAgICAgICAgIHsgcHJvdmlkZTogS2VuZG9JbnB1dCwgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gRGF0ZUlucHV0Q29tcG9uZW50XzEpIH0sXG4gICAgICAgICAgICBMb2NhbGl6YXRpb25TZXJ2aWNlXG4gICAgICAgIF0sXG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tZGF0ZWlucHV0JyxcbiAgICAgICAgdGVtcGxhdGU6IGBcbiAgICA8bmctY29udGFpbmVyIGtlbmRvRGF0ZUlucHV0TG9jYWxpemVkTWVzc2FnZXNcbiAgICAgICAgaTE4bi1pbmNyZW1lbnQ9XCJrZW5kby5kYXRlaW5wdXQuaW5jcmVtZW50fFRoZSBsYWJlbCBmb3IgdGhlICoqSW5jcmVtZW50KiogYnV0dG9uIGluIHRoZSBEYXRlSW5wdXRcIlxuICAgICAgICBpbmNyZW1lbnQ9XCJJbmNyZWFzZSB2YWx1ZVwiXG5cbiAgICAgICAgaTE4bi1kZWNyZW1lbnQ9XCJrZW5kby5kYXRlaW5wdXQuZGVjcmVtZW50fFRoZSBsYWJlbCBmb3IgdGhlICoqRGVjcmVtZW50KiogYnV0dG9uIGluIHRoZSBEYXRlSW5wdXRcIlxuICAgICAgICBkZWNyZW1lbnQ9XCJEZWNyZWFzZSB2YWx1ZVwiXG4gICAgPlxuICAgIDwvbmctY29udGFpbmVyPlxuICAgIDxzcGFuIGNsYXNzPVwiay1kYXRlaW5wdXQtd3JhcFwiICN3cmFwPlxuICAgICAgICA8aW5wdXRcbiAgICAgICAgICAgICNkYXRlSW5wdXRcbiAgICAgICAgICAgIGF1dG9jb21wbGV0ZT1cIm9mZlwiXG4gICAgICAgICAgICBhdXRvY29ycmVjdD1cIm9mZlwiXG4gICAgICAgICAgICBhdXRvY2FwaXRhbGl6ZT1cIm9mZlwiXG4gICAgICAgICAgICBzcGVsbGNoZWNrPVwiZmFsc2VcIlxuICAgICAgICAgICAgY2xhc3M9XCJrLWlucHV0XCJcbiAgICAgICAgICAgIFthdHRyLnJvbGVdPVwicm9sZVwiXG4gICAgICAgICAgICBbYXR0ci5hcmlhLXJlYWRvbmx5XT1cImFyaWFSZWFkT25seVwiXG4gICAgICAgICAgICBbaWRdPVwiZm9jdXNhYmxlSWRcIlxuICAgICAgICAgICAgW3RpdGxlXT1cInRpdGxlXCJcbiAgICAgICAgICAgIFt0YWJpbmRleF09XCJ0YWJpbmRleFwiXG4gICAgICAgICAgICBbZGlzYWJsZWRdPVwiZGlzYWJsZWRcIlxuICAgICAgICAgICAgW3JlYWRvbmx5XT1cInJlYWRvbmx5XCJcbiAgICAgICAgICAgIFtwbGFjZWhvbGRlcl09XCJwbGFjZWhvbGRlclwiXG4gICAgICAgICAgICBbYXR0ci5hcmlhLWV4cGFuZGVkXT1cImlzUG9wdXBPcGVuXCJcbiAgICAgICAgICAgIFthdHRyLmFyaWEtaGFzcG9wdXBdPVwiaGFzUG9wdXBcIlxuICAgICAgICAgICAgW2tlbmRvRXZlbnRzT3V0c2lkZUFuZ3VsYXJdPVwie1xuICAgICAgICAgICAgICAgIGNsaWNrOiBoYW5kbGVDbGljayxcbiAgICAgICAgICAgICAgICBmb2N1czogaGFuZGxlRm9jdXMsXG4gICAgICAgICAgICAgICAgbW91c2Vkb3duOiBoYW5kbGVNb3VzZWRvd24sXG4gICAgICAgICAgICAgICAgdG91Y2hzdGFydDogaGFuZGxlTW91c2Vkb3duLFxuICAgICAgICAgICAgICAgIGRyYWdzdGFydDogaGFuZGxlRHJhZ0FuZERyb3AsXG4gICAgICAgICAgICAgICAgZHJvcDogaGFuZGxlRHJhZ0FuZERyb3AsXG4gICAgICAgICAgICAgICAgYmx1cjogaGFuZGxlQmx1clxuICAgICAgICAgICAgfVwiXG4gICAgICAgICAgICBbc2NvcGVdPVwidGhpc1wiXG4gICAgICAgICAgICAvPlxuICAgICAgICA8c3BhbiAqbmdJZj1cInNwaW5uZXJzXCIgY2xhc3M9XCJrLXNlbGVjdFwiIChtb3VzZWRvd24pPVwiJGV2ZW50LnByZXZlbnREZWZhdWx0KClcIj5cbiAgICAgICAgICAgIDxzcGFuXG4gICAgICAgICAgICAgICAgY2xhc3M9XCJrLWxpbmsgay1saW5rLWluY3JlYXNlXCJcbiAgICAgICAgICAgICAgICBbY2xhc3Muay1zdGF0ZS1hY3RpdmVdPVwiYXJyb3dEaXJlY3Rpb24gPT09IGFycm93LlVwXCJcbiAgICAgICAgICAgICAgICAobW91c2Vkb3duKT1cImFycm93RGlyZWN0aW9uID0gYXJyb3cuVXBcIlxuICAgICAgICAgICAgICAgIChtb3VzZWxlYXZlKT1cImFycm93RGlyZWN0aW9uID0gYXJyb3cuTm9uZVwiXG4gICAgICAgICAgICAgICAgKGNsaWNrKT1cImhhbmRsZUJ1dHRvbkNsaWNrKDEpXCJcbiAgICAgICAgICAgICAgICBbdGl0bGVdPVwibG9jYWxpemF0aW9uLmdldCgnaW5jcmVtZW50JylcIlxuICAgICAgICAgICAgICAgIFthdHRyLmFyaWEtbGFiZWxdPVwibG9jYWxpemF0aW9uLmdldCgnaW5jcmVtZW50JylcIj5cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImstaWNvbiBrLWktYXJyb3ctblwiPjwvc3Bhbj5cbiAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgIDxzcGFuXG4gICAgICAgICAgICAgICAgY2xhc3M9XCJrLWxpbmsgay1saW5rLWRlY3JlYXNlXCJcbiAgICAgICAgICAgICAgICAoY2xpY2spPVwiaGFuZGxlQnV0dG9uQ2xpY2soLTEpXCJcbiAgICAgICAgICAgICAgICBbY2xhc3Muay1zdGF0ZS1hY3RpdmVdPVwiYXJyb3dEaXJlY3Rpb24gPT09IGFycm93LkRvd25cIlxuICAgICAgICAgICAgICAgIChtb3VzZWRvd24pPVwiYXJyb3dEaXJlY3Rpb24gPSBhcnJvdy5Eb3duXCJcbiAgICAgICAgICAgICAgICAobW91c2VsZWF2ZSk9XCJhcnJvd0RpcmVjdGlvbiA9IGFycm93Lk5vbmVcIlxuICAgICAgICAgICAgICAgIFt0aXRsZV09XCJsb2NhbGl6YXRpb24uZ2V0KCdkZWNyZW1lbnQnKVwiXG4gICAgICAgICAgICAgICAgW2F0dHIuYXJpYS1sYWJlbF09XCJsb2NhbGl6YXRpb24uZ2V0KCdkZWNyZW1lbnQnKVwiPlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiay1pY29uIGstaS1hcnJvdy1zXCI+PC9zcGFuPlxuICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICA8L3NwYW4+XG4gICAgPC9zcGFuPlxuICBgXG4gICAgfSksXG4gICAgX19wYXJhbSg3LCBPcHRpb25hbCgpKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0NoYW5nZURldGVjdG9yUmVmLFxuICAgICAgICBJbnRsU2VydmljZSxcbiAgICAgICAgUmVuZGVyZXIyLFxuICAgICAgICBFbGVtZW50UmVmLFxuICAgICAgICBOZ1pvbmUsXG4gICAgICAgIEluamVjdG9yLFxuICAgICAgICBMb2NhbGl6YXRpb25TZXJ2aWNlLFxuICAgICAgICBQaWNrZXJTZXJ2aWNlXSlcbl0sIERhdGVJbnB1dENvbXBvbmVudCk7XG5cbi8qKlxuICogQSBwcmV2ZW50YWJsZSBldmVudCBpbnN0YW5jZSB3aGljaCBpcyB0cmlnZ2VyZWQgYnkgdGhlIGBvcGVuYCBhbmQgYGNsb3NlYCBldmVudHMuXG4gKi9cbmNsYXNzIFByZXZlbnRhYmxlRXZlbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnByZXZlbnRlZCA9IGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcmV2ZW50cyB0aGUgZGVmYXVsdCBhY3Rpb24gZm9yIGEgc3BlY2lmaWVkIGV2ZW50LlxuICAgICAqIEluIHRoaXMgd2F5LCB0aGUgc291cmNlIGNvbXBvbmVudCBzdXBwcmVzc2VzIHRoZSBidWlsdC1pbiBiZWhhdmlvciB0aGF0IGZvbGxvd3MgdGhlIGV2ZW50LlxuICAgICAqL1xuICAgIHByZXZlbnREZWZhdWx0KCkge1xuICAgICAgICB0aGlzLnByZXZlbnRlZCA9IHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIElmIHRoZSBldmVudCBpcyBwcmV2ZW50ZWQgYnkgYW55IG9mIGl0cyBzdWJzY3JpYmVycywgcmV0dXJucyBgdHJ1ZWAuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGRlZmF1bHQgYWN0aW9uIHdhcyBwcmV2ZW50ZWQuIE90aGVyd2lzZSwgcmV0dXJucyBgZmFsc2VgLlxuICAgICAqL1xuICAgIGlzRGVmYXVsdFByZXZlbnRlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJldmVudGVkO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IFRPVUNIX0VOQUJMRUQgPSBuZXcgSW5qZWN0aW9uVG9rZW4oJ2RhdGVpbnB1dHMtdG91Y2gtZW5hYmxlZCcpO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgZGlzYWJsZWREYXRlc1ZhbGlkYXRvciA9IChpc0RhdGVEaXNhYmxlZCkgPT4ge1xuICAgIHJldHVybiAoY29udHJvbCkgPT4ge1xuICAgICAgICBpZiAoIWlzRGF0ZURpc2FibGVkIHx8ICFjb250cm9sLnZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlcnJvciA9IHtcbiAgICAgICAgICAgIGRpc2FibGVkRGF0ZTogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gaXNEYXRlRGlzYWJsZWQoY29udHJvbC52YWx1ZSkgPyBlcnJvciA6IG51bGw7XG4gICAgfTtcbn07XG5cbi8qIHRzbGludDpkaXNhYmxlOm1heC1saW5lLWxlbmd0aCAqL1xudmFyIERhdGVQaWNrZXJDb21wb25lbnRfMTtcbmNvbnN0IE1JTl9ET0NfTElOSyQyID0gJ2h0dHA6Ly93d3cudGVsZXJpay5jb20va2VuZG8tYW5ndWxhci11aS9jb21wb25lbnRzL2RhdGVpbnB1dHMvYXBpL0RhdGVQaWNrZXJDb21wb25lbnQvI3RvYy1taW4nO1xuY29uc3QgTUFYX0RPQ19MSU5LJDIgPSAnaHR0cDovL3d3dy50ZWxlcmlrLmNvbS9rZW5kby1hbmd1bGFyLXVpL2NvbXBvbmVudHMvZGF0ZWlucHV0cy9hcGkvRGF0ZVBpY2tlckNvbXBvbmVudC8jdG9jLW1heCc7XG5jb25zdCBWQUxVRV9ET0NfTElOSyQyID0gJ2h0dHA6Ly93d3cudGVsZXJpay5jb20va2VuZG8tYW5ndWxhci11aS9jb21wb25lbnRzL2RhdGVpbnB1dHMvZGF0ZXBpY2tlci8jdG9jLXVzaW5nLXdpdGgtanNvbic7XG5jb25zdCBERUZBVUxUX0ZPUk1BVCQxID0gJ2QnO1xuY29uc3QgVFdPX0RJR0lUX1lFQVJfTUFYJDEgPSA2ODtcbi8qKlxuICogUmVwcmVzZW50cyB0aGUgW0tlbmRvIFVJIERhdGVQaWNrZXIgY29tcG9uZW50IGZvciBBbmd1bGFyXSh7JSBzbHVnIG92ZXJ2aWV3X2RhdGVwaWNrZXIgJX0jdG9jLWJhc2ljLXVzYWdlKS5cbiAqL1xubGV0IERhdGVQaWNrZXJDb21wb25lbnQgPSBEYXRlUGlja2VyQ29tcG9uZW50XzEgPSBjbGFzcyBEYXRlUGlja2VyQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcih6b25lLCBsb2NhbGl6YXRpb24sIGNkciwgcG9wdXBTZXJ2aWNlLCBlbGVtZW50LCByZW5kZXJlciwgaW5qZWN0b3IsIHBpY2tlclNlcnZpY2UsIGRpc2FibGVkRGF0ZXNTZXJ2aWNlLCB0b3VjaEVuYWJsZWQkJDEpIHtcbiAgICAgICAgdGhpcy56b25lID0gem9uZTtcbiAgICAgICAgdGhpcy5sb2NhbGl6YXRpb24gPSBsb2NhbGl6YXRpb247XG4gICAgICAgIHRoaXMuY2RyID0gY2RyO1xuICAgICAgICB0aGlzLnBvcHVwU2VydmljZSA9IHBvcHVwU2VydmljZTtcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgICAgICB0aGlzLmluamVjdG9yID0gaW5qZWN0b3I7XG4gICAgICAgIHRoaXMucGlja2VyU2VydmljZSA9IHBpY2tlclNlcnZpY2U7XG4gICAgICAgIHRoaXMuZGlzYWJsZWREYXRlc1NlcnZpY2UgPSBkaXNhYmxlZERhdGVzU2VydmljZTtcbiAgICAgICAgdGhpcy50b3VjaEVuYWJsZWQgPSB0b3VjaEVuYWJsZWQkJDE7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaGlkZGVuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmZvY3VzYWJsZUlkID0gYGstJHtndWlkKCl9YDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlZmluZXMgdGhlIGFjdGl2ZSB2aWV3IHRoYXQgdGhlIENhbGVuZGFyIGluaXRpYWxseSByZW5kZXJzXG4gICAgICAgICAqIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgY2FsZW5kYXJfdHlwZV9kYXRlcGlja2VyICV9I3RvYy1hY3RpdmUtdmlldykpLlxuICAgICAgICAgKiBCeSBkZWZhdWx0LCB0aGUgYWN0aXZlIHZpZXcgaXMgYG1vbnRoYC5cbiAgICAgICAgICpcbiAgICAgICAgICogPiBZb3UgaGF2ZSB0byBzZXQgYGFjdGl2ZVZpZXdgIHdpdGhpbiB0aGUgYHRvcFZpZXdgLWBib3R0b21WaWV3YCByYW5nZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYWN0aXZlVmlldyA9IENhbGVuZGFyVmlld0VudW1bQ2FsZW5kYXJWaWV3RW51bS5tb250aF07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWZpbmVzIHRoZSBib3R0b21tb3N0IENhbGVuZGFyIHZpZXcgdG8gd2hpY2ggdGhlIHVzZXIgY2FuIG5hdmlnYXRlXG4gICAgICAgICAqIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgY2FsZW5kYXJfdHlwZV9kYXRlcGlja2VyICV9I3RvYy1mb2N1c2VkLWRhdGVzKSkuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmJvdHRvbVZpZXcgPSBDYWxlbmRhclZpZXdFbnVtW0NhbGVuZGFyVmlld0VudW0ubW9udGhdO1xuICAgICAgICAvKipcbiAgICAgICAgICogRGVmaW5lcyB0aGUgdG9wbW9zdCBDYWxlbmRhciB2aWV3IHRvIHdoaWNoIHRoZSB1c2VyIGNhbiBuYXZpZ2F0ZVxuICAgICAgICAgKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGNhbGVuZGFyX3R5cGVfZGF0ZXBpY2tlciAlfSN0b2MtZm9jdXNlZC1kYXRlcykpLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50b3BWaWV3ID0gQ2FsZW5kYXJWaWV3RW51bVtDYWxlbmRhclZpZXdFbnVtLmNlbnR1cnldO1xuICAgICAgICAvKipcbiAgICAgICAgICogU3BlY2lmaWVzIHRoZSBDYWxlbmRhciB0eXBlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGUgcG9zc2libGUgdmFsdWVzIGFyZTpcbiAgICAgICAgICogLSBgaW5maW5pdGVgIChkZWZhdWx0KVxuICAgICAgICAgKiAtIGBjbGFzc2ljYFxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jYWxlbmRhclR5cGUgPSAnaW5maW5pdGUnO1xuICAgICAgICAvKipcbiAgICAgICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRvIGVuYWJsZSBhbmltYXRpb24gd2hlbiBuYXZpZ2F0aW5nIHRvIHByZXZpb3VzL25leHQgQ2FsZW5kYXIgdmlldy5cbiAgICAgICAgICogQXBwbGllcyB0byB0aGUgW2BjbGFzc2ljYF0oeyUgc2x1ZyBhcGlfZGF0ZWlucHV0c19kYXRlcGlja2VyY29tcG9uZW50ICV9I3RvYy1jYWxlbmRhcnR5cGUpIENhbGVuZGFyIG9ubHkuXG4gICAgICAgICAqXG4gICAgICAgICAqID4gVGhpcyBmZWF0dXJlIHVzZXMgdGhlIFtXZWIgQW5pbWF0aW9ucyBBUEldKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9XZWJfQW5pbWF0aW9uc19BUEkpLiBJbiBvcmRlciB0byBydW4gdGhlIGFuaW1hdGlvbiBpbiBicm93c2VycyB0aGF0IGRvIG5vdCBzdXBwb3J0IGl0LCB5b3UgbmVlZCB0aGUgYHdlYi1hbmltYXRpb25zLWpzYCBwb2x5ZmlsbC5cbiAgICAgICAgICpcbiAgICAgICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYW5pbWF0ZUNhbGVuZGFyTmF2aWdhdGlvbiA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0cyBvciBnZXRzIHRoZSBgZGlzYWJsZWRgIHByb3BlcnR5IG9mIHRoZSBEYXRlUGlja2VyIGFuZCBkZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGNvbXBvbmVudCBpcyBhY3RpdmVcbiAgICAgICAgICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBkaXNhYmxlZF9kYXRlcGlja2VyICV9KSkuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRpc2FibGVkID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXRzIHRoZSByZWFkLW9ubHkgc3RhdGUgb2YgdGhlIERhdGVQaWNrZXJcbiAgICAgICAgICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyByZWFkb25seV9kYXRlcGlja2VyICV9I3RvYy1yZWFkLW9ubHktZGF0ZXBpY2tlcikpLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZWFkb25seSA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0cyB0aGUgcmVhZC1vbmx5IHN0YXRlIG9mIHRoZSBEYXRlUGlja2VyIGlucHV0IGZpZWxkXG4gICAgICAgICAqIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgcmVhZG9ubHlfZGF0ZXBpY2tlciAlfSN0b2MtcmVhZC1vbmx5LWlucHV0KSkuXG4gICAgICAgICAqXG4gICAgICAgICAqID4gTm90ZSB0aGF0IGlmIHlvdSBzZXQgdGhlIFtgcmVhZG9ubHlgXSh7JSBzbHVnIGFwaV9kYXRlaW5wdXRzX2RhdGVwaWNrZXJjb21wb25lbnQgJX0jdG9jLXJlYWRvbmx5KSBwcm9wZXJ0eSB2YWx1ZSB0byBgdHJ1ZWAsXG4gICAgICAgICAqIHRoZSBpbnB1dCB3aWxsIGJlIHJlbmRlcmVkIGluIGEgcmVhZC1vbmx5IHN0YXRlIHJlZ2FyZGxlc3Mgb2YgdGhlIGByZWFkT25seUlucHV0YCB2YWx1ZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVhZE9ubHlJbnB1dCA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0cyBvciBnZXRzIHRoZSBgbmF2aWdhdGlvbmAgcHJvcGVydHkgb2YgdGhlIENhbGVuZGFyXG4gICAgICAgICAqIGFuZCBkZXRlcm1pbmVzIHdoZXRoZXIgdGhlIG5hdmlnYXRpb24gc2lkZS1iYXIgaXMgZGlzcGxheWVkLlxuICAgICAgICAgKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIHNpZGViYXJfZGF0ZXBpY2tlciAlfSkpLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5uYXZpZ2F0aW9uID0gdHJ1ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZmllcyB0aGUgc21hbGxlc3QgdmFsaWQgZGF0ZVxuICAgICAgICAgKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGRhdGVyYW5nZXNfZGF0ZXBpY2tlciAlfSkpLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5taW4gPSBjbG9uZURhdGUoTUlOX0RBVEUpO1xuICAgICAgICAvKipcbiAgICAgICAgICogU3BlY2lmaWVzIHRoZSBiaWdnZXN0IHZhbGlkIGRhdGVcbiAgICAgICAgICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBkYXRlcmFuZ2VzX2RhdGVwaWNrZXIgJX0pKS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubWF4ID0gY2xvbmVEYXRlKE1BWF9EQVRFKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERldGVybWluZXMgd2hldGhlciB0aGUgYnVpbHQtaW4gdmFsaWRhdGlvbiBmb3IgaW5jb21wbGV0ZSBkYXRlcyBpcyB0byBiZSBlbmZvcmNlZCB3aGVuIGEgZm9ybSBpcyBiZWluZyB2YWxpZGF0ZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmluY29tcGxldGVEYXRlVmFsaWRhdGlvbiA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogU3BlY2lmaWVzIHRoZSBmb2N1c2VkIGRhdGUgb2YgdGhlIENhbGVuZGFyIGNvbXBvbmVudFxuICAgICAgICAgKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGNhbGVuZGFyX3R5cGVfZGF0ZXBpY2tlciAlfSN0b2MtZm9jdXNlZC1kYXRlcykpLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5mb2N1c2VkRGF0ZSA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVjaWZpZXMgdGhlIGRhdGUgZm9ybWF0IHRoYXQgaXMgdXNlZCB0byBkaXNwbGF5IHRoZSBpbnB1dCB2YWx1ZVxuICAgICAgICAgKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGZvcm1hdHNfZGF0ZXBpY2tlciAlfSkpLlxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3JtYXQgdmFsdWUgb3B0aW9uczpcbiAgICAgICAgICogLSBgc3RyaW5nYCAtIFByb3ZpZGUgYSBgc3RyaW5nYCBpZiBhIHNpbmdsZSBmb3JtYXQgaXMgZ29pbmcgdG8gYmUgdXNlZCByZWdhcmRsZXNzIHdoZXRoZXIgdGhlIGlucHV0IGlzIGZvY3VzZWQgb3IgYmx1cnJlZC5cbiAgICAgICAgICogLSBbYEZvcm1hdFNldHRpbmdzYF0oeyUgc2x1ZyBhcGlfZGF0ZWlucHV0c19mb3JtYXRzZXR0aW5ncyAlfSkgLSBUbyBkaXNwbGF5IGRpZmZlcmVudCBmb3JtYXRzIHdoZW4gdGhlIGNvbXBvbmVudCBpcyBmb2N1c2VkIG9yIGJsdXJyZWQsIHByb3ZpZGUgYSBzZXR0aW5ncyBvYmplY3Qgd2l0aCBzcGVjaWZpZWQgYGlucHV0Rm9ybWF0YCBhbmQgYGRpc3BsYXlGb3JtYXRgIHZhbHVlcy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZm9ybWF0ID0gREVGQVVMVF9GT1JNQVQkMTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBtYXhpbXVtIHllYXIgdG8gYXNzdW1lIHRvIGJlIGZyb20gdGhlIGN1cnJlbnQgY2VudHVyeSB3aGVuIHR5cGluZyB0d28tZGlnaXQgeWVhciB2YWx1ZVxuICAgICAgICAgKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGZvcm1hdHNfZGF0ZXBpY2tlciAlfSN0b2MtdHdvLWRpZ2l0LXllYXItZm9ybWF0KSkuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSBkZWZhdWx0IHZhbHVlIGlzIDY4LCBpbmRpY2F0aW5nIHRoYXQgdHlwaW5nIGFueSB2YWx1ZSBsZXNzIHRoYW4gNjlcbiAgICAgICAgICogd2lsbCBiZSBhc3N1bWVkIHRvIGJlIDIweHgsIHdoaWxlIDY5IGFuZCBsYXJnZXIgd2lsbCBiZSBhc3N1bWVkIHRvIGJlIDE5eHguXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnR3b0RpZ2l0WWVhck1heCA9IFRXT19ESUdJVF9ZRUFSX01BWCQxO1xuICAgICAgICAvKipcbiAgICAgICAgICogU3BlY2lmaWVzIHRoZSBoaW50IHRoZSBEYXRlUGlja2VyIGRpc3BsYXlzIHdoZW4gaXRzIHZhbHVlIGlzIGBudWxsYC5cbiAgICAgICAgICogKFttb3JlIGluZm9ybWF0aW9uIGFuZCBleGFwbGVzXSh7JSBzbHVnIHBsYWNlaG9sZGVyc19kYXRlcGlja2VyICV9KSkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIGBgYHRzXG4gICAgICAgICAqIF9AQ29tcG9uZW50KHtcbiAgICAgICAgICogc2VsZWN0b3I6ICdteS1hcHAnLFxuICAgICAgICAgKiB0ZW1wbGF0ZTogYFxuICAgICAgICAgKiAgPGtlbmRvLWRhdGVwaWNrZXIgcGxhY2Vob2xkZXI9XCJFbnRlciBiaXJ0aCBkYXRlLi4uXCI+PC9rZW5kby1kYXRlcGlja2VyPlxuICAgICAgICAgKiBgXG4gICAgICAgICAqIH0pXG4gICAgICAgICAqIGV4cG9ydCBjbGFzcyBBcHBDb21wb25lbnQgeyB9XG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wbGFjZWhvbGRlciA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXRzIG9yIGdldHMgdGhlIGB0YWJpbmRleGAgcHJvcGVydHkgb2YgdGhlIERhdGVQaWNrZXIuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRhYmluZGV4ID0gMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgdGhlIHRpdGxlIG9mIHRoZSBpbnB1dCBlbGVtZW50IG9mIHRoZSBEYXRlUGlja2VyLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50aXRsZSA9IFwiXCI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGJ1aWx0LWluIG1pbiBvciBtYXggdmFsaWRhdG9ycyBhcmUgZW5mb3JjZWQgd2hlbiB2YWxpZGF0aW5nIGEgZm9ybS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmFuZ2VWYWxpZGF0aW9uID0gdHJ1ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERldGVybWluZXMgd2hldGhlciB0aGUgYnVpbHQtaW4gdmFsaWRhdG9yIGZvciBkaXNhYmxlZFxuICAgICAgICAgKiBkYXRlIHJhbmdlcyBpcyBlbmZvcmNlZCB3aGVuIHZhbGlkYXRpbmcgYSBmb3JtXG4gICAgICAgICAqIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgZGlzYWJsZWRfZGF0ZXNfZGF0ZXBpY2tlciAlfSN0b2MtdmFsaWRhdGlvbikpLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kaXNhYmxlZERhdGVzVmFsaWRhdGlvbiA9IHRydWU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgdG8gZGlzcGxheSBhIHdlZWsgbnVtYmVyIGNvbHVtbiBpbiB0aGUgYG1vbnRoYCB2aWV3IG9mIHRoZSBDYWxlbmRhclxuICAgICAgICAgKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGNhbGVuZGFyX3R5cGVfZGF0ZXBpY2tlciAlfSN0b2Mtd2Vlay1udW1iZXItY29sdW1uKSkuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLndlZWtOdW1iZXIgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIGVhY2ggdGltZSB0aGUgdXNlciBzZWxlY3RzIGEgbmV3IHZhbHVlXG4gICAgICAgICAqIChbbW9yZSBpbmZvcm1hdGlvbiBhbmQgZXhhbXBsZV0oeyUgc2x1ZyBvdmVydmlld19kYXRlcGlja2VyICV9I3RvYy1ldmVudHMpKS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudmFsdWVDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyBlYWNoIHRpbWUgdGhlIHVzZXIgZm9jdXNlcyB0aGUgaW5wdXQgZWxlbWVudFxuICAgICAgICAgKiAoW21vcmUgaW5mb3JtYXRpb24gYW5kIGV4YW1wbGVdKHslIHNsdWcgb3ZlcnZpZXdfZGF0ZXBpY2tlciAlfSN0b2MtZXZlbnRzKSkuXG4gICAgICAgICAqXG4gICAgICAgICAqID4gVG8gd2lyZSB0aGUgZXZlbnQgcHJvZ3JhbW1hdGljYWxseSwgdXNlIHRoZSBgb25Gb2N1c2AgcHJvcGVydHkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIGBgYHRzXG4gICAgICAgICAqIF9AQ29tcG9uZW50KHtcbiAgICAgICAgICogc2VsZWN0b3I6ICdteS1hcHAnLFxuICAgICAgICAgKiB0ZW1wbGF0ZTogYFxuICAgICAgICAgKiAgPGtlbmRvLWRhdGVwaWNrZXIgKGZvY3VzKT1cImhhbmRsZUZvY3VzKClcIj48L2tlbmRvLWRhdGVwaWNrZXI+XG4gICAgICAgICAqIGBcbiAgICAgICAgICogfSlcbiAgICAgICAgICogZXhwb3J0IGNsYXNzIEFwcENvbXBvbmVudCB7XG4gICAgICAgICAqICAgcHVibGljIGhhbmRsZUZvY3VzKCk6IHZvaWQge1xuICAgICAgICAgKiAgICAgIGNvbnNvbGUubG9nKFwiQ29tcG9uZW50IGlzIGZvY3VzZWRcIik7XG4gICAgICAgICAqICAgfVxuICAgICAgICAgKiB9XG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vbkZvY3VzID0gbmV3IEV2ZW50RW1pdHRlcigpOyAvL3RzbGludDpkaXNhYmxlLWxpbmU6bm8tb3V0cHV0LXJlbmFtZVxuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgZWFjaCB0aW1lIHRoZSBpbnB1dCBlbGVtZW50IGdldHMgYmx1cnJlZFxuICAgICAgICAgKiAoW21vcmUgaW5mb3JtYXRpb24gYW5kIGV4YW1wbGVdKHslIHNsdWcgb3ZlcnZpZXdfZGF0ZXBpY2tlciAlfSN0b2MtZXZlbnRzKSkuXG4gICAgICAgICAqXG4gICAgICAgICAqID4gVG8gd2lyZSB0aGUgZXZlbnQgcHJvZ3JhbW1hdGljYWxseSwgdXNlIHRoZSBgb25CbHVyYCBwcm9wZXJ0eS5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogYGBgdHNcbiAgICAgICAgICogX0BDb21wb25lbnQoe1xuICAgICAgICAgKiBzZWxlY3RvcjogJ215LWFwcCcsXG4gICAgICAgICAqIHRlbXBsYXRlOiBgXG4gICAgICAgICAqICA8a2VuZG8tZGF0ZXBpY2tlciAoYmx1cik9XCJoYW5kbGVCbHVyKClcIj48L2tlbmRvLWRhdGVwaWNrZXI+XG4gICAgICAgICAqIGBcbiAgICAgICAgICogfSlcbiAgICAgICAgICogZXhwb3J0IGNsYXNzIEFwcENvbXBvbmVudCB7XG4gICAgICAgICAqICAgcHVibGljIGhhbmRsZUJsdXIoKTogdm9pZCB7XG4gICAgICAgICAqICAgICAgY29uc29sZS5sb2coXCJDb21wb25lbnQgaXMgYmx1cnJlZFwiKTtcbiAgICAgICAgICogICB9XG4gICAgICAgICAqIH1cbiAgICAgICAgICogYGBgXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9uQmx1ciA9IG5ldyBFdmVudEVtaXR0ZXIoKTsgLy90c2xpbnQ6ZGlzYWJsZS1saW5lOm5vLW91dHB1dC1yZW5hbWVcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIGVhY2ggdGltZSB0aGUgcG9wdXAgaXMgYWJvdXQgdG8gb3Blbi5cbiAgICAgICAgICogVGhpcyBldmVudCBpcyBwcmV2ZW50YWJsZS4gSWYgeW91IGNhbmNlbCB0aGUgZXZlbnQsIHRoZSBwb3B1cCB3aWxsIHJlbWFpbiBjbG9zZWRcbiAgICAgICAgICogKFttb3JlIGluZm9ybWF0aW9uIGFuZCBleGFtcGxlXSh7JSBzbHVnIG92ZXJ2aWV3X2RhdGVwaWNrZXIgJX0jdG9jLWV2ZW50cykpLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vcGVuID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgZWFjaCB0aW1lIHRoZSBwb3B1cCBpcyBhYm91dCB0byBjbG9zZS5cbiAgICAgICAgICogVGhpcyBldmVudCBpcyBwcmV2ZW50YWJsZS4gSWYgeW91IGNhbmNlbCB0aGUgZXZlbnQsIHRoZSBwb3B1cCB3aWxsIHJlbWFpbiBvcGVuXG4gICAgICAgICAqIChbbW9yZSBpbmZvcm1hdGlvbiBhbmQgZXhhbXBsZV0oeyUgc2x1ZyBvdmVydmlld19kYXRlcGlja2VyICV9I3RvYy1ldmVudHMpKS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2xvc2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaGlkZGVuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLndyYXBwZXJDbGFzc2VzID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5wb3B1cFVJRCA9IGd1aWQoKTtcbiAgICAgICAgdGhpcy5fcG9wdXBTZXR0aW5ncyA9IHsgYW5pbWF0ZTogdHJ1ZSB9O1xuICAgICAgICB0aGlzLl9zaG93ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3ZhbHVlID0gbnVsbDtcbiAgICAgICAgdGhpcy5fYWN0aXZlID0gZmFsc2U7XG4gICAgICAgIHRoaXMub25Db250cm9sQ2hhbmdlID0gbm9vcDtcbiAgICAgICAgdGhpcy5vbkNvbnRyb2xUb3VjaGVkID0gbm9vcDtcbiAgICAgICAgdGhpcy5vblZhbGlkYXRvckNoYW5nZSA9IG5vb3A7XG4gICAgICAgIHRoaXMubWluVmFsaWRhdGVGbiA9IG5vb3A7XG4gICAgICAgIHRoaXMubWF4VmFsaWRhdGVGbiA9IG5vb3A7XG4gICAgICAgIHRoaXMuZGlzYWJsZWREYXRlc1ZhbGlkYXRlRm4gPSBub29wO1xuICAgICAgICB0aGlzLmluY29tcGxldGVWYWxpZGF0b3IgPSBub29wO1xuICAgICAgICB0aGlzLnJlc29sdmVkUHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZShudWxsKTtcbiAgICAgICAgdGhpcy5kb21FdmVudHMgPSBbXTtcbiAgICAgICAgdmFsaWRhdGVQYWNrYWdlKHBhY2thZ2VNZXRhZGF0YSk7XG4gICAgICAgIHRoaXMucGlja2VyU3Vic2NyaXB0aW9ucyA9IHRoaXMucGlja2VyU2VydmljZS5vbkZvY3VzLnN1YnNjcmliZSh0aGlzLmhhbmRsZUZvY3VzLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLnBpY2tlclN1YnNjcmlwdGlvbnMuYWRkKHRoaXMucGlja2VyU2VydmljZS5vbkJsdXIuc3Vic2NyaWJlKHRoaXMuaGFuZGxlQmx1ci5iaW5kKHRoaXMpKSk7XG4gICAgICAgIHRoaXMucGlja2VyU3Vic2NyaXB0aW9ucy5hZGQodGhpcy5waWNrZXJTZXJ2aWNlLnNhbWVEYXRlU2VsZWN0ZWQuc3Vic2NyaWJlKHRoaXMuaGFuZGxlU2FtZVNlbGVjdGlvbi5iaW5kKHRoaXMpKSk7XG4gICAgICAgIHRoaXMucGlja2VyU3Vic2NyaXB0aW9ucy5hZGQodGhpcy5waWNrZXJTZXJ2aWNlLmRhdGVDb21wbGV0ZW5lc3NDaGFuZ2Uuc3Vic2NyaWJlKHRoaXMuaGFuZGxlRGF0ZUNvbXBsZXRlbmVzc0NoYW5nZS5iaW5kKHRoaXMpKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBzZXQgY2VsbFRlbXBsYXRlUmVmKHRlbXBsYXRlKSB7XG4gICAgICAgIHRoaXMuY2VsbFRlbXBsYXRlID0gdGVtcGxhdGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBzZXQgbW9udGhDZWxsVGVtcGxhdGVSZWYodGVtcGxhdGUpIHtcbiAgICAgICAgdGhpcy5tb250aENlbGxUZW1wbGF0ZSA9IHRlbXBsYXRlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgc2V0IHllYXJDZWxsVGVtcGxhdGVSZWYodGVtcGxhdGUpIHtcbiAgICAgICAgdGhpcy55ZWFyQ2VsbFRlbXBsYXRlID0gdGVtcGxhdGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBzZXQgZGVjYWRlQ2VsbFRlbXBsYXRlUmVmKHRlbXBsYXRlKSB7XG4gICAgICAgIHRoaXMuZGVjYWRlQ2VsbFRlbXBsYXRlID0gdGVtcGxhdGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBzZXQgY2VudHVyeUNlbGxUZW1wbGF0ZVJlZih0ZW1wbGF0ZSkge1xuICAgICAgICB0aGlzLmNlbnR1cnlDZWxsVGVtcGxhdGUgPSB0ZW1wbGF0ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHNldCB3ZWVrTnVtYmVyVGVtcGxhdGVSZWYodGVtcGxhdGUpIHtcbiAgICAgICAgdGhpcy53ZWVrTnVtYmVyVGVtcGxhdGUgPSB0ZW1wbGF0ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHNldCBoZWFkZXJUaXRsZVRlbXBsYXRlUmVmKHRlbXBsYXRlKSB7XG4gICAgICAgIHRoaXMuaGVhZGVyVGl0bGVUZW1wbGF0ZSA9IHRlbXBsYXRlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgc2V0IG5hdmlnYXRpb25JdGVtVGVtcGxhdGVSZWYodGVtcGxhdGUpIHtcbiAgICAgICAgdGhpcy5uYXZpZ2F0aW9uSXRlbVRlbXBsYXRlID0gdGVtcGxhdGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbmZpZ3VyZXMgdGhlIHBvcHVwIG9wdGlvbnMgb2YgdGhlIERhdGVQaWNrZXIuXG4gICAgICpcbiAgICAgKiBUaGUgYXZhaWxhYmxlIG9wdGlvbnMgYXJlOlxuICAgICAqIC0gYGFuaW1hdGU6IEJvb2xlYW5gJm1kYXNoO0NvbnRyb2xzIHRoZSBwb3B1cCBhbmltYXRpb24uIEJ5IGRlZmF1bHQsIHRoZSBvcGVuIGFuZCBjbG9zZSBhbmltYXRpb25zIGFyZSBlbmFibGVkLlxuICAgICAqIC0gYGFwcGVuZFRvOiAncm9vdCcgfCAnY29tcG9uZW50JyB8IFZpZXdDb250YWluZXJSZWZgJm1kYXNoO0NvbnRyb2xzIHRoZSBwb3B1cCBjb250YWluZXIuIEJ5IGRlZmF1bHQsIHRoZSBwb3B1cCB3aWxsIGJlIGFwcGVuZGVkIHRvIHRoZSByb290IGNvbXBvbmVudC5cbiAgICAgKiAtIGBwb3B1cENsYXNzOiBTdHJpbmdgJm1kYXNoO1NwZWNpZmllcyBhIGxpc3Qgb2YgQ1NTIGNsYXNzZXMgdGhhdCBhcmUgdXNlZCB0byBzdHlsZSB0aGUgcG9wdXAuXG4gICAgICovXG4gICAgc2V0IHBvcHVwU2V0dGluZ3Moc2V0dGluZ3MpIHtcbiAgICAgICAgdGhpcy5fcG9wdXBTZXR0aW5ncyA9IE9iamVjdC5hc3NpZ24oe30sIHsgYW5pbWF0ZTogdHJ1ZSB9LCBzZXR0aW5ncyk7XG4gICAgfVxuICAgIGdldCBwb3B1cFNldHRpbmdzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcG9wdXBTZXR0aW5ncztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3BlY2lmaWVzIHRoZSB2YWx1ZSBvZiB0aGUgRGF0ZVBpY2tlciBjb21wb25lbnQuXG4gICAgICpcbiAgICAgKiA+IFRoZSBgdmFsdWVgIGhhcyB0byBiZSBhIHZhbGlkXG4gICAgICogW0phdmFTY3JpcHQgYERhdGVgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9EYXRlKSBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBzZXQgdmFsdWUodmFsdWUpIHtcbiAgICAgICAgdGhpcy52ZXJpZnlWYWx1ZSh2YWx1ZSk7XG4gICAgICAgIHRoaXMuX3ZhbHVlID0gY2xvbmVEYXRlKHZhbHVlKTtcbiAgICB9XG4gICAgZ2V0IHZhbHVlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBzZXQgdGFiSW5kZXgodGFiSW5kZXgpIHtcbiAgICAgICAgdGhpcy50YWJpbmRleCA9IHRhYkluZGV4O1xuICAgIH1cbiAgICBnZXQgdGFiSW5kZXgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRhYmluZGV4O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBkYXRlcyBvZiB0aGUgRGF0ZVBpY2tlciB0aGF0IHdpbGwgYmUgZGlzYWJsZWRcbiAgICAgKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGRpc2FibGVkX2RhdGVzX2RhdGVwaWNrZXIgJX0pKS5cbiAgICAgKi9cbiAgICBzZXQgZGlzYWJsZWREYXRlcyh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9kaXNhYmxlZERhdGVzID0gdmFsdWU7XG4gICAgICAgIHRoaXMuZGlzYWJsZWREYXRlc1NlcnZpY2UuaW5pdGlhbGl6ZSh2YWx1ZSk7XG4gICAgfVxuICAgIGdldCBkaXNhYmxlZERhdGVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGlzYWJsZWREYXRlcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGdldCBkaXNhYmxlZENsYXNzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kaXNhYmxlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGdldCBpbnB1dFJvbGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlYWRPbmx5SW5wdXQgPyAnbGlzdGJveCcgOiAnc3BpbmJ1dHRvbic7XG4gICAgfVxuICAgIGdldCBpc0FjdGl2ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FjdGl2ZTtcbiAgICB9XG4gICAgc2V0IGlzQWN0aXZlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX2FjdGl2ZSA9IHZhbHVlO1xuICAgICAgICBpZiAoIXRoaXMud3JhcHBlcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLndyYXBwZXIubmF0aXZlRWxlbWVudDtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLmFkZENsYXNzKGVsZW1lbnQsICdrLXN0YXRlLWZvY3VzZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIucmVtb3ZlQ2xhc3MoZWxlbWVudCwgJ2stc3RhdGUtZm9jdXNlZCcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBzaG93KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2hvdztcbiAgICB9XG4gICAgc2V0IHNob3coc2hvdykge1xuICAgICAgICBpZiAoc2hvdyAmJiAodGhpcy5kaXNhYmxlZCB8fCB0aGlzLnJlYWRvbmx5KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNraXBab25lID0gIXNob3cgJiYgKCF0aGlzLl9zaG93IHx8ICFoYXNPYnNlcnZlcnModGhpcy5jbG9zZSkpO1xuICAgICAgICBpZiAoIXNraXBab25lKSB7XG4gICAgICAgICAgICB0aGlzLnpvbmUucnVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnRvZ2dsZVBvcHVwKHNob3cpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnRvZ2dsZVBvcHVwKHNob3cpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBVc2VkIGJ5IHRoZSBUZXh0Qm94Q29udGFpbmVyIHRvIGRldGVybWluZSBpZiB0aGUgY29tcG9uZW50IGlzIGVtcHR5LlxuICAgICAqL1xuICAgIGlzRW1wdHkoKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy52YWx1ZSAmJiB0aGlzLmlucHV0LmlzRW1wdHkoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIG5nT25Jbml0KCkge1xuICAgICAgICB0aGlzLmxvY2FsaXphdGlvbkNoYW5nZVN1YnNjcmlwdGlvbiA9IHRoaXMubG9jYWxpemF0aW9uXG4gICAgICAgICAgICAuY2hhbmdlc1xuICAgICAgICAgICAgLnN1YnNjcmliZSgoKSA9PiB0aGlzLmNkci5tYXJrRm9yQ2hlY2soKSk7XG4gICAgICAgIHRoaXMuY29udHJvbCA9IHRoaXMuaW5qZWN0b3IuZ2V0KE5nQ29udHJvbCwgbnVsbCk7XG4gICAgICAgIGlmICh0aGlzLmVsZW1lbnQpIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIucmVtb3ZlQXR0cmlidXRlKHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LCAndGFiaW5kZXgnKTtcbiAgICAgICAgICAgIHRoaXMuem9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5iaW5kRXZlbnRzKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgbmdPbkNoYW5nZXMoY2hhbmdlcykge1xuICAgICAgICB0aGlzLnZlcmlmeVNldHRpbmdzKCk7XG4gICAgICAgIGlmIChjaGFuZ2VzLm1pbiB8fCBjaGFuZ2VzLm1heCB8fCBjaGFuZ2VzLnJhbmdlVmFsaWRhdGlvbiB8fCBjaGFuZ2VzLmRpc2FibGVkRGF0ZXNWYWxpZGF0aW9uIHx8IGNoYW5nZXMuZGlzYWJsZWREYXRlcyB8fCBjaGFuZ2VzLmluY29tcGxldGVEYXRlVmFsaWRhdGlvbikge1xuICAgICAgICAgICAgdGhpcy5taW5WYWxpZGF0ZUZuID0gdGhpcy5yYW5nZVZhbGlkYXRpb24gPyBtaW5WYWxpZGF0b3IodGhpcy5taW4pIDogbm9vcDtcbiAgICAgICAgICAgIHRoaXMubWF4VmFsaWRhdGVGbiA9IHRoaXMucmFuZ2VWYWxpZGF0aW9uID8gbWF4VmFsaWRhdG9yKHRoaXMubWF4KSA6IG5vb3A7XG4gICAgICAgICAgICB0aGlzLmRpc2FibGVkRGF0ZXNWYWxpZGF0ZUZuID0gdGhpcy5kaXNhYmxlZERhdGVzVmFsaWRhdGlvbiA/IGRpc2FibGVkRGF0ZXNWYWxpZGF0b3IodGhpcy5kaXNhYmxlZERhdGVzU2VydmljZS5pc0RhdGVEaXNhYmxlZCkgOiBub29wO1xuICAgICAgICAgICAgdGhpcy5pbmNvbXBsZXRlVmFsaWRhdG9yID0gdGhpcy5pbmNvbXBsZXRlRGF0ZVZhbGlkYXRpb24gPyBpbmNvbXBsZXRlRGF0ZVZhbGlkYXRvcigpIDogbm9vcDtcbiAgICAgICAgICAgIHRoaXMub25WYWxpZGF0b3JDaGFuZ2UoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuaXNBY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zaG93ID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLmxvY2FsaXphdGlvbkNoYW5nZVN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgdGhpcy5sb2NhbGl6YXRpb25DaGFuZ2VTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy53aW5kb3dCbHVyU3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLndpbmRvd0JsdXJTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRvbUV2ZW50cy5mb3JFYWNoKHVuYmluZENhbGxiYWNrID0+IHVuYmluZENhbGxiYWNrKCkpO1xuICAgICAgICB0aGlzLnBpY2tlclN1YnNjcmlwdGlvbnMudW5zdWJzY3JpYmUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY3VycmVudCBvcGVuIHN0YXRlIG9mIHRoZSBwb3B1cC5cbiAgICAgKi9cbiAgICBnZXQgaXNPcGVuKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaG93O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgd3JpdGVWYWx1ZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLnZlcmlmeVZhbHVlKHZhbHVlKTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IGNsb25lRGF0ZSh2YWx1ZSk7XG4gICAgICAgIHRoaXMuY2RyLm1hcmtGb3JDaGVjaygpO1xuICAgICAgICBpZiAoIXZhbHVlICYmIHRoaXMuaW5wdXQpIHtcbiAgICAgICAgICAgIHRoaXMuaW5wdXQucGxhY2Vob2xkZXIgPSB0aGlzLnBsYWNlaG9sZGVyO1xuICAgICAgICAgICAgdGhpcy5pbnB1dC53cml0ZVZhbHVlKHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcmVnaXN0ZXJPbkNoYW5nZShmbikge1xuICAgICAgICB0aGlzLm9uQ29udHJvbENoYW5nZSA9IGZuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcmVnaXN0ZXJPblRvdWNoZWQoZm4pIHtcbiAgICAgICAgdGhpcy5vbkNvbnRyb2xUb3VjaGVkID0gZm47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBzZXREaXNhYmxlZFN0YXRlKGlzRGlzYWJsZWQpIHtcbiAgICAgICAgdGhpcy5kaXNhYmxlZCA9IGlzRGlzYWJsZWQ7XG4gICAgICAgIHRoaXMuY2RyLm1hcmtGb3JDaGVjaygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgdmFsaWRhdGUoY29udHJvbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taW5WYWxpZGF0ZUZuKGNvbnRyb2wpIHx8IHRoaXMubWF4VmFsaWRhdGVGbihjb250cm9sKSB8fCB0aGlzLmRpc2FibGVkRGF0ZXNWYWxpZGF0ZUZuKGNvbnRyb2wpIHx8IHRoaXMuaW5jb21wbGV0ZVZhbGlkYXRvcihjb250cm9sLCB0aGlzLmlucHV0ICYmIHRoaXMuaW5wdXQuaXNEYXRlSW5jb21wbGV0ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICByZWdpc3Rlck9uVmFsaWRhdG9yQ2hhbmdlKGZuKSB7XG4gICAgICAgIHRoaXMub25WYWxpZGF0b3JDaGFuZ2UgPSBmbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRm9jdXNlcyB0aGUgRGF0ZVBpY2tlciBjb21wb25lbnQuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHRzXG4gICAgICogX0BDb21wb25lbnQoe1xuICAgICAqIHNlbGVjdG9yOiAnbXktYXBwJyxcbiAgICAgKiB0ZW1wbGF0ZTogYFxuICAgICAqICA8YnV0dG9uIChjbGljayk9XCJkYXRlcGlja2VyLmZvY3VzKClcIj5Gb2N1cyBkYXRlIHBpY2tlcjwvYnV0dG9uPlxuICAgICAqICA8a2VuZG8tZGF0ZXBpY2tlciAjZGF0ZXBpY2tlcj48L2tlbmRvLWRhdGVwaWNrZXI+XG4gICAgICogYFxuICAgICAqIH0pXG4gICAgICogZXhwb3J0IGNsYXNzIEFwcENvbXBvbmVudCB7IH1cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBmb2N1cygpIHtcbiAgICAgICAgdGhpcy5pbnB1dC5mb2N1cygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBCbHVycyB0aGUgRGF0ZVBpY2tlciBjb21wb25lbnQuXG4gICAgICovXG4gICAgYmx1cigpIHtcbiAgICAgICAgKHRoaXMuY2FsZW5kYXIgfHwgdGhpcy5pbnB1dClbJ2JsdXInXSgpOyAvL3RzbGludDpkaXNhYmxlLWxpbmU6bm8tc3RyaW5nLWxpdGVyYWxcbiAgICB9XG4gICAgLyoqXG4gICAgICogVG9nZ2xlcyB0aGUgdmlzaWJpbGl0eSBvZiB0aGUgcG9wdXAuIElmIHlvdSB1c2UgdGhlIGB0b2dnbGVgIG1ldGhvZCB0byBzaG93IG9yIGhpZGUgdGhlIHBvcHVwLFxuICAgICAqIHRoZSBgb3BlbmAgYW5kIGBjbG9zZWAgZXZlbnRzIGRvIG5vdCBmaXJlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHNob3cgLSBUaGUgc3RhdGUgb2YgdGhlIHBvcHVwLlxuICAgICAqL1xuICAgIHRvZ2dsZShzaG93KSB7XG4gICAgICAgIGlmICh0aGlzLmRpc2FibGVkIHx8IHRoaXMucmVhZG9ubHkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlc29sdmVkUHJvbWlzZS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX3RvZ2dsZSgoc2hvdyA9PT0gdW5kZWZpbmVkKSA/ICF0aGlzLnNob3cgOiBzaG93KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBoYW5kbGVJY29uQ2xpY2soZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuZGlzYWJsZWQgfHwgdGhpcy5yZWFkb25seSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHRoaXMuZm9jdXNJbnB1dCgpO1xuICAgICAgICAvL1hYWDogZXhwbGljaXRseSBjYWxsIHRoZSBoYW5kbGVGb2N1cyBoYW5kbGVyIGhlcmVcbiAgICAgICAgLy9kdWUgdG8gYXN5bmMgSUUgZm9jdXMgZXZlbnRcbiAgICAgICAgdGhpcy5oYW5kbGVGb2N1cygpO1xuICAgICAgICB0aGlzLnNob3cgPSAhdGhpcy5zaG93O1xuICAgICAgICB0aGlzLmNkci5tYXJrRm9yQ2hlY2soKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGhhbmRsZU1vdXNlZG93bihhcmdzKSB7XG4gICAgICAgIGFyZ3MucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGhhbmRsZUNoYW5nZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLmNkci5tYXJrRm9yQ2hlY2soKTtcbiAgICAgICAgdGhpcy5mb2N1c0lucHV0KCk7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5zaG93ID0gZmFsc2U7XG4gICAgICAgIHRoaXMub25Db250cm9sQ2hhbmdlKGNsb25lRGF0ZSh2YWx1ZSkpO1xuICAgICAgICB0aGlzLnZhbHVlQ2hhbmdlLmVtaXQoY2xvbmVEYXRlKHZhbHVlKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBoYW5kbGVJbnB1dENoYW5nZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLmhhbmRsZUNoYW5nZSh0aGlzLmlucHV0LmZvcm1hdFNlY3Rpb25zLnRpbWUgPyB2YWx1ZSA6IHRoaXMubWVyZ2VUaW1lKHZhbHVlKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBnZXQgcG9wdXBDbGFzc2VzKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgJ2stY2FsZW5kYXItY29udGFpbmVyJyxcbiAgICAgICAgICAgICdrLWdyb3VwJyxcbiAgICAgICAgICAgICdrLXJlc2V0J1xuICAgICAgICBdLmNvbmNhdCh0aGlzLnBvcHVwU2V0dGluZ3MucG9wdXBDbGFzcyB8fCBbXSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBnZXQgYXBwZW5kVG8oKSB7XG4gICAgICAgIGNvbnN0IHsgYXBwZW5kVG8gfSA9IHRoaXMucG9wdXBTZXR0aW5ncztcbiAgICAgICAgaWYgKCFhcHBlbmRUbyB8fCBhcHBlbmRUbyA9PT0gJ3Jvb3QnKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcHBlbmRUbyA9PT0gJ2NvbXBvbmVudCcgPyB0aGlzLmNvbnRhaW5lciA6IGFwcGVuZFRvO1xuICAgIH1cbiAgICBnZXQgaW5wdXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBpY2tlclNlcnZpY2UuaW5wdXQ7XG4gICAgfVxuICAgIGdldCBjYWxlbmRhcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGlja2VyU2VydmljZS5jYWxlbmRhcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIG1lcmdlVGltZSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZSAmJiB2YWx1ZSA/IHNldFRpbWUodmFsdWUsIHRoaXMudmFsdWUpIDogdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBoYW5kbGVLZXlkb3duKGUpIHtcbiAgICAgICAgY29uc3QgeyBhbHRLZXksIGtleUNvZGUgfSA9IGU7XG4gICAgICAgIGlmIChrZXlDb2RlID09PSBLZXlzLkVzY2FwZSkge1xuICAgICAgICAgICAgdGhpcy5zaG93ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFsdEtleSkge1xuICAgICAgICAgICAgaWYgKGtleUNvZGUgPT09IEtleXMuQXJyb3dEb3duICYmICF0aGlzLnNob3cpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNob3cgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGtleUNvZGUgPT09IEtleXMuQXJyb3dVcCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2hvdyA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChrZXlDb2RlID09PSBLZXlzLlRhYiAmJiB0aGlzLnNob3cgJiYgdGhpcy5jYWxlbmRhci5pc0FjdGl2ZSkge1xuICAgICAgICAgICAgdGhpcy5pbnB1dC5mb2N1cygpO1xuICAgICAgICAgICAgdGhpcy5zaG93ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdG9nZ2xlUG9wdXAoc2hvdykge1xuICAgICAgICBjb25zdCBldmVudCA9IG5ldyBQcmV2ZW50YWJsZUV2ZW50KCk7XG4gICAgICAgIGlmICghdGhpcy5fc2hvdyAmJiBzaG93KSB7XG4gICAgICAgICAgICB0aGlzLm9wZW4uZW1pdChldmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5fc2hvdyAmJiAhc2hvdykge1xuICAgICAgICAgICAgdGhpcy5jbG9zZS5lbWl0KGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl90b2dnbGUoc2hvdyk7XG4gICAgICAgIHRoaXMudG9nZ2xlRm9jdXMoKTtcbiAgICB9XG4gICAgX3RvZ2dsZShzaG93KSB7XG4gICAgICAgIGlmIChzaG93ID09PSB0aGlzLl9zaG93KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc2hvdyA9IHNob3c7XG4gICAgICAgIGlmIChzaG93KSB7XG4gICAgICAgICAgICBjb25zdCBkaXJlY3Rpb24gPSB0aGlzLmxvY2FsaXphdGlvbi5ydGwgPyAncmlnaHQnIDogJ2xlZnQnO1xuICAgICAgICAgICAgdGhpcy5wb3B1cFJlZiA9IHRoaXMucG9wdXBTZXJ2aWNlLm9wZW4oe1xuICAgICAgICAgICAgICAgIGFuY2hvcjogdGhpcy53cmFwcGVyLFxuICAgICAgICAgICAgICAgIGFuY2hvckFsaWduOiB7IHZlcnRpY2FsOiAnYm90dG9tJywgaG9yaXpvbnRhbDogZGlyZWN0aW9uIH0sXG4gICAgICAgICAgICAgICAgYW5pbWF0ZTogdGhpcy5wb3B1cFNldHRpbmdzLmFuaW1hdGUsXG4gICAgICAgICAgICAgICAgYXBwZW5kVG86IHRoaXMuYXBwZW5kVG8sXG4gICAgICAgICAgICAgICAgY29udGVudDogdGhpcy5wb3B1cFRlbXBsYXRlLFxuICAgICAgICAgICAgICAgIHBvcHVwQWxpZ246IHsgdmVydGljYWw6ICd0b3AnLCBob3Jpem9udGFsOiBkaXJlY3Rpb24gfSxcbiAgICAgICAgICAgICAgICBwb3B1cENsYXNzOiB0aGlzLnBvcHVwQ2xhc3NlcyxcbiAgICAgICAgICAgICAgICBwb3NpdGlvbk1vZGU6ICdhYnNvbHV0ZSdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5wb3B1cFJlZi5wb3B1cEVsZW1lbnQuc2V0QXR0cmlidXRlKCdpZCcsIHRoaXMucG9wdXBVSUQpO1xuICAgICAgICAgICAgdGhpcy5zdWJzY3JpcHRpb24gPSB0aGlzLnBvcHVwUmVmLnBvcHVwQW5jaG9yVmlld3BvcnRMZWF2ZS5zdWJzY3JpYmUoKCkgPT4gdGhpcy5zaG93ID0gZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5wb3B1cFJlZi5jbG9zZSgpO1xuICAgICAgICAgICAgdGhpcy5wb3B1cFJlZiA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvY3VzSW5wdXQoKSB7XG4gICAgICAgIGlmICh0aGlzLnRvdWNoRW5hYmxlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5wdXQuZm9jdXMoKTtcbiAgICB9XG4gICAgdG9nZ2xlRm9jdXMoKSB7XG4gICAgICAgIGlmICghdGhpcy5pc0FjdGl2ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnNob3cpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5jYWxlbmRhcikge1xuICAgICAgICAgICAgICAgIHRoaXMuY2RyLmRldGVjdENoYW5nZXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNhbGVuZGFyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jYWxlbmRhci5mb2N1cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCF0aGlzLnRvdWNoRW5hYmxlZCkge1xuICAgICAgICAgICAgdGhpcy5pbnB1dC5mb2N1cygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCF0aGlzLmlucHV0LmlzQWN0aXZlKSB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZUJsdXIoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2ZXJpZnlTZXR0aW5ncygpIHtcbiAgICAgICAgaWYgKCFpc0Rldk1vZGUoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNWYWxpZFJhbmdlKHRoaXMubWluLCB0aGlzLm1heCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIG1heCB2YWx1ZSBzaG91bGQgYmUgYmlnZ2VyIHRoYW4gdGhlIG1pbi4gU2VlICR7TUlOX0RPQ19MSU5LJDJ9IGFuZCAke01BWF9ET0NfTElOSyQyfS5gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2ZXJpZnlWYWx1ZSh2YWx1ZSkge1xuICAgICAgICBpZiAoIWlzRGV2TW9kZSgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlICYmICEodmFsdWUgaW5zdGFuY2VvZiBEYXRlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgJ3ZhbHVlJyBzaG91bGQgYmUgYSB2YWxpZCBKYXZhU2NyaXB0IERhdGUgaW5zdGFuY2UuIENoZWNrICR7VkFMVUVfRE9DX0xJTkskMn0gZm9yIHBvc3NpYmxlIHJlc29sdXRpb24uYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYmluZEV2ZW50cygpIHtcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50O1xuICAgICAgICB0aGlzLmRvbUV2ZW50cy5wdXNoKHRoaXMucmVuZGVyZXIubGlzdGVuKGVsZW1lbnQsICdrZXlkb3duJywgdGhpcy5oYW5kbGVLZXlkb3duLmJpbmQodGhpcykpKTtcbiAgICAgICAgaWYgKGlzV2luZG93QXZhaWxhYmxlKCkpIHtcbiAgICAgICAgICAgIHRoaXMud2luZG93Qmx1clN1YnNjcmlwdGlvbiA9IGZyb21FdmVudCh3aW5kb3csICdibHVyJykuc3Vic2NyaWJlKHRoaXMuaGFuZGxlV2luZG93Qmx1ci5iaW5kKHRoaXMpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBoYW5kbGVGb2N1cygpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNBY3RpdmUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzQWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgaWYgKGhhc09ic2VydmVycyh0aGlzLm9uRm9jdXMpKSB7XG4gICAgICAgICAgICB0aGlzLnpvbmUucnVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLm9uRm9jdXMuZW1pdCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaGFuZGxlV2luZG93Qmx1cigpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzT3Blbikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2hvdyA9IGZhbHNlO1xuICAgIH1cbiAgICBoYW5kbGVCbHVyKGFyZ3MpIHtcbiAgICAgICAgY29uc3QgY3VycmVudFRhcmdldCA9IGFyZ3MgJiYgY3VycmVudEZvY3VzVGFyZ2V0KGFyZ3MpO1xuICAgICAgICBpZiAoY3VycmVudFRhcmdldCAmJiAodGhpcy5pbnB1dC5jb250YWluc0VsZW1lbnQoY3VycmVudFRhcmdldCkgfHxcbiAgICAgICAgICAgICh0aGlzLmNhbGVuZGFyICYmIHRoaXMuY2FsZW5kYXIuY29udGFpbnNFbGVtZW50KGN1cnJlbnRUYXJnZXQpKSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFzT2JzZXJ2ZXJzKHRoaXMub25CbHVyKSB8fCAodGhpcy5zaG93ICYmIGhhc09ic2VydmVycyh0aGlzLmNsb3NlKSkgfHwgcmVxdWlyZXNab25lT25CbHVyKHRoaXMuY29udHJvbCkpIHtcbiAgICAgICAgICAgIHRoaXMuem9uZS5ydW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuYmx1ckNvbXBvbmVudCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuY2RyLm1hcmtGb3JDaGVjaygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmJsdXJDb21wb25lbnQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBibHVyQ29tcG9uZW50KCkge1xuICAgICAgICB0aGlzLmlzQWN0aXZlID0gZmFsc2U7IC8vIG9yZGVyIGlzIGltcG9ydGFudCDCr1xcXyjjg4QpXy/Cr1xuICAgICAgICB0aGlzLnNob3cgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jZHIuZGV0ZWN0Q2hhbmdlcygpO1xuICAgICAgICB0aGlzLm9uQ29udHJvbFRvdWNoZWQoKTtcbiAgICAgICAgdGhpcy5vbkJsdXIuZW1pdCgpO1xuICAgIH1cbiAgICBoYW5kbGVTYW1lU2VsZWN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5zaG93KSB7XG4gICAgICAgICAgICB0aGlzLmZvY3VzSW5wdXQoKTtcbiAgICAgICAgICAgIHRoaXMuc2hvdyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhbmRsZURhdGVDb21wbGV0ZW5lc3NDaGFuZ2UoKSB7XG4gICAgICAgIHRoaXMuY2RyLm1hcmtGb3JDaGVjaygpO1xuICAgICAgICB0aGlzLnpvbmUucnVuKCgpID0+IHRoaXMub25WYWxpZGF0b3JDaGFuZ2UoKSk7XG4gICAgfVxufTtcbl9fZGVjb3JhdGUoW1xuICAgIFZpZXdDaGlsZCgnY29udGFpbmVyJywgeyByZWFkOiBWaWV3Q29udGFpbmVyUmVmLCBzdGF0aWM6IHRydWUgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFZpZXdDb250YWluZXJSZWYpXG5dLCBEYXRlUGlja2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJjb250YWluZXJcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIFZpZXdDaGlsZCgncG9wdXBUZW1wbGF0ZScsIHsgc3RhdGljOiB0cnVlIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBUZW1wbGF0ZVJlZilcbl0sIERhdGVQaWNrZXJDb21wb25lbnQucHJvdG90eXBlLCBcInBvcHVwVGVtcGxhdGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIFZpZXdDaGlsZCgnd3JhcHBlcicsIHsgc3RhdGljOiBmYWxzZSB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRWxlbWVudFJlZilcbl0sIERhdGVQaWNrZXJDb21wb25lbnQucHJvdG90eXBlLCBcIndyYXBwZXJcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIENvbnRlbnRDaGlsZChDZWxsVGVtcGxhdGVEaXJlY3RpdmUsIHsgc3RhdGljOiBmYWxzZSB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQ2VsbFRlbXBsYXRlRGlyZWN0aXZlKVxuXSwgRGF0ZVBpY2tlckNvbXBvbmVudC5wcm90b3R5cGUsIFwiY2VsbFRlbXBsYXRlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgnY2VsbFRlbXBsYXRlJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIENlbGxUZW1wbGF0ZURpcmVjdGl2ZSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtDZWxsVGVtcGxhdGVEaXJlY3RpdmVdKVxuXSwgRGF0ZVBpY2tlckNvbXBvbmVudC5wcm90b3R5cGUsIFwiY2VsbFRlbXBsYXRlUmVmXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgQ29udGVudENoaWxkKE1vbnRoQ2VsbFRlbXBsYXRlRGlyZWN0aXZlLCB7IHN0YXRpYzogZmFsc2UgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE1vbnRoQ2VsbFRlbXBsYXRlRGlyZWN0aXZlKVxuXSwgRGF0ZVBpY2tlckNvbXBvbmVudC5wcm90b3R5cGUsIFwibW9udGhDZWxsVGVtcGxhdGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCdtb250aENlbGxUZW1wbGF0ZScpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBNb250aENlbGxUZW1wbGF0ZURpcmVjdGl2ZSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtNb250aENlbGxUZW1wbGF0ZURpcmVjdGl2ZV0pXG5dLCBEYXRlUGlja2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJtb250aENlbGxUZW1wbGF0ZVJlZlwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIENvbnRlbnRDaGlsZChZZWFyQ2VsbFRlbXBsYXRlRGlyZWN0aXZlLCB7IHN0YXRpYzogZmFsc2UgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFllYXJDZWxsVGVtcGxhdGVEaXJlY3RpdmUpXG5dLCBEYXRlUGlja2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ5ZWFyQ2VsbFRlbXBsYXRlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgneWVhckNlbGxUZW1wbGF0ZScpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBZZWFyQ2VsbFRlbXBsYXRlRGlyZWN0aXZlKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW1llYXJDZWxsVGVtcGxhdGVEaXJlY3RpdmVdKVxuXSwgRGF0ZVBpY2tlckNvbXBvbmVudC5wcm90b3R5cGUsIFwieWVhckNlbGxUZW1wbGF0ZVJlZlwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIENvbnRlbnRDaGlsZChEZWNhZGVDZWxsVGVtcGxhdGVEaXJlY3RpdmUsIHsgc3RhdGljOiBmYWxzZSB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRGVjYWRlQ2VsbFRlbXBsYXRlRGlyZWN0aXZlKVxuXSwgRGF0ZVBpY2tlckNvbXBvbmVudC5wcm90b3R5cGUsIFwiZGVjYWRlQ2VsbFRlbXBsYXRlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgnZGVjYWRlQ2VsbFRlbXBsYXRlJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIERlY2FkZUNlbGxUZW1wbGF0ZURpcmVjdGl2ZSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtEZWNhZGVDZWxsVGVtcGxhdGVEaXJlY3RpdmVdKVxuXSwgRGF0ZVBpY2tlckNvbXBvbmVudC5wcm90b3R5cGUsIFwiZGVjYWRlQ2VsbFRlbXBsYXRlUmVmXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgQ29udGVudENoaWxkKENlbnR1cnlDZWxsVGVtcGxhdGVEaXJlY3RpdmUsIHsgc3RhdGljOiBmYWxzZSB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQ2VudHVyeUNlbGxUZW1wbGF0ZURpcmVjdGl2ZSlcbl0sIERhdGVQaWNrZXJDb21wb25lbnQucHJvdG90eXBlLCBcImNlbnR1cnlDZWxsVGVtcGxhdGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCdjZW50dXJ5Q2VsbFRlbXBsYXRlJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIENlbnR1cnlDZWxsVGVtcGxhdGVEaXJlY3RpdmUpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQ2VudHVyeUNlbGxUZW1wbGF0ZURpcmVjdGl2ZV0pXG5dLCBEYXRlUGlja2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJjZW50dXJ5Q2VsbFRlbXBsYXRlUmVmXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgQ29udGVudENoaWxkKFdlZWtOdW1iZXJDZWxsVGVtcGxhdGVEaXJlY3RpdmUsIHsgc3RhdGljOiBmYWxzZSB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgV2Vla051bWJlckNlbGxUZW1wbGF0ZURpcmVjdGl2ZSlcbl0sIERhdGVQaWNrZXJDb21wb25lbnQucHJvdG90eXBlLCBcIndlZWtOdW1iZXJUZW1wbGF0ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoJ3dlZWtOdW1iZXJUZW1wbGF0ZScpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBXZWVrTnVtYmVyQ2VsbFRlbXBsYXRlRGlyZWN0aXZlKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW1dlZWtOdW1iZXJDZWxsVGVtcGxhdGVEaXJlY3RpdmVdKVxuXSwgRGF0ZVBpY2tlckNvbXBvbmVudC5wcm90b3R5cGUsIFwid2Vla051bWJlclRlbXBsYXRlUmVmXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgQ29udGVudENoaWxkKEhlYWRlclRpdGxlVGVtcGxhdGVEaXJlY3RpdmUsIHsgc3RhdGljOiBmYWxzZSB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgSGVhZGVyVGl0bGVUZW1wbGF0ZURpcmVjdGl2ZSlcbl0sIERhdGVQaWNrZXJDb21wb25lbnQucHJvdG90eXBlLCBcImhlYWRlclRpdGxlVGVtcGxhdGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCdoZWFkZXJUaXRsZVRlbXBsYXRlJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEhlYWRlclRpdGxlVGVtcGxhdGVEaXJlY3RpdmUpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbSGVhZGVyVGl0bGVUZW1wbGF0ZURpcmVjdGl2ZV0pXG5dLCBEYXRlUGlja2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJoZWFkZXJUaXRsZVRlbXBsYXRlUmVmXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgQ29udGVudENoaWxkKE5hdmlnYXRpb25JdGVtVGVtcGxhdGVEaXJlY3RpdmUsIHsgc3RhdGljOiBmYWxzZSB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTmF2aWdhdGlvbkl0ZW1UZW1wbGF0ZURpcmVjdGl2ZSlcbl0sIERhdGVQaWNrZXJDb21wb25lbnQucHJvdG90eXBlLCBcIm5hdmlnYXRpb25JdGVtVGVtcGxhdGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCduYXZpZ2F0aW9uSXRlbVRlbXBsYXRlJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE5hdmlnYXRpb25JdGVtVGVtcGxhdGVEaXJlY3RpdmUpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbTmF2aWdhdGlvbkl0ZW1UZW1wbGF0ZURpcmVjdGl2ZV0pXG5dLCBEYXRlUGlja2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJuYXZpZ2F0aW9uSXRlbVRlbXBsYXRlUmVmXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgRGF0ZVBpY2tlckNvbXBvbmVudC5wcm90b3R5cGUsIFwiZm9jdXNhYmxlSWRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIERhdGVQaWNrZXJDb21wb25lbnQucHJvdG90eXBlLCBcImFjdGl2ZVZpZXdcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIERhdGVQaWNrZXJDb21wb25lbnQucHJvdG90eXBlLCBcImJvdHRvbVZpZXdcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIERhdGVQaWNrZXJDb21wb25lbnQucHJvdG90eXBlLCBcInRvcFZpZXdcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIERhdGVQaWNrZXJDb21wb25lbnQucHJvdG90eXBlLCBcImNhbGVuZGFyVHlwZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIERhdGVQaWNrZXJDb21wb25lbnQucHJvdG90eXBlLCBcImFuaW1hdGVDYWxlbmRhck5hdmlnYXRpb25cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBEYXRlUGlja2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkaXNhYmxlZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIERhdGVQaWNrZXJDb21wb25lbnQucHJvdG90eXBlLCBcInJlYWRvbmx5XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgRGF0ZVBpY2tlckNvbXBvbmVudC5wcm90b3R5cGUsIFwicmVhZE9ubHlJbnB1dFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW09iamVjdF0pXG5dLCBEYXRlUGlja2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJwb3B1cFNldHRpbmdzXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIERhdGVQaWNrZXJDb21wb25lbnQucHJvdG90eXBlLCBcIm5hdmlnYXRpb25cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIERhdGUpXG5dLCBEYXRlUGlja2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJtaW5cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIERhdGUpXG5dLCBEYXRlUGlja2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJtYXhcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBEYXRlUGlja2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJpbmNvbXBsZXRlRGF0ZVZhbGlkYXRpb25cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIERhdGUpXG5dLCBEYXRlUGlja2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJmb2N1c2VkRGF0ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRGF0ZSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtEYXRlXSlcbl0sIERhdGVQaWNrZXJDb21wb25lbnQucHJvdG90eXBlLCBcInZhbHVlXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgRGF0ZVBpY2tlckNvbXBvbmVudC5wcm90b3R5cGUsIFwiZm9ybWF0XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBEYXRlUGlja2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0d29EaWdpdFllYXJNYXhcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIERhdGVQaWNrZXJDb21wb25lbnQucHJvdG90eXBlLCBcImZvcm1hdFBsYWNlaG9sZGVyXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBEYXRlUGlja2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJwbGFjZWhvbGRlclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgRGF0ZVBpY2tlckNvbXBvbmVudC5wcm90b3R5cGUsIFwidGFiaW5kZXhcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlciksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtOdW1iZXJdKVxuXSwgRGF0ZVBpY2tlckNvbXBvbmVudC5wcm90b3R5cGUsIFwidGFiSW5kZXhcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbT2JqZWN0XSlcbl0sIERhdGVQaWNrZXJDb21wb25lbnQucHJvdG90eXBlLCBcImRpc2FibGVkRGF0ZXNcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBEYXRlUGlja2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0aXRsZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIERhdGVQaWNrZXJDb21wb25lbnQucHJvdG90eXBlLCBcInJhbmdlVmFsaWRhdGlvblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIERhdGVQaWNrZXJDb21wb25lbnQucHJvdG90eXBlLCBcImRpc2FibGVkRGF0ZXNWYWxpZGF0aW9uXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgRGF0ZVBpY2tlckNvbXBvbmVudC5wcm90b3R5cGUsIFwid2Vla051bWJlclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbl0sIERhdGVQaWNrZXJDb21wb25lbnQucHJvdG90eXBlLCBcInZhbHVlQ2hhbmdlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBPdXRwdXQoJ2ZvY3VzJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbl0sIERhdGVQaWNrZXJDb21wb25lbnQucHJvdG90eXBlLCBcIm9uRm9jdXNcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIE91dHB1dCgnYmx1cicpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXG5dLCBEYXRlUGlja2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJvbkJsdXJcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIE91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXG5dLCBEYXRlUGlja2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJvcGVuXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBPdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxuXSwgRGF0ZVBpY2tlckNvbXBvbmVudC5wcm90b3R5cGUsIFwiY2xvc2VcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5rLXdpZGdldCcpLFxuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5rLWRhdGVwaWNrZXInKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIERhdGVQaWNrZXJDb21wb25lbnQucHJvdG90eXBlLCBcIndyYXBwZXJDbGFzc2VzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBIb3N0QmluZGluZygnY2xhc3Muay1zdGF0ZS1kaXNhYmxlZCcpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBEYXRlUGlja2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkaXNhYmxlZENsYXNzXCIsIG51bGwpO1xuRGF0ZVBpY2tlckNvbXBvbmVudCA9IERhdGVQaWNrZXJDb21wb25lbnRfMSA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICBleHBvcnRBczogJ2tlbmRvLWRhdGVwaWNrZXInLFxuICAgICAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgICAgIHsgcHJvdmlkZTogTkdfVkFMVUVfQUNDRVNTT1IsIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IERhdGVQaWNrZXJDb21wb25lbnRfMSksIG11bHRpOiB0cnVlIH0sXG4gICAgICAgICAgICB7IHByb3ZpZGU6IE5HX1ZBTElEQVRPUlMsIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IERhdGVQaWNrZXJDb21wb25lbnRfMSksIG11bHRpOiB0cnVlIH0sXG4gICAgICAgICAgICB7IHByb3ZpZGU6IEtlbmRvSW5wdXQsIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IERhdGVQaWNrZXJDb21wb25lbnRfMSkgfSxcbiAgICAgICAgICAgIExvY2FsaXphdGlvblNlcnZpY2UsXG4gICAgICAgICAgICBQaWNrZXJTZXJ2aWNlLFxuICAgICAgICAgICAgRGlzYWJsZWREYXRlc1NlcnZpY2UsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcHJvdmlkZTogTDEwTl9QUkVGSVgsXG4gICAgICAgICAgICAgICAgdXNlVmFsdWU6ICdrZW5kby5kYXRlcGlja2VyJ1xuICAgICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLWRhdGVwaWNrZXInLFxuICAgICAgICB0ZW1wbGF0ZTogYFxuICAgICAgICA8bmctY29udGFpbmVyIGtlbmRvRGF0ZVBpY2tlckxvY2FsaXplZE1lc3NhZ2VzXG4gICAgICAgICAgICBpMThuLXRvZGF5PVwia2VuZG8uZGF0ZXBpY2tlci50b2RheXxUaGUgbGFiZWwgZm9yIHRoZSB0b2RheSBidXR0b24gaW4gdGhlIGNhbGVuZGFyIGhlYWRlclwiXG4gICAgICAgICAgICB0b2RheT1cIlRvZGF5XCJcblxuICAgICAgICAgICAgaTE4bi10b2dnbGU9XCJrZW5kby5kYXRlcGlja2VyLnRvZ2dsZXxUaGUgdGl0bGUgb2YgdGhlIHRvZ2dsZSBidXR0b24gaW4gdGhlIGRhdGVwaWNrZXIgY29tcG9uZW50XCJcbiAgICAgICAgICAgIHRvZ2dsZT1cIlRvZ2dsZSBjYWxlbmRhclwiXG5cbiAgICAgICAgICAgIGkxOG4tcHJldkJ1dHRvblRpdGxlPVwia2VuZG8uZGF0ZXBpY2tlci5wcmV2QnV0dG9uVGl0bGV8VGhlIHRpdGxlIG9mIHRoZSBwcmV2aW91cyBidXR0b24gaW4gdGhlIENsYXNzaWMgY2FsZW5kYXJcIlxuICAgICAgICAgICAgcHJldkJ1dHRvblRpdGxlPVwiTmF2aWdhdGUgdG8gcHJldmlvdXMgdmlld1wiXG5cbiAgICAgICAgICAgIGkxOG4tbmV4dEJ1dHRvblRpdGxlPVwia2VuZG8uZGF0ZXBpY2tlci5uZXh0QnV0dG9uVGl0bGV8VGhlIHRpdGxlIG9mIHRoZSBuZXh0IGJ1dHRvbiBpbiB0aGUgQ2xhc3NpYyBjYWxlbmRhclwiXG4gICAgICAgICAgICBuZXh0QnV0dG9uVGl0bGU9XCJOYXZpZ2F0ZSB0byBuZXh0IHZpZXdcIlxuICAgICAgICA+XG4gICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgICAgICA8c3BhbiAjd3JhcHBlclxuICAgICAgICAgICAgY2xhc3M9XCJrLXBpY2tlci13cmFwXCJcbiAgICAgICAgICAgIFtjbGFzcy5rLXN0YXRlLWRpc2FibGVkXT1cImRpc2FibGVkXCJcbiAgICAgICAgPlxuICAgICAgICAgICAgPGtlbmRvLWRhdGVpbnB1dFxuICAgICAgICAgICAgICAgICNpbnB1dFxuICAgICAgICAgICAgICAgIFtyb2xlXT1cImlucHV0Um9sZVwiXG4gICAgICAgICAgICAgICAgW2ZvY3VzYWJsZUlkXT1cImZvY3VzYWJsZUlkXCJcbiAgICAgICAgICAgICAgICBbaGFzUG9wdXBdPVwidHJ1ZVwiXG4gICAgICAgICAgICAgICAgW2lzUG9wdXBPcGVuXT1cInNob3dcIlxuICAgICAgICAgICAgICAgIFtkaXNhYmxlZF09XCJkaXNhYmxlZFwiXG4gICAgICAgICAgICAgICAgW3JlYWRvbmx5XT1cInJlYWRvbmx5IHx8IHJlYWRPbmx5SW5wdXRcIlxuICAgICAgICAgICAgICAgIFthcmlhUmVhZE9ubHldPVwicmVhZG9ubHlcIlxuICAgICAgICAgICAgICAgIFt0YWJpbmRleF09XCJ0YWJpbmRleFwiXG4gICAgICAgICAgICAgICAgW3RpdGxlXT1cInRpdGxlXCJcbiAgICAgICAgICAgICAgICBbZm9ybWF0XT1cImZvcm1hdFwiXG4gICAgICAgICAgICAgICAgW3R3b0RpZ2l0WWVhck1heF09XCJ0d29EaWdpdFllYXJNYXhcIlxuICAgICAgICAgICAgICAgIFtmb3JtYXRQbGFjZWhvbGRlcl09XCJmb3JtYXRQbGFjZWhvbGRlclwiXG4gICAgICAgICAgICAgICAgW3BsYWNlaG9sZGVyXT1cInBsYWNlaG9sZGVyXCJcbiAgICAgICAgICAgICAgICBbbWluXT1cIm1pblwiXG4gICAgICAgICAgICAgICAgW21heF09XCJtYXhcIlxuICAgICAgICAgICAgICAgIFtpbmNvbXBsZXRlRGF0ZVZhbGlkYXRpb25dPVwiaW5jb21wbGV0ZURhdGVWYWxpZGF0aW9uXCJcbiAgICAgICAgICAgICAgICBbdmFsdWVdPVwidmFsdWVcIlxuICAgICAgICAgICAgICAgICh2YWx1ZUNoYW5nZSk9XCJoYW5kbGVJbnB1dENoYW5nZSgkZXZlbnQpXCJcbiAgICAgICAgICAgID48L2tlbmRvLWRhdGVpbnB1dD5cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiay1zZWxlY3RcIlxuICAgICAgICAgICAgICAgIHJvbGU9XCJidXR0b25cIlxuICAgICAgICAgICAgICAgIFthdHRyLnRpdGxlXT1cImxvY2FsaXphdGlvbi5nZXQoJ3RvZ2dsZScpXCJcbiAgICAgICAgICAgICAgICBbYXR0ci5hcmlhLWxhYmVsXT1cImxvY2FsaXphdGlvbi5nZXQoJ3RvZ2dsZScpXCJcbiAgICAgICAgICAgICAgICBba2VuZG9FdmVudHNPdXRzaWRlQW5ndWxhcl09XCJ7XG4gICAgICAgICAgICAgICAgICAgIGNsaWNrOiBoYW5kbGVJY29uQ2xpY2ssXG4gICAgICAgICAgICAgICAgICAgIG1vdXNlZG93bjogaGFuZGxlTW91c2Vkb3duXG4gICAgICAgICAgICAgICAgfVwiXG4gICAgICAgICAgICAgICAgW3Njb3BlXT1cInRoaXNcIlxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiay1pY29uIGstaS1jYWxlbmRhclwiPjwvc3Bhbj5cbiAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgPC9zcGFuPlxuICAgICAgICA8bmctY29udGFpbmVyICNjb250YWluZXI+PC9uZy1jb250YWluZXI+XG4gICAgICAgIDxuZy10ZW1wbGF0ZSAjcG9wdXBUZW1wbGF0ZT5cbiAgICAgICAgICAgIDxrZW5kby1jYWxlbmRhclxuICAgICAgICAgICAgICAgICNjYWxlbmRhclxuICAgICAgICAgICAgICAgIFt0eXBlXT1cImNhbGVuZGFyVHlwZVwiXG4gICAgICAgICAgICAgICAgW21pbl09XCJtaW5cIlxuICAgICAgICAgICAgICAgIFttYXhdPVwibWF4XCJcbiAgICAgICAgICAgICAgICBbbmF2aWdhdGlvbl09XCJuYXZpZ2F0aW9uXCJcbiAgICAgICAgICAgICAgICBbYW5pbWF0ZU5hdmlnYXRpb25dPVwiYW5pbWF0ZUNhbGVuZGFyTmF2aWdhdGlvblwiXG4gICAgICAgICAgICAgICAgW2FjdGl2ZVZpZXddPVwiYWN0aXZlVmlld1wiXG4gICAgICAgICAgICAgICAgW2JvdHRvbVZpZXddPVwiYm90dG9tVmlld1wiXG4gICAgICAgICAgICAgICAgW3RvcFZpZXddPVwidG9wVmlld1wiXG4gICAgICAgICAgICAgICAgW3dlZWtOdW1iZXJdPVwid2Vla051bWJlclwiXG4gICAgICAgICAgICAgICAgW2NlbGxUZW1wbGF0ZV09XCJjZWxsVGVtcGxhdGVcIlxuICAgICAgICAgICAgICAgIFttb250aENlbGxUZW1wbGF0ZV09XCJtb250aENlbGxUZW1wbGF0ZVwiXG4gICAgICAgICAgICAgICAgW3llYXJDZWxsVGVtcGxhdGVdPVwieWVhckNlbGxUZW1wbGF0ZVwiXG4gICAgICAgICAgICAgICAgW2RlY2FkZUNlbGxUZW1wbGF0ZV09XCJkZWNhZGVDZWxsVGVtcGxhdGVcIlxuICAgICAgICAgICAgICAgIFtjZW50dXJ5Q2VsbFRlbXBsYXRlXT1cImNlbnR1cnlDZWxsVGVtcGxhdGVcIlxuICAgICAgICAgICAgICAgIFt3ZWVrTnVtYmVyVGVtcGxhdGVdPVwid2Vla051bWJlclRlbXBsYXRlXCJcbiAgICAgICAgICAgICAgICBbaGVhZGVyVGl0bGVUZW1wbGF0ZV09XCJoZWFkZXJUaXRsZVRlbXBsYXRlXCJcbiAgICAgICAgICAgICAgICBbbmF2aWdhdGlvbkl0ZW1UZW1wbGF0ZV09XCJuYXZpZ2F0aW9uSXRlbVRlbXBsYXRlXCJcbiAgICAgICAgICAgICAgICBbZm9jdXNlZERhdGVdPVwiZm9jdXNlZERhdGVcIlxuICAgICAgICAgICAgICAgIFt2YWx1ZV09XCJ2YWx1ZVwiXG4gICAgICAgICAgICAgICAgKHZhbHVlQ2hhbmdlKT1cImhhbmRsZUNoYW5nZShtZXJnZVRpbWUoJGV2ZW50KSlcIlxuICAgICAgICAgICAgICAgIFtrZW5kb0V2ZW50c091dHNpZGVBbmd1bGFyXT1cIntcbiAgICAgICAgICAgICAgICAgICAga2V5ZG93bjogaGFuZGxlS2V5ZG93blxuICAgICAgICAgICAgICAgIH1cIlxuICAgICAgICAgICAgICAgIFtzY29wZV09XCJ0aGlzXCJcbiAgICAgICAgICAgICAgICBbZGlzYWJsZWREYXRlc109XCJkaXNhYmxlZERhdGVzXCJcbiAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICA8a2VuZG8tY2FsZW5kYXItbWVzc2FnZXNcbiAgICAgICAgICAgICAgICAgICAgW3RvZGF5XT1cImxvY2FsaXphdGlvbi5nZXQoJ3RvZGF5JylcIlxuICAgICAgICAgICAgICAgICAgICBbcHJldkJ1dHRvblRpdGxlXT1cImxvY2FsaXphdGlvbi5nZXQoJ3ByZXZCdXR0b25UaXRsZScpXCJcbiAgICAgICAgICAgICAgICAgICAgW25leHRCdXR0b25UaXRsZV09XCJsb2NhbGl6YXRpb24uZ2V0KCduZXh0QnV0dG9uVGl0bGUnKVwiXG4gICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIDwva2VuZG8tY2FsZW5kYXItbWVzc2FnZXM+XG4gICAgICAgICAgICA8L2tlbmRvLWNhbGVuZGFyPlxuICAgICAgICA8bmctdGVtcGxhdGU+XG4gICAgYFxuICAgIH0pLFxuICAgIF9fcGFyYW0oOSwgT3B0aW9uYWwoKSksIF9fcGFyYW0oOSwgSW5qZWN0KFRPVUNIX0VOQUJMRUQpKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW05nWm9uZSxcbiAgICAgICAgTG9jYWxpemF0aW9uU2VydmljZSxcbiAgICAgICAgQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gICAgICAgIFBvcHVwU2VydmljZSxcbiAgICAgICAgRWxlbWVudFJlZixcbiAgICAgICAgUmVuZGVyZXIyLFxuICAgICAgICBJbmplY3RvcixcbiAgICAgICAgUGlja2VyU2VydmljZSxcbiAgICAgICAgRGlzYWJsZWREYXRlc1NlcnZpY2UsIEJvb2xlYW5dKVxuXSwgRGF0ZVBpY2tlckNvbXBvbmVudCk7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBUSU1FX1BBUlQgPSB7XG4gICAgZGF5cGVyaW9kOiAnZGF5cGVyaW9kJyxcbiAgICBob3VyOiAnaG91cicsXG4gICAgbWlsbGlzZWNvbmQ6ICdtaWxsaXNlY29uZCcsXG4gICAgbWludXRlOiAnbWludXRlJyxcbiAgICBzZWNvbmQ6ICdzZWNvbmQnXG59O1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgdGltZVJhbmdlVmFsaWRhdG9yID0gKG1pbiwgbWF4KSA9PiB7XG4gICAgcmV0dXJuIChjb250cm9sKSA9PiB7XG4gICAgICAgIGlmICghbWluIHx8ICFtYXggfHwgIWNvbnRyb2wudmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVyciA9IHtcbiAgICAgICAgICAgIHRpbWVSYW5nZUVycm9yOiB7XG4gICAgICAgICAgICAgICAgbWF4VmFsdWU6IG1heCxcbiAgICAgICAgICAgICAgICBtaW5WYWx1ZTogbWluLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBjb250cm9sLnZhbHVlXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBpc0luVGltZVJhbmdlKGNvbnRyb2wudmFsdWUsIG1pbiwgbWF4KSA/IG51bGwgOiBlcnI7XG4gICAgfTtcbn07XG5cbnZhciBUaW1lUGlja2VyQ29tcG9uZW50XzE7XG5jb25zdCBWQUxVRV9ET0NfTElOSyQzID0gJ2h0dHBzOi8vd3d3LnRlbGVyaWsuY29tL2tlbmRvLWFuZ3VsYXItdWkvY29tcG9uZW50cy9kYXRlaW5wdXRzL3RpbWVwaWNrZXIvI3RvYy1pbnRlZ3JhdGlvbi13aXRoLWpzb24nO1xuY29uc3QgSU5UTF9EQVRFX0ZPUk1BVCA9ICdodHRwczovL2dpdGh1Yi5jb20vdGVsZXJpay9rZW5kby1pbnRsL2Jsb2IvbWFzdGVyL2RvY3MvZGF0ZS1mb3JtYXR0aW5nL2luZGV4Lm1kJztcbmNvbnN0IGZvcm1hdFJlZ0V4cCA9IG5ldyBSZWdFeHAoYCR7VElNRV9QQVJULmhvdXJ9fCR7VElNRV9QQVJULm1pbnV0ZX18JHtUSU1FX1BBUlQuc2Vjb25kfXwke1RJTUVfUEFSVC5taWxsaXNlY29uZH18JHtUSU1FX1BBUlQuZGF5cGVyaW9kfXxsaXRlcmFsYCk7XG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIFtLZW5kbyBVSSBUaW1lUGlja2VyIGNvbXBvbmVudCBmb3IgQW5ndWxhcl0oeyUgc2x1ZyBvdmVydmlld190aW1lcGlja2VyICV9I3RvYy1iYXNpYy11c2FnZSkuXG4gKi9cbmxldCBUaW1lUGlja2VyQ29tcG9uZW50ID0gVGltZVBpY2tlckNvbXBvbmVudF8xID0gY2xhc3MgVGltZVBpY2tlckNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3Ioem9uZSwgbG9jYWxpemF0aW9uLCBjZHIsIHBvcHVwU2VydmljZSwgZWxlbWVudCwgcmVuZGVyZXIsIGluamVjdG9yLCBwaWNrZXJTZXJ2aWNlLCBpbnRsLCB0b3VjaEVuYWJsZWQkJDEpIHtcbiAgICAgICAgdGhpcy56b25lID0gem9uZTtcbiAgICAgICAgdGhpcy5sb2NhbGl6YXRpb24gPSBsb2NhbGl6YXRpb247XG4gICAgICAgIHRoaXMuY2RyID0gY2RyO1xuICAgICAgICB0aGlzLnBvcHVwU2VydmljZSA9IHBvcHVwU2VydmljZTtcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgICAgICB0aGlzLmluamVjdG9yID0gaW5qZWN0b3I7XG4gICAgICAgIHRoaXMucGlja2VyU2VydmljZSA9IHBpY2tlclNlcnZpY2U7XG4gICAgICAgIHRoaXMuaW50bCA9IGludGw7XG4gICAgICAgIHRoaXMudG91Y2hFbmFibGVkID0gdG91Y2hFbmFibGVkJCQxO1xuICAgICAgICAvKipcbiAgICAgICAgICogQGhpZGRlblxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5mb2N1c2FibGVJZCA9IGBrLSR7Z3VpZCgpfWA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXRzIG9yIGdldHMgdGhlIGBkaXNhYmxlZGAgcHJvcGVydHkgb2YgdGhlIFRpbWVQaWNrZXIgYW5kXG4gICAgICAgICAqIGRldGVybWluZXMgd2hldGhlciB0aGUgY29tcG9uZW50IGlzIGFjdGl2ZVxuICAgICAgICAgKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGRpc2FibGVkX3RpbWVwaWNrZXIgJX0pKS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgdGhlIHJlYWQtb25seSBzdGF0ZSBvZiB0aGUgVGltZVBpY2tlclxuICAgICAgICAgKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIHJlYWRvbmx5X3RpbWVwaWNrZXIgJX0jdG9jLXJlYWQtb25seS10aW1lcGlja2VyKSkuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJlYWRvbmx5ID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXRzIHRoZSByZWFkLW9ubHkgc3RhdGUgb2YgdGhlIFRpbWVQaWNrZXIgaW5wdXQgZmllbGRcbiAgICAgICAgICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyByZWFkb25seV90aW1lcGlja2VyICV9I3RvYy1yZWFkLW9ubHktaW5wdXQpKS5cbiAgICAgICAgICpcbiAgICAgICAgICogPiBOb3RlIHRoYXQgaWYgeW91IHNldCB0aGUgW2ByZWFkb25seWBdKHslIHNsdWcgYXBpX2RhdGVpbnB1dHNfdGltZXBpY2tlcmNvbXBvbmVudCAlfSN0b2MtcmVhZG9ubHkpIHByb3BlcnR5IHZhbHVlIHRvIGB0cnVlYCxcbiAgICAgICAgICogdGhlIGlucHV0IHdpbGwgYmUgcmVuZGVyZWQgaW4gYSByZWFkLW9ubHkgc3RhdGUgcmVnYXJkbGVzcyBvZiB0aGUgYHJlYWRPbmx5SW5wdXRgIHZhbHVlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZWFkT25seUlucHV0ID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVjaWZpZXMgdGhlIHRpbWUgZm9ybWF0IHRoYXQgaXMgdXNlZCB0byBkaXNwbGF5IHRoZSBpbnB1dCB2YWx1ZVxuICAgICAgICAgKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGZvcm1hdHNfdGltZXBpY2tlciAlfSkpLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5mb3JtYXQgPSAndCc7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVjaWZpZXMgdGhlIGhpbnQgdGhlIFRpbWVQaWNrZXIgZGlzcGxheXMgd2hlbiBpdHMgdmFsdWUgaXMgYG51bGxgLlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIGFydGljbGUgb25cbiAgICAgICAgICogW3BsYWNlaG9sZGVyc10oeyUgc2x1ZyBwbGFjZWhvbGRlcnNfdGltZXBpY2tlciAlfSkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIGBgYHRzXG4gICAgICAgICAqIF9AQ29tcG9uZW50KHtcbiAgICAgICAgICogc2VsZWN0b3I6ICdteS1hcHAnLFxuICAgICAgICAgKiB0ZW1wbGF0ZTogYFxuICAgICAgICAgKiAgPGtlbmRvLXRpbWVwaWNrZXIgcGxhY2Vob2xkZXI9XCJFbnRlciBzdGFydC4uLlwiPjwva2VuZG8tdGltZXBpY2tlcj5cbiAgICAgICAgICogYFxuICAgICAgICAgKiB9KVxuICAgICAgICAgKiBleHBvcnQgY2xhc3MgQXBwQ29tcG9uZW50IHsgfVxuICAgICAgICAgKiBgYGBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucGxhY2Vob2xkZXIgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBidWlsdC1pbiB2YWxpZGF0aW9uIGZvciBpbmNvbXBsZXRlIGRhdGVzIGlzIHRvIGJlIGVuZm9yY2VkIHdoZW4gYSBmb3JtIGlzIGJlaW5nIHZhbGlkYXRlZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaW5jb21wbGV0ZURhdGVWYWxpZGF0aW9uID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgdG8gZGlzcGxheSB0aGUgKipDYW5jZWwqKiBidXR0b24gaW4gdGhlIHBvcHVwLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jYW5jZWxCdXR0b24gPSB0cnVlO1xuICAgICAgICAvKipcbiAgICAgICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRvIGRpc3BsYXkgdGhlICoqTm93KiogYnV0dG9uIGluIHRoZSBwb3B1cC5cbiAgICAgICAgICpcbiAgICAgICAgICogPiBJZiB0aGUgY3VycmVudCB0aW1lIGlzIG91dCBvZiByYW5nZSBvciB0aGUgaW5jcmVtZW50YWwgc3RlcCBpcyBncmVhdGVyIHRoYW4gYDFgLCB0aGUgKipOb3cqKiBidXR0b24gd2lsbCBiZSBoaWRkZW4uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm5vd0J1dHRvbiA9IHRydWU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXRzIG9yIGdldHMgdGhlIGB0YWJpbmRleGAgcHJvcGVydHkgb2YgdGhlIFRpbWVQaWNrZXIuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRhYmluZGV4ID0gMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgdGhlIHRpdGxlIG9mIHRoZSBpbnB1dCBlbGVtZW50IG9mIHRoZSBUaW1lUGlja2VyLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50aXRsZSA9IFwiXCI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGJ1aWx0LWluIG1pbiBvciBtYXggdmFsaWRhdG9ycyBhcmUgZW5mb3JjZWQgd2hlbiBhIGZvcm0gaXMgYmVpbmcgdmFsaWRhdGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yYW5nZVZhbGlkYXRpb24gPSB0cnVlO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgZWFjaCB0aW1lIHRoZSB1c2VyIHNlbGVjdHMgYSBuZXcgdmFsdWUuXG4gICAgICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgc2VjdGlvbiBvblxuICAgICAgICAgKiBbZXZlbnRzXSh7JSBzbHVnIG92ZXJ2aWV3X3RpbWVwaWNrZXIgJX0jdG9jLWV2ZW50cykuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnZhbHVlQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgZWFjaCB0aW1lIHRoZSB1c2VyIGZvY3VzZXMgdGhlIGlucHV0IGVsZW1lbnQuXG4gICAgICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgc2VjdGlvbiBvblxuICAgICAgICAgKiBbZXZlbnRzXSh7JSBzbHVnIG92ZXJ2aWV3X3RpbWVwaWNrZXIgJX0jdG9jLWV2ZW50cykuXG4gICAgICAgICAqXG4gICAgICAgICAqID4gVG8gd2lyZSB0aGUgZXZlbnQgcHJvZ3JhbW1hdGljYWxseSwgdXNlIHRoZSBgb25Gb2N1c2AgcHJvcGVydHkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIGBgYHRzXG4gICAgICAgICAqIF9AQ29tcG9uZW50KHtcbiAgICAgICAgICogc2VsZWN0b3I6ICdteS1hcHAnLFxuICAgICAgICAgKiB0ZW1wbGF0ZTogYFxuICAgICAgICAgKiAgPGtlbmRvLXRpbWVwaWNrZXIgKGZvY3VzKT1cImhhbmRsZUZvY3VzKClcIj48L2tlbmRvLXRpbWVwaWNrZXI+XG4gICAgICAgICAqIGBcbiAgICAgICAgICogfSlcbiAgICAgICAgICogZXhwb3J0IGNsYXNzIEFwcENvbXBvbmVudCB7XG4gICAgICAgICAqICAgcHVibGljIGhhbmRsZUZvY3VzKCk6IHZvaWQge1xuICAgICAgICAgKiAgICAgIGNvbnNvbGUubG9nKFwiQ29tcG9uZW50IGlzIGZvY3VzZWRcIik7XG4gICAgICAgICAqICAgfVxuICAgICAgICAgKiB9XG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vbkZvY3VzID0gbmV3IEV2ZW50RW1pdHRlcigpOyAvL3RzbGludDpkaXNhYmxlLWxpbmU6bm8tb3V0cHV0LXJlbmFtZVxuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgZWFjaCB0aW1lIHRoZSBpbnB1dCBlbGVtZW50IGdldHMgYmx1cnJlZC5cbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBzZWN0aW9uIG9uXG4gICAgICAgICAqIFtldmVudHNdKHslIHNsdWcgb3ZlcnZpZXdfdGltZXBpY2tlciAlfSN0b2MtZXZlbnRzKS5cbiAgICAgICAgICpcbiAgICAgICAgICogPiBUbyB3aXJlIHRoZSBldmVudCBwcm9ncmFtbWF0aWNhbGx5LCB1c2UgdGhlIGBvbkJsdXJgIHByb3BlcnR5LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiBgYGB0c1xuICAgICAgICAgKiBfQENvbXBvbmVudCh7XG4gICAgICAgICAqIHNlbGVjdG9yOiAnbXktYXBwJyxcbiAgICAgICAgICogdGVtcGxhdGU6IGBcbiAgICAgICAgICogIDxrZW5kby10aW1lcGlja2VyIChibHVyKT1cImhhbmRsZUJsdXIoKVwiPjwva2VuZG8tdGltZXBpY2tlcj5cbiAgICAgICAgICogYFxuICAgICAgICAgKiB9KVxuICAgICAgICAgKiBleHBvcnQgY2xhc3MgQXBwQ29tcG9uZW50IHtcbiAgICAgICAgICogICBwdWJsaWMgaGFuZGxlQmx1cigpOiB2b2lkIHtcbiAgICAgICAgICogICAgICBjb25zb2xlLmxvZyhcIkNvbXBvbmVudCBpcyBibHVycmVkXCIpO1xuICAgICAgICAgKiAgIH1cbiAgICAgICAgICogfVxuICAgICAgICAgKiBgYGBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub25CbHVyID0gbmV3IEV2ZW50RW1pdHRlcigpOyAvL3RzbGludDpkaXNhYmxlLWxpbmU6bm8tb3V0cHV0LXJlbmFtZVxuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgZWFjaCB0aW1lIHRoZSBwb3B1cCBpcyBhYm91dCB0byBvcGVuLlxuICAgICAgICAgKiBUaGlzIGV2ZW50IGlzIHByZXZlbnRhYmxlLiBJZiB5b3UgY2FuY2VsIHRoZSBldmVudCwgdGhlIHBvcHVwIHdpbGwgcmVtYWluIGNsb3NlZC5cbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBzZWN0aW9uIG9uXG4gICAgICAgICAqIFtldmVudHNdKHslIHNsdWcgb3ZlcnZpZXdfdGltZXBpY2tlciAlfSN0b2MtZXZlbnRzKS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub3BlbiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIGVhY2ggdGltZSB0aGUgcG9wdXAgaXMgYWJvdXQgdG8gY2xvc2UuXG4gICAgICAgICAqIFRoaXMgZXZlbnQgaXMgcHJldmVudGFibGUuIElmIHlvdSBjYW5jZWwgdGhlIGV2ZW50LCB0aGUgcG9wdXAgd2lsbCByZW1haW4gb3Blbi5cbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBzZWN0aW9uIG9uXG4gICAgICAgICAqIFtldmVudHNdKHslIHNsdWcgb3ZlcnZpZXdfdGltZXBpY2tlciAlfSN0b2MtZXZlbnRzKS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2xvc2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaGlkZGVuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLndyYXBwZXJDbGFzc2VzID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5wb3B1cFVJRCA9IGd1aWQoKTtcbiAgICAgICAgdGhpcy5vbkNvbnRyb2xDaGFuZ2UgPSBub29wO1xuICAgICAgICB0aGlzLm9uQ29udHJvbFRvdWNoZWQgPSBub29wO1xuICAgICAgICB0aGlzLm9uVmFsaWRhdG9yQ2hhbmdlID0gbm9vcDtcbiAgICAgICAgdGhpcy5yZXNvbHZlZFByb21pc2UgPSBQcm9taXNlLnJlc29sdmUobnVsbCk7XG4gICAgICAgIHRoaXMudGltZVJhbmdlVmFsaWRhdGVGbiA9IG5vb3A7XG4gICAgICAgIHRoaXMuaW5jb21wbGV0ZVZhbGlkYXRvciA9IG5vb3A7XG4gICAgICAgIHRoaXMuX21pbiA9IGNsb25lRGF0ZShNSU5fVElNRSk7XG4gICAgICAgIHRoaXMuX21heCA9IGNsb25lRGF0ZShNQVhfVElNRSk7XG4gICAgICAgIHRoaXMuX3BvcHVwU2V0dGluZ3MgPSB7IGFuaW1hdGU6IHRydWUgfTtcbiAgICAgICAgdGhpcy5fc2hvdyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9zdGVwcyA9IHt9O1xuICAgICAgICB0aGlzLl92YWx1ZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX2FjdGl2ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRvbUV2ZW50cyA9IFtdO1xuICAgICAgICB2YWxpZGF0ZVBhY2thZ2UocGFja2FnZU1ldGFkYXRhKTtcbiAgICAgICAgdGhpcy5waWNrZXJTdWJzY3JpcHRpb25zID0gdGhpcy5waWNrZXJTZXJ2aWNlLm9uRm9jdXMuc3Vic2NyaWJlKHRoaXMuaGFuZGxlRm9jdXMuYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMucGlja2VyU3Vic2NyaXB0aW9ucy5hZGQodGhpcy5waWNrZXJTZXJ2aWNlLm9uQmx1ci5zdWJzY3JpYmUodGhpcy5oYW5kbGVCbHVyLmJpbmQodGhpcykpKTtcbiAgICAgICAgdGhpcy5waWNrZXJTdWJzY3JpcHRpb25zLmFkZCh0aGlzLnBpY2tlclNlcnZpY2UuZGF0ZUNvbXBsZXRlbmVzc0NoYW5nZS5zdWJzY3JpYmUodGhpcy5oYW5kbGVEYXRlQ29tcGxldGVuZXNzQ2hhbmdlLmJpbmQodGhpcykpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3BlY2lmaWVzIHRoZSBzbWFsbGVzdCB2YWxpZCB0aW1lIHZhbHVlXG4gICAgICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyB0aW1lcmFuZ2VzX3RpbWVwaWNrZXIgJX0pKS5cbiAgICAgKi9cbiAgICBzZXQgbWluKG1pbikge1xuICAgICAgICB0aGlzLl9taW4gPSBjbG9uZURhdGUobWluIHx8IE1JTl9USU1FKTtcbiAgICB9XG4gICAgZ2V0IG1pbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21pbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3BlY2lmaWVzIHRoZSBiaWdnZXN0IHZhbGlkIHRpbWUgdmFsdWVcbiAgICAgKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIHRpbWVyYW5nZXNfdGltZXBpY2tlciAlfSkpLlxuICAgICAqL1xuICAgIHNldCBtYXgobWF4KSB7XG4gICAgICAgIHRoaXMuX21heCA9IGNsb25lRGF0ZShtYXggfHwgTUFYX1RJTUUpO1xuICAgIH1cbiAgICBnZXQgbWF4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWF4O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb25maWd1cmVzIHRoZSBpbmNyZW1lbnRhbCBzdGVwcyBvZiB0aGUgVGltZVBpY2tlci5cbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIGFydGljbGUgb25cbiAgICAgKiBbaW5jcmVtZW50YWwgc3RlcHNdKHslIHNsdWcgaW5jcmVtZW50YWxzdGVwc190aW1lcGlja2VyICV9KS5cbiAgICAgKlxuICAgICAqID4gSWYgdGhlIGluY3JlbWVudGFsIHN0ZXAgaXMgZ3JlYXRlciB0aGFuIGAxYCwgdGhlICoqTm93KiogYnV0dG9uIHdpbGwgYmUgaGlkZGVuLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0c1xuICAgICAqIF9AQ29tcG9uZW50KHtcbiAgICAgKiBzZWxlY3RvcjogJ215LWFwcCcsXG4gICAgICogdGVtcGxhdGU6IGBcbiAgICAgKiAgPGtlbmRvLXRpbWVwaWNrZXIgZm9ybWF0PVwiSEg6bW06c3NcIiBbc3RlcHNdPVwic3RlcHNcIj48L2tlbmRvLXRpbWVwaWNrZXI+XG4gICAgICogYFxuICAgICAqIH0pXG4gICAgICogY2xhc3MgQXBwQ29tcG9uZW50IHtcbiAgICAgKiAgIHB1YmxpYyBzdGVwcyA9IHsgaG91cjogMiwgbWludXRlOiAxNSwgc2Vjb25kOiAxNSwgbWlsbGlzZWNvbmQ6IDEwIH07XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICovXG4gICAgc2V0IHN0ZXBzKHN0ZXBzKSB7XG4gICAgICAgIHRoaXMuX3N0ZXBzID0gc3RlcHMgfHwge307XG4gICAgfVxuICAgIGdldCBzdGVwcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0ZXBzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb25maWd1cmVzIHRoZSBwb3B1cCBvZiB0aGUgVGltZVBpY2tlci5cbiAgICAgKlxuICAgICAqIFRoZSBhdmFpbGFibGUgb3B0aW9ucyBhcmU6XG4gICAgICogLSBgYW5pbWF0ZTogQm9vbGVhbmAmbWRhc2g7Q29udHJvbHMgdGhlIHBvcHVwIGFuaW1hdGlvbi4gQnkgZGVmYXVsdCwgdGhlIG9wZW4gYW5kIGNsb3NlIGFuaW1hdGlvbnMgYXJlIGVuYWJsZWQuXG4gICAgICogLSBgYXBwZW5kVG86ICdyb290JyB8ICdjb21wb25lbnQnIHwgVmlld0NvbnRhaW5lclJlZmAmbWRhc2g7Q29udHJvbHMgdGhlIHBvcHVwIGNvbnRhaW5lci4gQnkgZGVmYXVsdCwgdGhlIHBvcHVwIHdpbGwgYmUgYXBwZW5kZWQgdG8gdGhlIHJvb3QgY29tcG9uZW50LlxuICAgICAqIC0gYHBvcHVwQ2xhc3M6IFN0cmluZ2AmbWRhc2g7U3BlY2lmaWVzIGEgbGlzdCBvZiBDU1MgY2xhc3NlcyB0aGF0IGFyZSB1c2VkIHRvIHN0eWxlIHRoZSBwb3B1cC5cbiAgICAgKi9cbiAgICBzZXQgcG9wdXBTZXR0aW5ncyhzZXR0aW5ncykge1xuICAgICAgICB0aGlzLl9wb3B1cFNldHRpbmdzID0gT2JqZWN0LmFzc2lnbih7fSwgeyBhbmltYXRlOiB0cnVlIH0sIHNldHRpbmdzKTtcbiAgICB9XG4gICAgZ2V0IHBvcHVwU2V0dGluZ3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wb3B1cFNldHRpbmdzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgc2V0IHRhYkluZGV4KHRhYkluZGV4KSB7XG4gICAgICAgIHRoaXMudGFiaW5kZXggPSB0YWJJbmRleDtcbiAgICB9XG4gICAgZ2V0IHRhYkluZGV4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy50YWJpbmRleDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3BlY2lmaWVzIHRoZSB2YWx1ZSBvZiB0aGUgVGltZVBpY2tlciBjb21wb25lbnQuXG4gICAgICovXG4gICAgc2V0IHZhbHVlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMudmVyaWZ5VmFsdWUodmFsdWUpO1xuICAgICAgICB0aGlzLl92YWx1ZSA9IGNsb25lRGF0ZSh2YWx1ZSk7XG4gICAgfVxuICAgIGdldCB2YWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0IGRpc2FibGVkQ2xhc3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRpc2FibGVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0IGlucHV0Um9sZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVhZE9ubHlJbnB1dCA/ICdsaXN0Ym94JyA6ICdzcGluYnV0dG9uJztcbiAgICB9XG4gICAgZ2V0IGlzQWN0aXZlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWN0aXZlO1xuICAgIH1cbiAgICBzZXQgaXNBY3RpdmUodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fYWN0aXZlID0gdmFsdWU7XG4gICAgICAgIGlmICghdGhpcy53cmFwcGVyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZWxlbWVudCA9IHRoaXMud3JhcHBlci5uYXRpdmVFbGVtZW50O1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuYWRkQ2xhc3MoZWxlbWVudCwgJ2stc3RhdGUtZm9jdXNlZCcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5yZW1vdmVDbGFzcyhlbGVtZW50LCAnay1zdGF0ZS1mb2N1c2VkJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IHNob3coKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zaG93O1xuICAgIH1cbiAgICBzZXQgc2hvdyhzaG93KSB7XG4gICAgICAgIGlmIChzaG93ICYmICh0aGlzLmRpc2FibGVkIHx8IHRoaXMucmVhZG9ubHkpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2tpcFpvbmUgPSAhc2hvdyAmJiAoIXRoaXMuX3Nob3cgfHwgIWhhc09ic2VydmVycyh0aGlzLmNsb3NlKSk7XG4gICAgICAgIGlmICghc2tpcFpvbmUpIHtcbiAgICAgICAgICAgIHRoaXMuem9uZS5ydW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMudG9nZ2xlUG9wdXAoc2hvdyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudG9nZ2xlUG9wdXAoc2hvdyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGlucHV0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5waWNrZXJTZXJ2aWNlLmlucHV0O1xuICAgIH1cbiAgICBnZXQgdGltZVNlbGVjdG9yKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5waWNrZXJTZXJ2aWNlLnRpbWVTZWxlY3RvcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIFVzZWQgYnkgdGhlIFRleHRCb3hDb250YWluZXIgdG8gZGV0ZXJtaW5lIGlmIHRoZSBjb21wb25lbnQgaXMgZW1wdHlcbiAgICAgKi9cbiAgICBpc0VtcHR5KCkge1xuICAgICAgICByZXR1cm4gIXRoaXMudmFsdWUgJiYgdGhpcy5pbnB1dC5pc0VtcHR5KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgdGhpcy5sb2NhbGl6YXRpb25DaGFuZ2VTdWJzY3JpcHRpb24gPSB0aGlzLmxvY2FsaXphdGlvblxuICAgICAgICAgICAgLmNoYW5nZXMuc3Vic2NyaWJlKCgpID0+IHRoaXMuY2RyLm1hcmtGb3JDaGVjaygpKTtcbiAgICAgICAgdGhpcy5jb250cm9sID0gdGhpcy5pbmplY3Rvci5nZXQoTmdDb250cm9sLCBudWxsKTtcbiAgICAgICAgaWYgKHRoaXMuZWxlbWVudCkge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5yZW1vdmVBdHRyaWJ1dGUodGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQsICd0YWJpbmRleCcpO1xuICAgICAgICAgICAgdGhpcy56b25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmJpbmRFdmVudHMoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzKSB7XG4gICAgICAgIGlmIChjaGFuZ2VzLm1pbiB8fCBjaGFuZ2VzLm1heCB8fCBjaGFuZ2VzLnJhbmdlVmFsaWRhdGlvbiB8fCBjaGFuZ2VzLmluY29tcGxldGVEYXRlVmFsaWRhdGlvbikge1xuICAgICAgICAgICAgdGhpcy50aW1lUmFuZ2VWYWxpZGF0ZUZuID0gdGhpcy5yYW5nZVZhbGlkYXRpb24gPyB0aW1lUmFuZ2VWYWxpZGF0b3IodGhpcy5taW4sIHRoaXMubWF4KSA6IG5vb3A7XG4gICAgICAgICAgICB0aGlzLmluY29tcGxldGVWYWxpZGF0b3IgPSB0aGlzLmluY29tcGxldGVEYXRlVmFsaWRhdGlvbiA/IGluY29tcGxldGVEYXRlVmFsaWRhdG9yKCkgOiBub29wO1xuICAgICAgICAgICAgdGhpcy5vblZhbGlkYXRvckNoYW5nZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFuZ2VzLmZvcm1hdCkge1xuICAgICAgICAgICAgdGhpcy52ZXJpZnlGb3JtYXQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuaXNBY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zaG93ID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLmxvY2FsaXphdGlvbkNoYW5nZVN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgdGhpcy5sb2NhbGl6YXRpb25DaGFuZ2VTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy53aW5kb3dCbHVyU3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLndpbmRvd0JsdXJTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRvbUV2ZW50cy5mb3JFYWNoKHVuYmluZENhbGxiYWNrID0+IHVuYmluZENhbGxiYWNrKCkpO1xuICAgICAgICB0aGlzLnBpY2tlclN1YnNjcmlwdGlvbnMudW5zdWJzY3JpYmUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGhhbmRsZUtleWRvd24oZXZlbnQpIHtcbiAgICAgICAgY29uc3QgeyBhbHRLZXksIGtleUNvZGUgfSA9IGV2ZW50O1xuICAgICAgICBpZiAoa2V5Q29kZSA9PT0gS2V5cy5Fc2NhcGUpIHtcbiAgICAgICAgICAgIHRoaXMuc2hvdyA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhbHRLZXkpIHtcbiAgICAgICAgICAgIGlmIChrZXlDb2RlID09PSBLZXlzLkFycm93VXApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNob3cgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChrZXlDb2RlID09PSBLZXlzLkFycm93RG93biAmJiAhdGhpcy5zaG93KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zaG93ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgd3JpdGVWYWx1ZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLnZlcmlmeVZhbHVlKHZhbHVlKTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IGNsb25lRGF0ZSh2YWx1ZSk7XG4gICAgICAgIHRoaXMuY2RyLm1hcmtGb3JDaGVjaygpO1xuICAgICAgICBpZiAoIXZhbHVlICYmIHRoaXMuaW5wdXQpIHtcbiAgICAgICAgICAgIHRoaXMuaW5wdXQucGxhY2Vob2xkZXIgPSB0aGlzLnBsYWNlaG9sZGVyO1xuICAgICAgICAgICAgdGhpcy5pbnB1dC53cml0ZVZhbHVlKHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcmVnaXN0ZXJPbkNoYW5nZShmbikge1xuICAgICAgICB0aGlzLm9uQ29udHJvbENoYW5nZSA9IGZuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcmVnaXN0ZXJPblRvdWNoZWQoZm4pIHtcbiAgICAgICAgdGhpcy5vbkNvbnRyb2xUb3VjaGVkID0gZm47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBzZXREaXNhYmxlZFN0YXRlKGlzRGlzYWJsZWQpIHtcbiAgICAgICAgdGhpcy5kaXNhYmxlZCA9IGlzRGlzYWJsZWQ7XG4gICAgICAgIHRoaXMuY2RyLm1hcmtGb3JDaGVjaygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgdmFsaWRhdGUoY29udHJvbCkge1xuICAgICAgICByZXR1cm4gdGhpcy50aW1lUmFuZ2VWYWxpZGF0ZUZuKGNvbnRyb2wpIHx8IHRoaXMuaW5jb21wbGV0ZVZhbGlkYXRvcihjb250cm9sLCB0aGlzLmlucHV0ICYmIHRoaXMuaW5wdXQuaXNEYXRlSW5jb21wbGV0ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICByZWdpc3Rlck9uVmFsaWRhdG9yQ2hhbmdlKGZuKSB7XG4gICAgICAgIHRoaXMub25WYWxpZGF0b3JDaGFuZ2UgPSBmbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRm9jdXNlcyB0aGUgVGltZVBpY2tlciBjb21wb25lbnQuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHRzXG4gICAgICogX0BDb21wb25lbnQoe1xuICAgICAqIHNlbGVjdG9yOiAnbXktYXBwJyxcbiAgICAgKiB0ZW1wbGF0ZTogYFxuICAgICAqICA8YnV0dG9uIChjbGljayk9XCJ0aW1lcGlja2VyLmZvY3VzKClcIj5Gb2N1cyB0aW1lIHBpY2tlcjwvYnV0dG9uPlxuICAgICAqICA8a2VuZG8tdGltZXBpY2tlciAjdGltZXBpY2tlcj48L2tlbmRvLXRpbWVwaWNrZXI+XG4gICAgICogYFxuICAgICAqIH0pXG4gICAgICogZXhwb3J0IGNsYXNzIEFwcENvbXBvbmVudCB7IH1cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBmb2N1cygpIHtcbiAgICAgICAgdGhpcy5pbnB1dC5mb2N1cygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBCbHVycyB0aGUgVGltZVBpY2tlciBjb21wb25lbnQuXG4gICAgICovXG4gICAgYmx1cigpIHtcbiAgICAgICAgKHRoaXMudGltZVNlbGVjdG9yIHx8IHRoaXMuaW5wdXQpWydibHVyJ10oKTsgLy90c2xpbnQ6ZGlzYWJsZS1saW5lOm5vLXN0cmluZy1saXRlcmFsXG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRvZ2dsZXMgdGhlIHZpc2liaWxpdHkgb2YgdGhlIHBvcHVwLiBJZiB5b3UgdXNlIHRoZSBgdG9nZ2xlYCBtZXRob2QgdG8gc2hvdyBvciBoaWRlIHRoZSBwb3B1cCxcbiAgICAgKiB0aGUgYG9wZW5gIGFuZCBgY2xvc2VgIGV2ZW50cyBkbyBub3QgZmlyZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzaG93IC0gVGhlIHN0YXRlIG9mIHRoZSBwb3B1cC5cbiAgICAgKi9cbiAgICB0b2dnbGUoc2hvdykge1xuICAgICAgICBpZiAodGhpcy5kaXNhYmxlZCB8fCB0aGlzLnJlYWRvbmx5KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZXNvbHZlZFByb21pc2UudGhlbigoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl90b2dnbGUoKHNob3cgPT09IHVuZGVmaW5lZCkgPyAhdGhpcy5zaG93IDogc2hvdyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IG9wZW4gc3RhdGUgb2YgdGhlIHBvcHVwLlxuICAgICAqL1xuICAgIGdldCBpc09wZW4oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNob3c7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBnZXQgYXBwZW5kVG8oKSB7XG4gICAgICAgIGNvbnN0IHsgYXBwZW5kVG8gfSA9IHRoaXMucG9wdXBTZXR0aW5ncztcbiAgICAgICAgaWYgKCFhcHBlbmRUbyB8fCBhcHBlbmRUbyA9PT0gJ3Jvb3QnKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcHBlbmRUbyA9PT0gJ2NvbXBvbmVudCcgPyB0aGlzLmNvbnRhaW5lciA6IGFwcGVuZFRvO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgaGFuZGxlQ2hhbmdlKHZhbHVlKSB7XG4gICAgICAgIGlmIChpc0VxdWFsKHRoaXMudmFsdWUsIHZhbHVlKSkge1xuICAgICAgICAgICAgdGhpcy5mb2N1c0lucHV0KCk7XG4gICAgICAgICAgICB0aGlzLnNob3cgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnZhbHVlID0gY2xvbmVEYXRlKHZhbHVlKTtcbiAgICAgICAgdGhpcy56b25lLnJ1bigoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmZvY3VzSW5wdXQoKTtcbiAgICAgICAgICAgIHRoaXMuc2hvdyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5vbkNvbnRyb2xDaGFuZ2UoY2xvbmVEYXRlKHZhbHVlKSk7XG4gICAgICAgICAgICB0aGlzLnZhbHVlQ2hhbmdlLmVtaXQoY2xvbmVEYXRlKHZhbHVlKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgaGFuZGxlUmVqZWN0KCkge1xuICAgICAgICB0aGlzLnNob3cgPSBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGhhbmRsZUlucHV0Q2hhbmdlKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IHZhbCA9IHRoaXMuaW5wdXQuZm9ybWF0U2VjdGlvbnMuZGF0ZSA/IHZhbHVlIDogdGhpcy5tZXJnZVRpbWUodmFsdWUpO1xuICAgICAgICB0aGlzLmhhbmRsZUNoYW5nZSh2YWwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgaGFuZGxlTW91c2Vkb3duKGFyZ3MpIHtcbiAgICAgICAgYXJncy5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgaGFuZGxlSWNvbkNsaWNrKGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLmRpc2FibGVkIHx8IHRoaXMucmVhZG9ubHkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB0aGlzLmZvY3VzSW5wdXQoKTtcbiAgICAgICAgLy9YWFg6IGV4cGxpY2l0IGNhbGwgaGFuZGxlRm9jdXMgaGFuZGxlciBoZXJlXG4gICAgICAgIC8vZHVlIHRvIGFzeW5jIElFIGZvY3VzIGV2ZW50XG4gICAgICAgIHRoaXMuaGFuZGxlRm9jdXMoKTtcbiAgICAgICAgdGhpcy5zaG93ID0gIXRoaXMuc2hvdztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGdldCBwb3B1cENsYXNzZXMoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAnay1ncm91cCcsXG4gICAgICAgICAgICAnay1yZXNldCdcbiAgICAgICAgXS5jb25jYXQodGhpcy5wb3B1cFNldHRpbmdzLnBvcHVwQ2xhc3MgfHwgW10pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgbm9ybWFsaXplVGltZShkYXRlKSB7XG4gICAgICAgIHJldHVybiBzZXRUaW1lKE1JRE5JR0hUX0RBVEUsIGRhdGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgbWVyZ2VUaW1lKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlICYmIHZhbHVlID8gc2V0VGltZSh0aGlzLnZhbHVlLCB2YWx1ZSkgOiB2YWx1ZTtcbiAgICB9XG4gICAgdG9nZ2xlUG9wdXAoc2hvdykge1xuICAgICAgICBjb25zdCBldmVudCA9IG5ldyBQcmV2ZW50YWJsZUV2ZW50KCk7XG4gICAgICAgIGlmICghdGhpcy5fc2hvdyAmJiBzaG93KSB7XG4gICAgICAgICAgICB0aGlzLm9wZW4uZW1pdChldmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5fc2hvdyAmJiAhc2hvdykge1xuICAgICAgICAgICAgdGhpcy5jbG9zZS5lbWl0KGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl90b2dnbGUoc2hvdyk7XG4gICAgICAgIHRoaXMudG9nZ2xlRm9jdXMoKTtcbiAgICB9XG4gICAgX3RvZ2dsZShzaG93KSB7XG4gICAgICAgIGlmIChzaG93ID09PSB0aGlzLmlzT3Blbikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3Nob3cgPSBzaG93O1xuICAgICAgICB0aGlzLmNkci5tYXJrRm9yQ2hlY2soKTtcbiAgICAgICAgaWYgKHNob3cpIHtcbiAgICAgICAgICAgIGNvbnN0IGRpcmVjdGlvbiA9IHRoaXMubG9jYWxpemF0aW9uLnJ0bCA/ICdyaWdodCcgOiAnbGVmdCc7XG4gICAgICAgICAgICB0aGlzLnBvcHVwUmVmID0gdGhpcy5wb3B1cFNlcnZpY2Uub3Blbih7XG4gICAgICAgICAgICAgICAgYW5jaG9yOiB0aGlzLndyYXBwZXIsXG4gICAgICAgICAgICAgICAgYW5jaG9yQWxpZ246IHsgdmVydGljYWw6ICdib3R0b20nLCBob3Jpem9udGFsOiBkaXJlY3Rpb24gfSxcbiAgICAgICAgICAgICAgICBhbmltYXRlOiB0aGlzLnBvcHVwU2V0dGluZ3MuYW5pbWF0ZSxcbiAgICAgICAgICAgICAgICBhcHBlbmRUbzogdGhpcy5hcHBlbmRUbyxcbiAgICAgICAgICAgICAgICBjb250ZW50OiB0aGlzLnBvcHVwVGVtcGxhdGUsXG4gICAgICAgICAgICAgICAgcG9wdXBBbGlnbjogeyB2ZXJ0aWNhbDogJ3RvcCcsIGhvcml6b250YWw6IGRpcmVjdGlvbiB9LFxuICAgICAgICAgICAgICAgIHBvcHVwQ2xhc3M6IHRoaXMucG9wdXBDbGFzc2VzLFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uTW9kZTogJ2Fic29sdXRlJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnBvcHVwUmVmLnBvcHVwRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2lkJywgdGhpcy5wb3B1cFVJRCk7XG4gICAgICAgICAgICB0aGlzLnBvcHVwUmVmLnBvcHVwQW5jaG9yVmlld3BvcnRMZWF2ZS5zdWJzY3JpYmUoKCkgPT4gdGhpcy5zaG93ID0gZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5wb3B1cFJlZi5jbG9zZSgpO1xuICAgICAgICAgICAgdGhpcy5wb3B1cFJlZiA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9jdXNJbnB1dCgpIHtcbiAgICAgICAgaWYgKHRoaXMudG91Y2hFbmFibGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbnB1dC5mb2N1cygpO1xuICAgIH1cbiAgICB0b2dnbGVGb2N1cygpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzQWN0aXZlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc2hvdykge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnRpbWVTZWxlY3Rvcikge1xuICAgICAgICAgICAgICAgIHRoaXMuY2RyLmRldGVjdENoYW5nZXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmlzQWN0aXZlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50aW1lU2VsZWN0b3IuZm9jdXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghdGhpcy50b3VjaEVuYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMuaW5wdXQuZm9jdXMoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghdGhpcy5pbnB1dC5pc0FjdGl2ZSkge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVCbHVyKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmVyaWZ5VmFsdWUodmFsdWUpIHtcbiAgICAgICAgaWYgKCFpc0Rldk1vZGUoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSAmJiAhKHZhbHVlIGluc3RhbmNlb2YgRGF0ZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlICd2YWx1ZScgc2hvdWxkIGJlIGEgdmFsaWQgSmF2YVNjcmlwdCBEYXRlIGluc3RhbmNlLiBDaGVjayAke1ZBTFVFX0RPQ19MSU5LJDN9IGZvciBwb3NzaWJsZSByZXNvbHV0aW9uLmApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZlcmlmeUZvcm1hdCgpIHtcbiAgICAgICAgaWYgKCFpc0Rldk1vZGUoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZvcm1hdENvbnRhaW5zRGF0ZVBhcnRzID0gdGhpcy5pbnRsLnNwbGl0RGF0ZUZvcm1hdCh0aGlzLmZvcm1hdCkuc29tZShwYXJ0ID0+ICFmb3JtYXRSZWdFeHAudGVzdChwYXJ0LnR5cGUpKTtcbiAgICAgICAgaWYgKGZvcm1hdENvbnRhaW5zRGF0ZVBhcnRzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFByb3ZpZGVkIGZvcm1hdCBpcyBub3Qgc3VwcG9ydGVkLiBTdXBwb3J0ZWQgc3BlY2lmaWVycyBhcmUgVHx0fEh8aHxtfHN8U3xhLiBTZWUgJHtJTlRMX0RBVEVfRk9STUFUfWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGJpbmRFdmVudHMoKSB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudDtcbiAgICAgICAgdGhpcy5kb21FdmVudHMucHVzaCh0aGlzLnJlbmRlcmVyLmxpc3RlbihlbGVtZW50LCAna2V5ZG93bicsIHRoaXMuaGFuZGxlS2V5ZG93bi5iaW5kKHRoaXMpKSk7XG4gICAgICAgIGlmIChpc1dpbmRvd0F2YWlsYWJsZSgpKSB7XG4gICAgICAgICAgICB0aGlzLndpbmRvd0JsdXJTdWJzY3JpcHRpb24gPSBmcm9tRXZlbnQod2luZG93LCAnYmx1cicpLnN1YnNjcmliZSh0aGlzLmhhbmRsZVdpbmRvd0JsdXIuYmluZCh0aGlzKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaGFuZGxlV2luZG93Qmx1cigpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzT3Blbikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2hvdyA9IGZhbHNlO1xuICAgIH1cbiAgICBoYW5kbGVGb2N1cygpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNBY3RpdmUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzQWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgaWYgKGhhc09ic2VydmVycyh0aGlzLm9uRm9jdXMpKSB7XG4gICAgICAgICAgICB0aGlzLnpvbmUucnVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLm9uRm9jdXMuZW1pdCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaGFuZGxlQmx1cihhcmdzKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRUYXJnZXQgPSBhcmdzICYmIGN1cnJlbnRGb2N1c1RhcmdldChhcmdzKTtcbiAgICAgICAgaWYgKGN1cnJlbnRUYXJnZXQgJiYgKHRoaXMuaW5wdXQuY29udGFpbnNFbGVtZW50KGN1cnJlbnRUYXJnZXQpIHx8XG4gICAgICAgICAgICAodGhpcy50aW1lU2VsZWN0b3IgJiYgdGhpcy50aW1lU2VsZWN0b3IuY29udGFpbnNFbGVtZW50KGN1cnJlbnRUYXJnZXQpKSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFzT2JzZXJ2ZXJzKHRoaXMub25CbHVyKSB8fCAodGhpcy5zaG93ICYmIGhhc09ic2VydmVycyh0aGlzLmNsb3NlKSkgfHwgcmVxdWlyZXNab25lT25CbHVyKHRoaXMuY29udHJvbCkpIHtcbiAgICAgICAgICAgIHRoaXMuem9uZS5ydW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuYmx1ckNvbXBvbmVudCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuY2RyLm1hcmtGb3JDaGVjaygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmJsdXJDb21wb25lbnQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBibHVyQ29tcG9uZW50KCkge1xuICAgICAgICB0aGlzLmlzQWN0aXZlID0gZmFsc2U7IC8vIG9yZGVyIGlzIGltcG9ydGFudCDCr1xcXyjjg4QpXy/Cr1xuICAgICAgICB0aGlzLnNob3cgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5vbkNvbnRyb2xUb3VjaGVkKCk7XG4gICAgICAgIHRoaXMub25CbHVyLmVtaXQoKTtcbiAgICB9XG4gICAgaGFuZGxlRGF0ZUNvbXBsZXRlbmVzc0NoYW5nZSgpIHtcbiAgICAgICAgdGhpcy5jZHIubWFya0ZvckNoZWNrKCk7XG4gICAgICAgIHRoaXMuem9uZS5ydW4oKCkgPT4gdGhpcy5vblZhbGlkYXRvckNoYW5nZSgpKTtcbiAgICB9XG59O1xuX19kZWNvcmF0ZShbXG4gICAgVmlld0NoaWxkKCdjb250YWluZXInLCB7IHJlYWQ6IFZpZXdDb250YWluZXJSZWYsIHN0YXRpYzogZmFsc2UgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFZpZXdDb250YWluZXJSZWYpXG5dLCBUaW1lUGlja2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJjb250YWluZXJcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIFZpZXdDaGlsZCgncG9wdXBUZW1wbGF0ZScsIHsgc3RhdGljOiBmYWxzZSB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgVGVtcGxhdGVSZWYpXG5dLCBUaW1lUGlja2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJwb3B1cFRlbXBsYXRlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBWaWV3Q2hpbGQoJ3dyYXBwZXInLCB7IHN0YXRpYzogZmFsc2UgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEVsZW1lbnRSZWYpXG5dLCBUaW1lUGlja2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ3cmFwcGVyXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBUaW1lUGlja2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJmb2N1c2FibGVJZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIFRpbWVQaWNrZXJDb21wb25lbnQucHJvdG90eXBlLCBcImRpc2FibGVkXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgVGltZVBpY2tlckNvbXBvbmVudC5wcm90b3R5cGUsIFwicmVhZG9ubHlcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBUaW1lUGlja2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJyZWFkT25seUlucHV0XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBUaW1lUGlja2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJmb3JtYXRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFRpbWVQaWNrZXJDb21wb25lbnQucHJvdG90eXBlLCBcImZvcm1hdFBsYWNlaG9sZGVyXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBUaW1lUGlja2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJwbGFjZWhvbGRlclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRGF0ZSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtEYXRlXSlcbl0sIFRpbWVQaWNrZXJDb21wb25lbnQucHJvdG90eXBlLCBcIm1pblwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIERhdGUpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbRGF0ZV0pXG5dLCBUaW1lUGlja2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJtYXhcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgVGltZVBpY2tlckNvbXBvbmVudC5wcm90b3R5cGUsIFwiaW5jb21wbGV0ZURhdGVWYWxpZGF0aW9uXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgVGltZVBpY2tlckNvbXBvbmVudC5wcm90b3R5cGUsIFwiY2FuY2VsQnV0dG9uXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgVGltZVBpY2tlckNvbXBvbmVudC5wcm90b3R5cGUsIFwibm93QnV0dG9uXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbT2JqZWN0XSlcbl0sIFRpbWVQaWNrZXJDb21wb25lbnQucHJvdG90eXBlLCBcInN0ZXBzXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW09iamVjdF0pXG5dLCBUaW1lUGlja2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJwb3B1cFNldHRpbmdzXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgVGltZVBpY2tlckNvbXBvbmVudC5wcm90b3R5cGUsIFwidGFiaW5kZXhcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlciksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtOdW1iZXJdKVxuXSwgVGltZVBpY2tlckNvbXBvbmVudC5wcm90b3R5cGUsIFwidGFiSW5kZXhcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBUaW1lUGlja2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0aXRsZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIFRpbWVQaWNrZXJDb21wb25lbnQucHJvdG90eXBlLCBcInJhbmdlVmFsaWRhdGlvblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRGF0ZSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtEYXRlXSlcbl0sIFRpbWVQaWNrZXJDb21wb25lbnQucHJvdG90eXBlLCBcInZhbHVlXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbl0sIFRpbWVQaWNrZXJDb21wb25lbnQucHJvdG90eXBlLCBcInZhbHVlQ2hhbmdlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBPdXRwdXQoJ2ZvY3VzJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbl0sIFRpbWVQaWNrZXJDb21wb25lbnQucHJvdG90eXBlLCBcIm9uRm9jdXNcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIE91dHB1dCgnYmx1cicpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXG5dLCBUaW1lUGlja2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJvbkJsdXJcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIE91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXG5dLCBUaW1lUGlja2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJvcGVuXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBPdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxuXSwgVGltZVBpY2tlckNvbXBvbmVudC5wcm90b3R5cGUsIFwiY2xvc2VcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5rLXdpZGdldCcpLFxuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5rLXRpbWVwaWNrZXInKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIFRpbWVQaWNrZXJDb21wb25lbnQucHJvdG90eXBlLCBcIndyYXBwZXJDbGFzc2VzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBIb3N0QmluZGluZygnY2xhc3Muay1zdGF0ZS1kaXNhYmxlZCcpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBUaW1lUGlja2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkaXNhYmxlZENsYXNzXCIsIG51bGwpO1xuVGltZVBpY2tlckNvbXBvbmVudCA9IFRpbWVQaWNrZXJDb21wb25lbnRfMSA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICBleHBvcnRBczogJ2tlbmRvLXRpbWVwaWNrZXInLFxuICAgICAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgICAgIHsgcHJvdmlkZTogTkdfVkFMVUVfQUNDRVNTT1IsIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IFRpbWVQaWNrZXJDb21wb25lbnRfMSksIG11bHRpOiB0cnVlIH0sXG4gICAgICAgICAgICB7IHByb3ZpZGU6IE5HX1ZBTElEQVRPUlMsIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IFRpbWVQaWNrZXJDb21wb25lbnRfMSksIG11bHRpOiB0cnVlIH0sXG4gICAgICAgICAgICB7IHByb3ZpZGU6IEtlbmRvSW5wdXQsIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IFRpbWVQaWNrZXJDb21wb25lbnRfMSkgfSxcbiAgICAgICAgICAgIExvY2FsaXphdGlvblNlcnZpY2UsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcHJvdmlkZTogTDEwTl9QUkVGSVgsXG4gICAgICAgICAgICAgICAgdXNlVmFsdWU6ICdrZW5kby50aW1lcGlja2VyJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFBpY2tlclNlcnZpY2VcbiAgICAgICAgXSxcbiAgICAgICAgc2VsZWN0b3I6ICdrZW5kby10aW1lcGlja2VyJyxcbiAgICAgICAgdGVtcGxhdGU6IGBcbiAgICAgICAgPG5nLWNvbnRhaW5lciBrZW5kb1RpbWVQaWNrZXJMb2NhbGl6ZWRNZXNzYWdlc1xuICAgICAgICAgICAgaTE4bi1hY2NlcHQ9XCJrZW5kby50aW1lcGlja2VyLmFjY2VwdHxUaGUgQWNjZXB0IGJ1dHRvbiB0ZXh0IGluIHRoZSB0aW1lcGlja2VyIGNvbXBvbmVudFwiXG4gICAgICAgICAgICBhY2NlcHQ9XCJTZXRcIlxuXG4gICAgICAgICAgICBpMThuLWFjY2VwdExhYmVsPVwia2VuZG8udGltZXBpY2tlci5hY2NlcHRMYWJlbHxUaGUgbGFiZWwgZm9yIHRoZSBBY2NlcHQgYnV0dG9uIGluIHRoZSB0aW1lcGlja2VyIGNvbXBvbmVudFwiXG4gICAgICAgICAgICBhY2NlcHRMYWJlbD1cIlNldCB0aW1lXCJcblxuICAgICAgICAgICAgaTE4bi1jYW5jZWw9XCJrZW5kby50aW1lcGlja2VyLmNhbmNlbHxUaGUgQ2FuY2VsIGJ1dHRvbiB0ZXh0IGluIHRoZSB0aW1lcGlja2VyIGNvbXBvbmVudFwiXG4gICAgICAgICAgICBjYW5jZWw9XCJDYW5jZWxcIlxuXG4gICAgICAgICAgICBpMThuLWNhbmNlbExhYmVsPVwia2VuZG8udGltZXBpY2tlci5jYW5jZWxMYWJlbHxUaGUgbGFiZWwgZm9yIHRoZSBDYW5jZWwgYnV0dG9uIGluIHRoZSB0aW1lcGlja2VyIGNvbXBvbmVudFwiXG4gICAgICAgICAgICBjYW5jZWxMYWJlbD1cIkNhbmNlbCBjaGFuZ2VzXCJcblxuICAgICAgICAgICAgaTE4bi1ub3c9XCJrZW5kby50aW1lcGlja2VyLm5vd3xUaGUgTm93IGJ1dHRvbiB0ZXh0IGluIHRoZSB0aW1lcGlja2VyIGNvbXBvbmVudFwiXG4gICAgICAgICAgICBub3c9XCJOb3dcIlxuXG4gICAgICAgICAgICBpMThuLW5vd0xhYmVsPVwia2VuZG8udGltZXBpY2tlci5ub3dMYWJlbHxUaGUgbGFiZWwgZm9yIHRoZSBOb3cgYnV0dG9uIGluIHRoZSB0aW1lcGlja2VyIGNvbXBvbmVudFwiXG4gICAgICAgICAgICBub3dMYWJlbD1cIlNlbGVjdCBub3dcIlxuXG4gICAgICAgICAgICBpMThuLXRvZ2dsZT1cImtlbmRvLnRpbWVwaWNrZXIudG9nZ2xlfFRoZSBsYWJlbCBmb3IgdGhlIHRvZ2dsZSBidXR0b24gaW4gdGhlIHRpbWVwaWNrZXIgY29tcG9uZW50XCJcbiAgICAgICAgICAgIHRvZ2dsZT1cIlRvZ2dsZSB0aW1lIGxpc3RcIlxuICAgICAgICA+XG4gICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgICAgICA8c3BhbiAjd3JhcHBlclxuICAgICAgICAgICAgY2xhc3M9XCJrLXBpY2tlci13cmFwXCJcbiAgICAgICAgICAgIFtjbGFzcy5rLXN0YXRlLWRpc2FibGVkXT1cImRpc2FibGVkXCJcbiAgICAgICAgPlxuICAgICAgICAgICAgPGtlbmRvLWRhdGVpbnB1dFxuICAgICAgICAgICAgICAgICNpbnB1dFxuICAgICAgICAgICAgICAgIFtmb2N1c2FibGVJZF09XCJmb2N1c2FibGVJZFwiXG4gICAgICAgICAgICAgICAgW2hhc1BvcHVwXT1cInRydWVcIlxuICAgICAgICAgICAgICAgIFtpc1BvcHVwT3Blbl09XCJzaG93XCJcbiAgICAgICAgICAgICAgICBbZGlzYWJsZWRdPVwiZGlzYWJsZWRcIlxuICAgICAgICAgICAgICAgIFtyZWFkb25seV09XCJyZWFkb25seSB8fCByZWFkT25seUlucHV0XCJcbiAgICAgICAgICAgICAgICBbcm9sZV09XCJpbnB1dFJvbGVcIlxuICAgICAgICAgICAgICAgIFthcmlhUmVhZE9ubHldPVwicmVhZG9ubHlcIlxuICAgICAgICAgICAgICAgIFtmb3JtYXRdPVwiZm9ybWF0XCJcbiAgICAgICAgICAgICAgICBbZm9ybWF0UGxhY2Vob2xkZXJdPVwiZm9ybWF0UGxhY2Vob2xkZXJcIlxuICAgICAgICAgICAgICAgIFtwbGFjZWhvbGRlcl09XCJwbGFjZWhvbGRlclwiXG4gICAgICAgICAgICAgICAgW21pbl09XCJub3JtYWxpemVUaW1lKG1pbilcIlxuICAgICAgICAgICAgICAgIFttYXhdPVwibm9ybWFsaXplVGltZShtYXgpXCJcbiAgICAgICAgICAgICAgICBbaW5jb21wbGV0ZURhdGVWYWxpZGF0aW9uXT1cImluY29tcGxldGVEYXRlVmFsaWRhdGlvblwiXG4gICAgICAgICAgICAgICAgW3N0ZXBzXT1cInN0ZXBzXCJcbiAgICAgICAgICAgICAgICBbdGFiaW5kZXhdPVwiIXNob3cgPyB0YWJpbmRleCA6IC0xXCJcbiAgICAgICAgICAgICAgICBbdGl0bGVdPVwidGl0bGVcIlxuICAgICAgICAgICAgICAgIFt2YWx1ZV09XCJ2YWx1ZVwiXG4gICAgICAgICAgICAgICAgKHZhbHVlQ2hhbmdlKT1cImhhbmRsZUlucHV0Q2hhbmdlKCRldmVudClcIlxuICAgICAgICAgICAgPjwva2VuZG8tZGF0ZWlucHV0PlxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJrLXNlbGVjdFwiXG4gICAgICAgICAgICAgICAgcm9sZT1cImJ1dHRvblwiXG4gICAgICAgICAgICAgICAgW2F0dHIudGl0bGVdPVwibG9jYWxpemF0aW9uLmdldCgndG9nZ2xlJylcIlxuICAgICAgICAgICAgICAgIFthdHRyLmFyaWEtbGFiZWxdPVwibG9jYWxpemF0aW9uLmdldCgndG9nZ2xlJylcIlxuICAgICAgICAgICAgICAgIFtrZW5kb0V2ZW50c091dHNpZGVBbmd1bGFyXT1cIntcbiAgICAgICAgICAgICAgICAgICAgY2xpY2s6IGhhbmRsZUljb25DbGljayxcbiAgICAgICAgICAgICAgICAgICAgbW91c2Vkb3duOiBoYW5kbGVNb3VzZWRvd25cbiAgICAgICAgICAgICAgICB9XCJcbiAgICAgICAgICAgICAgICBbc2NvcGVdPVwidGhpc1wiXG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJrLWljb24gay1pLWNsb2NrXCI+PC9zcGFuPlxuICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgPG5nLXRlbXBsYXRlICNwb3B1cFRlbXBsYXRlPlxuICAgICAgICAgICAgICAgIDxrZW5kby10aW1lc2VsZWN0b3JcbiAgICAgICAgICAgICAgICAgICAgI3RpbWVTZWxlY3RvclxuICAgICAgICAgICAgICAgICAgICBbY2FuY2VsQnV0dG9uXT1cImNhbmNlbEJ1dHRvblwiXG4gICAgICAgICAgICAgICAgICAgIFtub3dCdXR0b25dPVwibm93QnV0dG9uXCJcbiAgICAgICAgICAgICAgICAgICAgW2Zvcm1hdF09XCJmb3JtYXRcIlxuICAgICAgICAgICAgICAgICAgICBbbWluXT1cIm1pblwiXG4gICAgICAgICAgICAgICAgICAgIFttYXhdPVwibWF4XCJcbiAgICAgICAgICAgICAgICAgICAgW3N0ZXBzXT1cInN0ZXBzXCJcbiAgICAgICAgICAgICAgICAgICAgW3ZhbHVlXT1cInZhbHVlXCJcbiAgICAgICAgICAgICAgICAgICAgW2tlbmRvRXZlbnRzT3V0c2lkZUFuZ3VsYXJdPVwie1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5ZG93bjogaGFuZGxlS2V5ZG93bixcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vdXNlZG93bjogaGFuZGxlTW91c2Vkb3duXG4gICAgICAgICAgICAgICAgICAgIH1cIlxuICAgICAgICAgICAgICAgICAgICBbc2NvcGVdPVwidGhpc1wiXG4gICAgICAgICAgICAgICAgICAgICh2YWx1ZUNoYW5nZSk9XCJoYW5kbGVDaGFuZ2UoJGV2ZW50KVwiXG4gICAgICAgICAgICAgICAgICAgICh2YWx1ZVJlamVjdCk9XCJoYW5kbGVSZWplY3QoKVwiXG4gICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICA8a2VuZG8tdGltZXNlbGVjdG9yLW1lc3NhZ2VzXG4gICAgICAgICAgICAgICAgICAgICAgICBbYWNjZXB0TGFiZWxdPVwibG9jYWxpemF0aW9uLmdldCgnYWNjZXB0TGFiZWwnKVwiXG4gICAgICAgICAgICAgICAgICAgICAgICBbYWNjZXB0XT1cImxvY2FsaXphdGlvbi5nZXQoJ2FjY2VwdCcpXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIFtjYW5jZWxMYWJlbF09XCJsb2NhbGl6YXRpb24uZ2V0KCdjYW5jZWxMYWJlbCcpXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIFtjYW5jZWxdPVwibG9jYWxpemF0aW9uLmdldCgnY2FuY2VsJylcIlxuICAgICAgICAgICAgICAgICAgICAgICAgW25vd0xhYmVsXT1cImxvY2FsaXphdGlvbi5nZXQoJ25vd0xhYmVsJylcIlxuICAgICAgICAgICAgICAgICAgICAgICAgW25vd109XCJsb2NhbGl6YXRpb24uZ2V0KCdub3cnKVwiXG4gICAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgPC9rZW5kby10aW1lc2VsZWN0b3ItbWVzc2FnZXM+XG4gICAgICAgICAgICAgICAgPC9rZW5kby10aW1lc2VsZWN0b3I+XG4gICAgICAgICAgICA8L25nLXRlbXBsYXRlPlxuICAgICAgICA8L3NwYW4+XG4gICAgICAgIDxuZy1jb250YWluZXIgI2NvbnRhaW5lcj48L25nLWNvbnRhaW5lcj5cbiAgICBgXG4gICAgfSksXG4gICAgX19wYXJhbSg5LCBPcHRpb25hbCgpKSwgX19wYXJhbSg5LCBJbmplY3QoVE9VQ0hfRU5BQkxFRCkpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbTmdab25lLFxuICAgICAgICBMb2NhbGl6YXRpb25TZXJ2aWNlLFxuICAgICAgICBDaGFuZ2VEZXRlY3RvclJlZixcbiAgICAgICAgUG9wdXBTZXJ2aWNlLFxuICAgICAgICBFbGVtZW50UmVmLFxuICAgICAgICBSZW5kZXJlcjIsXG4gICAgICAgIEluamVjdG9yLFxuICAgICAgICBQaWNrZXJTZXJ2aWNlLFxuICAgICAgICBJbnRsU2VydmljZSwgQm9vbGVhbl0pXG5dLCBUaW1lUGlja2VyQ29tcG9uZW50KTtcblxudmFyIERhdGVUaW1lUGlja2VyQ29tcG9uZW50XzE7XG5jb25zdCB0aW1lRm9ybWF0UmVnRXhwID0gbmV3IFJlZ0V4cChgJHtUSU1FX1BBUlQuaG91cn18JHtUSU1FX1BBUlQubWludXRlfXwke1RJTUVfUEFSVC5zZWNvbmR9fCR7VElNRV9QQVJULmRheXBlcmlvZH18bGl0ZXJhbGApO1xuY29uc3QgVkFMVUVfRE9DX0xJTkskNCA9ICdodHRwczovL3d3dy50ZWxlcmlrLmNvbS9rZW5kby1hbmd1bGFyLXVpL2NvbXBvbmVudHMvZGF0ZWlucHV0cy9kYXRldGltZXBpY2tlci9pbnRlZ3JhdGlvbi13aXRoLWpzb24vJztcbmNvbnN0IE1JTl9NQVhfRE9DX0xJTksgPSAnaHR0cHM6Ly93d3cudGVsZXJpay5jb20va2VuZG8tYW5ndWxhci11aS9jb21wb25lbnRzL2RhdGVpbnB1dHMvZGF0ZXRpbWVwaWNrZXIvZGF0ZS10aW1lLWxpbWl0cy8nO1xuY29uc3QgREVGQVVMVF9BQ1RJVkVfVEFCID0gJ2RhdGUnO1xuY29uc3QgREVGQVVMVF9EQVRFSU5QVVRfRk9STUFUID0gJ2cnO1xuY29uc3QgREVGQVVMVF9USU1FU0VMRUNUT1JfRk9STUFUID0gJ3QnO1xuY29uc3QgVFdPX0RJR0lUX1lFQVJfTUFYJDIgPSA2ODtcbi8qKlxuICogUmVwcmVzZW50cyB0aGUgW0tlbmRvIFVJIERhdGVUaW1lUGlja2VyIGNvbXBvbmVudCBmb3IgQW5ndWxhcl0oeyUgc2x1ZyBvdmVydmlld19kYXRldGltZXBpY2tlciAlfSkuXG4gKi9cbmxldCBEYXRlVGltZVBpY2tlckNvbXBvbmVudCA9IERhdGVUaW1lUGlja2VyQ29tcG9uZW50XzEgPSBjbGFzcyBEYXRlVGltZVBpY2tlckNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IocG9wdXBTZXJ2aWNlLCBpbnRsLCBjZHIsIHBpY2tlclNlcnZpY2UsIG5nWm9uZSwgaG9zdCwgdG91Y2hFbmFibGVkJCQxLCBsb2NhbGl6YXRpb24sIGRpc2FibGVkRGF0ZXNTZXJ2aWNlLCByZW5kZXJlcikge1xuICAgICAgICB0aGlzLnBvcHVwU2VydmljZSA9IHBvcHVwU2VydmljZTtcbiAgICAgICAgdGhpcy5pbnRsID0gaW50bDtcbiAgICAgICAgdGhpcy5jZHIgPSBjZHI7XG4gICAgICAgIHRoaXMucGlja2VyU2VydmljZSA9IHBpY2tlclNlcnZpY2U7XG4gICAgICAgIHRoaXMubmdab25lID0gbmdab25lO1xuICAgICAgICB0aGlzLmhvc3QgPSBob3N0O1xuICAgICAgICB0aGlzLnRvdWNoRW5hYmxlZCA9IHRvdWNoRW5hYmxlZCQkMTtcbiAgICAgICAgdGhpcy5sb2NhbGl6YXRpb24gPSBsb2NhbGl6YXRpb247XG4gICAgICAgIHRoaXMuZGlzYWJsZWREYXRlc1NlcnZpY2UgPSBkaXNhYmxlZERhdGVzU2VydmljZTtcbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgICAgICAvKipcbiAgICAgICAgICogQGhpZGRlblxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5ob3N0Q2xhc3NlcyA9IHRydWU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbWF4aW11bSB5ZWFyIHRvIGFzc3VtZSB0byBiZSBmcm9tIHRoZSBjdXJyZW50IGNlbnR1cnkgd2hlbiB0eXBpbmcgdHdvLWRpZ2l0IHllYXIgdmFsdWVcbiAgICAgICAgICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBmb3JtYXRzX2RhdGV0aW1lcGlja2VyICV9I3RvYy10d28tZGlnaXQteWVhci1mb3JtYXQpKS5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhlIGRlZmF1bHQgdmFsdWUgaXMgNjgsIGluZGljYXRpbmcgdGhhdCB0eXBpbmcgYW55IHZhbHVlIGxlc3MgdGhhbiA2OVxuICAgICAgICAgKiB3aWxsIGJlIGFzc3VtZWQgdG8gYmUgMjB4eCwgd2hpbGUgNjkgYW5kIGxhcmdlciB3aWxsIGJlIGFzc3VtZWQgdG8gYmUgMTl4eC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudHdvRGlnaXRZZWFyTWF4ID0gVFdPX0RJR0lUX1lFQVJfTUFYJDI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaGlkZGVuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmZvY3VzYWJsZUlkID0gYGstJHtndWlkKCl9YDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgdGhlIHRpdGxlIG9mIHRoZSBpbnB1dCBlbGVtZW50IG9mIHRoZSBEYXRlVGltZVBpY2tlci5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudGl0bGUgPSAnJztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgb3IgZ2V0cyB0aGUgYGRpc2FibGVkYCBwcm9wZXJ0eSBvZiB0aGUgRGF0ZVRpbWVQaWNrZXIgYW5kIGRldGVybWluZXMgd2hldGhlciB0aGUgY29tcG9uZW50IGlzIGFjdGl2ZVxuICAgICAgICAgKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGRpc2FibGVkX2RhdGV0aW1lcGlja2VyICV9KSkuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRpc2FibGVkID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXRzIHRoZSByZWFkLW9ubHkgc3RhdGUgb2YgdGhlIERhdGVUaW1lUGlja2VyXG4gICAgICAgICAqIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgcmVhZG9ubHlfZGF0ZXRpbWVwaWNrZXIgJX0jdG9jLXJlYWQtb25seS1kYXRldGltZXBpY2tlcikpLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZWFkb25seSA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0cyB0aGUgcmVhZC1vbmx5IHN0YXRlIG9mIHRoZSBEYXRlVGltZVBpY2tlciBpbnB1dCBmaWVsZFxuICAgICAgICAgKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIHJlYWRvbmx5X2RhdGV0aW1lcGlja2VyICV9I3RvYy1yZWFkLW9ubHktaW5wdXQpKS5cbiAgICAgICAgICpcbiAgICAgICAgICogPiBOb3RlIHRoYXQgaWYgeW91IHNldCB0aGUgW2ByZWFkb25seWBdKHslIHNsdWcgYXBpX2RhdGVpbnB1dHNfZGF0ZXRpbWVwaWNrZXJjb21wb25lbnQgJX0jdG9jLXJlYWRvbmx5KSBwcm9wZXJ0eSB2YWx1ZSB0byBgdHJ1ZWAsXG4gICAgICAgICAqIHRoZSBpbnB1dCB3aWxsIGJlIHJlbmRlcmVkIGluIGEgcmVhZC1vbmx5IHN0YXRlIHJlZ2FyZGxlc3Mgb2YgdGhlIGByZWFkT25seUlucHV0YCB2YWx1ZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVhZE9ubHlJbnB1dCA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRvIGRpc3BsYXkgdGhlICoqQ2FuY2VsKiogYnV0dG9uIGluIHRoZSBwb3B1cFxuICAgICAgICAgKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGRhdGV0aW1lcGlja2VyX3BvcHVwX29wdGlvbnMgJX0jdG9jLXRvZ2dsaW5nLXRoZS1jYW5jZWwtYnV0dG9uKSkuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNhbmNlbEJ1dHRvbiA9IHRydWU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb25maWd1cmVzIHRoZSBpbmNyZW1lbnRhbCBzdGVwcyBvZiB0aGUgRGF0ZUlucHV0IGFuZCB0aGUgcG9wdXAgY29tcG9uZW50IG9mIHRoZSBUaW1lUGlja2VyXG4gICAgICAgICAqIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgaW5jcmVtZW50YWxzdGVwc19kYXRldGltZXBpY2tlciAlfSkpLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdGVwcyA9IHt9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU3BlY2lmaWVzIHRoZSBDYWxlbmRhciB0eXBlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGUgcG9zc2libGUgdmFsdWVzIGFyZTpcbiAgICAgICAgICogLSBgaW5maW5pdGVgIChkZWZhdWx0KVxuICAgICAgICAgKiAtIGBjbGFzc2ljYFxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jYWxlbmRhclR5cGUgPSAnaW5maW5pdGUnO1xuICAgICAgICAvKipcbiAgICAgICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRvIGVuYWJsZSBhbmltYXRpb24gd2hlbiBuYXZpZ2F0aW5nIHRvIHByZXZpb3VzL25leHQgQ2FsZW5kYXIgdmlldy5cbiAgICAgICAgICogQXBwbGllcyB0byB0aGUgW2BjbGFzc2ljYF0oeyUgc2x1ZyBhcGlfZGF0ZWlucHV0c19kYXRldGltZXBpY2tlcmNvbXBvbmVudCAlfSN0b2MtY2FsZW5kYXJ0eXBlKSBDYWxlbmRhciBvbmx5LlxuICAgICAgICAgKlxuICAgICAgICAgKiA+IFRoaXMgZmVhdHVyZSB1c2VzIHRoZSBbV2ViIEFuaW1hdGlvbnMgQVBJXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvV2ViX0FuaW1hdGlvbnNfQVBJKS4gSW4gb3JkZXIgdG8gcnVuIHRoZSBhbmltYXRpb24gaW4gYnJvd3NlcnMgdGhhdCBkbyBub3Qgc3VwcG9ydCBpdCwgeW91IG5lZWQgdGhlIGB3ZWItYW5pbWF0aW9ucy1qc2AgcG9seWZpbGwuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmFuaW1hdGVDYWxlbmRhck5hdmlnYXRpb24gPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERldGVybWluZXMgd2hldGhlciB0byBkaXNwbGF5IGEgd2VlayBudW1iZXIgY29sdW1uIGluIHRoZSBgbW9udGhgIHZpZXcgb2YgdGhlIHBvcHVwIENhbGVuZGFyXG4gICAgICAgICAqIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgZGF0ZXRpbWVwaWNrZXJfY2FsZW5kYXJfb3B0aW9ucyAlfSN0b2Mtd2Vlay1udW1iZXItY29sdW1uKSkuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLndlZWtOdW1iZXIgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERldGVybWluZXMgd2hldGhlciB0aGUgYnVpbHQtaW4gbWluIG9yIG1heCB2YWxpZGF0b3JzIGFyZSBlbmZvcmNlZCB3aGVuIHZhbGlkYXRpbmcgYSBmb3JtXG4gICAgICAgICAqIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgZGF0ZXJhbmdlc19kYXRldGltZXBpY2tlciAlfSN0b2MtcHJldmVudC1pbnZhbGlkLWlucHV0KSkuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJhbmdlVmFsaWRhdGlvbiA9IHRydWU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGJ1aWx0LWluIHZhbGlkYXRvciBmb3IgZGlzYWJsZWRcbiAgICAgICAgICogZGF0ZSByYW5nZXMgaXMgZW5mb3JjZWQgd2hlbiB2YWxpZGF0aW5nIGEgZm9ybVxuICAgICAgICAgKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGRpc2FibGVkX2RhdGVzX2RhdGV0aW1lcGlja2VyICV9I3RvYy12YWxpZGF0aW9uKSkuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRpc2FibGVkRGF0ZXNWYWxpZGF0aW9uID0gdHJ1ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERldGVybWluZXMgd2hldGhlciB0aGUgYnVpbHQtaW4gdmFsaWRhdGlvbiBmb3IgaW5jb21wbGV0ZSBkYXRlcyBpcyB0byBiZSBlbmZvcmNlZCB3aGVuIGEgZm9ybSBpcyBiZWluZyB2YWxpZGF0ZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmluY29tcGxldGVEYXRlVmFsaWRhdGlvbiA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgZWFjaCB0aW1lIHRoZSB1c2VyIHNlbGVjdHMgYSBuZXcgdmFsdWUuXG4gICAgICAgICAqIChbbW9yZSBpbmZvcm1hdGlvbiBhbmQgZXhhbXBsZV0oeyUgc2x1ZyBvdmVydmlld19kYXRldGltZXBpY2tlciAlfSN0b2MtbWV0aG9kcy1hbmQtZXZlbnRzKSkuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnZhbHVlQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgZWFjaCB0aW1lIHRoZSBwb3B1cCBpcyBhYm91dCB0byBvcGVuLlxuICAgICAgICAgKiBUaGlzIGV2ZW50IGlzIHByZXZlbnRhYmxlLiBJZiB5b3UgY2FuY2VsIHRoZSBldmVudCBieSBzZXR0aW5nIGBldmVudC5wcmV2ZW50RGVmYXVsdCgpYCwgdGhlIHBvcHVwIHdpbGwgcmVtYWluIGNsb3NlZC5cbiAgICAgICAgICogKFttb3JlIGluZm9ybWF0aW9uIGFuZCBleGFtcGxlXSh7JSBzbHVnIG92ZXJ2aWV3X2RhdGV0aW1lcGlja2VyICV9I3RvYy1tZXRob2RzLWFuZC1ldmVudHMpKS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub3BlbiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIGVhY2ggdGltZSB0aGUgcG9wdXAgaXMgYWJvdXQgdG8gY2xvc2UuXG4gICAgICAgICAqIFRoaXMgZXZlbnQgaXMgcHJldmVudGFibGUuIElmIHlvdSBjYW5jZWwgdGhlIGV2ZW50IGJ5IHNldHRpbmcgYGV2ZW50LnByZXZlbnREZWZhdWx0KClgLCB0aGUgcG9wdXAgd2lsbCByZW1haW4gb3Blbi5cbiAgICAgICAgICogKFttb3JlIGluZm9ybWF0aW9uIGFuZCBleGFtcGxlXSh7JSBzbHVnIG92ZXJ2aWV3X2RhdGV0aW1lcGlja2VyICV9I3RvYy1tZXRob2RzLWFuZC1ldmVudHMpKS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2xvc2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyBlYWNoIHRpbWUgdGhlIHVzZXIgZm9jdXNlcyB0aGUgY29tcG9uZW50LlxuICAgICAgICAgKiAoW21vcmUgaW5mb3JtYXRpb24gYW5kIGV4YW1wbGVdKHslIHNsdWcgb3ZlcnZpZXdfZGF0ZXRpbWVwaWNrZXIgJX0jdG9jLW1ldGhvZHMtYW5kLWV2ZW50cykpLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vbkZvY3VzID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgZWFjaCB0aW1lIHRoZSB1c2VyIGJsdXJzIHRoZSBjb21wb25lbnQuXG4gICAgICAgICAqIChbbW9yZSBpbmZvcm1hdGlvbiBhbmQgZXhhbXBsZV0oeyUgc2x1ZyBvdmVydmlld19kYXRldGltZXBpY2tlciAlfSN0b2MtbWV0aG9kcy1hbmQtZXZlbnRzKSkuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9uQmx1ciA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBoaWRkZW5cbiAgICAgICAgICpcbiAgICAgICAgICogQ29udHJvbHMgd2hldGhlciB0aGUgQ2FsZW5kYXIgb3IgdGhlIFRpbWVTZWxlY3RvciB3aWxsIGJlIGRpc3BsYXllZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYWN0aXZlVGFiID0gREVGQVVMVF9BQ1RJVkVfVEFCO1xuICAgICAgICAvKipcbiAgICAgICAgICogQGhpZGRlblxuICAgICAgICAgKlxuICAgICAgICAgKiBTcGVjaWZpZXMgdGhlIHN0cmlwcGVkIHRpbWUtcmVsYXRlZCBmb3JtYXQgdGhhdCBpcyB1c2VkIGluIHRoZSBUaW1lU2VsZWN0b3IuXG4gICAgICAgICAqIFVwZGF0ZXMgZWFjaCB0aW1lIHRoZSBgZm9ybWF0YCBwcm9wZXJ0eSB2YWx1ZSBjaGFuZ2VzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50aW1lU2VsZWN0b3JGb3JtYXQgPSBERUZBVUxUX1RJTUVTRUxFQ1RPUl9GT1JNQVQ7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaGlkZGVuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRpbWVTZWxlY3Rvck1pbiA9IGNsb25lRGF0ZShNSU5fVElNRSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaGlkZGVuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRpbWVTZWxlY3Rvck1heCA9IGNsb25lRGF0ZShNQVhfVElNRSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaGlkZGVuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNhbGVuZGFyVmFsdWUgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogQGhpZGRlblxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jYWxlbmRhck1pbiA9IGNsb25lRGF0ZShNSU5fREFURSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaGlkZGVuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNhbGVuZGFyTWF4ID0gbGFzdE1pbGxpc2Vjb25kT2ZEYXRlKE1BWF9EQVRFKTtcbiAgICAgICAgdGhpcy5fcG9wdXBTZXR0aW5ncyA9IHsgYW5pbWF0ZTogdHJ1ZSB9O1xuICAgICAgICB0aGlzLl92YWx1ZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX2Zvcm1hdCA9IERFRkFVTFRfREFURUlOUFVUX0ZPUk1BVDtcbiAgICAgICAgdGhpcy5fdGFiaW5kZXggPSAwO1xuICAgICAgICB0aGlzLl9kZWZhdWx0VGFiID0gREVGQVVMVF9BQ1RJVkVfVEFCO1xuICAgICAgICB0aGlzLl9taW4gPSBtZXJnZURhdGVBbmRUaW1lKE1JTl9EQVRFLCBNSU5fVElNRSk7XG4gICAgICAgIHRoaXMuX21heCA9IG1lcmdlRGF0ZUFuZFRpbWUoTUFYX0RBVEUsIE1BWF9USU1FKTtcbiAgICAgICAgdGhpcy5faXNBY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5vbkNvbnRyb2xUb3VjaGVkID0gbm9vcDtcbiAgICAgICAgdGhpcy5vbkNvbnRyb2xDaGFuZ2UgPSBub29wO1xuICAgICAgICB0aGlzLm9uVmFsaWRhdG9yQ2hhbmdlID0gbm9vcDtcbiAgICAgICAgdGhpcy5taW5WYWxpZGF0ZUZuID0gbm9vcDtcbiAgICAgICAgdGhpcy5tYXhWYWxpZGF0ZUZuID0gbm9vcDtcbiAgICAgICAgdGhpcy5kaXNhYmxlZERhdGVzVmFsaWRhdGVGbiA9IG5vb3A7XG4gICAgICAgIHRoaXMuaW5jb21wbGV0ZVZhbGlkYXRvciA9IG5vb3A7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucyA9IG5ldyBTdWJzY3JpcHRpb24oKTtcbiAgICAgICAgdmFsaWRhdGVQYWNrYWdlKHBhY2thZ2VNZXRhZGF0YSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBnZXQgaW5wdXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBpY2tlclNlcnZpY2UuaW5wdXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBnZXQgY2FsZW5kYXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBpY2tlclNlcnZpY2UuY2FsZW5kYXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBnZXQgdGltZVNlbGVjdG9yKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5waWNrZXJTZXJ2aWNlLnRpbWVTZWxlY3RvcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3BlY2lmaWVzIHRoZSB2YWx1ZSBvZiB0aGUgRGF0ZVRpbWVQaWNrZXIgY29tcG9uZW50LlxuICAgICAqXG4gICAgICogPiBUaGUgYHZhbHVlYCBoYXMgdG8gYmUgYSB2YWxpZCBbSmF2YVNjcmlwdCBgRGF0ZWBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0RhdGUpIGluc3RhbmNlLlxuICAgICAqL1xuICAgIHNldCB2YWx1ZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLnZlcmlmeVZhbHVlKHZhbHVlKTtcbiAgICAgICAgdGhpcy5fdmFsdWUgPSBjbG9uZURhdGUodmFsdWUpO1xuICAgICAgICB0aGlzLnNldENhbGVuZGFyVmFsdWUodmFsdWUpO1xuICAgICAgICB0aGlzLmNkci5tYXJrRm9yQ2hlY2soKTtcbiAgICB9XG4gICAgZ2V0IHZhbHVlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNwZWNpZmllcyB0aGUgZGF0ZSBmb3JtYXQgZm9yIGRpc3BsYXlpbmcgdGhlIGlucHV0IHZhbHVlXG4gICAgICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBmb3JtYXRzX2RhdGV0aW1lcGlja2VyICV9KSlcbiAgICAgKlxuICAgICAqIEZvcm1hdCB2YWx1ZSBvcHRpb25zOlxuICAgICAqIC0gYHN0cmluZ2AgLSBQcm92aWRlIGEgYHN0cmluZ2AgaWYgYSBzaW5nbGUgZm9ybWF0IGlzIGdvaW5nIHRvIGJlIHVzZWQgcmVnYXJkbGVzcyB3aGV0aGVyIHRoZSBpbnB1dCBpcyBmb2N1c2VkIG9yIGJsdXJyZWQuXG4gICAgICogLSBbYEZvcm1hdFNldHRpbmdzYF0oeyUgc2x1ZyBhcGlfZGF0ZWlucHV0c19mb3JtYXRzZXR0aW5ncyAlfSkgLSBUbyBkaXNwbGF5IGRpZmZlcmVudCBmb3JtYXRzIHdoZW4gdGhlIGNvbXBvbmVudCBpcyBmb2N1c2VkIG9yIGJsdXJyZWQsIHByb3ZpZGUgYSBzZXR0aW5ncyBvYmplY3Qgd2l0aCBzcGVjaWZpZWQgYGlucHV0Rm9ybWF0YCBhbmQgYGRpc3BsYXlGb3JtYXRgIHZhbHVlcy5cbiAgICAgKlxuICAgICAqID4gSWYgYSBbYEZvcm1hdFNldHRpbmdzYF0oeyUgc2x1ZyBhcGlfZGF0ZWlucHV0c19mb3JtYXRzZXR0aW5ncyAlfSkgb2JqZWN0IGlzIHByb3ZpZGVkLCB0aGUgYGRpc3BsYXlGb3JtYXRgIHZhbHVlIHdpbGwgYmUgdXNlZCBmb3IgdGhlIHBvcHVwIFRpbWVQaWNrZXIuXG4gICAgICovXG4gICAgc2V0IGZvcm1hdChmb3JtYXQpIHtcbiAgICAgICAgdGhpcy5fZm9ybWF0ID0gZm9ybWF0O1xuICAgICAgICBjb25zdCBkaXNwbGF5Rm9ybWF0ID0gdGhpcy5nZXREaXNwbGF5Rm9ybWF0KGZvcm1hdCk7XG4gICAgICAgIHRoaXMudGltZVNlbGVjdG9yRm9ybWF0ID0gdGhpcy5nZXRUaW1lU2VsZWN0b3JGb3JtYXQoZGlzcGxheUZvcm1hdCk7XG4gICAgfVxuICAgIGdldCBmb3JtYXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9mb3JtYXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNwZWNpZmllcyB0aGUgW2B0YWJpbmRleGBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvR2xvYmFsX2F0dHJpYnV0ZXMvdGFiaW5kZXgpIG9mIHRoZSBEYXRlVGltZVBpY2tlci5cbiAgICAgKi9cbiAgICBzZXQgdGFiaW5kZXgodmFsdWUpIHtcbiAgICAgICAgY29uc3QgdGFiaW5kZXggPSBOdW1iZXIodmFsdWUpO1xuICAgICAgICBjb25zdCBkZWZhdWx0VmFsdWUgPSAwO1xuICAgICAgICB0aGlzLl90YWJpbmRleCA9ICFpc05hTih0YWJpbmRleCkgPyB0YWJpbmRleCA6IGRlZmF1bHRWYWx1ZTtcbiAgICB9XG4gICAgZ2V0IHRhYmluZGV4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kaXNhYmxlZCA/IC0xIDogdGhpcy5fdGFiaW5kZXg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGRhdGVzIG9mIHRoZSBEYXRlVGltZVBpY2tlciB0aGF0IHdpbGwgYmUgZGlzYWJsZWRcbiAgICAgKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGRpc2FibGVkX2RhdGVzX2RhdGV0aW1lcGlja2VyICV9KSkuXG4gICAgICovXG4gICAgc2V0IGRpc2FibGVkRGF0ZXModmFsdWUpIHtcbiAgICAgICAgdGhpcy5fZGlzYWJsZWREYXRlcyA9IHZhbHVlO1xuICAgICAgICB0aGlzLmRpc2FibGVkRGF0ZXNTZXJ2aWNlLmluaXRpYWxpemUodmFsdWUpO1xuICAgIH1cbiAgICBnZXQgZGlzYWJsZWREYXRlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Rpc2FibGVkRGF0ZXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbmZpZ3VyZXMgdGhlIHBvcHVwIHNldHRpbmdzIG9mIHRoZSBEYXRlVGltZVBpY2tlclxuICAgICAqIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgZGF0ZXRpbWVwaWNrZXJfcG9wdXBfb3B0aW9ucyAlfSN0b2MtY3VzdG9taXppbmctdGhlLXBvcHVwKSkuXG4gICAgICpcbiAgICAgKiBUaGUgYXZhaWxhYmxlIG9wdGlvbnMgYXJlOlxuICAgICAqIC0gYGFuaW1hdGU6IEJvb2xlYW5gJm1kYXNoO0NvbnRyb2xzIHRoZSBwb3B1cCBhbmltYXRpb24uIEJ5IGRlZmF1bHQsIHRoZSBvcGVuIGFuZCBjbG9zZSBhbmltYXRpb25zIGFyZSBlbmFibGVkLlxuICAgICAqIC0gYGFwcGVuZFRvOiAncm9vdCcgfCAnY29tcG9uZW50JyB8IFZpZXdDb250YWluZXJSZWZgJm1kYXNoO0NvbnRyb2xzIHRoZSBwb3B1cCBjb250YWluZXIuIEJ5IGRlZmF1bHQsIHRoZSBwb3B1cCB3aWxsIGJlIGFwcGVuZGVkIHRvIHRoZSByb290IGNvbXBvbmVudC5cbiAgICAgKiAtIGBwb3B1cENsYXNzOiBTdHJpbmdgJm1kYXNoO1NwZWNpZmllcyBhIGxpc3Qgb2YgQ1NTIGNsYXNzZXMgdGhhdCBhcmUgdXNlZCB0byBzdHlsZSB0aGUgcG9wdXAuXG4gICAgICovXG4gICAgc2V0IHBvcHVwU2V0dGluZ3Moc2V0dGluZ3MpIHtcbiAgICAgICAgdGhpcy5fcG9wdXBTZXR0aW5ncyA9IE9iamVjdC5hc3NpZ24oe30sIHsgYW5pbWF0ZTogdHJ1ZSB9LCBzZXR0aW5ncyk7XG4gICAgfVxuICAgIGdldCBwb3B1cFNldHRpbmdzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcG9wdXBTZXR0aW5ncztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3BlY2lmaWVzIHRoZSBzbWFsbGVzdCB2YWxpZCBkYXRlLlxuICAgICAqIFRoZSBDYWxlbmRhciB3aWxsIG5vdCBkaXNwbGF5IGRhdGVzIGJlZm9yZSB0aGlzIHZhbHVlLlxuICAgICAqIElmIHRoZSBgbWluYCB2YWx1ZSBvZiB0aGUgQ2FsZW5kYXIgaXMgc2VsZWN0ZWQsIHRoZSBUaW1lUGlja2VyIHdpbGwgbm90IGRpc3BsYXlcbiAgICAgKiB0aW1lIGVudHJpZXMgYmVmb3JlIHRoZSBzcGVjaWZpZWQgdGltZSBwb3J0aW9uIG9mIHRoaXMgdmFsdWVcbiAgICAgKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGRhdGVyYW5nZXNfZGF0ZXRpbWVwaWNrZXIgJX0pKS5cbiAgICAgKi9cbiAgICBzZXQgbWluKHZhbHVlKSB7XG4gICAgICAgIGlmICghaXNQcmVzZW50KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX21pbiA9IGNsb25lRGF0ZSh2YWx1ZSk7XG4gICAgICAgIHRoaXMuY2FsZW5kYXJNaW4gPSBnZXREYXRlKHZhbHVlKTtcbiAgICB9XG4gICAgZ2V0IG1pbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21pbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3BlY2lmaWVzIHRoZSBiaWdnZXN0IHZhbGlkIGRhdGUuXG4gICAgICogVGhlIENhbGVuZGFyIHdpbGwgbm90IGRpc3BsYXkgZGF0ZXMgYWZ0ZXIgdGhpcyB2YWx1ZS5cbiAgICAgKiBJZiB0aGUgYG1heGAgdmFsdWUgb2YgdGhlIENhbGVuZGFyIGlzIHNlbGVjdGVkLCB0aGUgVGltZVBpY2tlciB3aWxsIG5vdCBkaXNwbGF5XG4gICAgICogdGltZSBlbnRyaWVzIGFmdGVyIHRoZSBzcGVjaWZpZWQgdGltZSBwb3J0aW9uIG9mIHRoaXMgdmFsdWVcbiAgICAgKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGRhdGVyYW5nZXNfZGF0ZXRpbWVwaWNrZXIgJX0pKS5cbiAgICAgKi9cbiAgICBzZXQgbWF4KHZhbHVlKSB7XG4gICAgICAgIGlmICghaXNQcmVzZW50KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX21heCA9IGNsb25lRGF0ZSh2YWx1ZSk7XG4gICAgICAgIHRoaXMuY2FsZW5kYXJNYXggPSBsYXN0TWlsbGlzZWNvbmRPZkRhdGUodmFsdWUpO1xuICAgIH1cbiAgICBnZXQgbWF4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWF4O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgY29tcG9uZW50IGlzIGN1cnJlbnRseSBvcGVuLlxuICAgICAqL1xuICAgIGdldCBpc09wZW4oKSB7XG4gICAgICAgIHJldHVybiBpc1ByZXNlbnQodGhpcy5wb3B1cFJlZik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSBjb21wb25lbnQgb3IgaXRzIHBvcHVwIGNvbnRlbnQgaXMgZm9jdXNlZC5cbiAgICAgKi9cbiAgICBnZXQgaXNBY3RpdmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc0FjdGl2ZTtcbiAgICB9XG4gICAgc2V0IGlzQWN0aXZlKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5hZGRDbGFzcyh0aGlzLndyYXBwZXIubmF0aXZlRWxlbWVudCwgJ2stc3RhdGUtZm9jdXNlZCcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5yZW1vdmVDbGFzcyh0aGlzLndyYXBwZXIubmF0aXZlRWxlbWVudCwgJ2stc3RhdGUtZm9jdXNlZCcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2lzQWN0aXZlID0gdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGFjdGl2ZSB0YWIgb24gb3BlbmluZyB0aGUgcG9wdXBcbiAgICAgKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGRhdGV0aW1lcGlja2VyX3BvcHVwX29wdGlvbnMgJX0jdG9jLXNldHRpbmctdGhlLWRlZmF1bHQtdGFiKSkuXG4gICAgICovXG4gICAgc2V0IGRlZmF1bHRUYWIodGFiKSB7XG4gICAgICAgIHRoaXMuX2RlZmF1bHRUYWIgPSB0YWIgfHwgREVGQVVMVF9BQ1RJVkVfVEFCO1xuICAgICAgICB0aGlzLmFjdGl2ZVRhYiA9IHRoaXMuZGVmYXVsdFRhYjtcbiAgICB9XG4gICAgZ2V0IGRlZmF1bHRUYWIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWZhdWx0VGFiO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0IHRhYlN3aXRjaFRyYW5zaXRpb24oKSB7XG4gICAgICAgIC8qXG4gICAgICAgICBXaGVuIHRoZSBwb3B1cCBpcyBvcGVuaW5nLCBkaXNhYmxlcyB0aGUgc2V0IHRyYW5zaXRpb24gaW4gdGhlIHRoZW1lcy4gV2hlbiBgZGVmYXVsdFRhYmAgaXMgc2V0IHRvIGB0aW1lYCxcbiAgICAgICAgIHRoZSBwb3B1cCBvcGVucyB3aXRoIGFuIGFjdGl2ZSAqKlRpbWUqKiB0YWIgYW5kIHRoZSBhbmltYXRpb24gb2YgdGhlIGluaXRpYWwgdHJhbnNpdGlvbiBpcyB1bmRlc2lyZWQuXG4gICAgICAgICBTZXR0aW5nIHRoZSBpbmxpbmUgdHJhbnNpdGlvbiBzdHlsZSB0byBgbm9uZWAgb3ZlcnJpZGVzIHRoZSBzZXQgYW5pbWF0aW9uIGluIHRoZSB0aGVtZXMuXG4gICAgICAgICBTZXR0aW5nIHRoZSBpbmxpbmUgdHJhbnNpdGlvbiBzdHlsZSB0byBgbnVsbGAgZG9lcyBub3QgYXBwbHkgYW55IGlubGluZSBzdHlsZXMgb3Igb3ZlcnJpZGUgdGhlIHRoZW1lcyBDU1MuXG4gICAgICAgICovXG4gICAgICAgIHJldHVybiB0aGlzLmlzT3BlbiA/IG51bGwgOiAnbm9uZSc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKlxuICAgICAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSBDYWxlbmRhciB3aWxsIGJlIGRpc2FibGVkLlxuICAgICAqIFRoZSBpbmFjdGl2ZSB0YWIgY29tcG9uZW50IGdldHMgZGlzYWJsZWQgYW5kIGJlY29tZXMgaW5hY2Nlc3NpYmxlIG9uIHRhYiBjbGljay5cbiAgICAgKi9cbiAgICBnZXQgZGlzYWJsZUNhbGVuZGFyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hY3RpdmVUYWIgIT09ICdkYXRlJyAmJiAhdGhpcy5jYWxlbmRhci5pc0FjdGl2ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGdldCBpbnB1dFJvbGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlYWRPbmx5SW5wdXQgPyAnbGlzdGJveCcgOiAnc3BpbmJ1dHRvbic7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKlxuICAgICAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSBUaW1lU2VsZWN0b3Igd2lsbCBiZSBkaXNhYmxlZC5cbiAgICAgKiBUaGUgaW5hY3RpdmUgdGFiIGNvbXBvbmVudCBnZXRzIGRpc2FibGVkIGFuZCBiZWNvbWVzIGluYWNjZXNzaWJsZSBvbiB0YWIgY2xpY2suXG4gICAgICovXG4gICAgZ2V0IGRpc2FibGVUaW1lU2VsZWN0b3IoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFjdGl2ZVRhYiAhPT0gJ3RpbWUnICYmICF0aGlzLnRpbWVTZWxlY3Rvci5pc0FjdGl2ZTtcbiAgICB9XG4gICAgZ2V0IGFjdGl2ZVRhYkNvbXBvbmVudCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzT3Blbikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKGlzUHJlc2VudCh0aGlzLmNhbGVuZGFyKSB8fCBpc1ByZXNlbnQodGhpcy50aW1lU2VsZWN0b3IpKSkge1xuICAgICAgICAgICAgdGhpcy5jZHIuZGV0ZWN0Q2hhbmdlcygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmFjdGl2ZVRhYiA9PT0gJ2RhdGUnID8gdGhpcy5jYWxlbmRhciA6IHRoaXMudGltZVNlbGVjdG9yO1xuICAgIH1cbiAgICBnZXQgYXBwZW5kVG8oKSB7XG4gICAgICAgIGNvbnN0IHsgYXBwZW5kVG8gfSA9IHRoaXMucG9wdXBTZXR0aW5ncztcbiAgICAgICAgaWYgKCFpc1ByZXNlbnQoYXBwZW5kVG8pIHx8IGFwcGVuZFRvID09PSAncm9vdCcpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFwcGVuZFRvID09PSAnY29tcG9uZW50JyA/IHRoaXMuY29udGFpbmVyIDogYXBwZW5kVG87XG4gICAgfVxuICAgIG5nT25Jbml0KCkge1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMuYWRkKHRoaXMucGlja2VyU2VydmljZS5vbkZvY3VzXG4gICAgICAgICAgICAvLyBkZXRlY3QgcG9wdXAgY2hhbmdlcyB0byBkaXNhYmxlIHRoZSBpbmFjdGl2ZSB2aWV3IG1hcmstdXAgd2hlbiB0aGUgcG9wdXAgaXMgb3BlblxuICAgICAgICAgICAgLnBpcGUodGFwKHRoaXMuZGV0ZWN0UG9wdXBDaGFuZ2VzLmJpbmQodGhpcykpKVxuICAgICAgICAgICAgLnN1YnNjcmliZSh0aGlzLmhhbmRsZUZvY3VzLmJpbmQodGhpcykpKTtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLmFkZCh0aGlzLnBpY2tlclNlcnZpY2Uub25CbHVyLnN1YnNjcmliZSh0aGlzLmhhbmRsZUJsdXIuYmluZCh0aGlzKSkpO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMuYWRkKHRoaXMucGlja2VyU2VydmljZS5zYW1lRGF0ZVNlbGVjdGVkLnN1YnNjcmliZSh0aGlzLmhhbmRsZUNhbGVuZGFyVmFsdWVDaGFuZ2UuYmluZCh0aGlzKSkpO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMuYWRkKHRoaXMubG9jYWxpemF0aW9uLmNoYW5nZXMuc3Vic2NyaWJlKCgpID0+IHRoaXMuY2RyLm1hcmtGb3JDaGVjaygpKSk7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5hZGQodGhpcy5waWNrZXJTZXJ2aWNlLmRhdGVDb21wbGV0ZW5lc3NDaGFuZ2Uuc3Vic2NyaWJlKHRoaXMuaGFuZGxlRGF0ZUNvbXBsZXRlbmVzc0NoYW5nZS5iaW5kKHRoaXMpKSk7XG4gICAgICAgIGlmIChpc1dpbmRvd0F2YWlsYWJsZSgpKSB7XG4gICAgICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMuYWRkKHRoaXMubmdab25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IGZyb21FdmVudCh3aW5kb3csICdibHVyJykuc3Vic2NyaWJlKHRoaXMuaGFuZGxlQ2FuY2VsLmJpbmQodGhpcykpKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbmdPbkNoYW5nZXMoY2hhbmdlcykge1xuICAgICAgICBpZiAoaXNQcmVzZW50KGNoYW5nZXMubWluKSB8fCBpc1ByZXNlbnQoY2hhbmdlcy5tYXgpKSB7XG4gICAgICAgICAgICB0aGlzLnZlcmlmeU1pbk1heFJhbmdlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYW5nZXMubWluIHx8IGNoYW5nZXMubWF4IHx8IGNoYW5nZXMucmFuZ2VWYWxpZGF0aW9uIHx8IGNoYW5nZXMuZGlzYWJsZWREYXRlc1ZhbGlkYXRpb24gfHwgY2hhbmdlcy5kaXNhYmxlZERhdGVzIHx8IGNoYW5nZXMuaW5jb21wbGV0ZURhdGVWYWxpZGF0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLm1pblZhbGlkYXRlRm4gPSB0aGlzLnJhbmdlVmFsaWRhdGlvbiA/IG1pblZhbGlkYXRvcih0aGlzLm1pbikgOiBub29wO1xuICAgICAgICAgICAgdGhpcy5tYXhWYWxpZGF0ZUZuID0gdGhpcy5yYW5nZVZhbGlkYXRpb24gPyBtYXhWYWxpZGF0b3IodGhpcy5tYXgpIDogbm9vcDtcbiAgICAgICAgICAgIHRoaXMuZGlzYWJsZWREYXRlc1ZhbGlkYXRlRm4gPSB0aGlzLmRpc2FibGVkRGF0ZXNWYWxpZGF0aW9uID8gZGlzYWJsZWREYXRlc1ZhbGlkYXRvcih0aGlzLmRpc2FibGVkRGF0ZXNTZXJ2aWNlLmlzRGF0ZURpc2FibGVkKSA6IG5vb3A7XG4gICAgICAgICAgICB0aGlzLmluY29tcGxldGVWYWxpZGF0b3IgPSB0aGlzLmluY29tcGxldGVEYXRlVmFsaWRhdGlvbiA/IGluY29tcGxldGVEYXRlVmFsaWRhdG9yKCkgOiBub29wO1xuICAgICAgICAgICAgdGhpcy5vblZhbGlkYXRvckNoYW5nZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICBpZiAodGhpcy5pc09wZW4pIHtcbiAgICAgICAgICAgIHRoaXMuY2xvc2VQb3B1cCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy51bnN1YnNjcmliZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAqIElmIHRoZSBwb3B1cCBpcyBjbG9zZWQsIGZvY3VzZXMgdGhlIERhdGVUaW1lUGlja2VyIGlucHV0LlxuICAgICAqICogSWYgdGhlIHBvcHVwIGlzIG9wZW4sIHRoZSBmb2N1cyBpcyBtb3ZlZCB0byBpdHMgY29udGVudC5cbiAgICAgKi9cbiAgICBmb2N1cygpIHtcbiAgICAgICAgaWYgKHRoaXMuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pc09wZW4pIHtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlVGFiQ29tcG9uZW50LmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmlucHV0LmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQmx1cnMgdGhlIERhdGVUaW1lUGlja2VyLlxuICAgICAqL1xuICAgIGJsdXIoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzT3BlbiAmJiB0aGlzLmFjdGl2ZVRhYkNvbXBvbmVudC5pc0FjdGl2ZSkge1xuICAgICAgICAgICAgdGhpcy5hY3RpdmVUYWJDb21wb25lbnQuYmx1cigpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5pbnB1dC5ibHVyKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVG9nZ2xlcyB0aGUgdmlzaWJpbGl0eSBvZiB0aGUgcG9wdXAuIElmIHlvdSB1c2UgdGhlIGB0b2dnbGVgIG1ldGhvZCB0byBzaG93IG9yIGhpZGUgdGhlIHBvcHVwLFxuICAgICAqIHRoZSBgb3BlbmAgYW5kIGBjbG9zZWAgZXZlbnRzIGRvIG5vdCBmaXJlLlxuICAgICAqIChbbW9yZSBpbmZvcm1hdGlvbiBhbmQgZXhhbXBsZV0oeyUgc2x1ZyBvdmVydmlld19kYXRldGltZXBpY2tlciAlfSN0b2MtbWV0aG9kcy1hbmQtZXZlbnRzKSkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc2hvdyAtIFRoZSBzdGF0ZSBvZiB0aGUgcG9wdXAuXG4gICAgICovXG4gICAgdG9nZ2xlKHNob3cpIHtcbiAgICAgICAgaWYgKHRoaXMuZGlzYWJsZWQgfHwgdGhpcy5yZWFkb25seSB8fCBzaG93ID09PSB0aGlzLmlzT3Blbikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNob3VsZE9wZW4gPSBpc1ByZXNlbnQoc2hvdykgPyBzaG93IDogIXRoaXMuaXNPcGVuO1xuICAgICAgICBpZiAoc2hvdWxkT3Blbikge1xuICAgICAgICAgICAgdGhpcy5vcGVuUG9wdXAoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY2xvc2VQb3B1cCgpO1xuICAgICAgICAgICAgLy8gQ2hhbmdlcyB0aGUgdGFiIGFuZCB0aGUgY2FsZW5kYXIgb3IgY2xvY2sgaWNvbiB0byB0aGUgZGVzaWduYXRlZCBkZWZhdWx0LlxuICAgICAgICAgICAgaWYgKHRoaXMuYWN0aXZlVGFiICE9PSB0aGlzLmRlZmF1bHRUYWIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFjdGl2ZVRhYiA9IHRoaXMuZGVmYXVsdFRhYjtcbiAgICAgICAgICAgICAgICB0aGlzLmNkci5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHdyaXRlVmFsdWUodmFsdWUpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcmVnaXN0ZXJPbkNoYW5nZShmbikge1xuICAgICAgICB0aGlzLm9uQ29udHJvbENoYW5nZSA9IGZuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcmVnaXN0ZXJPblRvdWNoZWQoZm4pIHtcbiAgICAgICAgdGhpcy5vbkNvbnRyb2xUb3VjaGVkID0gZm47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBzZXREaXNhYmxlZFN0YXRlKGRpc2FibGVkKSB7XG4gICAgICAgIHRoaXMuZGlzYWJsZWQgPSBkaXNhYmxlZDtcbiAgICAgICAgdGhpcy5jZHIubWFya0ZvckNoZWNrKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICB2YWxpZGF0ZShjb250cm9sKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pblZhbGlkYXRlRm4oY29udHJvbCkgfHwgdGhpcy5tYXhWYWxpZGF0ZUZuKGNvbnRyb2wpIHx8IHRoaXMuZGlzYWJsZWREYXRlc1ZhbGlkYXRlRm4oY29udHJvbCkgfHwgdGhpcy5pbmNvbXBsZXRlVmFsaWRhdG9yKGNvbnRyb2wsIHRoaXMuaW5wdXQgJiYgdGhpcy5pbnB1dC5pc0RhdGVJbmNvbXBsZXRlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHJlZ2lzdGVyT25WYWxpZGF0b3JDaGFuZ2UoZm4pIHtcbiAgICAgICAgdGhpcy5vblZhbGlkYXRvckNoYW5nZSA9IGZuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICpcbiAgICAgKiBVc2VkIGJ5IHRoZSBUZXh0Qm94Q29udGFpbmVyIHRvIGRldGVybWluZSBpZiB0aGUgZmxvYXRpbmcgbGFiZWwgd2lsbCByZW5kZXIgaW4gdGhlIGlucHV0LlxuICAgICAqL1xuICAgIGlzRW1wdHkoKSB7XG4gICAgICAgIHJldHVybiAhaXNQcmVzZW50KHRoaXMudmFsdWUpICYmIHRoaXMuaW5wdXQuaXNFbXB0eSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgaGFuZGxlSWNvbkNsaWNrKGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLmRpc2FibGVkIHx8IHRoaXMucmVhZG9ubHkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBwcmV2ZW50cyB0aGUgZXZlbnQgZGVmYXVsdCB0byBldmFkZSBmb2N1c2luZyB0aGUgRGF0ZUlucHV0IGlucHV0IHdoZW4gcGxhY2VkIGluc2lkZSBhIGxhYmVsIChGRi9JRS9FZGdlKVxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBjb25zdCBydW5JblpvbmUgPSAhdGhpcy5pc09wZW4gfHwgaGFzT2JzZXJ2ZXJzKHRoaXMuY2xvc2UpO1xuICAgICAgICB0aGlzLnJ1bihydW5JblpvbmUsICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHNob3VsZE9wZW4gPSAhdGhpcy5pc09wZW47XG4gICAgICAgICAgICAvLyBoYW5kbGUgZm9jdXMgZmlyc3QgdG8gbWFpbnRhaW4gY29ycmVjdCBldmVudCBvcmRlciBgZm9jdXNgID0+IGBvcGVuYFxuICAgICAgICAgICAgdGhpcy5oYW5kbGVGb2N1cygpO1xuICAgICAgICAgICAgdGhpcy50b2dnbGVQb3B1cChzaG91bGRPcGVuKTtcbiAgICAgICAgICAgIHRoaXMuc3dpdGNoRm9jdXMoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBoYW5kbGVGb2N1cygpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNBY3RpdmUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzQWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgaWYgKGhhc09ic2VydmVycyh0aGlzLm9uRm9jdXMpKSB7XG4gICAgICAgICAgICB0aGlzLm5nWm9uZS5ydW4oKCkgPT4gdGhpcy5vbkZvY3VzLmVtaXQoKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGhhbmRsZUJsdXIoZXZlbnQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzQWN0aXZlIHx8IHRoaXMuZm9jdXNUYXJnZXRJbkNvbXBvbmVudChldmVudCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzQWN0aXZlID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IGlzTmdDb250cm9sVW50b3VjaGVkID0gdGhpcy5ob3N0Lm5hdGl2ZUVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKCduZy11bnRvdWNoZWQnKTtcbiAgICAgICAgY29uc3QgcnVuSW5ab25lID0gaXNOZ0NvbnRyb2xVbnRvdWNoZWQgfHwgaGFzT2JzZXJ2ZXJzKHRoaXMub25CbHVyKSB8fCAodGhpcy5pc09wZW4gJiYgaGFzT2JzZXJ2ZXJzKHRoaXMuY2xvc2UpKTtcbiAgICAgICAgdGhpcy5ydW4ocnVuSW5ab25lLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLm9uQmx1ci5lbWl0KCk7XG4gICAgICAgICAgICB0aGlzLm9uQ29udHJvbFRvdWNoZWQoKTtcbiAgICAgICAgICAgIHRoaXMudG9nZ2xlUG9wdXAoZmFsc2UpO1xuICAgICAgICAgICAgdGhpcy5jZHIubWFya0ZvckNoZWNrKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgY2hhbmdlQWN0aXZlVGFiKHRhYikge1xuICAgICAgICBpZiAoIXRoaXMuaXNPcGVuIHx8IHRoaXMuYWN0aXZlVGFiID09PSB0YWIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBwZXJzaXN0cyB0aGUgVGN1cnJlbnQgdmFsdWUgb2YgdGhlIFRpbWVTZWxlY3RvciB3aGVuIHN3aXRjaGluZyBiZXR3ZWVuIHRhYnNcbiAgICAgICAgaWYgKCFpc0VxdWFsKHRoaXMudGltZVNlbGVjdG9yLnZhbHVlLCB0aGlzLnRpbWVTZWxlY3Rvci5jdXJyZW50KSkge1xuICAgICAgICAgICAgdGhpcy50aW1lU2VsZWN0b3IuaGFuZGxlQWNjZXB0KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hY3RpdmVUYWIgPSB0YWI7XG4gICAgICAgIHRoaXMuY2RyLmRldGVjdENoYW5nZXMoKTtcbiAgICAgICAgdGhpcy5kZXRlY3RQb3B1cENoYW5nZXMoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGhhbmRsZVRhYkNoYW5nZVRyYW5zaXRpb25FbmQoZGF0ZVRpbWVTZWxlY3RvciwgZXZlbnQpIHtcbiAgICAgICAgLy8gaGFuZGxlIG9ubHkgdGhlIC5rLWRhdGV0aW1lLXNlbGVjdG9yIGVsZW1lbnQgdHJhbnNpdGlvbiwgaWdub3JlIGFueSBjaGlsZCBlbGVtZW50IHRyYW5zaXRpb25zXG4gICAgICAgIGlmIChldmVudC50YXJnZXQgIT09IGRhdGVUaW1lU2VsZWN0b3IpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFjdGl2ZVRhYkNvbXBvbmVudC5mb2N1cygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgaGFuZGxlQWNjZXB0KCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNPcGVuKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gbWVyZ2VEYXRlQW5kVGltZSh0aGlzLmNhbGVuZGFyLnZhbHVlLCB0aGlzLnRpbWVTZWxlY3Rvci5jdXJyZW50KTtcbiAgICAgICAgY29uc3QgdmFsdWVDaGFuZ2VQcmVzZW50ID0gIWlzRXF1YWwodGhpcy52YWx1ZSwgY2FuZGlkYXRlKTtcbiAgICAgICAgY29uc3QgcnVuSW5ab25lID0gdmFsdWVDaGFuZ2VQcmVzZW50IHx8IGhhc09ic2VydmVycyh0aGlzLmNsb3NlKTtcbiAgICAgICAgdGhpcy5ydW4ocnVuSW5ab25lLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZVZhbHVlQ2hhbmdlKGNhbmRpZGF0ZSk7XG4gICAgICAgICAgICB0aGlzLnRvZ2dsZVBvcHVwKGZhbHNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBoYW5kbGVDYW5jZWwoKSB7XG4gICAgICAgIGlmICghdGhpcy5pc09wZW4pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBydW5JblpvbmUgPSBoYXNPYnNlcnZlcnModGhpcy5jbG9zZSk7XG4gICAgICAgIHRoaXMucnVuKHJ1bkluWm9uZSwgKCkgPT4gdGhpcy50b2dnbGVQb3B1cChmYWxzZSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgaGFuZGxlSW5wdXRWYWx1ZUNoYW5nZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLmhhbmRsZVZhbHVlQ2hhbmdlKHZhbHVlKTtcbiAgICAgICAgaWYgKHRoaXMuaXNPcGVuKSB7XG4gICAgICAgICAgICB0aGlzLnRvZ2dsZVBvcHVwKGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgaGFuZGxlQ2FsZW5kYXJWYWx1ZUNoYW5nZSgpIHtcbiAgICAgICAgdGhpcy5zZXRUaW1lU2VsZWN0b3JNaW5NYXgodGhpcy5jYWxlbmRhci52YWx1ZSk7XG4gICAgICAgIHRoaXMuY2hhbmdlQWN0aXZlVGFiKCd0aW1lJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBoYW5kbGVLZXlEb3duKGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLmRpc2FibGVkIHx8IHRoaXMucmVhZG9ubHkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IGtleUNvZGUsIGFsdEtleSB9ID0gZXZlbnQ7XG4gICAgICAgIHN3aXRjaCAoa2V5Q29kZSkge1xuICAgICAgICAgICAgY2FzZSBhbHRLZXkgJiYgS2V5cy5BcnJvd1VwOlxuICAgICAgICAgICAgY2FzZSBLZXlzLkVzY2FwZTpcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZUNhbmNlbCgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAhdGhpcy5pc09wZW4gJiYgYWx0S2V5ICYmIEtleXMuQXJyb3dEb3duOlxuICAgICAgICAgICAgICAgIHRoaXMubmdab25lLnJ1bigoKSA9PiB0aGlzLnRvZ2dsZVBvcHVwKHRydWUpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgYWx0S2V5ICYmIEtleXMuQXJyb3dSaWdodDpcbiAgICAgICAgICAgICAgICB0aGlzLmNoYW5nZUFjdGl2ZVRhYigndGltZScpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBhbHRLZXkgJiYgS2V5cy5BcnJvd0xlZnQ6XG4gICAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VBY3RpdmVUYWIoJ2RhdGUnKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgdGhpcy5pc09wZW4gJiYgdGhpcy50aW1lU2VsZWN0b3IuaXNBY3RpdmUgJiYgaXNQcmVzZW50KHRoaXMuY2FsZW5kYXJWYWx1ZSkgJiYgS2V5cy5FbnRlcjpcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZUFjY2VwdCgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDogcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBoYW5kbGVUYWJPdXQoZXZlbnQpIHtcbiAgICAgICAgY29uc3QgeyBrZXlDb2RlLCBzaGlmdEtleSwgdGFyZ2V0IH0gPSBldmVudDtcbiAgICAgICAgLy8gaWYgbm8gZm9jdXNhYmxlIG5leHQgc2libGluZyBlbGVtZW50cyBleGlzdCBpbiB0aGUgY29udHJvbHMgc2VjdGlvbnMsIHRoZSB1c2VyIGlzIHRhYmJpbmcgb3V0IG9mIHRoZSBwb3B1cFxuICAgICAgICBjb25zdCBmb2N1c2FibGVTaWJsaW5nQXZhaWxhYmxlID0gaXNQcmVzZW50KHRhcmdldC5uZXh0RWxlbWVudFNpYmxpbmcpICYmICF0YXJnZXQubmV4dEVsZW1lbnRTaWJsaW5nLmRpc2FibGVkO1xuICAgICAgICBpZiAoa2V5Q29kZSA9PT0gS2V5cy5UYWIgJiYgIXNoaWZ0S2V5ICYmICFmb2N1c2FibGVTaWJsaW5nQXZhaWxhYmxlKSB7XG4gICAgICAgICAgICB0aGlzLmlucHV0LmZvY3VzKCk7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZUNhbmNlbCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBoYW5kbGVCYWNrVGFiT3V0KGV2ZW50KSB7XG4gICAgICAgIGNvbnN0IHsga2V5Q29kZSwgc2hpZnRLZXkgfSA9IGV2ZW50O1xuICAgICAgICBpZiAoa2V5Q29kZSA9PT0gS2V5cy5UYWIgJiYgc2hpZnRLZXkpIHtcbiAgICAgICAgICAgIHRoaXMuaW5wdXQuZm9jdXMoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICpcbiAgICAgKiBQcmV2ZW50cyB0aGUgZGl2ZXJzaW9uIG9mIHRoZSBmb2N1cyBmcm9tIHRoZSBjdXJyZW50bHkgYWN0aXZlIGVsZW1lbnQgaW4gdGhlIGNvbXBvbmVudC5cbiAgICAgKi9cbiAgICBwcmV2ZW50TW91c2VEb3duKGV2ZW50KSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICAgIHZlcmlmeVZhbHVlKHZhbHVlKSB7XG4gICAgICAgIGlmICghaXNEZXZNb2RlKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNQcmVzZW50KHZhbHVlKSAmJiAhKHZhbHVlIGluc3RhbmNlb2YgRGF0ZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlICd2YWx1ZScgc2hvdWxkIGJlIGEgdmFsaWQgSmF2YVNjcmlwdCBEYXRlIGluc3RhbmNlLiBDaGVjayAke1ZBTFVFX0RPQ19MSU5LJDR9IGZvciBwb3NzaWJsZSByZXNvbHV0aW9uLmApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZlcmlmeU1pbk1heFJhbmdlKCkge1xuICAgICAgICBpZiAoIWlzRGV2TW9kZSgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1ZhbGlkUmFuZ2UodGhpcy5taW4sIHRoaXMubWF4KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgbWF4IHZhbHVlIHNob3VsZCBiZSBiaWdnZXIgdGhhbiB0aGUgbWluLiBTZWUgJHtNSU5fTUFYX0RPQ19MSU5LfS5gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBFeHRyYWN0cyB0aGUgdGltZSBzbG90cyBhbmQgdGhlIGxpdGVyYWxzIHRoYXQgYXJlIG5vdCBwcmVjZWRlZCBieSBkYXRlIHBhcnRzXG4gICAgICogYW5kIGNvbmNhdGVuYXRlcyB0aGUgcmVzdWx0aW5nIHBhcnRzIGludG8gYSBzdHJpbmcuXG4gICAgICogSWYgdGhlIHByb3ZpZGVkIGZvcm1hdCB2YWx1ZSBkb2VzIG5vdCBjb250YWluIGFueSB0aW1lIHBhcnRzLFxuICAgICAqIHJldHVybnMgdGhlIGRlc2lnbmF0ZWQgZm9ybWF0IG9mIHRoZSBkZWZhdWx0IHBvcHVwIGNvbXBvbmVudCBvZiB0aGUgVGltZVBpY2tlci5cbiAgICAgKi9cbiAgICBnZXRUaW1lU2VsZWN0b3JGb3JtYXQoZm9ybWF0KSB7XG4gICAgICAgIGNvbnN0IHRpbWVTZWxlY3RvckZvcm1hdCA9IHRoaXMuaW50bFxuICAgICAgICAgICAgLnNwbGl0RGF0ZUZvcm1hdChmb3JtYXQpXG4gICAgICAgICAgICAuZmlsdGVyKHRoaXMudGltZUZvcm1hdFBhcnRGaWx0ZXIpXG4gICAgICAgICAgICAucmVkdWNlKChmb3JtYXQsIHBhcnQpID0+IGZvcm1hdCArPSBwYXJ0LnBhdHRlcm4sICcnKTtcbiAgICAgICAgcmV0dXJuIHRpbWVTZWxlY3RvckZvcm1hdCB8fCBERUZBVUxUX1RJTUVTRUxFQ1RPUl9GT1JNQVQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV4dHJhY3RzIHRoZSBgZGlzcGxheUZvcm1hdGAgZnJvbSB0aGUgcHJvdmlkZWQgYHN0cmluZyB8IEZvcm1hdFNldHRpbmdzYCB2YWx1ZS5cbiAgICAgKiBGYWxsYmFja3MgdG8gdGhlIGRlZmF1bHQgaW5wdXQgdmFsdWUsIGlmIGEgZmFsc3kgdmFsdWUgcGFyYW0gaXMgcGFzc2VkLlxuICAgICAqL1xuICAgIGdldERpc3BsYXlGb3JtYXQoZm9ybWF0KSB7XG4gICAgICAgIGlmICghZm9ybWF0KSB7XG4gICAgICAgICAgICByZXR1cm4gREVGQVVMVF9EQVRFSU5QVVRfRk9STUFUO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZm9ybWF0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmb3JtYXQuZGlzcGxheUZvcm1hdDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgZmlsdGVyIGV4cHJlc3Npb24gdGhhdCBmaWx0ZXJzIG91dCBhbGwgZm9ybWF0IHBhcnRzXG4gICAgICogZXhjZXB0IGZvciBgaG91cmAsIGBtaW51dGVgLCBgc2Vjb25kYCwgYGRheXBlcmlvZGAsIGFuZCBzcGVjaWZpYyBsaXRlcmFscy5cbiAgICAgKiBMaXRlcmFscyB3aWxsIGJlIGxlZnQgb25seSBpZiB0aGV5IGFyZSBub3QgcHJlY2VkZWQgYnkgZGF0ZSBwYXJ0cy5cbiAgICAgKi9cbiAgICB0aW1lRm9ybWF0UGFydEZpbHRlcihwYXJ0LCBpbmRleCwgcGFydHMpIHtcbiAgICAgICAgY29uc3QgcHJldmlvdXNQYXJ0ID0gaW5kZXggPj0gMSAmJiBwYXJ0c1tpbmRleCAtIDFdO1xuICAgICAgICBpZiAocHJldmlvdXNQYXJ0ICYmIHBhcnQudHlwZSA9PT0gJ2xpdGVyYWwnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGltZUZvcm1hdFJlZ0V4cC50ZXN0KHByZXZpb3VzUGFydC50eXBlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGltZUZvcm1hdFJlZ0V4cC50ZXN0KHBhcnQudHlwZSk7XG4gICAgfVxuICAgIHRvZ2dsZVBvcHVwKG9wZW4pIHtcbiAgICAgICAgaWYgKG9wZW4gPT09IHRoaXMuaXNPcGVuKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZXZlbnQgPSBuZXcgUHJldmVudGFibGVFdmVudCgpO1xuICAgICAgICBvcGVuID8gdGhpcy5vcGVuLmVtaXQoZXZlbnQpIDogdGhpcy5jbG9zZS5lbWl0KGV2ZW50KTtcbiAgICAgICAgaWYgKGV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50b2dnbGUob3Blbik7XG4gICAgICAgIHRoaXMuc3dpdGNoRm9jdXMoKTtcbiAgICB9XG4gICAgc3dpdGNoRm9jdXMoKSB7XG4gICAgICAgIGlmICghdGhpcy5pc0FjdGl2ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmlzT3Blbikge1xuICAgICAgICAgICAgdGhpcy5hY3RpdmVUYWJDb21wb25lbnQuZm9jdXMoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghdGhpcy50b3VjaEVuYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMuaW5wdXQuZm9jdXMoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghdGhpcy5pbnB1dC5pc0FjdGl2ZSkge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVCbHVyKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgb3BlblBvcHVwKCkge1xuICAgICAgICB0aGlzLnNldENhbGVuZGFyVmFsdWUodGhpcy52YWx1ZSk7XG4gICAgICAgIHRoaXMuc2V0VGltZVNlbGVjdG9yTWluTWF4KHRoaXMudmFsdWUpO1xuICAgICAgICBjb25zdCBkaXJlY3Rpb24gPSB0aGlzLmxvY2FsaXphdGlvbi5ydGwgPyAncmlnaHQnIDogJ2xlZnQnO1xuICAgICAgICB0aGlzLnBvcHVwUmVmID0gdGhpcy5wb3B1cFNlcnZpY2Uub3Blbih7XG4gICAgICAgICAgICBhbmNob3I6IHRoaXMud3JhcHBlcixcbiAgICAgICAgICAgIGNvbnRlbnQ6IHRoaXMucG9wdXBUZW1wbGF0ZSxcbiAgICAgICAgICAgIHBvc2l0aW9uTW9kZTogJ2Fic29sdXRlJyxcbiAgICAgICAgICAgIGFuaW1hdGU6IHRoaXMucG9wdXBTZXR0aW5ncy5hbmltYXRlLFxuICAgICAgICAgICAgYXBwZW5kVG86IHRoaXMuYXBwZW5kVG8sXG4gICAgICAgICAgICBwb3B1cENsYXNzOiBgay1kYXRldGltZS1jb250YWluZXIgJHt0aGlzLnBvcHVwU2V0dGluZ3MucG9wdXBDbGFzcyB8fCAnJ31gLFxuICAgICAgICAgICAgYW5jaG9yQWxpZ246IHsgdmVydGljYWw6ICdib3R0b20nLCBob3Jpem9udGFsOiBkaXJlY3Rpb24gfSxcbiAgICAgICAgICAgIHBvcHVwQWxpZ246IHsgdmVydGljYWw6ICd0b3AnLCBob3Jpem9udGFsOiBkaXJlY3Rpb24gfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5wb3B1cFJlZi5wb3B1cEFuY2hvclZpZXdwb3J0TGVhdmUuc3Vic2NyaWJlKCgpID0+IHRoaXMuaGFuZGxlQ2FuY2VsKCkpO1xuICAgIH1cbiAgICBjbG9zZVBvcHVwKCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNPcGVuKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wb3B1cFJlZi5jbG9zZSgpO1xuICAgICAgICB0aGlzLnBvcHVwUmVmID0gbnVsbDtcbiAgICB9XG4gICAgaGFuZGxlVmFsdWVDaGFuZ2UodmFsdWUpIHtcbiAgICAgICAgaWYgKGlzRXF1YWwodGhpcy52YWx1ZSwgdmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52YWx1ZSA9IGNsb25lRGF0ZSh2YWx1ZSk7XG4gICAgICAgIHRoaXMub25Db250cm9sQ2hhbmdlKGNsb25lRGF0ZSh2YWx1ZSkpO1xuICAgICAgICB0aGlzLnZhbHVlQ2hhbmdlLmVtaXQoY2xvbmVEYXRlKHZhbHVlKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSBmb2N1cyB0YXJnZXQgaXMgcGFydCBvZiB0aGlzIGNvbXBvbmVudCxcbiAgICAgKiB0aGF0IGlzLCB3aGV0aGVyIHRoZSBmb2N1cyB0YXJnZXQgaXMgaW5zaWRlIHRoZSBjb21wb25lbnQgd3JhcHBlciBvciBpbiB0aGUgcG9wdXAuXG4gICAgICovXG4gICAgZm9jdXNUYXJnZXRJbkNvbXBvbmVudChldmVudCkge1xuICAgICAgICBpZiAoIWlzUHJlc2VudChldmVudCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZWxhdGVkVGFyZ2V0ID0gZXZlbnQucmVsYXRlZFRhcmdldCB8fCBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAgICAgICBjb25zdCBmb2N1c0luUG9wdXAgPSBpc1ByZXNlbnQodGhpcy5wb3B1cFJlZikgJiYgdGhpcy5wb3B1cFJlZi5wb3B1cEVsZW1lbnQuY29udGFpbnMocmVsYXRlZFRhcmdldCk7XG4gICAgICAgIGNvbnN0IGZvY3VzSW5XcmFwcGVyID0gdGhpcy53cmFwcGVyLm5hdGl2ZUVsZW1lbnQuY29udGFpbnMocmVsYXRlZFRhcmdldCk7XG4gICAgICAgIHJldHVybiBmb2N1c0luUG9wdXAgfHwgZm9jdXNJbldyYXBwZXI7XG4gICAgfVxuICAgIHNldFRpbWVTZWxlY3Rvck1pbk1heChzZWxlY3RlZERhdGUpIHtcbiAgICAgICAgY29uc3QgbWluRGF0ZVNlbGVjdGVkID0gaXNQcmVzZW50KHNlbGVjdGVkRGF0ZSkgJiYgaXNFcXVhbChnZXREYXRlKHNlbGVjdGVkRGF0ZSksIGdldERhdGUodGhpcy5taW4pKTtcbiAgICAgICAgdGhpcy50aW1lU2VsZWN0b3JNaW4gPSBjbG9uZURhdGUobWluRGF0ZVNlbGVjdGVkID8gdGhpcy5taW4gOiBNSU5fVElNRSk7XG4gICAgICAgIGNvbnN0IG1heERhdGVTZWxlY3RlZCA9IGlzUHJlc2VudChzZWxlY3RlZERhdGUpICYmIGlzRXF1YWwoZ2V0RGF0ZShzZWxlY3RlZERhdGUpLCBnZXREYXRlKHRoaXMubWF4KSk7XG4gICAgICAgIHRoaXMudGltZVNlbGVjdG9yTWF4ID0gY2xvbmVEYXRlKG1heERhdGVTZWxlY3RlZCA/IHRoaXMubWF4IDogTUFYX1RJTUUpO1xuICAgIH1cbiAgICBzZXRDYWxlbmRhclZhbHVlKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGlzSW5DYWxlbmRhclJhbmdlID0gaXNQcmVzZW50KHZhbHVlKSAmJiBpc0luUmFuZ2UodmFsdWUsIHRoaXMuY2FsZW5kYXJNaW4sIHRoaXMuY2FsZW5kYXJNYXgpO1xuICAgICAgICB0aGlzLmNhbGVuZGFyVmFsdWUgPSBpc0luQ2FsZW5kYXJSYW5nZSA/IGdldERhdGUodmFsdWUpIDogbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSWYgdGhlIHBvcHVwIGlzIGF2YWlsYWJsZSwgcnVucyBhIHBvcHVwIGNoYW5nZSBkZXRlY3Rpb24uXG4gICAgICovXG4gICAgZGV0ZWN0UG9wdXBDaGFuZ2VzKCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNPcGVuKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wb3B1cFJlZi5wb3B1cC5jaGFuZ2VEZXRlY3RvclJlZi5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlcGVuZGluZyBvbiB0aGUgcHJlZGljYXRlIGBydW5JblpvbmVgIHZhbHVlIHRoYXQgaXMgcGFzc2VkLFxuICAgICAqIHJ1bnMgdGhlIHByb3ZpZGVkIGZ1bmN0aW9uIGVpdGhlciBpbiB0aGUgQW5ndWxhciBvciBpbiB0aGUgY3VycmVudCB6b25lLlxuICAgICAqL1xuICAgIHJ1bihydW5JblpvbmUsIGZuKSB7XG4gICAgICAgIGlmIChydW5JblpvbmUpIHtcbiAgICAgICAgICAgIHRoaXMubmdab25lLnJ1bigoKSA9PiBmbigpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZuKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaGFuZGxlRGF0ZUNvbXBsZXRlbmVzc0NoYW5nZSgpIHtcbiAgICAgICAgdGhpcy5jZHIubWFya0ZvckNoZWNrKCk7XG4gICAgICAgIHRoaXMubmdab25lLnJ1bigoKSA9PiB0aGlzLm9uVmFsaWRhdG9yQ2hhbmdlKCkpO1xuICAgIH1cbn07XG5fX2RlY29yYXRlKFtcbiAgICBIb3N0QmluZGluZygnY2xhc3Muay13aWRnZXQnKSxcbiAgICBIb3N0QmluZGluZygnY2xhc3Muay1kYXRldGltZXBpY2tlcicpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgRGF0ZVRpbWVQaWNrZXJDb21wb25lbnQucHJvdG90eXBlLCBcImhvc3RDbGFzc2VzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBWaWV3Q2hpbGQoJ3dyYXBwZXInLCB7IHN0YXRpYzogdHJ1ZSB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRWxlbWVudFJlZilcbl0sIERhdGVUaW1lUGlja2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ3cmFwcGVyXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBEYXRlKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0RhdGVdKVxuXSwgRGF0ZVRpbWVQaWNrZXJDb21wb25lbnQucHJvdG90eXBlLCBcInZhbHVlXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW09iamVjdF0pXG5dLCBEYXRlVGltZVBpY2tlckNvbXBvbmVudC5wcm90b3R5cGUsIFwiZm9ybWF0XCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgRGF0ZVRpbWVQaWNrZXJDb21wb25lbnQucHJvdG90eXBlLCBcInR3b0RpZ2l0WWVhck1heFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW051bWJlcl0pXG5dLCBEYXRlVGltZVBpY2tlckNvbXBvbmVudC5wcm90b3R5cGUsIFwidGFiaW5kZXhcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbT2JqZWN0XSlcbl0sIERhdGVUaW1lUGlja2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkaXNhYmxlZERhdGVzXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW09iamVjdF0pXG5dLCBEYXRlVGltZVBpY2tlckNvbXBvbmVudC5wcm90b3R5cGUsIFwicG9wdXBTZXR0aW5nc1wiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIERhdGVUaW1lUGlja2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJmb2N1c2FibGVJZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgRGF0ZVRpbWVQaWNrZXJDb21wb25lbnQucHJvdG90eXBlLCBcInRpdGxlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgRGF0ZVRpbWVQaWNrZXJDb21wb25lbnQucHJvdG90eXBlLCBcImRpc2FibGVkXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgRGF0ZVRpbWVQaWNrZXJDb21wb25lbnQucHJvdG90eXBlLCBcInJlYWRvbmx5XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgRGF0ZVRpbWVQaWNrZXJDb21wb25lbnQucHJvdG90eXBlLCBcInJlYWRPbmx5SW5wdXRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBEYXRlVGltZVBpY2tlckNvbXBvbmVudC5wcm90b3R5cGUsIFwiY2FuY2VsQnV0dG9uXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBEYXRlVGltZVBpY2tlckNvbXBvbmVudC5wcm90b3R5cGUsIFwiZm9ybWF0UGxhY2Vob2xkZXJcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIERhdGVUaW1lUGlja2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJwbGFjZWhvbGRlclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgRGF0ZVRpbWVQaWNrZXJDb21wb25lbnQucHJvdG90eXBlLCBcInN0ZXBzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBEYXRlKVxuXSwgRGF0ZVRpbWVQaWNrZXJDb21wb25lbnQucHJvdG90eXBlLCBcImZvY3VzZWREYXRlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBEYXRlVGltZVBpY2tlckNvbXBvbmVudC5wcm90b3R5cGUsIFwiY2FsZW5kYXJUeXBlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgRGF0ZVRpbWVQaWNrZXJDb21wb25lbnQucHJvdG90eXBlLCBcImFuaW1hdGVDYWxlbmRhck5hdmlnYXRpb25cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBEYXRlVGltZVBpY2tlckNvbXBvbmVudC5wcm90b3R5cGUsIFwid2Vla051bWJlclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRGF0ZSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtEYXRlXSlcbl0sIERhdGVUaW1lUGlja2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJtaW5cIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBEYXRlKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0RhdGVdKVxuXSwgRGF0ZVRpbWVQaWNrZXJDb21wb25lbnQucHJvdG90eXBlLCBcIm1heFwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBEYXRlVGltZVBpY2tlckNvbXBvbmVudC5wcm90b3R5cGUsIFwicmFuZ2VWYWxpZGF0aW9uXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgRGF0ZVRpbWVQaWNrZXJDb21wb25lbnQucHJvdG90eXBlLCBcImRpc2FibGVkRGF0ZXNWYWxpZGF0aW9uXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgRGF0ZVRpbWVQaWNrZXJDb21wb25lbnQucHJvdG90eXBlLCBcImluY29tcGxldGVEYXRlVmFsaWRhdGlvblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbl0sIERhdGVUaW1lUGlja2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ2YWx1ZUNoYW5nZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbl0sIERhdGVUaW1lUGlja2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJvcGVuXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBPdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxuXSwgRGF0ZVRpbWVQaWNrZXJDb21wb25lbnQucHJvdG90eXBlLCBcImNsb3NlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBPdXRwdXQoJ2ZvY3VzJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbl0sIERhdGVUaW1lUGlja2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJvbkZvY3VzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBPdXRwdXQoJ2JsdXInKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxuXSwgRGF0ZVRpbWVQaWNrZXJDb21wb25lbnQucHJvdG90eXBlLCBcIm9uQmx1clwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW1N0cmluZ10pXG5dLCBEYXRlVGltZVBpY2tlckNvbXBvbmVudC5wcm90b3R5cGUsIFwiZGVmYXVsdFRhYlwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIENvbnRlbnRDaGlsZChDZWxsVGVtcGxhdGVEaXJlY3RpdmUsIHsgc3RhdGljOiBmYWxzZSB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQ2VsbFRlbXBsYXRlRGlyZWN0aXZlKVxuXSwgRGF0ZVRpbWVQaWNrZXJDb21wb25lbnQucHJvdG90eXBlLCBcImNlbGxUZW1wbGF0ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgQ29udGVudENoaWxkKE1vbnRoQ2VsbFRlbXBsYXRlRGlyZWN0aXZlLCB7IHN0YXRpYzogZmFsc2UgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE1vbnRoQ2VsbFRlbXBsYXRlRGlyZWN0aXZlKVxuXSwgRGF0ZVRpbWVQaWNrZXJDb21wb25lbnQucHJvdG90eXBlLCBcIm1vbnRoQ2VsbFRlbXBsYXRlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBDb250ZW50Q2hpbGQoWWVhckNlbGxUZW1wbGF0ZURpcmVjdGl2ZSwgeyBzdGF0aWM6IGZhbHNlIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBZZWFyQ2VsbFRlbXBsYXRlRGlyZWN0aXZlKVxuXSwgRGF0ZVRpbWVQaWNrZXJDb21wb25lbnQucHJvdG90eXBlLCBcInllYXJDZWxsVGVtcGxhdGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIENvbnRlbnRDaGlsZChEZWNhZGVDZWxsVGVtcGxhdGVEaXJlY3RpdmUsIHsgc3RhdGljOiBmYWxzZSB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRGVjYWRlQ2VsbFRlbXBsYXRlRGlyZWN0aXZlKVxuXSwgRGF0ZVRpbWVQaWNrZXJDb21wb25lbnQucHJvdG90eXBlLCBcImRlY2FkZUNlbGxUZW1wbGF0ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgQ29udGVudENoaWxkKENlbnR1cnlDZWxsVGVtcGxhdGVEaXJlY3RpdmUsIHsgc3RhdGljOiBmYWxzZSB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQ2VudHVyeUNlbGxUZW1wbGF0ZURpcmVjdGl2ZSlcbl0sIERhdGVUaW1lUGlja2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJjZW50dXJ5Q2VsbFRlbXBsYXRlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBDb250ZW50Q2hpbGQoV2Vla051bWJlckNlbGxUZW1wbGF0ZURpcmVjdGl2ZSwgeyBzdGF0aWM6IGZhbHNlIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBXZWVrTnVtYmVyQ2VsbFRlbXBsYXRlRGlyZWN0aXZlKVxuXSwgRGF0ZVRpbWVQaWNrZXJDb21wb25lbnQucHJvdG90eXBlLCBcIndlZWtOdW1iZXJUZW1wbGF0ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgQ29udGVudENoaWxkKEhlYWRlclRpdGxlVGVtcGxhdGVEaXJlY3RpdmUsIHsgc3RhdGljOiBmYWxzZSB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgSGVhZGVyVGl0bGVUZW1wbGF0ZURpcmVjdGl2ZSlcbl0sIERhdGVUaW1lUGlja2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJoZWFkZXJUaXRsZVRlbXBsYXRlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBWaWV3Q2hpbGQoJ2NvbnRhaW5lcicsIHsgcmVhZDogVmlld0NvbnRhaW5lclJlZiwgc3RhdGljOiB0cnVlIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBWaWV3Q29udGFpbmVyUmVmKVxuXSwgRGF0ZVRpbWVQaWNrZXJDb21wb25lbnQucHJvdG90eXBlLCBcImNvbnRhaW5lclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgVmlld0NoaWxkKCdwb3B1cFRlbXBsYXRlJywgeyByZWFkOiBUZW1wbGF0ZVJlZiwgc3RhdGljOiB0cnVlIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBUZW1wbGF0ZVJlZilcbl0sIERhdGVUaW1lUGlja2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJwb3B1cFRlbXBsYXRlXCIsIHZvaWQgMCk7XG5EYXRlVGltZVBpY2tlckNvbXBvbmVudCA9IERhdGVUaW1lUGlja2VyQ29tcG9uZW50XzEgPSBfX2RlY29yYXRlKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLWRhdGV0aW1lcGlja2VyJyxcbiAgICAgICAgZXhwb3J0QXM6ICdrZW5kby1kYXRldGltZXBpY2tlcicsXG4gICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgICAgIFBpY2tlclNlcnZpY2UsXG4gICAgICAgICAgICBMb2NhbGl6YXRpb25TZXJ2aWNlLFxuICAgICAgICAgICAgRGlzYWJsZWREYXRlc1NlcnZpY2UsXG4gICAgICAgICAgICB7IHByb3ZpZGU6IEwxME5fUFJFRklYLCB1c2VWYWx1ZTogJ2tlbmRvLmRhdGV0aW1lcGlja2VyJyB9LFxuICAgICAgICAgICAgeyBwcm92aWRlOiBOR19WQUxVRV9BQ0NFU1NPUiwgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gRGF0ZVRpbWVQaWNrZXJDb21wb25lbnRfMSksIG11bHRpOiB0cnVlIH0sXG4gICAgICAgICAgICB7IHByb3ZpZGU6IE5HX1ZBTElEQVRPUlMsIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IERhdGVUaW1lUGlja2VyQ29tcG9uZW50XzEpLCBtdWx0aTogdHJ1ZSB9LFxuICAgICAgICAgICAgeyBwcm92aWRlOiBLZW5kb0lucHV0LCB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBEYXRlVGltZVBpY2tlckNvbXBvbmVudF8xKSB9XG4gICAgICAgIF0sXG4gICAgICAgIHRlbXBsYXRlOiBgXG4gICAgICAgIDxuZy1jb250YWluZXJcbiAgICAgICAgICAgIGtlbmRvRGF0ZVRpbWVQaWNrZXJMb2NhbGl6ZWRNZXNzYWdlc1xuXG4gICAgICAgICAgICBpMThuLWRhdGVUYWI9XCJrZW5kby5kYXRldGltZXBpY2tlci5kYXRlVGFifFRoZSBEYXRlIHRhYiB0ZXh0IGluIHRoZSBkYXRldGltZXBpY2tlciBwb3B1cCBoZWFkZXJcIlxuICAgICAgICAgICAgZGF0ZVRhYj1cIkRhdGVcIlxuXG4gICAgICAgICAgICBpMThuLWRhdGVUYWJMYWJlbD1cImtlbmRvLmRhdGV0aW1lcGlja2VyLmRhdGVUYWJMYWJlbHxUaGUgbGFiZWwgZm9yIHRoZSBEYXRlIHRhYiBpbiB0aGUgZGF0ZXRpbWVwaWNrZXIgcG9wdXAgaGVhZGVyXCJcbiAgICAgICAgICAgIGRhdGVUYWJMYWJlbD1cIkRhdGUgdGFiXCJcblxuICAgICAgICAgICAgaTE4bi10aW1lVGFiPVwia2VuZG8uZGF0ZXRpbWVwaWNrZXIudGltZVRhYnxUaGUgVGltZSB0YWIgdGV4dCBpbiB0aGUgZGF0ZXRpbWVwaWNrZXIgcG9wdXAgaGVhZGVyXCJcbiAgICAgICAgICAgIHRpbWVUYWI9XCJUaW1lXCJcblxuICAgICAgICAgICAgaTE4bi10aW1lVGFiTGFiZWw9XCJrZW5kby5kYXRldGltZXBpY2tlci50aW1lVGFiTGFiZWx8VGhlIGxhYmVsIGZvciB0aGUgVGltZSB0YWIgaW4gdGhlIGRhdGV0aW1lcGlja2VyIHBvcHVwIGhlYWRlclwiXG4gICAgICAgICAgICB0aW1lVGFiTGFiZWw9XCJUaW1lIHRhYlwiXG5cbiAgICAgICAgICAgIGkxOG4tdG9nZ2xlPVwia2VuZG8uZGF0ZXRpbWVwaWNrZXIudG9nZ2xlfFRoZSB0aXRsZSBvZiB0aGUgdG9nZ2xlIGJ1dHRvbiBpbiB0aGUgZGF0ZXRpbWVwaWNrZXIgY29tcG9uZW50XCJcbiAgICAgICAgICAgIHRvZ2dsZT1cIlRvZ2dsZSBwb3B1cFwiXG5cbiAgICAgICAgICAgIGkxOG4tYWNjZXB0PVwia2VuZG8uZGF0ZXRpbWVwaWNrZXIuYWNjZXB0fFRoZSBBY2NlcHQgYnV0dG9uIHRleHQgaW4gdGhlIGRhdGV0aW1lcGlja2VyIGNvbXBvbmVudFwiXG4gICAgICAgICAgICBhY2NlcHQ9XCJTZXRcIlxuXG4gICAgICAgICAgICBpMThuLWFjY2VwdExhYmVsPVwia2VuZG8uZGF0ZXRpbWVwaWNrZXIuYWNjZXB0TGFiZWx8VGhlIGxhYmVsIGZvciB0aGUgQWNjZXB0IGJ1dHRvbiBpbiB0aGUgZGF0ZXRpbWVwaWNrZXIgY29tcG9uZW50XCJcbiAgICAgICAgICAgIGFjY2VwdExhYmVsPVwiU2V0XCJcblxuICAgICAgICAgICAgaTE4bi1jYW5jZWw9XCJrZW5kby5kYXRldGltZXBpY2tlci5jYW5jZWx8VGhlIENhbmNlbCBidXR0b24gdGV4dCBpbiB0aGUgZGF0ZXRpbWVwaWNrZXIgY29tcG9uZW50XCJcbiAgICAgICAgICAgIGNhbmNlbD1cIkNhbmNlbFwiXG5cbiAgICAgICAgICAgIGkxOG4tY2FuY2VsTGFiZWw9XCJrZW5kby5kYXRldGltZXBpY2tlci5jYW5jZWxMYWJlbHxUaGUgbGFiZWwgZm9yIHRoZSBDYW5jZWwgYnV0dG9uIGluIHRoZSBkYXRldGltZXBpY2tlciBjb21wb25lbnRcIlxuICAgICAgICAgICAgY2FuY2VsTGFiZWw9XCJDYW5jZWxcIlxuXG4gICAgICAgICAgICBpMThuLW5vdz1cImtlbmRvLmRhdGV0aW1lcGlja2VyLm5vd3xUaGUgTm93IGJ1dHRvbiB0ZXh0IGluIHRoZSB0aW1lcGlja2VyIGNvbXBvbmVudFwiXG4gICAgICAgICAgICBub3c9XCJOT1dcIlxuXG4gICAgICAgICAgICBpMThuLW5vd0xhYmVsPVwia2VuZG8uZGF0ZXRpbWVwaWNrZXIubm93TGFiZWx8VGhlIGxhYmVsIGZvciB0aGUgTm93IGJ1dHRvbiBpbiB0aGUgdGltZXBpY2tlciBjb21wb25lbnRcIlxuICAgICAgICAgICAgbm93TGFiZWw9XCJTZWxlY3Qgbm93XCJcblxuICAgICAgICAgICAgaTE4bi10b2RheT1cImtlbmRvLmRhdGV0aW1lcGlja2VyLnRvZGF5fFRoZSBsYWJlbCBmb3IgdGhlIHRvZGF5IGJ1dHRvbiBpbiB0aGUgY2FsZW5kYXIgaGVhZGVyXCJcbiAgICAgICAgICAgIHRvZGF5PVwiVG9kYXlcIlxuXG4gICAgICAgICAgICBpMThuLXByZXZCdXR0b25UaXRsZT1cImtlbmRvLmRhdGV0aW1lcGlja2VyLnByZXZCdXR0b25UaXRsZXxUaGUgdGl0bGUgb2YgdGhlIHByZXZpb3VzIGJ1dHRvbiBpbiB0aGUgQ2xhc3NpYyBjYWxlbmRhclwiXG4gICAgICAgICAgICBwcmV2QnV0dG9uVGl0bGU9XCJOYXZpZ2F0ZSB0byBwcmV2aW91cyB2aWV3XCJcblxuICAgICAgICAgICAgaTE4bi1uZXh0QnV0dG9uVGl0bGU9XCJrZW5kby5kYXRldGltZXBpY2tlci5uZXh0QnV0dG9uVGl0bGV8VGhlIHRpdGxlIG9mIHRoZSBuZXh0IGJ1dHRvbiBpbiB0aGUgQ2xhc3NpYyBjYWxlbmRhclwiXG4gICAgICAgICAgICBuZXh0QnV0dG9uVGl0bGU9XCJOYXZpZ2F0ZSB0byBuZXh0IHZpZXdcIlxuICAgICAgICA+XG4gICAgICAgIDwvbmctY29udGFpbmVyPlxuXG4gICAgICAgIDxzcGFuXG4gICAgICAgICAgICAjd3JhcHBlclxuICAgICAgICAgICAgY2xhc3M9XCJrLXBpY2tlci13cmFwXCJcbiAgICAgICAgICAgIFtjbGFzcy5rLXN0YXRlLWRpc2FibGVkXT1cImRpc2FibGVkXCJcbiAgICAgICAgPlxuICAgICAgICAgICAgPGtlbmRvLWRhdGVpbnB1dFxuICAgICAgICAgICAgICAgIFt2YWx1ZV09XCJ2YWx1ZVwiXG4gICAgICAgICAgICAgICAgW2Zvcm1hdF09XCJmb3JtYXRcIlxuICAgICAgICAgICAgICAgIFt0d29EaWdpdFllYXJNYXhdPVwidHdvRGlnaXRZZWFyTWF4XCJcbiAgICAgICAgICAgICAgICBbbWluXT1cIm1pblwiXG4gICAgICAgICAgICAgICAgW21heF09XCJtYXhcIlxuICAgICAgICAgICAgICAgIFtpbmNvbXBsZXRlRGF0ZVZhbGlkYXRpb25dPVwiaW5jb21wbGV0ZURhdGVWYWxpZGF0aW9uXCJcbiAgICAgICAgICAgICAgICBbZm9ybWF0UGxhY2Vob2xkZXJdPVwiZm9ybWF0UGxhY2Vob2xkZXJcIlxuICAgICAgICAgICAgICAgIFtwbGFjZWhvbGRlcl09XCJwbGFjZWhvbGRlclwiXG4gICAgICAgICAgICAgICAgW2Rpc2FibGVkXT1cImRpc2FibGVkXCJcbiAgICAgICAgICAgICAgICBbcmVhZG9ubHldPVwicmVhZG9ubHkgfHwgcmVhZE9ubHlJbnB1dFwiXG4gICAgICAgICAgICAgICAgW3JvbGVdPVwiaW5wdXRSb2xlXCJcbiAgICAgICAgICAgICAgICBbYXJpYVJlYWRPbmx5XT1cInJlYWRvbmx5XCJcbiAgICAgICAgICAgICAgICBbc3RlcHNdPVwic3RlcHNcIlxuICAgICAgICAgICAgICAgIFt0YWJpbmRleF09XCJ0YWJpbmRleFwiXG4gICAgICAgICAgICAgICAgW3RpdGxlXT1cInRpdGxlXCJcbiAgICAgICAgICAgICAgICBbZm9jdXNhYmxlSWRdPVwiZm9jdXNhYmxlSWRcIlxuICAgICAgICAgICAgICAgIFtoYXNQb3B1cF09XCJ0cnVlXCJcbiAgICAgICAgICAgICAgICBbaXNQb3B1cE9wZW5dPVwiaXNPcGVuXCJcbiAgICAgICAgICAgICAgICAodmFsdWVDaGFuZ2UpPVwiaGFuZGxlSW5wdXRWYWx1ZUNoYW5nZSgkZXZlbnQpXCJcbiAgICAgICAgICAgICAgICBba2VuZG9FdmVudHNPdXRzaWRlQW5ndWxhcl09XCJ7XG4gICAgICAgICAgICAgICAgICAgIGtleWRvd246IGhhbmRsZUtleURvd25cbiAgICAgICAgICAgICAgICB9XCJcbiAgICAgICAgICAgICAgICBbc2NvcGVdPVwidGhpc1wiXG4gICAgICAgICAgICA+XG4gICAgICAgICAgICA8L2tlbmRvLWRhdGVpbnB1dD5cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiay1zZWxlY3RcIlxuICAgICAgICAgICAgICAgIFthdHRyLnRpdGxlXT1cImxvY2FsaXphdGlvbi5nZXQoJ3RvZ2dsZScpXCJcbiAgICAgICAgICAgICAgICBbYXR0ci5hcmlhLWxhYmVsXT1cImxvY2FsaXphdGlvbi5nZXQoJ3RvZ2dsZScpXCJcbiAgICAgICAgICAgICAgICBba2VuZG9FdmVudHNPdXRzaWRlQW5ndWxhcl09XCJ7XG4gICAgICAgICAgICAgICAgICAgIG1vdXNlZG93bjogcHJldmVudE1vdXNlRG93bixcbiAgICAgICAgICAgICAgICAgICAgY2xpY2s6IGhhbmRsZUljb25DbGlja1xuICAgICAgICAgICAgICAgIH1cIlxuICAgICAgICAgICAgICAgIFtzY29wZV09XCJ0aGlzXCJcbiAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImstbGluayBrLWxpbmstZGF0ZVwiPlxuICAgICAgICAgICAgICAgICAgICA8c3BhblxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M9XCJrLWljb25cIlxuICAgICAgICAgICAgICAgICAgICAgICAgW2NsYXNzLmstaS1jYWxlbmRhcl09XCJhY3RpdmVUYWIgPT09ICdkYXRlJ1wiXG4gICAgICAgICAgICAgICAgICAgICAgICBbY2xhc3Muay1pLWNsb2NrXT1cImFjdGl2ZVRhYiA9PT0gJ3RpbWUnXCJcbiAgICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICA8L3NwYW4+XG5cbiAgICAgICAgPG5nLWNvbnRhaW5lciAjY29udGFpbmVyPjwvbmctY29udGFpbmVyPlxuXG4gICAgICAgIDxuZy10ZW1wbGF0ZSAjcG9wdXBUZW1wbGF0ZT5cbiAgICAgICAgICAgIDxkaXZcbiAgICAgICAgICAgICAgICBjbGFzcz1cImstZGF0ZXRpbWUtd3JhcCBrLXt7YWN0aXZlVGFifX0tdGFiXCJcbiAgICAgICAgICAgICAgICBba2VuZG9FdmVudHNPdXRzaWRlQW5ndWxhcl09XCJ7XG4gICAgICAgICAgICAgICAgICAgIG1vdXNlZG93bjogcHJldmVudE1vdXNlRG93bixcbiAgICAgICAgICAgICAgICAgICAga2V5ZG93bjogaGFuZGxlS2V5RG93blxuICAgICAgICAgICAgICAgIH1cIlxuICAgICAgICAgICAgICAgIFtzY29wZV09XCJ0aGlzXCJcbiAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiay1kYXRldGltZS1idXR0b25ncm91cFwiXG4gICAgICAgICAgICAgICAgICAgIFtrZW5kb0V2ZW50c091dHNpZGVBbmd1bGFyXT1cIntcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvY3VzaW46IGhhbmRsZUZvY3VzLFxuICAgICAgICAgICAgICAgICAgICAgICAgZm9jdXNvdXQ6IGhhbmRsZUJsdXJcbiAgICAgICAgICAgICAgICAgICAgfVwiXG4gICAgICAgICAgICAgICAgICAgIFtzY29wZV09XCJ0aGlzXCJcbiAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJrLWJ1dHRvbi1ncm91cCBrLWJ1dHRvbi1ncm91cC1zdHJldGNoZWRcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzcz1cImstYnV0dG9uIGstZGF0ZS10YWJcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtjbGFzcy5rLXN0YXRlLWFjdGl2ZV09XCJhY3RpdmVUYWIgPT09ICdkYXRlJ1wiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW2F0dHIudGl0bGVdPVwibG9jYWxpemF0aW9uLmdldCgnZGF0ZVRhYkxhYmVsJylcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFthdHRyLmFyaWEtbGFiZWxdPVwibG9jYWxpemF0aW9uLmdldCgnZGF0ZVRhYkxhYmVsJylcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtrZW5kb0V2ZW50c091dHNpZGVBbmd1bGFyXT1cIntcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xpY2s6IGNoYW5nZUFjdGl2ZVRhYi5iaW5kKHRoaXMsICdkYXRlJyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleWRvd246IGhhbmRsZUJhY2tUYWJPdXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbc2NvcGVdPVwidGhpc1wiXG4gICAgICAgICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge3tsb2NhbGl6YXRpb24uZ2V0KCdkYXRlVGFiJyl9fVxuICAgICAgICAgICAgICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M9XCJrLWJ1dHRvbiBrLXRpbWUtdGFiXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbY2xhc3Muay1zdGF0ZS1hY3RpdmVdPVwiYWN0aXZlVGFiID09PSAndGltZSdcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFthdHRyLnRpdGxlXT1cImxvY2FsaXphdGlvbi5nZXQoJ3RpbWVUYWJMYWJlbCcpXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbYXR0ci5hcmlhLWxhYmVsXT1cImxvY2FsaXphdGlvbi5nZXQoJ3RpbWVUYWJMYWJlbCcpXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBba2VuZG9FdmVudHNPdXRzaWRlQW5ndWxhcl09XCJ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaWNrOiBjaGFuZ2VBY3RpdmVUYWIuYmluZCh0aGlzLCAndGltZScpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVwiXG4gICAgICAgICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge3tsb2NhbGl6YXRpb24uZ2V0KCd0aW1lVGFiJyl9fVxuICAgICAgICAgICAgICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIDxkaXZcbiAgICAgICAgICAgICAgICAgICAgI2RhdGVUaW1lU2VsZWN0b3JcbiAgICAgICAgICAgICAgICAgICAgY2xhc3M9XCJrLWRhdGV0aW1lLXNlbGVjdG9yXCJcbiAgICAgICAgICAgICAgICAgICAgW3N0eWxlLnRyYW5zaXRpb25dPVwidGFiU3dpdGNoVHJhbnNpdGlvblwiXG4gICAgICAgICAgICAgICAgICAgIFtrZW5kb0V2ZW50c091dHNpZGVBbmd1bGFyXT1cIntcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zaXRpb25lbmQ6IGhhbmRsZVRhYkNoYW5nZVRyYW5zaXRpb25FbmQuYmluZCh0aGlzLCBkYXRlVGltZVNlbGVjdG9yKVxuICAgICAgICAgICAgICAgICAgICB9XCJcbiAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJrLWRhdGV0aW1lLWNhbGVuZGFyLXdyYXBcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxrZW5kby1jYWxlbmRhclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFsodmFsdWUpXT1cImNhbGVuZGFyVmFsdWVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFt0eXBlXT1cImNhbGVuZGFyVHlwZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW21pbl09XCJjYWxlbmRhck1pblwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW21heF09XCJjYWxlbmRhck1heFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW2ZvY3VzZWREYXRlXT1cImZvY3VzZWREYXRlXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbd2Vla051bWJlcl09XCJ3ZWVrTnVtYmVyXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbbmF2aWdhdGlvbl09XCJmYWxzZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW2FuaW1hdGVOYXZpZ2F0aW9uXT1cImFuaW1hdGVDYWxlbmRhck5hdmlnYXRpb25cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtjZWxsVGVtcGxhdGVdPVwiY2VsbFRlbXBsYXRlXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbbW9udGhDZWxsVGVtcGxhdGVdPVwibW9udGhDZWxsVGVtcGxhdGVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFt5ZWFyQ2VsbFRlbXBsYXRlXT1cInllYXJDZWxsVGVtcGxhdGVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtkZWNhZGVDZWxsVGVtcGxhdGVdPVwiZGVjYWRlQ2VsbFRlbXBsYXRlXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbY2VudHVyeUNlbGxUZW1wbGF0ZV09XCJjZW50dXJ5Q2VsbFRlbXBsYXRlXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbd2Vla051bWJlclRlbXBsYXRlXT1cIndlZWtOdW1iZXJUZW1wbGF0ZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW2hlYWRlclRpdGxlVGVtcGxhdGVdPVwiaGVhZGVyVGl0bGVUZW1wbGF0ZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW2Rpc2FibGVkXT1cImRpc2FibGVDYWxlbmRhclwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW2Rpc2FibGVkRGF0ZXNdPVwiZGlzYWJsZWREYXRlc1wiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKHZhbHVlQ2hhbmdlKT1cImhhbmRsZUNhbGVuZGFyVmFsdWVDaGFuZ2UoKVwiXG4gICAgICAgICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGtlbmRvLWNhbGVuZGFyLW1lc3NhZ2VzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFt0b2RheV09XCJsb2NhbGl6YXRpb24uZ2V0KCd0b2RheScpXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW3ByZXZCdXR0b25UaXRsZV09XCJsb2NhbGl6YXRpb24uZ2V0KCdwcmV2QnV0dG9uVGl0bGUnKVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtuZXh0QnV0dG9uVGl0bGVdPVwibG9jYWxpemF0aW9uLmdldCgnbmV4dEJ1dHRvblRpdGxlJylcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2tlbmRvLWNhbGVuZGFyLW1lc3NhZ2VzPlxuICAgICAgICAgICAgICAgICAgICAgICAgPC9rZW5kby1jYWxlbmRhcj5cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJrLWRhdGV0aW1lLXRpbWUtd3JhcFwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGtlbmRvLXRpbWVzZWxlY3RvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFt2YWx1ZV09XCJ2YWx1ZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW2Zvcm1hdF09XCJ0aW1lU2VsZWN0b3JGb3JtYXRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFttaW5dPVwidGltZVNlbGVjdG9yTWluXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbbWF4XT1cInRpbWVTZWxlY3Rvck1heFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW3NldEJ1dHRvbl09XCJmYWxzZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW2NhbmNlbEJ1dHRvbl09XCJmYWxzZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW3N0ZXBzXT1cInN0ZXBzXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbZGlzYWJsZWRdPVwiZGlzYWJsZVRpbWVTZWxlY3RvclwiXG4gICAgICAgICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGtlbmRvLXRpbWVzZWxlY3Rvci1tZXNzYWdlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbbm93XT1cImxvY2FsaXphdGlvbi5nZXQoJ25vdycpXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW25vd0xhYmVsXT1cImxvY2FsaXphdGlvbi5nZXQoJ25vd0xhYmVsJylcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2tlbmRvLXRpbWVzZWxlY3Rvci1tZXNzYWdlcz5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwva2VuZG8tdGltZXNlbGVjdG9yPlxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzPVwiay1kYXRldGltZS1mb290ZXIgay1hY3Rpb24tYnV0dG9ucyBrLWFjdGlvbnMgay1oc3RhY2sgay1qdXN0aWZ5LWNvbnRlbnQtc3RyZXRjaFwiXG4gICAgICAgICAgICAgICAgICAgIFtrZW5kb0V2ZW50c091dHNpZGVBbmd1bGFyXT1cIntcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleWRvd246IGhhbmRsZVRhYk91dCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvY3VzaW46IGhhbmRsZUZvY3VzLFxuICAgICAgICAgICAgICAgICAgICAgICAgZm9jdXNvdXQ6IGhhbmRsZUJsdXJcbiAgICAgICAgICAgICAgICAgICAgfVwiXG4gICAgICAgICAgICAgICAgICAgIFtzY29wZV09XCJ0aGlzXCJcbiAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgIDxidXR0b25cbiAgICAgICAgICAgICAgICAgICAgICAgICpuZ0lmPVwiY2FuY2VsQnV0dG9uXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU9XCJidXR0b25cIlxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M9XCJrLWJ1dHRvbiBrLXRpbWUtY2FuY2VsXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIFthdHRyLnRpdGxlXT1cImxvY2FsaXphdGlvbi5nZXQoJ2NhbmNlbExhYmVsJylcIlxuICAgICAgICAgICAgICAgICAgICAgICAgW2F0dHIuYXJpYS1sYWJlbF09XCJsb2NhbGl6YXRpb24uZ2V0KCdjYW5jZWxMYWJlbCcpXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIFtrZW5kb0V2ZW50c091dHNpZGVBbmd1bGFyXT1cIntcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGljazogaGFuZGxlQ2FuY2VsXG4gICAgICAgICAgICAgICAgICAgICAgICB9XCJcbiAgICAgICAgICAgICAgICAgICAgICAgIFtzY29wZV09XCJ0aGlzXCJcbiAgICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICAgICAge3tsb2NhbGl6YXRpb24uZ2V0KCdjYW5jZWwnKX19XG4gICAgICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzPVwiay10aW1lLWFjY2VwdCBrLWJ1dHRvbiBrLXByaW1hcnlcIlxuICAgICAgICAgICAgICAgICAgICAgICAgW2F0dHIudGl0bGVdPVwibG9jYWxpemF0aW9uLmdldCgnYWNjZXB0TGFiZWwnKVwiXG4gICAgICAgICAgICAgICAgICAgICAgICBbYXR0ci5hcmlhLWxhYmVsXT1cImxvY2FsaXphdGlvbi5nZXQoJ2FjY2VwdExhYmVsJylcIlxuICAgICAgICAgICAgICAgICAgICAgICAgW2Rpc2FibGVkXT1cIiFjYWxlbmRhclZhbHVlXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIFtrZW5kb0V2ZW50c091dHNpZGVBbmd1bGFyXT1cIntcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGljazogaGFuZGxlQWNjZXB0XG4gICAgICAgICAgICAgICAgICAgICAgICB9XCJcbiAgICAgICAgICAgICAgICAgICAgICAgIFtzY29wZV09XCJ0aGlzXCJcbiAgICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICAgICAge3tsb2NhbGl6YXRpb24uZ2V0KCdhY2NlcHQnKX19XG4gICAgICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvbmctdGVtcGxhdGU+XG4gICAgYFxuICAgIH0pLFxuICAgIF9fcGFyYW0oNiwgSW5qZWN0KFRPVUNIX0VOQUJMRUQpKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW1BvcHVwU2VydmljZSxcbiAgICAgICAgSW50bFNlcnZpY2UsXG4gICAgICAgIENoYW5nZURldGVjdG9yUmVmLFxuICAgICAgICBQaWNrZXJTZXJ2aWNlLFxuICAgICAgICBOZ1pvbmUsXG4gICAgICAgIEVsZW1lbnRSZWYsIEJvb2xlYW4sIExvY2FsaXphdGlvblNlcnZpY2UsXG4gICAgICAgIERpc2FibGVkRGF0ZXNTZXJ2aWNlLFxuICAgICAgICBSZW5kZXJlcjJdKVxuXSwgRGF0ZVRpbWVQaWNrZXJDb21wb25lbnQpO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xubGV0IFdlZWtOYW1lc1NlcnZpY2UgPSBjbGFzcyBXZWVrTmFtZXNTZXJ2aWNlIHtcbiAgICBjb25zdHJ1Y3RvcihpbnRsKSB7XG4gICAgICAgIHRoaXMuaW50bCA9IGludGw7XG4gICAgfVxuICAgIGdldFdlZWtOYW1lcyhpbmNsdWRlV2Vla051bWJlciA9IGZhbHNlKSB7XG4gICAgICAgIGNvbnN0IHdlZWtOYW1lcyA9IHNoaWZ0V2Vla05hbWVzKHRoaXMuaW50bC5kYXRlRm9ybWF0TmFtZXMoeyBuYW1lVHlwZTogJ3Nob3J0JywgdHlwZTogJ2RheXMnIH0pLCB0aGlzLmludGwuZmlyc3REYXkoKSk7XG4gICAgICAgIHJldHVybiBpbmNsdWRlV2Vla051bWJlciA/IFsnJ10uY29uY2F0KHdlZWtOYW1lcykgOiB3ZWVrTmFtZXM7XG4gICAgfVxufTtcbldlZWtOYW1lc1NlcnZpY2UgPSBfX2RlY29yYXRlKFtcbiAgICBJbmplY3RhYmxlKCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtJbnRsU2VydmljZV0pXG5dLCBXZWVrTmFtZXNTZXJ2aWNlKTtcblxuY29uc3QgREVGQVVMVF9WSUVXU19MRU5HVEggPSAyO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmxldCBIb3Jpem9udGFsVmlld0xpc3RDb21wb25lbnQgPSBjbGFzcyBIb3Jpem9udGFsVmlld0xpc3RDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGJ1cywgaW50bCwgd2Vla1NlcnZpY2UsIGNkciwgZWxlbWVudCwgcmVuZGVyZXIpIHtcbiAgICAgICAgdGhpcy5idXMgPSBidXM7XG4gICAgICAgIHRoaXMuaW50bCA9IGludGw7XG4gICAgICAgIHRoaXMud2Vla1NlcnZpY2UgPSB3ZWVrU2VydmljZTtcbiAgICAgICAgdGhpcy5jZHIgPSBjZHI7XG4gICAgICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgICAgICAgdGhpcy5hY3RpdmVWaWV3ID0gQ2FsZW5kYXJWaWV3RW51bS5tb250aDtcbiAgICAgICAgdGhpcy5pc0FjdGl2ZSA9IHRydWU7XG4gICAgICAgIHRoaXMubWluID0gbmV3IERhdGUoTUlOX0RBVEUpO1xuICAgICAgICB0aGlzLm1heCA9IG5ldyBEYXRlKE1BWF9EQVRFKTtcbiAgICAgICAgdGhpcy5zZWxlY3RlZERhdGVzID0gW107XG4gICAgICAgIHRoaXMudmlld3MgPSBERUZBVUxUX1ZJRVdTX0xFTkdUSDtcbiAgICAgICAgdGhpcy5zaG93Vmlld0hlYWRlciA9IGZhbHNlO1xuICAgICAgICB0aGlzLmFuaW1hdGVOYXZpZ2F0aW9uID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY2VsbENsaWNrID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLndlZWtOdW1iZXJDZWxsQ2xpY2sgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuY2VsbEVudGVyID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLmNlbGxMZWF2ZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5hY3RpdmVEYXRlQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLmdldENvbXBvbmVudENsYXNzID0gdHJ1ZTtcbiAgICAgICAgdGhpcy53ZWVrTmFtZXMgPSBbXTtcbiAgICAgICAgdGhpcy5kYXRlcyA9IFtdO1xuICAgICAgICB0aGlzLmludGxTdWJzY3JpcHRpb24gPSB0aGlzLmludGwuY2hhbmdlcy5zdWJzY3JpYmUodGhpcy5pbnRsQ2hhbmdlLmJpbmQodGhpcykpO1xuICAgIH1cbiAgICBnZXQgd2Vla051bWJlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2hvd1dlZWtOdW1iZXJzICYmIHRoaXMuaXNNb250aFZpZXcoKTtcbiAgICB9XG4gICAgc2V0IHdlZWtOdW1iZXIoc2hvd1dlZWtOdW1iZXJzKSB7XG4gICAgICAgIHRoaXMuc2hvd1dlZWtOdW1iZXJzID0gc2hvd1dlZWtOdW1iZXJzO1xuICAgIH1cbiAgICBnZXQgZ2V0Q29tcG9uZW50TW9udGhDbGFzcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWN0aXZlVmlldyA9PT0gQ2FsZW5kYXJWaWV3RW51bS5tb250aDtcbiAgICB9XG4gICAgZ2V0IGdldENvbXBvbmVudFllYXJDbGFzcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWN0aXZlVmlldyA9PT0gQ2FsZW5kYXJWaWV3RW51bS55ZWFyO1xuICAgIH1cbiAgICBnZXQgZ2V0Q29tcG9uZW50RGVjYWRlQ2xhc3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFjdGl2ZVZpZXcgPT09IENhbGVuZGFyVmlld0VudW0uZGVjYWRlO1xuICAgIH1cbiAgICBnZXQgZ2V0Q29tcG9uZW50Q2VudHVyeUNsYXNzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hY3RpdmVWaWV3ID09PSBDYWxlbmRhclZpZXdFbnVtLmNlbnR1cnk7XG4gICAgfVxuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXMpIHtcbiAgICAgICAgdGhpcy5pbml0U2VydmljZSgpO1xuICAgICAgICBpZiAodGhpcy53ZWVrTmFtZXMubGVuZ3RoID09PSAwIHx8IGNoYW5nZXMud2Vla051bWJlcikge1xuICAgICAgICAgICAgdGhpcy53ZWVrTmFtZXMgPSB0aGlzLndlZWtTZXJ2aWNlLmdldFdlZWtOYW1lcyh0aGlzLndlZWtOdW1iZXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5zZXJ2aWNlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52aWV3cyA9IHRoaXMudmlld3MgfHwgREVGQVVMVF9WSUVXU19MRU5HVEg7XG4gICAgICAgIGNvbnN0IGZvY3VzZWREYXRlID0gdGhpcy5mb2N1c2VkRGF0ZTtcbiAgICAgICAgY29uc3Qgdmlld0RhdGUgPSB0aGlzLmNsYW1wRGF0ZSh0aGlzLnNlcnZpY2Uudmlld0RhdGUoZm9jdXNlZERhdGUsIHRoaXMubWF4LCB0aGlzLnZpZXdzKSk7XG4gICAgICAgIHRoaXMuc2tpcCA9IHRoaXMuc2VydmljZS5za2lwKHZpZXdEYXRlLCB0aGlzLm1pbik7XG4gICAgICAgIHRoaXMudG90YWwgPSB0aGlzLnNlcnZpY2UudG90YWwodGhpcy5taW4sIHRoaXMubWF4KTtcbiAgICAgICAgY29uc3QgYWN0aXZlVmlld0NoYW5nZWQgPSBoYXNDaGFuZ2UoY2hhbmdlcywgJ2FjdGl2ZVZpZXcnKTtcbiAgICAgICAgY29uc3Qgdmlld3NIYXNDaGFuZ2VkID0gdGhpcy52aWV3cyA+IDAgJiYgaGFzQ2hhbmdlKGNoYW5nZXMsICd2aWV3cycpO1xuICAgICAgICBpZiAoYWN0aXZlVmlld0NoYW5nZWQgfHwgIXRoaXMuaXNJbkRhdGVzKGZvY3VzZWREYXRlKSB8fCB2aWV3c0hhc0NoYW5nZWQgfHwgIXRoaXMuYWN0aXZlRGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5kYXRlcyA9IHRoaXMuc2VydmljZS5kYXRlc0xpc3Qodmlld0RhdGUsIHRoaXMuZ2V0VGFrZSh0aGlzLnNraXApKTtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlRGF0ZSA9IGNsb25lRGF0ZSh0aGlzLmRhdGVzWzBdKTtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlRGF0ZUNoYW5nZS5lbWl0KHRoaXMuYWN0aXZlRGF0ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbmdBZnRlclZpZXdJbml0KCkge1xuICAgICAgICAvLyBtYWtlIHRoZSBjYWxlbmRhciBsb29rIHRoZSBzYW1lIGluIHRoZSBkaWZmZXJlbnQgYnJvd3NlcnNcbiAgICAgICAgLy8gd2hpY2ggYWxzbyBzbW9vdGhlbnMgdGhlIG5hdmlnYXRpb24gYW5pbWF0aW9uXG4gICAgICAgIGlmICh0aGlzLnZpZXdzID09PSAxKSB7XG4gICAgICAgICAgICB0aGlzLnNldFRhYmxlTWluV2lkdGgoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5pbnRsU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxuICAgIGluaXRTZXJ2aWNlKCkge1xuICAgICAgICB0aGlzLnNlcnZpY2UgPSB0aGlzLmJ1cy5zZXJ2aWNlKHRoaXMuYWN0aXZlVmlldyk7XG4gICAgfVxuICAgIGlzTW9udGhWaWV3KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hY3RpdmVWaWV3ID09PSBDYWxlbmRhclZpZXdFbnVtLm1vbnRoO1xuICAgIH1cbiAgICBnZXRDYXB0aW9uVGl0bGUoZGF0ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXJ2aWNlLnRpdGxlKGRhdGUpO1xuICAgIH1cbiAgICBnZXRDYXB0aW9uQ2xhc3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzTW9udGhWaWV3KCkgPyAnay1tb250aC1oZWFkZXInIDogJ2stbWV0YS1oZWFkZXInO1xuICAgIH1cbiAgICBhbmltYXRlVmlldyhhY3Rpb24pIHtcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgIGNvbnN0IHRhYmxlID0gY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoJ3RhYmxlJyk7XG4gICAgICAgIC8vIHRoZSB3aG9sZSB3aWR0aCBleGNsdWRpbmcgcGFkZGluZy9tYXJnaW5cbiAgICAgICAgY29uc3QgaW5pdGlhbENvbnRhaW5lcldpZHRoID0gcGFyc2VGbG9hdChnZXRDb21wdXRlZFN0eWxlKGNvbnRhaW5lcikud2lkdGgpO1xuICAgICAgICAvLyB0YWJsZSB3aWR0aFxuICAgICAgICBjb25zdCB0YWJsZVdpZHRoID0gcGFyc2VGbG9hdChnZXRDb21wdXRlZFN0eWxlKHRhYmxlKS53aWR0aCk7XG4gICAgICAgIHRoaXMucmVuZGVyZXIuc2V0U3R5bGUoY29udGFpbmVyLCAnd2lkdGgnLCBgJHtpbml0aWFsQ29udGFpbmVyV2lkdGh9cHhgKTtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRTdHlsZShjb250YWluZXIsICdvdmVyZmxvdycsICd2aXNpYmxlJyk7XG4gICAgICAgIC8vIGluaXRpYWxpemUgYW4gYWRkaXRpb25hbCB2aWV3IGZvciB0aGUgYW5pbWF0aW9uXG4gICAgICAgIGlmIChhY3Rpb24gPT09IEFjdGlvbi5OZXh0Vmlldykge1xuICAgICAgICAgICAgLy8gYW5pbWF0aW5nIEFjdGlvbi5OZXh0VmlldyByZXF1aXJlcyBhZGRpbmcgYW4gYWRkaXRpb25hbCB2aWV3IGJlZm9yZSB0aGUgcmVuZGVyZWQgdmlld3NcbiAgICAgICAgICAgIHRoaXMubmV4dEFuaW1hdGlvbkRhdGUgPSBjbG9uZURhdGUodGhpcy5kYXRlc1swXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBhbmltYXRpbmcgQWN0aW9uLlByZXZWaWV3IHJlcXVpcmVzIGFkZGluZyBhbiBhZGRpdGlvbmFsIHZpZXcgYWZ0ZXIgdGhlIHJlbmRlcmVkIHZpZXdzXG4gICAgICAgICAgICB0aGlzLnByZXZBbmltYXRpb25EYXRlID0gY2xvbmVEYXRlKHRoaXMuZGF0ZXNbdGhpcy5kYXRlcy5sZW5ndGggLSAxXSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcnVuIGNkciB0byByZW5kZXIgdGhlIGFkZGl0aW9uYWwgdmlld1xuICAgICAgICB0aGlzLmNkci5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgICAgIGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yQWxsKCd0YWJsZScpLmZvckVhY2godGFibGUgPT4ge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRTdHlsZSh0YWJsZSwgJ3dpZHRoJywgYCR7dGFibGVXaWR0aH1weGApO1xuICAgICAgICAgICAgaWYgKHRoaXMudmlld3MgPT09IDEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnNldFN0eWxlKHRhYmxlLCAnbWluLXdpZHRoJywgYCR7aW5pdGlhbENvbnRhaW5lcldpZHRofXB4YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyB3ZSBhbHdheXMgc2xpZGUgYnkgdGhlIHdpZHRoIG9mIDEgdGFibGVcbiAgICAgICAgLy8gY3Jvc3MtYnJvd3NlciBjb21wYXRpYmlsaXR5IGlzIGVuc3VyZWQgYnkgbWVhc3VyaW5nIHRoZSBjbGllbnQgcmVjdGFuZ2xlIGFuZCBzdWJzdHJhY3RpbmcgdGhlIGdhcFxuICAgICAgICBjb25zdCB0YWJSZWN0ID0gdGFibGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lckdhcCA9IHBhcnNlRmxvYXQoZ2V0Q29tcHV0ZWRTdHlsZShjb250YWluZXIpLmNvbHVtbkdhcCk7XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gYWN0aW9uID09PSBBY3Rpb24uTmV4dFZpZXcgPyAndHJhbnNsYXRlWCgwKScgOiBgdHJhbnNsYXRlWCgtJHt0YWJSZWN0LndpZHRoICsgY29udGFpbmVyR2FwfXB4KWA7XG4gICAgICAgIGNvbnN0IGVuZCA9IGFjdGlvbiA9PT0gQWN0aW9uLk5leHRWaWV3ID8gYHRyYW5zbGF0ZVgoLSR7dGFiUmVjdC53aWR0aCArIGNvbnRhaW5lckdhcH1weClgIDogJ3RyYW5zbGF0ZVgoMCknO1xuICAgICAgICBpZiAoIXRoaXMuYW5pbWF0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmFuaW1hdGlvbiA9IGNvbnRhaW5lci5hbmltYXRlKFtcbiAgICAgICAgICAgICAgICB7IHRyYW5zZm9ybTogc3RhcnQgfSxcbiAgICAgICAgICAgICAgICB7IHRyYW5zZm9ybTogZW5kIH1cbiAgICAgICAgICAgIF0sIHtcbiAgICAgICAgICAgICAgICBkdXJhdGlvbjogNTAwLFxuICAgICAgICAgICAgICAgIGVhc2luZzogJ2Vhc2Utb3V0J1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmFuaW1hdGlvbi5vbmNhbmNlbCA9IHRoaXMuYW5pbWF0aW9uLm9uZmluaXNoID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIGNsZWFyIGFsbCBpbmxpbmUgc3R5bGVzXG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5yZW1vdmVTdHlsZShjb250YWluZXIsICd3aWR0aCcpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZXIucmVtb3ZlU3R5bGUoY29udGFpbmVyLCAnb3ZlcmZsb3cnKTtcbiAgICAgICAgICAgICAgICBjb250YWluZXIucXVlcnlTZWxlY3RvckFsbCgndGFibGUnKS5mb3JFYWNoKHRhYmxlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5yZW1vdmVTdHlsZSh0YWJsZSwgJ3dpZHRoJyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgLy8gY2xlYXIgdGhlIGFuaW1hdGlvbiBhbmQgdGhlIGFuaW1hdGlvbiB2aWV3XG4gICAgICAgICAgICAgICAgdGhpcy5hbmltYXRpb24gPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMubmV4dEFuaW1hdGlvbkRhdGUgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMucHJldkFuaW1hdGlvbkRhdGUgPSBudWxsO1xuICAgICAgICAgICAgICAgIC8vIHJ1biBjZHIgdG8gcmVtb3ZlIGFkZGl0aW9uYWwgYW5pbWF0aW9uIHZpZXcgZnJvbSB0aGUgbWFya3VwXG4gICAgICAgICAgICAgICAgdGhpcy5jZHIuZGV0ZWN0Q2hhbmdlcygpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGlmIGFuaW1hdGlvbiBpcyBhbHJlYWR5IHJ1bm5pbmcsIGNhbmNlbCBpdCBhbmQgc2hvdyB0aGUgZW5kIG5hdmlnYXRpb24gcmVzdWx0IG9uIG11bHRpcGxlIHByZXYvbmV4dCBidXR0b24gY2xpY2tzXG4gICAgICAgICAgICB0aGlzLmFuaW1hdGlvbi5jYW5jZWwoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBuYXZpZ2F0ZShhY3Rpb24pIHtcbiAgICAgICAgaWYgKHRoaXMuYW5pbWF0ZU5hdmlnYXRpb24gJiYgaXNEb2N1bWVudEF2YWlsYWJsZSgpICYmIGlzUHJlc2VudCh0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudC5hbmltYXRlKSkge1xuICAgICAgICAgICAgdGhpcy5hbmltYXRlVmlldyhhY3Rpb24pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHRoaXMubW92ZShhY3Rpb24pO1xuICAgICAgICBjb25zdCBsaXN0ID0gdGhpcy5zZXJ2aWNlLmRhdGVzTGlzdChjYW5kaWRhdGUsIHRoaXMuZ2V0VGFrZSh0aGlzLnNraXApKTtcbiAgICAgICAgaWYgKHRoaXMuaXNMaXN0SW5SYW5nZShsaXN0KSkge1xuICAgICAgICAgICAgdGhpcy5kYXRlcyA9IGxpc3Q7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hY3RpdmVEYXRlID0gY2xvbmVEYXRlKHRoaXMuZGF0ZXNbMF0pO1xuICAgICAgICB0aGlzLmZvY3VzZWREYXRlID0gY2xvbmVEYXRlKGNhbmRpZGF0ZSk7XG4gICAgICAgIHRoaXMuY2RyLm1hcmtGb3JDaGVjaygpO1xuICAgICAgICB0aGlzLmFjdGl2ZURhdGVDaGFuZ2UuZW1pdCh0aGlzLmFjdGl2ZURhdGUpO1xuICAgICAgICByZXR1cm4gY2xvbmVEYXRlKGNhbmRpZGF0ZSk7XG4gICAgfVxuICAgIGNhbk5hdmlnYXRlKGFjdGlvbikge1xuICAgICAgICBpZiAoIXRoaXMuc2VydmljZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmlzTGlzdEluUmFuZ2UodGhpcy5zZXJ2aWNlLmRhdGVzTGlzdCh0aGlzLm1vdmUoYWN0aW9uKSwgdGhpcy5nZXRUYWtlKHRoaXMuc2tpcCkpKTtcbiAgICB9XG4gICAgc2V0VGFibGVNaW5XaWR0aCgpIHtcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgIGNvbnN0IHRhYmxlID0gY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoJ3RhYmxlJyk7XG4gICAgICAgIGlmICh0YWJsZSkge1xuICAgICAgICAgICAgY29uc3QgY29udGFpbmVyV2lkdGggPSBwYXJzZUZsb2F0KGdldENvbXB1dGVkU3R5bGUoY29udGFpbmVyKS53aWR0aCk7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnNldFN0eWxlKHRhYmxlLCAnbWluLXdpZHRoJywgYCR7Y29udGFpbmVyV2lkdGh9cHhgKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpbnRsQ2hhbmdlKCkge1xuICAgICAgICB0aGlzLndlZWtOYW1lcyA9IHRoaXMud2Vla1NlcnZpY2UuZ2V0V2Vla05hbWVzKHRoaXMud2Vla051bWJlcik7XG4gICAgICAgIHRoaXMuY2RyLm1hcmtGb3JDaGVjaygpO1xuICAgIH1cbiAgICBjbGFtcERhdGUodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGRhdGVJblJhbmdlKHZhbHVlLCB0aGlzLm1pbiwgdGhpcy5tYXgpO1xuICAgIH1cbiAgICBtb3ZlKGFjdGlvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXJ2aWNlLm1vdmUodGhpcy5kYXRlc1swXSB8fCB0aGlzLmZvY3VzZWREYXRlLCBhY3Rpb24pO1xuICAgIH1cbiAgICBpc0xpc3RJblJhbmdlKGxpc3QpIHtcbiAgICAgICAgY29uc3QgbG93ZXJCb3VuZCA9IHRoaXMuc2VydmljZS5iZWdpbm5pbmdPZlBlcmlvZCh0aGlzLm1pbik7XG4gICAgICAgIGNvbnN0IHVwcGVyQm91bmQgPSB0aGlzLnNlcnZpY2UuYmVnaW5uaW5nT2ZQZXJpb2QodGhpcy5zZXJ2aWNlLmFkZFRvRGF0ZSh0aGlzLm1heCwgMSkpO1xuICAgICAgICByZXR1cm4gbG93ZXJCb3VuZCA8PSBsaXN0WzBdICYmIGxpc3RbbGlzdC5sZW5ndGggLSAxXSA8IHVwcGVyQm91bmQ7XG4gICAgfVxuICAgIGlzSW5EYXRlcyh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXJ2aWNlLmlzSW5BcnJheSh2YWx1ZSwgdGhpcy5kYXRlcyk7XG4gICAgfVxuICAgIGdldFRha2Uoc2tpcCkge1xuICAgICAgICByZXR1cm4gTWF0aC5taW4odGhpcy50b3RhbCAtIHNraXAsIHRoaXMudmlld3MpO1xuICAgIH1cbn07XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBUZW1wbGF0ZVJlZilcbl0sIEhvcml6b250YWxWaWV3TGlzdENvbXBvbmVudC5wcm90b3R5cGUsIFwiY2VsbFRlbXBsYXRlUmVmXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBUZW1wbGF0ZVJlZilcbl0sIEhvcml6b250YWxWaWV3TGlzdENvbXBvbmVudC5wcm90b3R5cGUsIFwid2Vla051bWJlclRlbXBsYXRlUmVmXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBIb3Jpem9udGFsVmlld0xpc3RDb21wb25lbnQucHJvdG90eXBlLCBcImFjdGl2ZVJhbmdlRW5kXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBIb3Jpem9udGFsVmlld0xpc3RDb21wb25lbnQucHJvdG90eXBlLCBcImFjdGl2ZVZpZXdcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIEhvcml6b250YWxWaWV3TGlzdENvbXBvbmVudC5wcm90b3R5cGUsIFwiY2VsbFVJRFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRGF0ZSlcbl0sIEhvcml6b250YWxWaWV3TGlzdENvbXBvbmVudC5wcm90b3R5cGUsIFwiZm9jdXNlZERhdGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBIb3Jpem9udGFsVmlld0xpc3RDb21wb25lbnQucHJvdG90eXBlLCBcImlzQWN0aXZlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBEYXRlKVxuXSwgSG9yaXpvbnRhbFZpZXdMaXN0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJtaW5cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIERhdGUpXG5dLCBIb3Jpem9udGFsVmlld0xpc3RDb21wb25lbnQucHJvdG90eXBlLCBcIm1heFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgSG9yaXpvbnRhbFZpZXdMaXN0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJzZWxlY3Rpb25SYW5nZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpXG5dLCBIb3Jpem9udGFsVmlld0xpc3RDb21wb25lbnQucHJvdG90eXBlLCBcInNlbGVjdGVkRGF0ZXNcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIEhvcml6b250YWxWaWV3TGlzdENvbXBvbmVudC5wcm90b3R5cGUsIFwidmlld3NcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBIb3Jpem9udGFsVmlld0xpc3RDb21wb25lbnQucHJvdG90eXBlLCBcInNob3dWaWV3SGVhZGVyXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgSG9yaXpvbnRhbFZpZXdMaXN0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJhbmltYXRlTmF2aWdhdGlvblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtCb29sZWFuXSlcbl0sIEhvcml6b250YWxWaWV3TGlzdENvbXBvbmVudC5wcm90b3R5cGUsIFwid2Vla051bWJlclwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIE91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXG5dLCBIb3Jpem9udGFsVmlld0xpc3RDb21wb25lbnQucHJvdG90eXBlLCBcImNlbGxDbGlja1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbl0sIEhvcml6b250YWxWaWV3TGlzdENvbXBvbmVudC5wcm90b3R5cGUsIFwid2Vla051bWJlckNlbGxDbGlja1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbl0sIEhvcml6b250YWxWaWV3TGlzdENvbXBvbmVudC5wcm90b3R5cGUsIFwiY2VsbEVudGVyXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBPdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxuXSwgSG9yaXpvbnRhbFZpZXdMaXN0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJjZWxsTGVhdmVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIE91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXG5dLCBIb3Jpem9udGFsVmlld0xpc3RDb21wb25lbnQucHJvdG90eXBlLCBcImFjdGl2ZURhdGVDaGFuZ2VcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RCaW5kaW5nKFwiY2xhc3Muay1jYWxlbmRhci12aWV3XCIpLFxuICAgIEhvc3RCaW5kaW5nKFwiY2xhc3Muay1qdXN0aWZ5LWFsaWduLXN0YXJ0XCIpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgSG9yaXpvbnRhbFZpZXdMaXN0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJnZXRDb21wb25lbnRDbGFzc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSG9zdEJpbmRpbmcoXCJjbGFzcy5rLWNhbGVuZGFyLW1vbnRodmlld1wiKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgSG9yaXpvbnRhbFZpZXdMaXN0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJnZXRDb21wb25lbnRNb250aENsYXNzXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSG9zdEJpbmRpbmcoXCJjbGFzcy5rLWNhbGVuZGFyLXllYXJ2aWV3XCIpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBIb3Jpem9udGFsVmlld0xpc3RDb21wb25lbnQucHJvdG90eXBlLCBcImdldENvbXBvbmVudFllYXJDbGFzc1wiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RCaW5kaW5nKFwiY2xhc3Muay1jYWxlbmRhci1kZWNhZGV2aWV3XCIpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBIb3Jpem9udGFsVmlld0xpc3RDb21wb25lbnQucHJvdG90eXBlLCBcImdldENvbXBvbmVudERlY2FkZUNsYXNzXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSG9zdEJpbmRpbmcoXCJjbGFzcy5rLWNhbGVuZGFyLWNlbnR1cnl2aWV3XCIpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBIb3Jpem9udGFsVmlld0xpc3RDb21wb25lbnQucHJvdG90eXBlLCBcImdldENvbXBvbmVudENlbnR1cnlDbGFzc1wiLCBudWxsKTtcbkhvcml6b250YWxWaWV3TGlzdENvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLWNhbGVuZGFyLWhvcml6b250YWwnLFxuICAgICAgICB0ZW1wbGF0ZTogYFxuICAgICAgICA8bmctdGVtcGxhdGUgI3RhYmxlVGVtcGxhdGUgbGV0LWRhdGU9XCJkYXRlXCIgbGV0LWNsYXNzPVwiY2xhc3NOYW1lXCI+XG4gICAgICAgICAgICA8dGFibGVcbiAgICAgICAgICAgICAgICBjbGFzcz1cImstY29udGVudCBrLWNhbGVuZGFyLWNvbnRlbnQgay1jYWxlbmRhci10YWJsZVwiXG4gICAgICAgICAgICAgICAgW25nQ2xhc3NdPVwiY2xhc3NcIlxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIDxjYXB0aW9uICpuZ0lmPVwic2hvd1ZpZXdIZWFkZXJcIiBbbmdDbGFzc109XCJnZXRDYXB0aW9uQ2xhc3MoKVwiPnt7IGdldENhcHRpb25UaXRsZShkYXRlKSB9fTwvY2FwdGlvbj5cbiAgICAgICAgICAgICAgICA8dGhlYWQgKm5nSWY9XCJpc01vbnRoVmlldygpXCIgY2xhc3M9XCJrLWNhbGVuZGFyLXRoZWFkXCI+XG4gICAgICAgICAgICAgICAgICAgIDx0ciBjbGFzcz1cImstY2FsZW5kYXItdHJcIiByb2xlPVwicm93XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8dGggKm5nRm9yPVwibGV0IG5hbWUgb2Ygd2Vla05hbWVzXCIgY2xhc3M9XCJrLWNhbGVuZGFyLXRoXCI+e3tuYW1lfX08L3RoPlxuICAgICAgICAgICAgICAgICAgICA8L3RyPlxuICAgICAgICAgICAgICAgIDwvdGhlYWQ+XG4gICAgICAgICAgICAgICAgPHRib2R5XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzPVwiay1jYWxlbmRhci10Ym9keVwiXG4gICAgICAgICAgICAgICAgICAgIGtlbmRvQ2FsZW5kYXJWaWV3XG4gICAgICAgICAgICAgICAgICAgIHJvbGU9XCJyb3dncm91cFwiXG4gICAgICAgICAgICAgICAgICAgIGRpcmVjdGlvbj1cImhvcml6b250YWxcIlxuICAgICAgICAgICAgICAgICAgICBbYWN0aXZlVmlld109XCJhY3RpdmVWaWV3XCJcbiAgICAgICAgICAgICAgICAgICAgW2lzQWN0aXZlXT1cImlzQWN0aXZlXCJcbiAgICAgICAgICAgICAgICAgICAgW21pbl09XCJtaW5cIlxuICAgICAgICAgICAgICAgICAgICBbbWF4XT1cIm1heFwiXG4gICAgICAgICAgICAgICAgICAgIFtjZWxsVUlEXT1cImNlbGxVSURcIlxuICAgICAgICAgICAgICAgICAgICBbZm9jdXNlZERhdGVdPVwiZm9jdXNlZERhdGVcIlxuICAgICAgICAgICAgICAgICAgICBbc2VsZWN0ZWREYXRlc109XCJzZWxlY3RlZERhdGVzXCJcbiAgICAgICAgICAgICAgICAgICAgW3NlbGVjdGlvblJhbmdlXT1cInNlbGVjdGlvblJhbmdlXCJcbiAgICAgICAgICAgICAgICAgICAgW2FjdGl2ZVJhbmdlRW5kXT1cImFjdGl2ZVJhbmdlRW5kXCJcbiAgICAgICAgICAgICAgICAgICAgW3dlZWtOdW1iZXJdPVwid2Vla051bWJlclwiXG4gICAgICAgICAgICAgICAgICAgIFt0ZW1wbGF0ZVJlZl09XCJjZWxsVGVtcGxhdGVSZWZcIlxuICAgICAgICAgICAgICAgICAgICBbd2Vla051bWJlclRlbXBsYXRlUmVmXT1cIndlZWtOdW1iZXJUZW1wbGF0ZVJlZlwiXG4gICAgICAgICAgICAgICAgICAgIFt2aWV3RGF0ZV09XCJkYXRlXCJcbiAgICAgICAgICAgICAgICAgICAgKGNlbGxDbGljayk9XCJjZWxsQ2xpY2suZW1pdCgkZXZlbnQpXCJcbiAgICAgICAgICAgICAgICAgICAgKHdlZWtOdW1iZXJDZWxsQ2xpY2spPVwid2Vla051bWJlckNlbGxDbGljay5lbWl0KCRldmVudClcIlxuICAgICAgICAgICAgICAgICAgICAoY2VsbEVudGVyKT1cImNlbGxFbnRlci5lbWl0KCRldmVudClcIlxuICAgICAgICAgICAgICAgICAgICAoY2VsbExlYXZlKT1cImNlbGxMZWF2ZS5lbWl0KCRldmVudClcIlxuICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICA8L3Rib2R5PlxuICAgICAgICAgICAgPC90YWJsZT5cbiAgICAgICAgPC9uZy10ZW1wbGF0ZT5cblxuICAgICAgICA8IS0tIFdoZW4gTmV4dCBpcyBjbGlja2VkIGEgcGxhY2Vob2xkZXIgdGFibGUgaXMgcmVuZGVyZWQgYmVmb3JlIHRoZSBNYWluIFRhYmxlIC0tPlxuICAgICAgICA8bmctdGVtcGxhdGVcbiAgICAgICAgICAgICpuZ0lmPVwibmV4dEFuaW1hdGlvbkRhdGVcIlxuICAgICAgICAgICAgW25nVGVtcGxhdGVPdXRsZXRdPVwidGFibGVUZW1wbGF0ZVwiXG4gICAgICAgICAgICBbbmdUZW1wbGF0ZU91dGxldENvbnRleHRdPVwie1xuICAgICAgICAgICAgICAgIGRhdGU6IG5leHRBbmltYXRpb25EYXRlLFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogJ2stcG9pbnRlci1ldmVudHMtbm9uZSdcbiAgICAgICAgICAgIH1cIlxuICAgICAgICA+XG4gICAgICAgIDwvbmctdGVtcGxhdGU+XG5cbiAgICAgICAgPG5nLXRlbXBsYXRlXG4gICAgICAgICAgICAqa0Zvcj1cImxldCBkYXRlIG9mIGRhdGVzXCJcbiAgICAgICAgICAgIFtuZ1RlbXBsYXRlT3V0bGV0XT1cInRhYmxlVGVtcGxhdGVcIlxuICAgICAgICAgICAgW25nVGVtcGxhdGVPdXRsZXRDb250ZXh0XT1cIntcbiAgICAgICAgICAgICAgICBkYXRlOiBkYXRlXG4gICAgICAgICAgICB9XCJcbiAgICAgICAgPlxuICAgICAgICA8L25nLXRlbXBsYXRlPlxuXG4gICAgICAgIDwhLS0gV2hlbiBQcmV2IGlzIGNsaWNrZWQgYSBwbGFjZWhvbGRlciB0YWJsZSBpcyByZW5kZXJlZCBhZnRlciB0aGUgTWFpbiBUYWJsZSAtLT5cbiAgICAgICAgPG5nLXRlbXBsYXRlXG4gICAgICAgICAgICAqbmdJZj1cInByZXZBbmltYXRpb25EYXRlXCJcbiAgICAgICAgICAgIFtuZ1RlbXBsYXRlT3V0bGV0XT1cInRhYmxlVGVtcGxhdGVcIlxuICAgICAgICAgICAgW25nVGVtcGxhdGVPdXRsZXRDb250ZXh0XT1cIntcbiAgICAgICAgICAgICAgICBkYXRlOiBwcmV2QW5pbWF0aW9uRGF0ZSxcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6ICdrLXBvaW50ZXItZXZlbnRzLW5vbmUnXG4gICAgICAgICAgICB9XCJcbiAgICAgICAgPlxuICAgICAgICA8L25nLXRlbXBsYXRlPlxuICAgIGBcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0J1c1ZpZXdTZXJ2aWNlLFxuICAgICAgICBJbnRsU2VydmljZSxcbiAgICAgICAgV2Vla05hbWVzU2VydmljZSxcbiAgICAgICAgQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gICAgICAgIEVsZW1lbnRSZWYsXG4gICAgICAgIFJlbmRlcmVyMl0pXG5dLCBIb3Jpem9udGFsVmlld0xpc3RDb21wb25lbnQpO1xuXG5jb25zdCBub29wJDIgPSAoKSA9PiBudWxsO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGRpc2FibGVkRGF0ZXNSYW5nZVZhbGlkYXRvciA9IChpc0RhdGVEaXNhYmxlZCkgPT4ge1xuICAgIGlmICghaXNQcmVzZW50KGlzRGF0ZURpc2FibGVkKSkge1xuICAgICAgICByZXR1cm4gbm9vcCQyO1xuICAgIH1cbiAgICByZXR1cm4gKHNlbGVjdGVkUmFuZ2UpID0+IHtcbiAgICAgICAgY29uc3QgaXNSYW5nZUNvbXBsZXRlID0gaXNQcmVzZW50KHNlbGVjdGVkUmFuZ2UpICYmIGlzUHJlc2VudChzZWxlY3RlZFJhbmdlLnN0YXJ0KSAmJiBpc1ByZXNlbnQoc2VsZWN0ZWRSYW5nZS5lbmQpO1xuICAgICAgICBpZiAoIWlzUmFuZ2VDb21wbGV0ZSB8fCBzZWxlY3RlZFJhbmdlLnN0YXJ0ID4gc2VsZWN0ZWRSYW5nZS5lbmQpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRpc2FibGVkRGF0ZXMgPSBkaXNhYmxlZERhdGVzSW5SYW5nZShzZWxlY3RlZFJhbmdlLnN0YXJ0LCBzZWxlY3RlZFJhbmdlLmVuZCwgaXNEYXRlRGlzYWJsZWQpO1xuICAgICAgICBjb25zdCBlcnJvciA9IHtcbiAgICAgICAgICAgIGRpc2FibGVkRGF0ZXNJblJhbmdlOiBkaXNhYmxlZERhdGVzXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBkaXNhYmxlZERhdGVzLmxlbmd0aCA/IGVycm9yIDogbnVsbDtcbiAgICB9O1xufTtcblxuY29uc3QgQk9UVE9NX1ZJRVdfRE9DX0xJTkskMSA9ICdodHRwOi8vd3d3LnRlbGVyaWsuY29tL2tlbmRvLWFuZ3VsYXItdWkvY29tcG9uZW50cy9kYXRlaW5wdXRzL2FwaS9DYWxlbmRhckNvbXBvbmVudC8jdG9jLWJvdHRvbXZpZXcnO1xuY29uc3QgVE9QX1ZJRVdfRE9DX0xJTkskMSA9ICdodHRwOi8vd3d3LnRlbGVyaWsuY29tL2tlbmRvLWFuZ3VsYXItdWkvY29tcG9uZW50cy9kYXRlaW5wdXRzL2FwaS9DYWxlbmRhckNvbXBvbmVudC8jdG9jLXRvcHZpZXcnO1xuY29uc3QgTUlOX0RPQ19MSU5LJDMgPSAnaHR0cDovL3d3dy50ZWxlcmlrLmNvbS9rZW5kby1hbmd1bGFyLXVpL2NvbXBvbmVudHMvZGF0ZWlucHV0cy9hcGkvQ2FsZW5kYXJDb21wb25lbnQvI3RvYy1taW4nO1xuY29uc3QgTUFYX0RPQ19MSU5LJDMgPSAnaHR0cDovL3d3dy50ZWxlcmlrLmNvbS9rZW5kby1hbmd1bGFyLXVpL2NvbXBvbmVudHMvZGF0ZWlucHV0cy9hcGkvQ2FsZW5kYXJDb21wb25lbnQvI3RvYy1tYXgnO1xuY29uc3QgVkFMVUVfRE9DX0xJTkskNSA9ICdodHRwOi8vd3d3LnRlbGVyaWsuY29tL2tlbmRvLWFuZ3VsYXItdWkvY29tcG9uZW50cy9kYXRlaW5wdXRzL2NhbGVuZGFyLyN0b2MtdXNpbmctd2l0aC1qc29uJztcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBSQU5HRV9DQUxFTkRBUl9WQUxVRV9BQ0NFU1NPUiA9IHtcbiAgICBtdWx0aTogdHJ1ZSxcbiAgICBwcm92aWRlOiBOR19WQUxVRV9BQ0NFU1NPUixcbiAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBNdWx0aVZpZXdDYWxlbmRhckNvbXBvbmVudCkgLy90c2xpbnQ6ZGlzYWJsZS1saW5lOm5vLXVzZS1iZWZvcmUtZGVjbGFyZVxufTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBSQU5HRV9DQUxFTkRBUl9SQU5HRV9WQUxJREFUT1JTID0ge1xuICAgIG11bHRpOiB0cnVlLFxuICAgIHByb3ZpZGU6IE5HX1ZBTElEQVRPUlMsXG4gICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gTXVsdGlWaWV3Q2FsZW5kYXJDb21wb25lbnQpIC8vdHNsaW50OmRpc2FibGUtbGluZTpuby11c2UtYmVmb3JlLWRlY2xhcmVcbn07XG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIEtlbmRvIFVJIE11bHRpVmlld0NhbGVuZGFyIGNvbXBvbmVudCBmb3IgQW5ndWxhci5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIF9AQ29tcG9uZW50KHtcbiAqIHNlbGVjdG9yOiAnbXktYXBwJyxcbiAqIHRlbXBsYXRlOiBgXG4gKiAgPGtlbmRvLW11bHRpdmlld2NhbGVuZGFyPjwva2VuZG8tbXVsdGl2aWV3Y2FsZW5kYXI+XG4gKiBgXG4gKiB9KVxuICogZXhwb3J0IGNsYXNzIEFwcENvbXBvbmVudCB7IH1cbiAqIGBgYFxuICovXG5sZXQgTXVsdGlWaWV3Q2FsZW5kYXJDb21wb25lbnQgPSBjbGFzcyBNdWx0aVZpZXdDYWxlbmRhckNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoYnVzLCBlbGVtZW50LCBuYXZpZ2F0b3IsIHJlbmRlcmVyLCBjZHIsIHpvbmUsIGRpc2FibGVkRGF0ZXNTZXJ2aWNlLCBzZWxlY3Rpb25TZXJ2aWNlKSB7XG4gICAgICAgIHRoaXMuYnVzID0gYnVzO1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICB0aGlzLm5hdmlnYXRvciA9IG5hdmlnYXRvcjtcbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgICAgICB0aGlzLmNkciA9IGNkcjtcbiAgICAgICAgdGhpcy56b25lID0gem9uZTtcbiAgICAgICAgdGhpcy5kaXNhYmxlZERhdGVzU2VydmljZSA9IGRpc2FibGVkRGF0ZXNTZXJ2aWNlO1xuICAgICAgICB0aGlzLnNlbGVjdGlvblNlcnZpY2UgPSBzZWxlY3Rpb25TZXJ2aWNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogQGhpZGRlblxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pZCA9IGd1aWQoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERldGVybWluZXMgd2hldGhlciB0aGUgYnVpbHQtaW4gbWluIG9yIG1heCB2YWxpZGF0b3JzIGFyZSBlbmZvcmNlZCB3aGVuIHZhbGlkYXRpbmcgYSBmb3JtLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yYW5nZVZhbGlkYXRpb24gPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERldGVybWluZXMgd2hldGhlciB0aGUgYnVpbHQtaW4gdmFsaWRhdG9yIGZvciBkaXNhYmxlZFxuICAgICAgICAgKiBkYXRlIHJhbmdlcyBpcyBlbmZvcmNlZCB3aGVuIHZhbGlkYXRpbmcgYSBmb3JtXG4gICAgICAgICAqIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgZGlzYWJsZWRfZGF0ZXNfbXVsdGl2aWV3Y2FsZW5kYXIgJX0jdG9jLXZhbGlkYXRpb24pKS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZGlzYWJsZWREYXRlc1JhbmdlVmFsaWRhdGlvbiA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0cyB0aGUgQ2FsZW5kYXIgc2VsZWN0aW9uIG1vZGVcbiAgICAgICAgICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBtdWx0aXBsZV9zZWxlY3Rpb25fbXVsdGl2aWV3Y2FsZW5kYXIgJX0pKS5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhlIGF2YWlsYWJsZSB2YWx1ZXMgYXJlOlxuICAgICAgICAgKiAqIGBzaW5nbGVgIChkZWZhdWx0KVxuICAgICAgICAgKiAqIGBtdWx0aXBsZWBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2VsZWN0aW9uID0gJ3NpbmdsZSc7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXRzIG9yIGdldHMgdGhlIGBkaXNhYmxlZGAgcHJvcGVydHkgb2YgdGhlIENhbGVuZGFyIGFuZFxuICAgICAgICAgKiBkZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGNvbXBvbmVudCBpcyBhY3RpdmVcbiAgICAgICAgICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBkaXNhYmxlZF9tdWx0aXZpZXdjYWxlbmRhciAlfSkpLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kaXNhYmxlZCA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0cyBvciBnZXRzIHRoZSBgdGFiaW5kZXhgIHByb3BlcnR5IG9mIHRoZSBDYWxlbmRhci4gQmFzZWQgb24gdGhlXG4gICAgICAgICAqIFtIVE1MIGB0YWJpbmRleGBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvR2xvYmFsX2F0dHJpYnV0ZXMvdGFiaW5kZXgpIGJlaGF2aW9yLFxuICAgICAgICAgKiBpdCBkZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGNvbXBvbmVudCBpcyBmb2N1c2FibGUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRhYmluZGV4ID0gMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBoaWRkZW5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaXNBY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlZmluZXMgdGhlIGFjdGl2ZSB2aWV3IHRoYXQgdGhlIENhbGVuZGFyIGluaXRpYWxseSByZW5kZXJzXG4gICAgICAgICAqIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgYWN0aXZldmlld19tdWx0aXZpZXdjYWxlbmRhciAlfSkpLlxuICAgICAgICAgKiBCeSBkZWZhdWx0LCB0aGUgYWN0aXZlIHZpZXcgaXMgYG1vbnRoYC5cbiAgICAgICAgICpcbiAgICAgICAgICogPiBZb3UgaGF2ZSB0byBzZXQgYGFjdGl2ZVZpZXdgIHdpdGhpbiB0aGUgYHRvcFZpZXdgLWBib3R0b21WaWV3YCByYW5nZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYWN0aXZlVmlldyA9IENhbGVuZGFyVmlld0VudW1bQ2FsZW5kYXJWaWV3RW51bS5tb250aF07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWZpbmVzIHRoZSBib3R0b21tb3N0IHZpZXcsIHRvIHdoaWNoIHRoZSB1c2VyIGNhbiBuYXZpZ2F0ZVxuICAgICAgICAgKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGRhdGVzX211bHRpdmlld2NhbGVuZGFyICV9I3RvYy1wYXJ0aWFsLWRhdGVzKSkuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmJvdHRvbVZpZXcgPSBDYWxlbmRhclZpZXdFbnVtW0NhbGVuZGFyVmlld0VudW0ubW9udGhdO1xuICAgICAgICAvKipcbiAgICAgICAgICogRGVmaW5lcyB0aGUgdG9wbW9zdCB2aWV3LCB0byB3aGljaCB0aGUgdXNlciBjYW4gbmF2aWdhdGUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRvcFZpZXcgPSBDYWxlbmRhclZpZXdFbnVtW0NhbGVuZGFyVmlld0VudW0uY2VudHVyeV07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgdG8gZGlzcGxheSBhIGhlYWRlciBmb3IgZXZlcnkgdmlldyAoZm9yIGV4YW1wbGUgdGhlIG1vbnRoIG5hbWUpLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zaG93Vmlld0hlYWRlciA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRvIGVuYWJsZSBhbmltYXRpb24gd2hlbiBuYXZpZ2F0aW5nIHRvIHByZXZpb3VzL25leHQgdmlldy5cbiAgICAgICAgICpcbiAgICAgICAgICogPiBUaGlzIGZlYXR1cmUgdXNlcyB0aGUgW1dlYiBBbmltYXRpb25zIEFQSV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1dlYl9BbmltYXRpb25zX0FQSSkuIEluIG9yZGVyIHRvIHJ1biB0aGUgYW5pbWF0aW9uIGluIGJyb3dzZXJzIHRoYXQgZG8gbm90IHN1cHBvcnQgaXQsIHlvdSBuZWVkIHRoZSBgd2ViLWFuaW1hdGlvbnMtanNgIHBvbHlmaWxsLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hbmltYXRlTmF2aWdhdGlvbiA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRvIGRpc3BsYXkgYSB3ZWVrIG51bWJlciBjb2x1bW4gaW4gdGhlIGBtb250aGAgdmlld1xuICAgICAgICAgKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIHdlZWtudW1jb2x1bW5fbXVsdGl2aWV3Y2FsZW5kYXIgJX0pKS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMud2Vla051bWJlciA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0cyBvciBnZXRzIHRoZSBgdmlld3NgIHByb3BlcnR5IG9mIHRoZSBDYWxlbmRhciBhbmRcbiAgICAgICAgICogZGVmaW5lcyB0aGUgbnVtYmVyIG9mIHJlbmRlcmVkIG1vbnRocy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudmlld3MgPSAyO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgd2hlbiB0aGUgYWN0aXZlIHZpZXcgaXMgY2hhbmdlZFxuICAgICAgICAgKiAoW21vcmUgaW5mb3JtYXRpb24gYW5kIGV4YW1wbGVdKHslIHNsdWcgb3ZlcnZpZXdfbXVsdGl2aWV3Y2FsZW5kYXIgJX0jdG9jLWV2ZW50cykpLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hY3RpdmVWaWV3Q2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgd2hlbiBhIHZpZXcgY2VsbCBpcyBlbnRlcmVkXG4gICAgICAgICAqIChbbW9yZSBpbmZvcm1hdGlvbiBhbmQgZXhhbXBsZV0oeyUgc2x1ZyBvdmVydmlld19tdWx0aXZpZXdjYWxlbmRhciAlfSN0b2MtZXZlbnRzKSkuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNlbGxFbnRlciA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIHdoZW4gYSB2aWV3IGNlbGwgaXMgbGVhdmVkXG4gICAgICAgICAqIChbbW9yZSBpbmZvcm1hdGlvbiBhbmQgZXhhbXBsZV0oeyUgc2x1ZyBvdmVydmlld19tdWx0aXZpZXdjYWxlbmRhciAlfSN0b2MtZXZlbnRzKSkuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNlbGxMZWF2ZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIHdoZW4gdGhlIHZhbHVlIGlzIGNoYW5nZWRcbiAgICAgICAgICogKFttb3JlIGluZm9ybWF0aW9uIGFuZCBleGFtcGxlXSh7JSBzbHVnIG92ZXJ2aWV3X211bHRpdmlld2NhbGVuZGFyICV9I3RvYy1ldmVudHMpKS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudmFsdWVDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuY2VsbFVJRCA9IGd1aWQoKTtcbiAgICAgICAgdGhpcy5pc0hvdmVyZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pc1ByZXZEaXNhYmxlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuaXNOZXh0RGlzYWJsZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLnByZXZWaWV3ID0gQWN0aW9uLlByZXZWaWV3O1xuICAgICAgICB0aGlzLm5leHRWaWV3ID0gQWN0aW9uLk5leHRWaWV3O1xuICAgICAgICB0aGlzLnNlbGVjdGVkRGF0ZXMgPSBbXTtcbiAgICAgICAgdGhpcy5fbWluID0gbmV3IERhdGUoTUlOX0RBVEUpO1xuICAgICAgICB0aGlzLl9tYXggPSBuZXcgRGF0ZShNQVhfREFURSk7XG4gICAgICAgIHRoaXMuX2ZvY3VzZWREYXRlID0gZ2V0VG9kYXkoKTtcbiAgICAgICAgdGhpcy5yZXNvbHZlZFByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgdGhpcy5vbkNvbnRyb2xDaGFuZ2UgPSBub29wO1xuICAgICAgICB0aGlzLm9uQ29udHJvbFRvdWNoZWQgPSBub29wO1xuICAgICAgICB0aGlzLm9uVmFsaWRhdG9yQ2hhbmdlID0gbm9vcDtcbiAgICAgICAgdGhpcy5taW5WYWxpZGF0ZUZuID0gbm9vcDtcbiAgICAgICAgdGhpcy5tYXhWYWxpZGF0ZUZuID0gbm9vcDtcbiAgICAgICAgdGhpcy5kaXNhYmxlZERhdGVzUmFuZ2VWYWxpZGF0ZUZuID0gbm9vcDtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zID0gbmV3IFN1YnNjcmlwdGlvbigoKSA9PiB7IH0pO1xuICAgICAgICB0aGlzLnNldENsYXNzZXMoZWxlbWVudC5uYXRpdmVFbGVtZW50KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBvciBnZXRzIHRoZSBgZm9jdXNlZERhdGVgIHByb3BlcnR5IG9mIHRoZSBDYWxlbmRhciBhbmRcbiAgICAgKiBkZWZpbmVzIHRoZSBmb2N1c2VkIGRhdGUgb2YgdGhlIGNvbXBvbmVudFxuICAgICAqIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgZGF0ZXNfbXVsdGl2aWV3Y2FsZW5kYXIgJX0jdG9jLWZvY3VzZWQtZGF0ZXMpKS5cbiAgICAgKlxuICAgICAqID4gSWYgdGhlIENhbGVuZGFyIGlzIG91dCBvZiB0aGUgbWluIG9yIG1heCByYW5nZSwgaXQgbm9ybWFsaXplcyB0aGUgZGVmaW5lZCBgZm9jdXNlZERhdGVgLlxuICAgICAqL1xuICAgIHNldCBmb2N1c2VkRGF0ZShmb2N1c2VkRGF0ZSkge1xuICAgICAgICB0aGlzLl9mb2N1c2VkRGF0ZSA9IGZvY3VzZWREYXRlIHx8IGdldFRvZGF5KCk7XG4gICAgfVxuICAgIGdldCBmb2N1c2VkRGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZvY3VzZWREYXRlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIG9yIGdldHMgdGhlIGBtaW5gIHByb3BlcnR5IG9mIHRoZSBDYWxlbmRhciBhbmRcbiAgICAgKiBkZWZpbmVzIHRoZSBtaW5pbXVtIGFsbG93ZWQgZGF0ZSB2YWx1ZS5cbiAgICAgKiBCeSBkZWZhdWx0LCB0aGUgYG1pbmAgdmFsdWUgaXMgYDE5MDAtMS0xYC5cbiAgICAgKi9cbiAgICBzZXQgbWluKG1pbikge1xuICAgICAgICB0aGlzLl9taW4gPSBtaW4gfHwgbmV3IERhdGUoTUlOX0RBVEUpO1xuICAgIH1cbiAgICBnZXQgbWluKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWluO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIG9yIGdldHMgdGhlIGBtYXhgIHByb3BlcnR5IG9mIHRoZSBDYWxlbmRhciBhbmRcbiAgICAgKiBkZWZpbmVzIHRoZSBtYXhpbXVtIGFsbG93ZWQgZGF0ZSB2YWx1ZS5cbiAgICAgKiBCeSBkZWZhdWx0LCB0aGUgYG1heGAgdmFsdWUgaXMgYDIwOTktMTItMzFgLlxuICAgICAqL1xuICAgIHNldCBtYXgobWF4KSB7XG4gICAgICAgIHRoaXMuX21heCA9IG1heCB8fCBuZXcgRGF0ZShNQVhfREFURSk7XG4gICAgfVxuICAgIGdldCBtYXgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tYXg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgb3IgZ2V0cyB0aGUgYHZhbHVlYCBwcm9wZXJ0eSBvZiB0aGUgQ2FsZW5kYXIgYW5kIGRlZmluZXMgdGhlIHNlbGVjdGVkIHZhbHVlIG9mIHRoZSBjb21wb25lbnQuXG4gICAgICpcbiAgICAgKiA+IFRoZSBgdmFsdWVgIGhhcyB0byBiZSBhIHZhbGlkXG4gICAgICogW0phdmFTY3JpcHQgYERhdGVgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9EYXRlKVxuICAgICAqIGluc3RhbmNlIHdoZW4gaW4gYHNpbmdsZWAgc2VsZWN0aW9uIG1vZGUgb3IgYW4gYXJyYXkgb2YgdmFsaWQgSmF2YVNjcmlwdCBEYXRlIGluc3RhbmNlcyB3aGVuIGluIGBtdWx0aXBsZWAgc2VsZWN0aW9uIG1vZGUuXG4gICAgICovXG4gICAgZ2V0IHZhbHVlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmFsdWU7XG4gICAgfVxuICAgIHNldCB2YWx1ZShjYW5kaWRhdGUpIHtcbiAgICAgICAgdGhpcy52ZXJpZnlWYWx1ZShjYW5kaWRhdGUpO1xuICAgICAgICB0aGlzLl92YWx1ZSA9IEFycmF5LmlzQXJyYXkoY2FuZGlkYXRlKSA/XG4gICAgICAgICAgICBjYW5kaWRhdGUuZmlsdGVyKGRhdGUgPT4gaXNQcmVzZW50KGRhdGUpKS5tYXAoZWxlbWVudCA9PiBjbG9uZURhdGUoZWxlbWVudCkpIDpcbiAgICAgICAgICAgIGNsb25lRGF0ZShjYW5kaWRhdGUpO1xuICAgICAgICBjb25zdCBzZWxlY3Rpb24gPSBbXS5jb25jYXQoY2FuZGlkYXRlKS5maWx0ZXIoZGF0ZSA9PiBpc1ByZXNlbnQoZGF0ZSkpLm1hcChkYXRlID0+IGNsb25lRGF0ZShkYXRlKSk7XG4gICAgICAgIGlmICghYXJlRGF0ZXNFcXVhbChzZWxlY3Rpb24sIHRoaXMuc2VsZWN0ZWREYXRlcykpIHtcbiAgICAgICAgICAgIGNvbnN0IGxhc3RTZWxlY3RlZCA9IGxhc3Qoc2VsZWN0aW9uKTtcbiAgICAgICAgICAgIHRoaXMucmFuZ2VQaXZvdCA9IGNsb25lRGF0ZShsYXN0U2VsZWN0ZWQpO1xuICAgICAgICAgICAgdGhpcy5mb2N1c2VkRGF0ZSA9IGNsb25lRGF0ZShsYXN0U2VsZWN0ZWQpIHx8IHRoaXMuZm9jdXNlZERhdGU7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGVkRGF0ZXMgPSBzZWxlY3Rpb247XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHNldCB0YWJJbmRleCh0YWJJbmRleCkge1xuICAgICAgICB0aGlzLnRhYmluZGV4ID0gdGFiSW5kZXg7XG4gICAgfVxuICAgIGdldCB0YWJJbmRleCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGFiaW5kZXg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGRhdGVzIG9mIHRoZSBNdWx0aVZpZXdDYWxlbmRhciB0aGF0IHdpbGwgYmUgZGlzYWJsZWRcbiAgICAgKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGRpc2FibGVkX2RhdGVzX211bHRpdmlld2NhbGVuZGFyICV9KSkuXG4gICAgICovXG4gICAgc2V0IGRpc2FibGVkRGF0ZXModmFsdWUpIHtcbiAgICAgICAgdGhpcy5kaXNhYmxlZERhdGVzU2VydmljZS5pbml0aWFsaXplKHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBvciBnZXRzIHRoZSBgc2VsZWN0aW9uUmFuZ2VgIHByb3BlcnR5IG9mIHRoZSBDYWxlbmRhciBhbmRcbiAgICAgKiBkZWZpbmVzIHRoZSBzZWxlY3Rpb24gcmFuZ2Ugb2YgdGhlIGNvbXBvbmVudFxuICAgICAqIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgZGF0ZXNfbXVsdGl2aWV3Y2FsZW5kYXIgJX0jdG9jLXNlbGVjdGlvbi1yYW5nZSkpLlxuICAgICAqL1xuICAgIHNldCBzZWxlY3Rpb25SYW5nZShyYW5nZSQkMSkge1xuICAgICAgICB0aGlzLl9zZWxlY3Rpb25SYW5nZSA9IHJhbmdlJCQxO1xuICAgICAgICBpZiAodGhpcy5kaXNhYmxlZERhdGVzUmFuZ2VWYWxpZGF0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLm9uVmFsaWRhdG9yQ2hhbmdlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IHNlbGVjdGlvblJhbmdlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2VsZWN0aW9uUmFuZ2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBzZXQgY2VsbFRlbXBsYXRlUmVmKHRlbXBsYXRlKSB7XG4gICAgICAgIHRoaXMuY2VsbFRlbXBsYXRlID0gdGVtcGxhdGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBzZXQgbW9udGhDZWxsVGVtcGxhdGVSZWYodGVtcGxhdGUpIHtcbiAgICAgICAgdGhpcy5tb250aENlbGxUZW1wbGF0ZSA9IHRlbXBsYXRlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgc2V0IHllYXJDZWxsVGVtcGxhdGVSZWYodGVtcGxhdGUpIHtcbiAgICAgICAgdGhpcy55ZWFyQ2VsbFRlbXBsYXRlID0gdGVtcGxhdGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBzZXQgZGVjYWRlQ2VsbFRlbXBsYXRlUmVmKHRlbXBsYXRlKSB7XG4gICAgICAgIHRoaXMuZGVjYWRlQ2VsbFRlbXBsYXRlID0gdGVtcGxhdGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBzZXQgY2VudHVyeUNlbGxUZW1wbGF0ZVJlZih0ZW1wbGF0ZSkge1xuICAgICAgICB0aGlzLmNlbnR1cnlDZWxsVGVtcGxhdGUgPSB0ZW1wbGF0ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHNldCB3ZWVrTnVtYmVyVGVtcGxhdGVSZWYodGVtcGxhdGUpIHtcbiAgICAgICAgdGhpcy53ZWVrTnVtYmVyVGVtcGxhdGUgPSB0ZW1wbGF0ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHNldCBoZWFkZXJUaXRsZVRlbXBsYXRlUmVmKHRlbXBsYXRlKSB7XG4gICAgICAgIHRoaXMuaGVhZGVyVGl0bGVUZW1wbGF0ZSA9IHRlbXBsYXRlO1xuICAgIH1cbiAgICBnZXQgYWN0aXZlVmlld0VudW0oKSB7XG4gICAgICAgIGNvbnN0IGFjdGl2ZVZpZXcgPSBDYWxlbmRhclZpZXdFbnVtW3RoaXMuYWN0aXZlVmlld107XG4gICAgICAgIHJldHVybiBhY3RpdmVWaWV3IDwgdGhpcy5ib3R0b21WaWV3RW51bSA/IHRoaXMuYm90dG9tVmlld0VudW0gOiBhY3RpdmVWaWV3O1xuICAgIH1cbiAgICBnZXQgYm90dG9tVmlld0VudW0oKSB7XG4gICAgICAgIHJldHVybiBDYWxlbmRhclZpZXdFbnVtW3RoaXMuYm90dG9tVmlld107XG4gICAgfVxuICAgIGdldCB0b3BWaWV3RW51bSgpIHtcbiAgICAgICAgcmV0dXJuIENhbGVuZGFyVmlld0VudW1bdGhpcy50b3BWaWV3XTtcbiAgICB9XG4gICAgZ2V0IHdpZGdldElkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pZDtcbiAgICB9XG4gICAgZ2V0IHdpZGdldFJvbGUoKSB7XG4gICAgICAgIHJldHVybiAnZ3JpZCc7XG4gICAgfVxuICAgIGdldCBjYWxlbmRhclRhYkluZGV4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kaXNhYmxlZCA/IHVuZGVmaW5lZCA6IHRoaXMudGFiSW5kZXg7XG4gICAgfVxuICAgIGdldCBhcmlhRGlzYWJsZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRpc2FibGVkO1xuICAgIH1cbiAgICBnZXQgYXJpYUFjdGl2ZWRlc2NlbmRhbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNlbGxVSUQgKyB0aGlzLmZvY3VzZWREYXRlLmdldFRpbWUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGhhbmRsZUJsdXIoKSB7XG4gICAgICAgIHRoaXMub25Db250cm9sVG91Y2hlZCgpO1xuICAgICAgICB0aGlzLmlzQWN0aXZlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXNIb3ZlcmVkID0gZmFsc2U7IC8vZW5zdXJlIHRoYXQgaG92ZXJlZCBpcyBhbHNvIG5vdCBhY3RpdmVcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGhhbmRsZUZvY3VzKCkge1xuICAgICAgICB0aGlzLmlzQWN0aXZlID0gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGhhbmRsZU1vdXNlRW50ZXIoKSB7XG4gICAgICAgIHRoaXMuaXNIb3ZlcmVkID0gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGhhbmRsZU1vdXNlTGVhdmUoKSB7XG4gICAgICAgIHRoaXMuaXNIb3ZlcmVkID0gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBoYW5kbGVNb3VzZWRvd24oZXZlbnQpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGhhbmRsZUNsaWNrKCkge1xuICAgICAgICBpZiAodGhpcy5pc0FjdGl2ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZm9jdXMoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGtleWRvd24oZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50LmtleUNvZGUgPT09IEtleXMuRW50ZXIpIHtcbiAgICAgICAgICAgIHRoaXMucGVyZm9ybVNlbGVjdGlvbih0aGlzLmZvY3VzZWREYXRlLCBldmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gZGF0ZUluUmFuZ2UodGhpcy5uYXZpZ2F0b3IubW92ZSh0aGlzLmZvY3VzZWREYXRlLCB0aGlzLm5hdmlnYXRvci5hY3Rpb24oZXZlbnQpLCB0aGlzLmFjdGl2ZVZpZXdFbnVtKSwgdGhpcy5taW4sIHRoaXMubWF4KTtcbiAgICAgICAgaWYgKGlzRXF1YWwodGhpcy5mb2N1c2VkRGF0ZSwgY2FuZGlkYXRlKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZm9jdXNlZERhdGUgPSBjYW5kaWRhdGU7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICAgIG5nT25Jbml0KCkge1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMuYWRkKHRoaXMuYnVzLnZpZXdDaGFuZ2VkLnN1YnNjcmliZSgoeyB2aWV3IH0pID0+IHtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlVmlldyA9IENhbGVuZGFyVmlld0VudW1bdmlld107XG4gICAgICAgICAgICB0aGlzLmFjdGl2ZVZpZXdDaGFuZ2UuZW1pdCh0aGlzLmFjdGl2ZVZpZXcpO1xuICAgICAgICAgICAgdGhpcy5jZHIuZGV0ZWN0Q2hhbmdlcygpO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVCdXR0b25TdGF0ZSgpO1xuICAgICAgICB9KSk7XG4gICAgfVxuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXMpIHtcbiAgICAgICAgdGhpcy52ZXJpZnlDaGFuZ2VzKCk7XG4gICAgICAgIHRoaXMuYnVzLmNvbmZpZ3VyZSh0aGlzLmJvdHRvbVZpZXdFbnVtLCB0aGlzLnRvcFZpZXdFbnVtKTtcbiAgICAgICAgaWYgKGhhc0V4aXN0aW5nVmFsdWUoY2hhbmdlcywgJ2ZvY3VzZWREYXRlJykpIHtcbiAgICAgICAgICAgIGNvbnN0IGZvY3VzZWREYXRlID0gY2hhbmdlcy5mb2N1c2VkRGF0ZS5jdXJyZW50VmFsdWU7XG4gICAgICAgICAgICB0aGlzLmZvY3VzZWREYXRlID0gZGF0ZUluUmFuZ2UoZm9jdXNlZERhdGUsIHRoaXMubWluLCB0aGlzLm1heCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYW5nZXMubWluIHx8IGNoYW5nZXMubWF4IHx8IGNoYW5nZXMucmFuZ2VWYWxpZGF0aW9uIHx8IGNoYW5nZXMuZGlzYWJsZWREYXRlcyB8fCBjaGFuZ2VzLmRpc2FibGVkRGF0ZXNSYW5nZVZhbGlkYXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMubWluVmFsaWRhdGVGbiA9IHRoaXMucmFuZ2VWYWxpZGF0aW9uID8gbWluVmFsaWRhdG9yKHRoaXMubWluKSA6IG5vb3A7XG4gICAgICAgICAgICB0aGlzLm1heFZhbGlkYXRlRm4gPSB0aGlzLnJhbmdlVmFsaWRhdGlvbiA/IG1heFZhbGlkYXRvcih0aGlzLm1heCkgOiBub29wO1xuICAgICAgICAgICAgdGhpcy5kaXNhYmxlZERhdGVzUmFuZ2VWYWxpZGF0ZUZuID0gdGhpcy5kaXNhYmxlZERhdGVzUmFuZ2VWYWxpZGF0aW9uID8gZGlzYWJsZWREYXRlc1JhbmdlVmFsaWRhdG9yKHRoaXMuZGlzYWJsZWREYXRlc1NlcnZpY2UuaXNEYXRlRGlzYWJsZWQpIDogbm9vcDtcbiAgICAgICAgICAgIHRoaXMub25WYWxpZGF0b3JDaGFuZ2UoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhbmdlcy5taW4gfHwgY2hhbmdlcy5tYXggfHwgY2hhbmdlcy5mb2N1c2VkRGF0ZSB8fCBjaGFuZ2VzLmFjdGl2ZVZpZXcpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQnV0dG9uU3RhdGUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxuICAgIG5nQWZ0ZXJWaWV3SW5pdCgpIHtcbiAgICAgICAgdGhpcy51cGRhdGVCdXR0b25TdGF0ZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGb2N1c2VzIHRoZSBob3N0IGVsZW1lbnQgb2YgdGhlIENhbGVuZGFyLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0c1xuICAgICAqIF9AQ29tcG9uZW50KHtcbiAgICAgKiBzZWxlY3RvcjogJ215LWFwcCcsXG4gICAgICogdGVtcGxhdGU6IGBcbiAgICAgKiAgPGJ1dHRvbiAoY2xpY2spPVwibXVsdGl2aWV3Y2FsZW5kYXIuZm9jdXMoKVwiPkZvY3VzIGNhbGVuZGFyPC9idXR0b24+XG4gICAgICogIDxrZW5kby1tdWx0aXZpZXdjYWxlbmRhciAjbXVsdGl2aWV3Y2FsZW5kYXI+PC9rZW5kby1tdWx0aXZpZXdjYWxlbmRhcj5cbiAgICAgKiBgXG4gICAgICogfSlcbiAgICAgKiBleHBvcnQgY2xhc3MgQXBwQ29tcG9uZW50IHsgfVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGZvY3VzKCkge1xuICAgICAgICBpZiAoIXRoaXMuZWxlbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LmZvY3VzKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJsdXJzIHRoZSBDYWxlbmRhciBjb21wb25lbnQuXG4gICAgICovXG4gICAgYmx1cigpIHtcbiAgICAgICAgaWYgKCF0aGlzLmVsZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudC5ibHVyKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBoYW5kbGVEYXRlQ2hhbmdlKGFyZ3MpIHtcbiAgICAgICAgY29uc3QgY2FuTmF2aWdhdGVEb3duID0gdGhpcy5idXMuY2FuTW92ZURvd24odGhpcy5hY3RpdmVWaWV3RW51bSk7XG4gICAgICAgIGNvbnN0IGF2YWlsYWJsZURhdGVzID0gYXJncy5zZWxlY3RlZERhdGVzLmZpbHRlcihkYXRlID0+ICF0aGlzLmRpc2FibGVkRGF0ZXNTZXJ2aWNlLmlzRGF0ZURpc2FibGVkKGRhdGUpKTtcbiAgICAgICAgdGhpcy5mb2N1c2VkRGF0ZSA9IGFyZ3MuZm9jdXNlZERhdGUgfHwgdGhpcy5mb2N1c2VkRGF0ZTtcbiAgICAgICAgY29uc3Qgc2FtZURhdGVzID0gIWNhbk5hdmlnYXRlRG93biAmJiBhcmVEYXRlc0VxdWFsKGF2YWlsYWJsZURhdGVzLCB0aGlzLnNlbGVjdGVkRGF0ZXMpO1xuICAgICAgICBpZiAodGhpcy5kaXNhYmxlZCB8fCBzYW1lRGF0ZXMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2FuTmF2aWdhdGVEb3duKSB7XG4gICAgICAgICAgICB0aGlzLmJ1cy5tb3ZlRG93bih0aGlzLmFjdGl2ZVZpZXdFbnVtKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5kaXNhYmxlZERhdGVzU2VydmljZS5pc0RhdGVEaXNhYmxlZCh0aGlzLmZvY3VzZWREYXRlKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2VsZWN0ZWREYXRlcyA9IGF2YWlsYWJsZURhdGVzLm1hcChkYXRlID0+IGNsb25lRGF0ZShkYXRlKSk7XG4gICAgICAgIHRoaXMudmFsdWUgPSB0aGlzLnBhcnNlU2VsZWN0aW9uVG9WYWx1ZShhdmFpbGFibGVEYXRlcyk7XG4gICAgICAgIHRoaXMub25Db250cm9sQ2hhbmdlKHRoaXMucGFyc2VTZWxlY3Rpb25Ub1ZhbHVlKGF2YWlsYWJsZURhdGVzKSk7XG4gICAgICAgIHRoaXMudmFsdWVDaGFuZ2UuZW1pdCh0aGlzLnBhcnNlU2VsZWN0aW9uVG9WYWx1ZShhdmFpbGFibGVEYXRlcykpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgc2V0QWN0aXZlRGF0ZShkYXRlKSB7XG4gICAgICAgIHRoaXMuYWN0aXZlRGF0ZSA9IGNsb25lRGF0ZShkYXRlKTtcbiAgICAgICAgdGhpcy5jZHIuZGV0ZWN0Q2hhbmdlcygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgd3JpdGVWYWx1ZShjYW5kaWRhdGUpIHtcbiAgICAgICAgdGhpcy52ZXJpZnlWYWx1ZShjYW5kaWRhdGUpO1xuICAgICAgICB0aGlzLnZhbHVlID0gY2FuZGlkYXRlO1xuICAgICAgICB0aGlzLmNkci5tYXJrRm9yQ2hlY2soKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHJlZ2lzdGVyT25DaGFuZ2UoZm4pIHtcbiAgICAgICAgdGhpcy5vbkNvbnRyb2xDaGFuZ2UgPSBmbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHJlZ2lzdGVyT25Ub3VjaGVkKGZuKSB7XG4gICAgICAgIHRoaXMub25Db250cm9sVG91Y2hlZCA9IGZuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgc2V0RGlzYWJsZWRTdGF0ZShpc0Rpc2FibGVkKSB7XG4gICAgICAgIHRoaXMuZGlzYWJsZWQgPSBpc0Rpc2FibGVkO1xuICAgICAgICB0aGlzLmNkci5tYXJrRm9yQ2hlY2soKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHZhbGlkYXRlKGNvbnRyb2wpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWluVmFsaWRhdGVGbihjb250cm9sKSB8fCB0aGlzLm1heFZhbGlkYXRlRm4oY29udHJvbCkgfHwgdGhpcy5kaXNhYmxlZERhdGVzUmFuZ2VWYWxpZGF0ZUZuKHRoaXMuc2VsZWN0aW9uUmFuZ2UpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcmVnaXN0ZXJPblZhbGlkYXRvckNoYW5nZShmbikge1xuICAgICAgICB0aGlzLm9uVmFsaWRhdG9yQ2hhbmdlID0gZm47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBhY3RpdmVDZWxsVGVtcGxhdGUoKSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy5hY3RpdmVWaWV3RW51bSkge1xuICAgICAgICAgICAgY2FzZSBDYWxlbmRhclZpZXdFbnVtLm1vbnRoOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm1vbnRoQ2VsbFRlbXBsYXRlIHx8IHRoaXMuY2VsbFRlbXBsYXRlO1xuICAgICAgICAgICAgY2FzZSBDYWxlbmRhclZpZXdFbnVtLnllYXI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMueWVhckNlbGxUZW1wbGF0ZTtcbiAgICAgICAgICAgIGNhc2UgQ2FsZW5kYXJWaWV3RW51bS5kZWNhZGU6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVjYWRlQ2VsbFRlbXBsYXRlO1xuICAgICAgICAgICAgY2FzZSBDYWxlbmRhclZpZXdFbnVtLmNlbnR1cnk6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2VudHVyeUNlbGxUZW1wbGF0ZTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIG5hdmlnYXRlKGFjdGlvbikge1xuICAgICAgICB0aGlzLmZvY3VzZWREYXRlID0gdGhpcy52aWV3TGlzdC5uYXZpZ2F0ZShhY3Rpb24pO1xuICAgICAgICB0aGlzLnVwZGF0ZUJ1dHRvblN0YXRlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBlbWl0Q2VsbEV2ZW50KGVtaXR0ZXIsIGFyZ3MpIHtcbiAgICAgICAgaWYgKGhhc09ic2VydmVycyhlbWl0dGVyKSkge1xuICAgICAgICAgICAgdGhpcy56b25lLnJ1bigoKSA9PiB7XG4gICAgICAgICAgICAgICAgZW1pdHRlci5lbWl0KGFyZ3MpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGhhbmRsZUNlbGxDbGljayh7IGRhdGUsIG1vZGlmaWVycyB9KSB7XG4gICAgICAgIHRoaXMucGVyZm9ybVNlbGVjdGlvbihkYXRlLCBtb2RpZmllcnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgaGFuZGxlV2Vla051bWJlckNsaWNrKGRhdGVzKSB7XG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbiA9PT0gJ3NpbmdsZScpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnpvbmUucnVuKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlRGF0ZUNoYW5nZSh7XG4gICAgICAgICAgICAgICAgc2VsZWN0ZWREYXRlczogZGF0ZXMsXG4gICAgICAgICAgICAgICAgZm9jdXNlZERhdGU6IGxhc3QoZGF0ZXMpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNldENsYXNzZXMoZWxlbWVudCkge1xuICAgICAgICB0aGlzLnJlbmRlcmVyLmFkZENsYXNzKGVsZW1lbnQsICdrLXdpZGdldCcpO1xuICAgICAgICB0aGlzLnJlbmRlcmVyLmFkZENsYXNzKGVsZW1lbnQsICdrLWNhbGVuZGFyJyk7XG4gICAgICAgIHRoaXMucmVuZGVyZXIuYWRkQ2xhc3MoZWxlbWVudCwgJ2stY2FsZW5kYXItcmFuZ2UnKTtcbiAgICB9XG4gICAgdmVyaWZ5Q2hhbmdlcygpIHtcbiAgICAgICAgaWYgKCFpc0Rldk1vZGUoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm1pbiA+IHRoaXMubWF4KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBtYXggdmFsdWUgc2hvdWxkIGJlIGJpZ2dlciB0aGFuIHRoZSBtaW4uIFNlZSAke01JTl9ET0NfTElOSyQzfSBhbmQgJHtNQVhfRE9DX0xJTkskM30uYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuYm90dG9tVmlld0VudW0gPiB0aGlzLnRvcFZpZXdFbnVtKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSB0b3BWaWV3IHNob3VsZCBiZSBncmVhdGVyIHRoYW4gYm90dG9tVmlldy4gU2VlICR7Qk9UVE9NX1ZJRVdfRE9DX0xJTkskMX0gYW5kICR7VE9QX1ZJRVdfRE9DX0xJTkskMX0uYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmVyaWZ5VmFsdWUoY2FuZGlkYXRlKSB7XG4gICAgICAgIGlmICghaXNEZXZNb2RlKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb24gPT09ICdzaW5nbGUnICYmIGNhbmRpZGF0ZSAmJiAhKGNhbmRpZGF0ZSBpbnN0YW5jZW9mIERhdGUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSAndmFsdWUnIHNob3VsZCBiZSBhIHZhbGlkIEphdmFTY3JpcHQgRGF0ZSBpbnN0YW5jZS4gQ2hlY2sgJHtWQUxVRV9ET0NfTElOSyQ1fSBmb3IgcG9zc2libGUgcmVzb2x1dGlvbi5gKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnNlbGVjdGlvbiA9PT0gJ211bHRpcGxlJyAmJiBjYW5kaWRhdGUgJiYgQXJyYXkuaXNBcnJheShjYW5kaWRhdGUpKSB7XG4gICAgICAgICAgICBjb25zdCBvbmx5RGF0ZXMgPSBjYW5kaWRhdGUuZXZlcnkodmFsdWUgPT4gdmFsdWUgaW5zdGFuY2VvZiBEYXRlKTtcbiAgICAgICAgICAgIGlmICghb25seURhdGVzKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgJ3ZhbHVlJyBzaG91bGQgYmUgYW4gYXJyYXkgb2YgdmFsaWQgSmF2YVNjcmlwdCBEYXRlIGluc3RhbmNlcy4gQ2hlY2sgJHtWQUxVRV9ET0NfTElOSyQ1fSBmb3IgcG9zc2libGUgcmVzb2x1dGlvbi5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGVCdXR0b25TdGF0ZSgpIHtcbiAgICAgICAgdGhpcy5yZXNvbHZlZFByb21pc2UudGhlbigoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmlzUHJldkRpc2FibGVkID0gIXRoaXMudmlld0xpc3QuY2FuTmF2aWdhdGUodGhpcy5wcmV2Vmlldyk7XG4gICAgICAgICAgICB0aGlzLmlzTmV4dERpc2FibGVkID0gIXRoaXMudmlld0xpc3QuY2FuTmF2aWdhdGUodGhpcy5uZXh0Vmlldyk7XG4gICAgICAgICAgICB0aGlzLmNkci5tYXJrRm9yQ2hlY2soKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHBhcnNlU2VsZWN0aW9uVG9WYWx1ZShzZWxlY3Rpb24pIHtcbiAgICAgICAgc2VsZWN0aW9uID0gc2VsZWN0aW9uIHx8IFtdO1xuICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3Rpb24gPT09ICdzaW5nbGUnID8gY2xvbmVEYXRlKGxhc3Qoc2VsZWN0aW9uKSkgOiBzZWxlY3Rpb24ubWFwKGRhdGUgPT4gY2xvbmVEYXRlKGRhdGUpKTtcbiAgICB9XG4gICAgcGVyZm9ybVNlbGVjdGlvbihkYXRlLCBzZWxlY3Rpb25Nb2RpZmllcnMpIHtcbiAgICAgICAgY29uc3Qgc2VsZWN0aW9uID0gdGhpcy5zZWxlY3Rpb25TZXJ2aWNlLnBlcmZvcm1TZWxlY3Rpb24oe1xuICAgICAgICAgICAgZGF0ZTogZGF0ZSxcbiAgICAgICAgICAgIG1vZGlmaWVyczogc2VsZWN0aW9uTW9kaWZpZXJzLFxuICAgICAgICAgICAgc2VsZWN0aW9uTW9kZTogdGhpcy5zZWxlY3Rpb24sXG4gICAgICAgICAgICBhY3RpdmVWaWV3RW51bTogdGhpcy5hY3RpdmVWaWV3RW51bSxcbiAgICAgICAgICAgIHJhbmdlUGl2b3Q6IHRoaXMucmFuZ2VQaXZvdCxcbiAgICAgICAgICAgIHNlbGVjdGVkRGF0ZXM6IHRoaXMuc2VsZWN0ZWREYXRlc1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yYW5nZVBpdm90ID0gc2VsZWN0aW9uLnJhbmdlUGl2b3Q7XG4gICAgICAgIHRoaXMuaGFuZGxlRGF0ZUNoYW5nZSh7XG4gICAgICAgICAgICBzZWxlY3RlZERhdGVzOiBzZWxlY3Rpb24uc2VsZWN0ZWREYXRlcyxcbiAgICAgICAgICAgIGZvY3VzZWREYXRlOiBkYXRlXG4gICAgICAgIH0pO1xuICAgIH1cbn07XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBNdWx0aVZpZXdDYWxlbmRhckNvbXBvbmVudC5wcm90b3R5cGUsIFwiaWRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIERhdGUpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbRGF0ZV0pXG5dLCBNdWx0aVZpZXdDYWxlbmRhckNvbXBvbmVudC5wcm90b3R5cGUsIFwiZm9jdXNlZERhdGVcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBEYXRlKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0RhdGVdKVxuXSwgTXVsdGlWaWV3Q2FsZW5kYXJDb21wb25lbnQucHJvdG90eXBlLCBcIm1pblwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIERhdGUpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbRGF0ZV0pXG5dLCBNdWx0aVZpZXdDYWxlbmRhckNvbXBvbmVudC5wcm90b3R5cGUsIFwibWF4XCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIE11bHRpVmlld0NhbGVuZGFyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJyYW5nZVZhbGlkYXRpb25cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBNdWx0aVZpZXdDYWxlbmRhckNvbXBvbmVudC5wcm90b3R5cGUsIFwiZGlzYWJsZWREYXRlc1JhbmdlVmFsaWRhdGlvblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgTXVsdGlWaWV3Q2FsZW5kYXJDb21wb25lbnQucHJvdG90eXBlLCBcInNlbGVjdGlvblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW09iamVjdF0pXG5dLCBNdWx0aVZpZXdDYWxlbmRhckNvbXBvbmVudC5wcm90b3R5cGUsIFwidmFsdWVcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgTXVsdGlWaWV3Q2FsZW5kYXJDb21wb25lbnQucHJvdG90eXBlLCBcImRpc2FibGVkXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBNdWx0aVZpZXdDYWxlbmRhckNvbXBvbmVudC5wcm90b3R5cGUsIFwidGFiaW5kZXhcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlciksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtOdW1iZXJdKVxuXSwgTXVsdGlWaWV3Q2FsZW5kYXJDb21wb25lbnQucHJvdG90eXBlLCBcInRhYkluZGV4XCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIE11bHRpVmlld0NhbGVuZGFyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJpc0FjdGl2ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW09iamVjdF0pXG5dLCBNdWx0aVZpZXdDYWxlbmRhckNvbXBvbmVudC5wcm90b3R5cGUsIFwiZGlzYWJsZWREYXRlc1wiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIE11bHRpVmlld0NhbGVuZGFyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJhY3RpdmVWaWV3XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBNdWx0aVZpZXdDYWxlbmRhckNvbXBvbmVudC5wcm90b3R5cGUsIFwiYm90dG9tVmlld1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgTXVsdGlWaWV3Q2FsZW5kYXJDb21wb25lbnQucHJvdG90eXBlLCBcInRvcFZpZXdcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBNdWx0aVZpZXdDYWxlbmRhckNvbXBvbmVudC5wcm90b3R5cGUsIFwic2hvd1ZpZXdIZWFkZXJcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBNdWx0aVZpZXdDYWxlbmRhckNvbXBvbmVudC5wcm90b3R5cGUsIFwiYW5pbWF0ZU5hdmlnYXRpb25cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBNdWx0aVZpZXdDYWxlbmRhckNvbXBvbmVudC5wcm90b3R5cGUsIFwid2Vla051bWJlclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgTXVsdGlWaWV3Q2FsZW5kYXJDb21wb25lbnQucHJvdG90eXBlLCBcImFjdGl2ZVJhbmdlRW5kXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbT2JqZWN0XSlcbl0sIE11bHRpVmlld0NhbGVuZGFyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzZWxlY3Rpb25SYW5nZVwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIE11bHRpVmlld0NhbGVuZGFyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ2aWV3c1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbl0sIE11bHRpVmlld0NhbGVuZGFyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJhY3RpdmVWaWV3Q2hhbmdlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBPdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxuXSwgTXVsdGlWaWV3Q2FsZW5kYXJDb21wb25lbnQucHJvdG90eXBlLCBcImNlbGxFbnRlclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbl0sIE11bHRpVmlld0NhbGVuZGFyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJjZWxsTGVhdmVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIE91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXG5dLCBNdWx0aVZpZXdDYWxlbmRhckNvbXBvbmVudC5wcm90b3R5cGUsIFwidmFsdWVDaGFuZ2VcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIENvbnRlbnRDaGlsZChDZWxsVGVtcGxhdGVEaXJlY3RpdmUsIHsgc3RhdGljOiB0cnVlIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBDZWxsVGVtcGxhdGVEaXJlY3RpdmUpXG5dLCBNdWx0aVZpZXdDYWxlbmRhckNvbXBvbmVudC5wcm90b3R5cGUsIFwiY2VsbFRlbXBsYXRlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgnY2VsbFRlbXBsYXRlJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIENlbGxUZW1wbGF0ZURpcmVjdGl2ZSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtDZWxsVGVtcGxhdGVEaXJlY3RpdmVdKVxuXSwgTXVsdGlWaWV3Q2FsZW5kYXJDb21wb25lbnQucHJvdG90eXBlLCBcImNlbGxUZW1wbGF0ZVJlZlwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIENvbnRlbnRDaGlsZChNb250aENlbGxUZW1wbGF0ZURpcmVjdGl2ZSwgeyBzdGF0aWM6IHRydWUgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE1vbnRoQ2VsbFRlbXBsYXRlRGlyZWN0aXZlKVxuXSwgTXVsdGlWaWV3Q2FsZW5kYXJDb21wb25lbnQucHJvdG90eXBlLCBcIm1vbnRoQ2VsbFRlbXBsYXRlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgnbW9udGhDZWxsVGVtcGxhdGUnKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTW9udGhDZWxsVGVtcGxhdGVEaXJlY3RpdmUpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbTW9udGhDZWxsVGVtcGxhdGVEaXJlY3RpdmVdKVxuXSwgTXVsdGlWaWV3Q2FsZW5kYXJDb21wb25lbnQucHJvdG90eXBlLCBcIm1vbnRoQ2VsbFRlbXBsYXRlUmVmXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgQ29udGVudENoaWxkKFllYXJDZWxsVGVtcGxhdGVEaXJlY3RpdmUsIHsgc3RhdGljOiB0cnVlIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBZZWFyQ2VsbFRlbXBsYXRlRGlyZWN0aXZlKVxuXSwgTXVsdGlWaWV3Q2FsZW5kYXJDb21wb25lbnQucHJvdG90eXBlLCBcInllYXJDZWxsVGVtcGxhdGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCd5ZWFyQ2VsbFRlbXBsYXRlJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFllYXJDZWxsVGVtcGxhdGVEaXJlY3RpdmUpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbWWVhckNlbGxUZW1wbGF0ZURpcmVjdGl2ZV0pXG5dLCBNdWx0aVZpZXdDYWxlbmRhckNvbXBvbmVudC5wcm90b3R5cGUsIFwieWVhckNlbGxUZW1wbGF0ZVJlZlwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIENvbnRlbnRDaGlsZChEZWNhZGVDZWxsVGVtcGxhdGVEaXJlY3RpdmUsIHsgc3RhdGljOiB0cnVlIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBEZWNhZGVDZWxsVGVtcGxhdGVEaXJlY3RpdmUpXG5dLCBNdWx0aVZpZXdDYWxlbmRhckNvbXBvbmVudC5wcm90b3R5cGUsIFwiZGVjYWRlQ2VsbFRlbXBsYXRlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgnZGVjYWRlQ2VsbFRlbXBsYXRlJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIERlY2FkZUNlbGxUZW1wbGF0ZURpcmVjdGl2ZSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtEZWNhZGVDZWxsVGVtcGxhdGVEaXJlY3RpdmVdKVxuXSwgTXVsdGlWaWV3Q2FsZW5kYXJDb21wb25lbnQucHJvdG90eXBlLCBcImRlY2FkZUNlbGxUZW1wbGF0ZVJlZlwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIENvbnRlbnRDaGlsZChDZW50dXJ5Q2VsbFRlbXBsYXRlRGlyZWN0aXZlLCB7IHN0YXRpYzogdHJ1ZSB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQ2VudHVyeUNlbGxUZW1wbGF0ZURpcmVjdGl2ZSlcbl0sIE11bHRpVmlld0NhbGVuZGFyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJjZW50dXJ5Q2VsbFRlbXBsYXRlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgnY2VudHVyeUNlbGxUZW1wbGF0ZScpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBDZW50dXJ5Q2VsbFRlbXBsYXRlRGlyZWN0aXZlKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0NlbnR1cnlDZWxsVGVtcGxhdGVEaXJlY3RpdmVdKVxuXSwgTXVsdGlWaWV3Q2FsZW5kYXJDb21wb25lbnQucHJvdG90eXBlLCBcImNlbnR1cnlDZWxsVGVtcGxhdGVSZWZcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBDb250ZW50Q2hpbGQoV2Vla051bWJlckNlbGxUZW1wbGF0ZURpcmVjdGl2ZSwgeyBzdGF0aWM6IHRydWUgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFdlZWtOdW1iZXJDZWxsVGVtcGxhdGVEaXJlY3RpdmUpXG5dLCBNdWx0aVZpZXdDYWxlbmRhckNvbXBvbmVudC5wcm90b3R5cGUsIFwid2Vla051bWJlclRlbXBsYXRlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgnd2Vla051bWJlclRlbXBsYXRlJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFdlZWtOdW1iZXJDZWxsVGVtcGxhdGVEaXJlY3RpdmUpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbV2Vla051bWJlckNlbGxUZW1wbGF0ZURpcmVjdGl2ZV0pXG5dLCBNdWx0aVZpZXdDYWxlbmRhckNvbXBvbmVudC5wcm90b3R5cGUsIFwid2Vla051bWJlclRlbXBsYXRlUmVmXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgQ29udGVudENoaWxkKEhlYWRlclRpdGxlVGVtcGxhdGVEaXJlY3RpdmUsIHsgc3RhdGljOiB0cnVlIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBIZWFkZXJUaXRsZVRlbXBsYXRlRGlyZWN0aXZlKVxuXSwgTXVsdGlWaWV3Q2FsZW5kYXJDb21wb25lbnQucHJvdG90eXBlLCBcImhlYWRlclRpdGxlVGVtcGxhdGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCdoZWFkZXJUaXRsZVRlbXBsYXRlJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEhlYWRlclRpdGxlVGVtcGxhdGVEaXJlY3RpdmUpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbSGVhZGVyVGl0bGVUZW1wbGF0ZURpcmVjdGl2ZV0pXG5dLCBNdWx0aVZpZXdDYWxlbmRhckNvbXBvbmVudC5wcm90b3R5cGUsIFwiaGVhZGVyVGl0bGVUZW1wbGF0ZVJlZlwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIFZpZXdDaGlsZChIb3Jpem9udGFsVmlld0xpc3RDb21wb25lbnQsIHsgc3RhdGljOiBmYWxzZSB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgSG9yaXpvbnRhbFZpZXdMaXN0Q29tcG9uZW50KVxuXSwgTXVsdGlWaWV3Q2FsZW5kYXJDb21wb25lbnQucHJvdG90eXBlLCBcInZpZXdMaXN0XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBIb3N0QmluZGluZygnYXR0ci5pZCcpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIE11bHRpVmlld0NhbGVuZGFyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ3aWRnZXRJZFwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RCaW5kaW5nKCdhdHRyLnJvbGUnKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBNdWx0aVZpZXdDYWxlbmRhckNvbXBvbmVudC5wcm90b3R5cGUsIFwid2lkZ2V0Um9sZVwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RCaW5kaW5nKCdhdHRyLnRhYmluZGV4JyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlciksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgTXVsdGlWaWV3Q2FsZW5kYXJDb21wb25lbnQucHJvdG90eXBlLCBcImNhbGVuZGFyVGFiSW5kZXhcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBIb3N0QmluZGluZygnYXR0ci5hcmlhLWRpc2FibGVkJyksXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLmstc3RhdGUtZGlzYWJsZWQnKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgTXVsdGlWaWV3Q2FsZW5kYXJDb21wb25lbnQucHJvdG90eXBlLCBcImFyaWFEaXNhYmxlZFwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RCaW5kaW5nKCdhdHRyLmFyaWEtYWN0aXZlZGVzY2VuZGFudCcpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIE11bHRpVmlld0NhbGVuZGFyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJhcmlhQWN0aXZlZGVzY2VuZGFudFwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RMaXN0ZW5lcihcImJsdXJcIiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cmV0dXJudHlwZVwiLCB2b2lkIDApXG5dLCBNdWx0aVZpZXdDYWxlbmRhckNvbXBvbmVudC5wcm90b3R5cGUsIFwiaGFuZGxlQmx1clwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RMaXN0ZW5lcihcImZvY3VzXCIpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnJldHVybnR5cGVcIiwgdm9pZCAwKVxuXSwgTXVsdGlWaWV3Q2FsZW5kYXJDb21wb25lbnQucHJvdG90eXBlLCBcImhhbmRsZUZvY3VzXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSG9zdExpc3RlbmVyKFwibW91c2VlbnRlclwiKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpyZXR1cm50eXBlXCIsIHZvaWQgMClcbl0sIE11bHRpVmlld0NhbGVuZGFyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJoYW5kbGVNb3VzZUVudGVyXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSG9zdExpc3RlbmVyKFwibW91c2VsZWF2ZVwiKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpyZXR1cm50eXBlXCIsIHZvaWQgMClcbl0sIE11bHRpVmlld0NhbGVuZGFyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJoYW5kbGVNb3VzZUxlYXZlXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSG9zdExpc3RlbmVyKFwibW91c2Vkb3duXCIsIFsnJGV2ZW50J10pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtPYmplY3RdKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnJldHVybnR5cGVcIiwgdm9pZCAwKVxuXSwgTXVsdGlWaWV3Q2FsZW5kYXJDb21wb25lbnQucHJvdG90eXBlLCBcImhhbmRsZU1vdXNlZG93blwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RMaXN0ZW5lcihcImNsaWNrXCIpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnJldHVybnR5cGVcIiwgdm9pZCAwKVxuXSwgTXVsdGlWaWV3Q2FsZW5kYXJDb21wb25lbnQucHJvdG90eXBlLCBcImhhbmRsZUNsaWNrXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSG9zdExpc3RlbmVyKFwia2V5ZG93blwiLCBbXCIkZXZlbnRcIl0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtPYmplY3RdKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnJldHVybnR5cGVcIiwgdm9pZCAwKVxuXSwgTXVsdGlWaWV3Q2FsZW5kYXJDb21wb25lbnQucHJvdG90eXBlLCBcImtleWRvd25cIiwgbnVsbCk7XG5NdWx0aVZpZXdDYWxlbmRhckNvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICBleHBvcnRBczogJ2tlbmRvLW11bHRpdmlld2NhbGVuZGFyJyxcbiAgICAgICAgcHJvdmlkZXJzOiBbXG4gICAgICAgICAgICBCdXNWaWV3U2VydmljZSxcbiAgICAgICAgICAgIFJBTkdFX0NBTEVOREFSX1ZBTFVFX0FDQ0VTU09SLFxuICAgICAgICAgICAgUkFOR0VfQ0FMRU5EQVJfUkFOR0VfVkFMSURBVE9SUyxcbiAgICAgICAgICAgIExvY2FsaXphdGlvblNlcnZpY2UsXG4gICAgICAgICAgICBEaXNhYmxlZERhdGVzU2VydmljZSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBwcm92aWRlOiBMMTBOX1BSRUZJWCxcbiAgICAgICAgICAgICAgICB1c2VWYWx1ZTogJ2tlbmRvLm11bHRpdmlld2NhbGVuZGFyJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIE5hdmlnYXRpb25TZXJ2aWNlLFxuICAgICAgICAgICAgU2VsZWN0aW9uU2VydmljZVxuICAgICAgICBdLFxuICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLW11bHRpdmlld2NhbGVuZGFyJyxcbiAgICAgICAgdGVtcGxhdGU6IGBcbiAgICA8bmctY29udGFpbmVyIGtlbmRvTXVsdGlWaWV3Q2FsZW5kYXJMb2NhbGl6ZWRNZXNzYWdlc1xuICAgICAgICBpMThuLXRvZGF5PVwia2VuZG8ubXVsdGl2aWV3Y2FsZW5kYXIudG9kYXl8VGhlIGxhYmVsIGZvciB0aGUgdG9kYXkgYnV0dG9uIGluIHRoZSBjYWxlbmRhciBoZWFkZXJcIlxuICAgICAgICB0b2RheT1cIlRvZGF5XCJcblxuICAgICAgICBpMThuLXByZXZCdXR0b25UaXRsZT1cImtlbmRvLm11bHRpdmlld2NhbGVuZGFyLnByZXZCdXR0b25UaXRsZXxUaGUgbGFiZWwgZm9yIHRoZSBwcmV2aW91cyBidXR0b24gaW4gdGhlIE11bHRpdmlldyBjYWxlbmRhclwiXG4gICAgICAgIHByZXZCdXR0b25UaXRsZT1cIk5hdmlnYXRlIHRvIHByZXZpb3VzIHZpZXdcIlxuXG4gICAgICAgIGkxOG4tbmV4dEJ1dHRvblRpdGxlPVwia2VuZG8ubXVsdGl2aWV3Y2FsZW5kYXIubmV4dEJ1dHRvblRpdGxlfFRoZSBsYWJlbCBmb3IgdGhlIG5leHQgYnV0dG9uIGluIHRoZSBNdWx0aXZpZXcgY2FsZW5kYXJcIlxuICAgICAgICBuZXh0QnV0dG9uVGl0bGU9XCJOYXZpZ2F0ZSB0byBuZXh0IHZpZXdcIlxuICAgID5cbiAgICA8L25nLWNvbnRhaW5lcj5cbiAgICA8a2VuZG8tY2FsZW5kYXItaGVhZGVyXG4gICAgICAgIFthY3RpdmVWaWV3XT1cImFjdGl2ZVZpZXdFbnVtXCJcbiAgICAgICAgW2N1cnJlbnREYXRlXT1cImFjdGl2ZURhdGVcIlxuICAgICAgICBbbWluXT1cIm1pblwiXG4gICAgICAgIFttYXhdPVwibWF4XCJcbiAgICAgICAgW3JhbmdlTGVuZ3RoXT1cInZpZXdzXCJcbiAgICAgICAgW3RlbXBsYXRlUmVmXT1cImhlYWRlclRpdGxlVGVtcGxhdGU/LnRlbXBsYXRlUmVmXCJcbiAgICAgICAgW2lzUHJldkRpc2FibGVkXT1cImlzUHJldkRpc2FibGVkXCJcbiAgICAgICAgW2lzTmV4dERpc2FibGVkXT1cImlzTmV4dERpc2FibGVkXCJcbiAgICAgICAgW3Nob3dOYXZpZ2F0aW9uQnV0dG9uc109XCJ0cnVlXCJcbiAgICAgICAgKHRvZGF5QnV0dG9uQ2xpY2spPVwiaGFuZGxlRGF0ZUNoYW5nZSh7IHNlbGVjdGVkRGF0ZXM6IFskZXZlbnRdLCBmb2N1c2VkRGF0ZTogJGV2ZW50IH0pXCJcbiAgICAgICAgKHByZXZCdXR0b25DbGljayk9XCJuYXZpZ2F0ZShwcmV2VmlldylcIlxuICAgICAgICAobmV4dEJ1dHRvbkNsaWNrKT1cIm5hdmlnYXRlKG5leHRWaWV3KVwiXG4gICAgPlxuICAgIDwva2VuZG8tY2FsZW5kYXItaGVhZGVyPlxuICAgIDxrZW5kby1jYWxlbmRhci1ob3Jpem9udGFsXG4gICAgICAgIFthY3RpdmVWaWV3XT1cImFjdGl2ZVZpZXdFbnVtXCJcbiAgICAgICAgW2lzQWN0aXZlXT1cImlzQWN0aXZlIHx8IGlzSG92ZXJlZFwiXG4gICAgICAgIFtjZWxsVGVtcGxhdGVSZWZdPVwiYWN0aXZlQ2VsbFRlbXBsYXRlKCk/LnRlbXBsYXRlUmVmXCJcbiAgICAgICAgW3dlZWtOdW1iZXJUZW1wbGF0ZVJlZl09XCJ3ZWVrTnVtYmVyVGVtcGxhdGU/LnRlbXBsYXRlUmVmXCJcbiAgICAgICAgW2NlbGxVSURdPVwiY2VsbFVJRFwiXG4gICAgICAgIFt2aWV3c109XCJ2aWV3c1wiXG4gICAgICAgIFttaW5dPVwibWluXCJcbiAgICAgICAgW21heF09XCJtYXhcIlxuICAgICAgICBbZm9jdXNlZERhdGVdPVwiZm9jdXNlZERhdGVcIlxuICAgICAgICBbYW5pbWF0ZU5hdmlnYXRpb25dPVwiYW5pbWF0ZU5hdmlnYXRpb25cIlxuICAgICAgICBbc2hvd1ZpZXdIZWFkZXJdPVwic2hvd1ZpZXdIZWFkZXJcIlxuICAgICAgICBbd2Vla051bWJlcl09XCJ3ZWVrTnVtYmVyXCJcbiAgICAgICAgW2FjdGl2ZVJhbmdlRW5kXT1cImFjdGl2ZVJhbmdlRW5kXCJcbiAgICAgICAgW3NlbGVjdGlvblJhbmdlXT1cInNlbGVjdGlvblJhbmdlXCJcbiAgICAgICAgW3NlbGVjdGVkRGF0ZXNdPVwic2VsZWN0ZWREYXRlc1wiXG4gICAgICAgICh2YWx1ZUNoYW5nZSk9XCJoYW5kbGVEYXRlQ2hhbmdlKCRldmVudClcIlxuICAgICAgICAoY2VsbENsaWNrKT1cImhhbmRsZUNlbGxDbGljaygkZXZlbnQpXCJcbiAgICAgICAgKHdlZWtOdW1iZXJDZWxsQ2xpY2spPVwiaGFuZGxlV2Vla051bWJlckNsaWNrKCRldmVudClcIlxuICAgICAgICAoY2VsbEVudGVyKT1cImVtaXRDZWxsRXZlbnQoY2VsbEVudGVyLCAkZXZlbnQpXCJcbiAgICAgICAgKGNlbGxMZWF2ZSk9XCJlbWl0Q2VsbEV2ZW50KGNlbGxMZWF2ZSwgJGV2ZW50KVwiXG4gICAgICAgIChhY3RpdmVEYXRlQ2hhbmdlKT1cInNldEFjdGl2ZURhdGUoJGV2ZW50KVwiXG4gICAgPlxuICAgIDwva2VuZG8tY2FsZW5kYXItaG9yaXpvbnRhbD5cbiAgYFxuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQnVzVmlld1NlcnZpY2UsXG4gICAgICAgIEVsZW1lbnRSZWYsXG4gICAgICAgIE5hdmlnYXRpb25TZXJ2aWNlLFxuICAgICAgICBSZW5kZXJlcjIsXG4gICAgICAgIENoYW5nZURldGVjdG9yUmVmLFxuICAgICAgICBOZ1pvbmUsXG4gICAgICAgIERpc2FibGVkRGF0ZXNTZXJ2aWNlLFxuICAgICAgICBTZWxlY3Rpb25TZXJ2aWNlXSlcbl0sIE11bHRpVmlld0NhbGVuZGFyQ29tcG9uZW50KTtcblxuLyoqXG4gKiBBIGRpcmVjdGl2ZSB3aGljaCByZW5kZXJzIHRoZSBjb250ZW50IG9mIHRoZSBEYXRlUmFuZ2UgUG9wdXAuIFRvIGRlZmluZSB0aGUgY2VsbCB0ZW1wbGF0ZSwgbmVzdCBhblxuICogYDxuZy10ZW1wbGF0ZT5gIHRhZyB3aXRoIHRoZSBga2VuZG9SYW5nZVBvcHVwVGVtcGxhdGVgIGRpcmVjdGl2ZSBpbnNpZGUgdGhlIGNvbXBvbmVudCB0YWcuXG4gKi9cbmxldCBEYXRlUmFuZ2VQb3B1cFRlbXBsYXRlRGlyZWN0aXZlID0gY2xhc3MgRGF0ZVJhbmdlUG9wdXBUZW1wbGF0ZURpcmVjdGl2ZSB7XG4gICAgY29uc3RydWN0b3IodGVtcGxhdGVSZWYpIHtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZVJlZiA9IHRlbXBsYXRlUmVmO1xuICAgIH1cbn07XG5EYXRlUmFuZ2VQb3B1cFRlbXBsYXRlRGlyZWN0aXZlID0gX19kZWNvcmF0ZShbXG4gICAgRGlyZWN0aXZlKHtcbiAgICAgICAgc2VsZWN0b3I6ICdba2VuZG9EYXRlUmFuZ2VQb3B1cFRlbXBsYXRlXSdcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW1RlbXBsYXRlUmVmXSlcbl0sIERhdGVSYW5nZVBvcHVwVGVtcGxhdGVEaXJlY3RpdmUpO1xuXG5jb25zdCBpc0FjdGl2ZSA9IChjbXApID0+IChjbXAgJiYgY21wLmlzQWN0aXZlKSB8fCBmYWxzZTtcbmNvbnN0IGhhc0FjdGl2ZUNvbnRlbnQgPSAocG9wdXApID0+IHBvcHVwICYmIHBvcHVwLmhhc0FjdGl2ZUNvbnRlbnQoKTtcbi8qKlxuICogQSBzZXJ2aWNlIHRoYXQgaGFuZGxlcyB0aGUgY29tbXVuaWNhdGlvbiBiZXR3ZWVuIHRoZSBjb21wb25lbnRzIHRoYXQgYXJlIHBsYWNlZCBpbnNpZGUgdGhlIERhdGVSYW5nZUNvbXBvbmVudC5cbiAqIEZvciBleGFtcGxlLCB0aGUgc3RhcnQgYW5kIGVuZCBgRGF0ZUlucHV0YCBhbmQgYERhdGVSYW5nZVBvcHVwYCBjb21wb25lbnRzLlxuICovXG5sZXQgRGF0ZVJhbmdlU2VydmljZSA9IGNsYXNzIERhdGVSYW5nZVNlcnZpY2Uge1xuICAgIC8qKlxuICAgICAqIEEgc2VydmljZSB0aGF0IGhhbmRsZXMgdGhlIGNvbW11bmljYXRpb24gYmV0d2VlbiB0aGUgY29tcG9uZW50cyB0aGF0IGFyZSBwbGFjZWQgaW5zaWRlIHRoZSBEYXRlUmFuZ2VDb21wb25lbnQuXG4gICAgICogRm9yIGV4YW1wbGUsIHRoZSBzdGFydCBhbmQgZW5kIGBEYXRlSW5wdXRgIGFuZCBgRGF0ZVJhbmdlUG9wdXBgIGNvbXBvbmVudHMuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbiBPYnNlcnZhYmxlIGluc3RhbmNlIHRoYXQgbm90aWZpZXMgd2hlbiB0aGUgYGFjdGl2ZVJhbmdlRW5kYCBzdGF0ZSBpcyBjaGFuZ2VkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hY3RpdmVSYW5nZUVuZCQgPSBuZXcgQmVoYXZpb3JTdWJqZWN0KG51bGwpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQW4gT2JzZXJ2YWJsZSBpbnN0YW5jZSB0aGF0IG5vdGlmaWVzIHdoZW4gdGhlIGBmb2N1c2VkRGF0ZWAgaXMgY2hhbmdlZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZm9jdXNlZERhdGUkID0gbmV3IEJlaGF2aW9yU3ViamVjdChudWxsKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuIE9ic2VydmFibGUgaW5zdGFuY2UgdGhhdCBub3RpZmllcyB3aGVuIHRoZSBlbmQgYERhdGVJbnB1dGAgY29tcG9uZW50IGlzIGNoYW5nZWQuXG4gICAgICAgICAqIEZvciBleGFtcGxlLCB3aGVuIGEgbmV3IGVuZCBgRGF0ZUlucHV0YCBpcyBhdHRhY2hlZCBvciB3aGVuIHRoZSBvbGQgb25lIGlzIGRldGFjaGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5lbmRJbnB1dCQgPSBuZXcgQmVoYXZpb3JTdWJqZWN0KG51bGwpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQW4gT2JzZXJ2YWJsZSBpbnN0YW5jZSB0aGF0IG5vdGlmaWVzIHdoZW4gdGhlIHN0YXJ0IGBEYXRlSW5wdXRgIGNvbXBvbmVudCBpcyBjaGFuZ2VkLlxuICAgICAgICAgKiBGb3IgZXhhbXBsZSwgd2hlbiBhIG5ldyBzdGFydCBgRGF0ZUlucHV0YCBpcyBhdHRhY2hlZCBvciB0aGUgb2xkIG9uZSBpcyBkZXRhY2hlZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3RhcnRJbnB1dCQgPSBuZXcgQmVoYXZpb3JTdWJqZWN0KG51bGwpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQW4gT2JzZXJ2YWJsZSBpbnN0YW5jZSB0aGF0IG5vdGlmaWVzIHdoZW4gdGhlIGBEYXRlUmFuZ2VQb3B1cGAgY29tcG9uZW50IGlzIGNoYW5nZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRhdGVSYW5nZVBvcHVwJCA9IG5ldyBCZWhhdmlvclN1YmplY3QobnVsbCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbiBPYnNlcnZhYmxlIGluc3RhbmNlIHRoYXQgbm90aWZpZXMgd2hlbiB0aGUgc3RhdGUgb2YgdGhlIHNlbGVjdGlvbiByYW5nZSBpcyBjaGFuZ2VkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yYW5nZSQgPSBuZXcgQmVoYXZpb3JTdWJqZWN0KEVNUFRZX1NFTEVDVElPTlJBTkdFKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgY3VycmVudCBgYWN0aXZlUmFuZ2VFbmRgIHZhbHVlLlxuICAgICAqL1xuICAgIGdldCBhY3RpdmVSYW5nZUVuZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWN0aXZlUmFuZ2VFbmQkLnZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBjdXJyZW50IGBmb2N1c2VkRGF0ZWAgdmFsdWUuXG4gICAgICovXG4gICAgZ2V0IGZvY3VzZWREYXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mb2N1c2VkRGF0ZSQudmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGBtaW5gIHJhbmdlIHZhbHVlLlxuICAgICAqIFRoZSBgbWluYCB2YWx1ZSBpcyBleHRyYWN0ZWQgZnJvbSB0aGUgYHN0YXJ0YCBEYXRlSW5wdXQgdmFsdWUgb3IgdGhlIGBtaW5gIHZhbHVlIG9mIHRoZSBDYWxlbmRhci5cbiAgICAgKi9cbiAgICBnZXQgbWluKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuc3RhcnRJbnB1dCQudmFsdWUgfHwge30pLm1pbiB8fCBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBgbWF4YCByYW5nZSB2YWx1ZS5cbiAgICAgKiBUaGUgYG1heGAgdmFsdWUgaXMgZXh0cmFjdGVkIGZyb20gdGhlIGBlbmRgIERhdGVJbnB1dCB2YWx1ZSBvciB0aGUgYG1heGAgdmFsdWUgb2YgdGhlIENhbGVuZGFyLlxuICAgICAqL1xuICAgIGdldCBtYXgoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5lbmRJbnB1dCQudmFsdWUgfHwge30pLm1heCB8fCBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBjdXJyZW50IGBzZWxlY3Rpb25SYW5nZWAgdmFsdWUuXG4gICAgICovXG4gICAgZ2V0IHNlbGVjdGlvblJhbmdlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yYW5nZSQudmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFjdGl2YXRlcyB0aGUgcmVnaXN0ZXJlZCBgRGF0ZVJhbmdlUG9wdXBgIGNvbXBvbmVudC5cbiAgICAgKiBUaGUgbWV0aG9kIG9wZW5zIHRoZSBwb3B1cCBhbmQgZm9jdXNlcyB0aGUgY2FsZW5kYXIuXG4gICAgICovXG4gICAgYWN0aXZhdGVQb3B1cCgpIHtcbiAgICAgICAgY29uc3QgZGF0ZVJhbmdlUG9wdXAgPSB0aGlzLmRhdGVSYW5nZVBvcHVwJC52YWx1ZTtcbiAgICAgICAgaWYgKCFkYXRlUmFuZ2VQb3B1cCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGRhdGVSYW5nZVBvcHVwLmFjdGl2YXRlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlYWN0aXZhdGVzIHRoZSByZWdpc3RlcmVkIGBEYXRlUmFuZ2VQb3B1cGAgY29tcG9uZW50LlxuICAgICAqIFRoZSBtZXRob2QgY2xvc2VzIHRoZSBwb3B1cC5cbiAgICAgKi9cbiAgICBkZWFjdGl2YXRlUG9wdXAoKSB7XG4gICAgICAgIGNvbnN0IGRhdGVSYW5nZVBvcHVwID0gdGhpcy5kYXRlUmFuZ2VQb3B1cCQudmFsdWU7XG4gICAgICAgIGlmICghKGRhdGVSYW5nZVBvcHVwICYmIGRhdGVSYW5nZVBvcHVwLnNob3cpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZGF0ZVJhbmdlUG9wdXAuc2hvdyA9IGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICpcbiAgICAgKiBEZWFjdGl2YXRlcyB0aGUgcmVnaXN0ZXJlZCBgRGF0ZVJhbmdlUG9wdXBgIGNvbXBvbmVudCBhbmQgZmlyZXMgdGhlIGBjYW5jZWxgIGV2ZW50LlxuICAgICAqIFRoZSBtZXRob2QgY2xvc2VzIHRoZSBwb3B1cC5cbiAgICAgKi9cbiAgICBjYW5jZWxQb3B1cCgpIHtcbiAgICAgICAgY29uc3QgZGF0ZVJhbmdlUG9wdXAgPSB0aGlzLmRhdGVSYW5nZVBvcHVwJC52YWx1ZTtcbiAgICAgICAgaWYgKCEoZGF0ZVJhbmdlUG9wdXAgJiYgZGF0ZVJhbmdlUG9wdXAuc2hvdykpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBkYXRlUmFuZ2VQb3B1cC5jYW5jZWxQb3B1cCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb21wbGV0ZXMgYWxsIG9ic2VydmFibGVzIHRvIG1pdGlnYXRlIHBvc3NpYmxlIG1lbW9yeSBsZWFrcy5cbiAgICAgKiBDYWxscyB0aGUgbWV0aG9kIHdoZW4gYSBjb21wb25lbnQgdGhhdCB1c2VzIGl0IGlzIGRlc3Ryb3llZC5cbiAgICAgKi9cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLmFjdGl2ZVJhbmdlRW5kJC5jb21wbGV0ZSgpO1xuICAgICAgICB0aGlzLmRhdGVSYW5nZVBvcHVwJC5jb21wbGV0ZSgpO1xuICAgICAgICB0aGlzLmZvY3VzZWREYXRlJC5jb21wbGV0ZSgpO1xuICAgICAgICB0aGlzLmVuZElucHV0JC5jb21wbGV0ZSgpO1xuICAgICAgICB0aGlzLnN0YXJ0SW5wdXQkLmNvbXBsZXRlKCk7XG4gICAgICAgIHRoaXMucmFuZ2UkLmNvbXBsZXRlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYHRydWVgIHdoZW4gYW4gYWN0aXZlIGNvbXBvbmVudCB0aGF0IGlzIHBsYWNlZCBpbnNpZGUgdGhlIGBEYXRlUmFuZ2VDb21wb25lbnRgIGlzIGRldGVjdGVkLlxuICAgICAqIEZvciBleGFtcGxlLCB0aGUgb3BlbmVkIHBvcHVwIG9yIHRoZSBmb2N1c2VkIERhdGVJbnB1dC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIGB0cnVlYCBpZiBhbiBhY3RpdmUgY29tcG9uZW50IGlzIHByZXNlbnQuXG4gICAgICovXG4gICAgaGFzQWN0aXZlQ29tcG9uZW50KCkge1xuICAgICAgICBjb25zdCBwb3B1cCA9IHRoaXMuZGF0ZVJhbmdlUG9wdXAkLnZhbHVlO1xuICAgICAgICBjb25zdCBpc1BvcHVwID0gaXNBY3RpdmUocG9wdXApO1xuICAgICAgICBjb25zdCBpc1N0YXJ0ID0gaXNBY3RpdmUodGhpcy5zdGFydElucHV0JC52YWx1ZSk7XG4gICAgICAgIGNvbnN0IGlzRW5kID0gaXNBY3RpdmUodGhpcy5lbmRJbnB1dCQudmFsdWUpO1xuICAgICAgICByZXR1cm4gaXNQb3B1cCB8fCBpc1N0YXJ0IHx8IGlzRW5kIHx8IGhhc0FjdGl2ZUNvbnRlbnQocG9wdXApIHx8IGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgYSBuZXcgc3RhcnQgYERhdGVJbnB1dGAgY29tcG9uZW50LiBOb3RpZmllcyBhbGwgYHN0YXJ0SW5wdXQkYCBsaXN0ZW5lcnMuXG4gICAgICovXG4gICAgcmVnaXN0ZXJTdGFydElucHV0KHN0YXJ0SW5wdXQpIHtcbiAgICAgICAgdGhpcy5zdGFydElucHV0JC5uZXh0KHN0YXJ0SW5wdXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgYSBuZXcgZW5kIGBEYXRlSW5wdXRgIGNvbXBvbmVudC4gTm90aWZpZXMgYWxsIGBlbmRJbnB1dCRgIGxpc3RlbmVycy5cbiAgICAgKi9cbiAgICByZWdpc3RlckVuZElucHV0KGVuZElucHV0KSB7XG4gICAgICAgIHRoaXMuZW5kSW5wdXQkLm5leHQoZW5kSW5wdXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgYSBuZXcgYERhdGVSYW5nZVBvcHVwYCBjb21wb25lbnQuIE5vdGlmaWVzIGFsbCBgZGF0ZVJhbmdlUG9wdXAkYCBsaXN0ZW5lcnMuXG4gICAgICovXG4gICAgcmVnaXN0ZXJQb3B1cChkYXRlUmFuZ2VQb3B1cCkge1xuICAgICAgICB0aGlzLmRhdGVSYW5nZVBvcHVwJC5uZXh0KGRhdGVSYW5nZVBvcHVwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgYGFjdGl2ZVJhbmdlRW5kYCB2YWx1ZS4gTm90aWZpZXMgYWxsIGBhY3RpdmVSYW5nZUVuZCRgIGxpc3RlbmVycy5cbiAgICAgKi9cbiAgICBzZXRBY3RpdmVSYW5nZUVuZChhY3RpdmVSYW5nZSkge1xuICAgICAgICBpZiAoIWFjdGl2ZVJhbmdlIHx8IHRoaXMuYWN0aXZlUmFuZ2VFbmQgPT09IGFjdGl2ZVJhbmdlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hY3RpdmVSYW5nZUVuZCQubmV4dChhY3RpdmVSYW5nZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIGZvY3VzZWQgZGF0ZS4gTm90aWZpZXMgYWxsIGBmb2N1c2VkRGF0ZSRgIGxpc3RlbmVycy5cbiAgICAgKi9cbiAgICBzZXRGb2N1c2VkRGF0ZSh2YWx1ZSkge1xuICAgICAgICBpZiAoaXNFcXVhbCh0aGlzLmZvY3VzZWREYXRlJC52YWx1ZSwgdmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5mb2N1c2VkRGF0ZSQubmV4dCh2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIHNlbGVjdGlvbiByYW5nZS4gTm90aWZpZXMgYWxsIGByYW5nZSRgIGxpc3RlbmVycy5cbiAgICAgKi9cbiAgICBzZXRSYW5nZShyYW5nZSA9IEVNUFRZX1NFTEVDVElPTlJBTkdFKSB7XG4gICAgICAgIHRoaXMucmFuZ2UkLm5leHQocmFuZ2UpO1xuICAgIH1cbn07XG5EYXRlUmFuZ2VTZXJ2aWNlID0gX19kZWNvcmF0ZShbXG4gICAgSW5qZWN0YWJsZSgpXG5dLCBEYXRlUmFuZ2VTZXJ2aWNlKTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBLZW5kbyBVSSBEYXRlUmFuZ2VQb3B1cCBjb21wb25lbnQgZm9yIEFuZ3VsYXIuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBEYXRlSW5wdXRzTW9kdWxlLCBEYXRlUmFuZ2VTZXJ2aWNlIH0gZnJvbSAnQHByb2dyZXNzL2tlbmRvLWFuZ3VsYXItZGF0ZWlucHV0cyc7XG4gKlxuICogX0BDb21wb25lbnQoe1xuICogcHJvdmlkZXJzOiBbRGF0ZVJhbmdlU2VydmljZV0sXG4gKiBzZWxlY3RvcjogJ215LWFwcCcsXG4gKiB0ZW1wbGF0ZTogYFxuICogIDxidXR0b24gI2FuY2hvciAoY2xpY2spPVwicG9wdXAudG9nZ2xlKClcIj5Ub2dnbGU8L2J1dHRvbj5cbiAqICA8a2VuZG8tZGF0ZXJhbmdlLXBvcHVwIFthbmNob3JdPVwiYW5jaG9yXCIgI3BvcHVwPjwva2VuZG8tZGF0ZXJhbmdlLXBvcHVwPlxuICogYFxuICogfSlcbiAqIGV4cG9ydCBjbGFzcyBBcHBDb21wb25lbnQge1xuICogfVxuICogYGBgXG4gKi9cbmxldCBEYXRlUmFuZ2VQb3B1cENvbXBvbmVudCA9IGNsYXNzIERhdGVSYW5nZVBvcHVwQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihwb3B1cFNlcnZpY2UsIGRhdGVSYW5nZVNlcnZpY2UsIHJlZiwgem9uZSwgcnRsKSB7XG4gICAgICAgIHRoaXMucG9wdXBTZXJ2aWNlID0gcG9wdXBTZXJ2aWNlO1xuICAgICAgICB0aGlzLmRhdGVSYW5nZVNlcnZpY2UgPSBkYXRlUmFuZ2VTZXJ2aWNlO1xuICAgICAgICB0aGlzLnJlZiA9IHJlZjtcbiAgICAgICAgdGhpcy56b25lID0gem9uZTtcbiAgICAgICAgdGhpcy5ydGwgPSBydGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb250cm9scyB0aGUgcG9wdXAgYW5pbWF0aW9uLlxuICAgICAgICAgKiBCeSBkZWZhdWx0LCB0aGUgb3BlbmluZyBhbmQgY2xvc2luZyBhbmltYXRpb25zIGFyZSBlbmFibGVkLlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBhYm91dCBjb250cm9sbGluZyB0aGUgcG9wdXAgYW5pbWF0aW9ucyxcbiAgICAgICAgICogcmVmZXIgdG8gdGhlIGFydGljbGUgb24gW2FuaW1hdGlvbnNdKHslIHNsdWcgYW5pbWF0aW9uc19wb3B1cCAlfSkuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmFuaW1hdGUgPSB0cnVlO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ29uZmlndXJlcyB0aGUgY29sbGlzaW9uIGJlaGF2aW9yIG9mIHRoZSBwb3B1cC5cbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBhcnRpY2xlIG9uXG4gICAgICAgICAqIFt2aWV3cG9ydCBib3VuZGFyeSBkZXRlY3Rpb25dKHslIHNsdWcgdmlld3BvcnRib3VuZGFyeWRldGVjdGlvbl9wb3B1cCAlfSkuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNvbGxpc2lvbiA9IHsgaG9yaXpvbnRhbDogJ2ZpdCcsIHZlcnRpY2FsOiAnZmxpcCcgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIGVhY2ggdGltZSB0aGUgcG9wdXAgaXMgYWJvdXQgdG8gb3Blbi5cbiAgICAgICAgICogVGhpcyBldmVudCBpcyBwcmV2ZW50YWJsZS4gSWYgeW91IGNhbmNlbCB0aGUgZXZlbnQsIHRoZSBwb3B1cCB3aWxsIHJlbWFpbiBjbG9zZWQuXG4gICAgICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgc2VjdGlvbiBvblxuICAgICAgICAgKiBbZXZlbnRzXSh7JSBzbHVnIG92ZXJ2aWV3X2RhdGVwaWNrZXIgJX0jdG9jLWV2ZW50cykuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9wZW4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyBlYWNoIHRpbWUgdGhlIHBvcHVwIGlzIGFib3V0IHRvIGNsb3NlLlxuICAgICAgICAgKiBUaGlzIGV2ZW50IGlzIHByZXZlbnRhYmxlLiBJZiB5b3UgY2FuY2VsIHRoZSBldmVudCwgdGhlIHBvcHVwIHdpbGwgcmVtYWluIG9wZW4uXG4gICAgICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgc2VjdGlvbiBvblxuICAgICAgICAgKiBbZXZlbnRzXSh7JSBzbHVnIG92ZXJ2aWV3X2RhdGVwaWNrZXIgJX0jdG9jLWV2ZW50cykuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNsb3NlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgZWFjaCB0aW1lIHRoZSBjYWxlbmRhciBlbGVtZW50IGlzIGJsdXJyZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9uQmx1ciA9IG5ldyBFdmVudEVtaXR0ZXIoKTsgLy90c2xpbnQ6ZGlzYWJsZS1saW5lOm5vLW91dHB1dC1yZW5hbWVcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIGVhY2ggdGltZSB0aGUgY2FsZW5kYXIgZWxlbWVudCBpcyBmb2N1c2VkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vbkZvY3VzID0gbmV3IEV2ZW50RW1pdHRlcigpOyAvL3RzbGludDpkaXNhYmxlLWxpbmU6bm8tb3V0cHV0LXJlbmFtZVxuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgZWFjaCB0aW1lIHRoZSBwb3B1cCBpcyBjbG9zZWQgZWl0aGVyIG9uIGBFU0NgIGtleXByZXNzIG9yIG9uIGxlYXZpbmcgdGhlIHZpZXdwb3J0LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jYW5jZWwgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaGlkZGVuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnBvcHVwVUlEID0gZ3VpZCgpO1xuICAgICAgICB0aGlzLmNhbGVuZGFyU3Vic2NyaXB0aW9ucyA9IG5ldyBTdWJzY3JpcHRpb24oKCkgPT4geyB9KTtcbiAgICAgICAgdGhpcy5wb3B1cFN1YnNjcmlwdGlvbnMgPSBuZXcgU3Vic2NyaXB0aW9uKCgpID0+IHsgfSk7XG4gICAgICAgIHRoaXMucmVzb2x2ZWRQcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBhY3RpdmUgY2FsZW5kYXIgdGhhdCBpcyB2aXNpYmxlIGluIHRoZSBwb3B1cC5cbiAgICAgKlxuICAgICAqID4gV2hlbiB0aGUgcG9wdXAgaXMgY2xvc2VkLCB0aGUgcHJvcGVydHkgcmV0dXJucyBgbnVsbGAuXG4gICAgICovXG4gICAgZ2V0IGNhbGVuZGFyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2FsZW5kYXI7XG4gICAgfVxuICAgIHNldCBjYWxlbmRhcihjYWxlbmRhcikge1xuICAgICAgICB0aGlzLl9jYWxlbmRhciA9IGNhbGVuZGFyO1xuICAgICAgICB0aGlzLnN1YnNjcmliZUZvY3VzQmx1cihjYWxlbmRhcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGFjdGl2ZSBzdGF0ZSBvZiB0aGUgY29tcG9uZW50LlxuICAgICAqIFdoZW4gdGhlIG9wZW5lZCBjYWxlbmRhciBpcyBhY3RpdmUsIHJldHVybnMgYHRydWVgLlxuICAgICAqL1xuICAgIGdldCBpc0FjdGl2ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsZW5kYXIgJiYgdGhpcy5jYWxlbmRhci5pc0FjdGl2ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyBvciBzZXRzIHRoZSB2aXNpYmlsaXR5IHN0YXRlIG9mIHRoZSBjb21wb25lbnQuXG4gICAgICovXG4gICAgc2V0IHNob3coc2hvdykge1xuICAgICAgICBpZiAodGhpcy5fc2hvdyA9PT0gc2hvdykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGV2ZW50ID0gbmV3IFByZXZlbnRhYmxlRXZlbnQoKTtcbiAgICAgICAgaWYgKHNob3cpIHtcbiAgICAgICAgICAgIHRoaXMub3Blbi5lbWl0KGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY2xvc2UuZW1pdChldmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdG9nZ2xlKHNob3cpO1xuICAgIH1cbiAgICBnZXQgc2hvdygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Nob3c7XG4gICAgfVxuICAgIG5nT25Jbml0KCkge1xuICAgICAgICB0aGlzLmRhdGVSYW5nZVNlcnZpY2UucmVnaXN0ZXJQb3B1cCh0aGlzKTtcbiAgICB9XG4gICAgbmdBZnRlclZpZXdJbml0KCkge1xuICAgICAgICB0aGlzLmNhbGVuZGFyU3Vic2NyaXB0aW9ucy5hZGQodGhpcy5jb250ZW50Q2FsZW5kYXIuY2hhbmdlcy5zdWJzY3JpYmUoKGNoYW5nZXMpID0+IHRoaXMuY2FsZW5kYXIgPSBjaGFuZ2VzLmZpcnN0KSk7XG4gICAgICAgIHRoaXMuY2FsZW5kYXJTdWJzY3JpcHRpb25zLmFkZCh0aGlzLnZpZXdDYWxlbmRhci5jaGFuZ2VzLnN1YnNjcmliZSgoY2hhbmdlcykgPT4gdGhpcy5jYWxlbmRhciA9IGNoYW5nZXMuZmlyc3QpKTtcbiAgICAgICAgaWYgKGlzV2luZG93QXZhaWxhYmxlKCkpIHtcbiAgICAgICAgICAgIHRoaXMuem9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB0aGlzLndpbmRvd0JsdXJTdWJzY3JpcHRpb24gPSBmcm9tRXZlbnQod2luZG93LCAnYmx1cicpLnN1YnNjcmliZSh0aGlzLmhhbmRsZVdpbmRvd0JsdXIuYmluZCh0aGlzKSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICB0aGlzLmRlc3Ryb3lQb3B1cCgpO1xuICAgICAgICB0aGlzLmNhbGVuZGFyU3Vic2NyaXB0aW9ucy51bnN1YnNjcmliZSgpO1xuICAgICAgICBpZiAodGhpcy5hY3RpdmF0ZVN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgdGhpcy5hY3RpdmF0ZVN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmJsdXJTdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuYmx1clN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgdGhpcy5mb2N1c1N1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLndpbmRvd0JsdXJTdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMud2luZG93Qmx1clN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBPcGVucyB0aGUgcG9wdXAgY29tcG9uZW50IGFuZCBmb2N1c2VzIHRoZSBjYWxlbmRhci5cbiAgICAgKi9cbiAgICBhY3RpdmF0ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuc2hvdyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmFjdGl2YXRlU3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmFjdGl2YXRlU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zaG93ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5yZWYubWFya0ZvckNoZWNrKCk7XG4gICAgICAgIHRoaXMuem9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmFjdGl2YXRlU3Vic2NyaXB0aW9uID0gbWVyZ2UodGhpcy5jb250ZW50Q2FsZW5kYXIuY2hhbmdlcywgdGhpcy52aWV3Q2FsZW5kYXIuY2hhbmdlcylcbiAgICAgICAgICAgICAgICAucGlwZShmaWx0ZXIoY2hhbmdlcyA9PiBjaGFuZ2VzICYmIGNoYW5nZXMuZmlyc3QpLCBtYXAoY2hhbmdlcyA9PiBjaGFuZ2VzLmZpcnN0KSlcbiAgICAgICAgICAgICAgICAuc3Vic2NyaWJlKChjYWxlbmRhcikgPT4gc2V0VGltZW91dCgoKSA9PiBjYWxlbmRhci5mb2N1cygpKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgRm9jdXNlcyB0aGUgY2FsZW5kYXIgKGlmIGF2YWlsYWJsZSkuXG4gICAgICovXG4gICAgZm9jdXMoKSB7XG4gICAgICAgIGlmICh0aGlzLmNhbGVuZGFyKSB7XG4gICAgICAgICAgICB0aGlzLmNhbGVuZGFyLmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGEgZm9jdXNlZCBlbGVtZW50IGlkcyBwbGFjZWQgaW5zaWRlIHRoZSBwb3B1cC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gYm9vbGVhbjtcbiAgICAgKi9cbiAgICBoYXNBY3RpdmVDb250ZW50KCkge1xuICAgICAgICBpZiAoIWlzRG9jdW1lbnRBdmFpbGFibGUoKSB8fCAhdGhpcy5wb3B1cFJlZikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnBvcHVwUmVmLnBvcHVwRWxlbWVudC5jb250YWlucyhkb2N1bWVudC5hY3RpdmVFbGVtZW50KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVG9nZ2xlcyB0aGUgdmlzaWJpbGl0eSBvZiB0aGUgcG9wdXAuXG4gICAgICogSWYgeW91IHVzZSB0aGUgYHRvZ2dsZWAgbWV0aG9kIHRvIHNob3cgb3IgaGlkZSB0aGUgcG9wdXAsXG4gICAgICogdGhlIGBvcGVuYCBhbmQgYGNsb3NlYCBldmVudHMgZG8gbm90IGZpcmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc2hvdyBUaGUgc3RhdGUgb2YgdGhlIHBvcHVwLlxuICAgICAqL1xuICAgIHRvZ2dsZShzaG93KSB7XG4gICAgICAgIHRoaXMucmVzb2x2ZWRQcm9taXNlLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fdG9nZ2xlKChzaG93ID09PSB1bmRlZmluZWQpID8gIXRoaXMuc2hvdyA6IHNob3cpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqXG4gICAgICogQ2xvc2VzIHRoZSBwb3B1cCBhbmQgdHJpZ2dlcnMgdGhlIGBjYW5jZWxgIGV2ZW50LlxuICAgICAqL1xuICAgIGNhbmNlbFBvcHVwKCkge1xuICAgICAgICB0aGlzLnNob3cgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jYW5jZWwuZW1pdCgpO1xuICAgIH1cbiAgICBoYW5kbGVXaW5kb3dCbHVyKCkge1xuICAgICAgICBpZiAoIXRoaXMuc2hvdykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoYXNPYnNlcnZlcnModGhpcy5jbG9zZSkpIHtcbiAgICAgICAgICAgIHRoaXMuem9uZS5ydW4oKCkgPT4gdGhpcy5zaG93ID0gZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zaG93ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaGFuZGxlTW91c2VMZWF2ZSgpIHtcbiAgICAgICAgdGhpcy5kYXRlUmFuZ2VTZXJ2aWNlLnNldFJhbmdlKHRoaXMuZGF0ZVJhbmdlU2VydmljZS5zZWxlY3Rpb25SYW5nZSk7XG4gICAgfVxuICAgIGhhbmRsZUtleWRvd24oZXZlbnQpIHtcbiAgICAgICAgY29uc3QgeyBhbHRLZXksIGtleUNvZGUgfSA9IGV2ZW50O1xuICAgICAgICBpZiAoa2V5Q29kZSA9PT0gS2V5cy5Fc2NhcGUgfHwgKGFsdEtleSAmJiBrZXlDb2RlID09PSBLZXlzLkFycm93VXApKSB7XG4gICAgICAgICAgICB0aGlzLnpvbmUucnVuKCgpID0+IHRoaXMuY2FuY2VsUG9wdXAoKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3Vic2NyaWJlRm9jdXNCbHVyKGNhbGVuZGFyKSB7XG4gICAgICAgIGlmICh0aGlzLmJsdXJTdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuYmx1clN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgdGhpcy5mb2N1c1N1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY2FsZW5kYXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuYXRpdmVFbGVtZW50ID0gY2FsZW5kYXIuZWxlbWVudC5uYXRpdmVFbGVtZW50O1xuICAgICAgICB0aGlzLmJsdXJTdWJzY3JpcHRpb24gPSBmcm9tRXZlbnQobmF0aXZlRWxlbWVudCwgJ2JsdXInKS5zdWJzY3JpYmUoKCkgPT4gdGhpcy5vbkJsdXIuZW1pdCgpKTtcbiAgICAgICAgdGhpcy5mb2N1c1N1YnNjcmlwdGlvbiA9IGZyb21FdmVudChuYXRpdmVFbGVtZW50LCAnZm9jdXMnKS5zdWJzY3JpYmUoKCkgPT4gdGhpcy5vbkZvY3VzLmVtaXQoKSk7XG4gICAgfVxuICAgIGFkZFBvcHVwU3Vic2NyaXB0aW9ucyguLi5zdWJzY3JpcHRpb25zKSB7XG4gICAgICAgIGlmICghaXNQcmVzZW50KHRoaXMucG9wdXBTdWJzY3JpcHRpb25zKSkge1xuICAgICAgICAgICAgdGhpcy5wb3B1cFN1YnNjcmlwdGlvbnMgPSBuZXcgU3Vic2NyaXB0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgc3Vic2NyaXB0aW9ucy5tYXAocyA9PiB0aGlzLnBvcHVwU3Vic2NyaXB0aW9ucy5hZGQocykpO1xuICAgIH1cbiAgICBnZXQgX2FwcGVuZFRvKCkge1xuICAgICAgICBjb25zdCBhcHBlbmRUbyA9IHRoaXMuYXBwZW5kVG87XG4gICAgICAgIGlmICghYXBwZW5kVG8gfHwgYXBwZW5kVG8gPT09ICdyb290Jykge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXBwZW5kVG8gPT09ICdjb21wb25lbnQnID8gdGhpcy5jb250YWluZXIgOiBhcHBlbmRUbztcbiAgICB9XG4gICAgX3RvZ2dsZShzaG93KSB7XG4gICAgICAgIHRoaXMuX3Nob3cgPSBzaG93O1xuICAgICAgICBpZiAodGhpcy5wb3B1cFJlZikge1xuICAgICAgICAgICAgdGhpcy5kZXN0cm95UG9wdXAoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fc2hvdykge1xuICAgICAgICAgICAgY29uc3QgZGlyZWN0aW9uID0gdGhpcy5ydGwgPyAncmlnaHQnIDogJ2xlZnQnO1xuICAgICAgICAgICAgdGhpcy5wb3B1cFJlZiA9IHRoaXMucG9wdXBTZXJ2aWNlLm9wZW4oe1xuICAgICAgICAgICAgICAgIGFuY2hvcjogdGhpcy5hbmNob3IsXG4gICAgICAgICAgICAgICAgYW5jaG9yQWxpZ246IHRoaXMuYW5jaG9yQWxpZ24gfHwgeyB2ZXJ0aWNhbDogJ2JvdHRvbScsIGhvcml6b250YWw6IGRpcmVjdGlvbiB9LFxuICAgICAgICAgICAgICAgIGFuaW1hdGU6IHRoaXMuYW5pbWF0ZSxcbiAgICAgICAgICAgICAgICBhcHBlbmRUbzogdGhpcy5fYXBwZW5kVG8sXG4gICAgICAgICAgICAgICAgY29sbGlzaW9uOiB0aGlzLmNvbGxpc2lvbixcbiAgICAgICAgICAgICAgICBjb250ZW50OiAodGhpcy5jb250ZW50VGVtcGxhdGUgfHwge30pLnRlbXBsYXRlUmVmIHx8IHRoaXMuZGVmYXVsdFRlbXBsYXRlLFxuICAgICAgICAgICAgICAgIG1hcmdpbjogdGhpcy5tYXJnaW4sXG4gICAgICAgICAgICAgICAgcG9wdXBBbGlnbjogdGhpcy5wb3B1cEFsaWduIHx8IHsgdmVydGljYWw6ICd0b3AnLCBob3Jpem9udGFsOiBkaXJlY3Rpb24gfSxcbiAgICAgICAgICAgICAgICBwb3NpdGlvbk1vZGU6ICdhYnNvbHV0ZSdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgeyBwb3B1cEVsZW1lbnQsIHBvcHVwQW5jaG9yVmlld3BvcnRMZWF2ZSB9ID0gdGhpcy5wb3B1cFJlZjtcbiAgICAgICAgICAgIHBvcHVwRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2lkJywgdGhpcy5wb3B1cFVJRCk7XG4gICAgICAgICAgICB0aGlzLmFkZFBvcHVwU3Vic2NyaXB0aW9ucyh0aGlzLnpvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4gZnJvbUV2ZW50KHBvcHVwRWxlbWVudCwgJ2tleWRvd24nKS5zdWJzY3JpYmUodGhpcy5oYW5kbGVLZXlkb3duLmJpbmQodGhpcykpKSwgZnJvbUV2ZW50KHBvcHVwRWxlbWVudCwgJ21vdXNlbGVhdmUnKS5zdWJzY3JpYmUodGhpcy5oYW5kbGVNb3VzZUxlYXZlLmJpbmQodGhpcykpLCBwb3B1cEFuY2hvclZpZXdwb3J0TGVhdmUuc3Vic2NyaWJlKCgpID0+IHRoaXMuY2FuY2VsUG9wdXAoKSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRlc3Ryb3lQb3B1cCgpIHtcbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLnBvcHVwUmVmKSkge1xuICAgICAgICAgICAgdGhpcy5wb3B1cFJlZi5jbG9zZSgpO1xuICAgICAgICAgICAgdGhpcy5wb3B1cFJlZiA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLnBvcHVwU3Vic2NyaXB0aW9ucykpIHtcbiAgICAgICAgICAgIHRoaXMucG9wdXBTdWJzY3JpcHRpb25zLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuX19kZWNvcmF0ZShbXG4gICAgVmlld0NoaWxkKCdjb250YWluZXInLCB7IHJlYWQ6IFZpZXdDb250YWluZXJSZWYsIHN0YXRpYzogZmFsc2UgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFZpZXdDb250YWluZXJSZWYpXG5dLCBEYXRlUmFuZ2VQb3B1cENvbXBvbmVudC5wcm90b3R5cGUsIFwiY29udGFpbmVyXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBWaWV3Q2hpbGQoJ2RlZmF1bHRUZW1wbGF0ZScsIHsgc3RhdGljOiBmYWxzZSB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgVGVtcGxhdGVSZWYpXG5dLCBEYXRlUmFuZ2VQb3B1cENvbXBvbmVudC5wcm90b3R5cGUsIFwiZGVmYXVsdFRlbXBsYXRlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBDb250ZW50Q2hpbGQoRGF0ZVJhbmdlUG9wdXBUZW1wbGF0ZURpcmVjdGl2ZSwgeyBzdGF0aWM6IGZhbHNlIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBEYXRlUmFuZ2VQb3B1cFRlbXBsYXRlRGlyZWN0aXZlKVxuXSwgRGF0ZVJhbmdlUG9wdXBDb21wb25lbnQucHJvdG90eXBlLCBcImNvbnRlbnRUZW1wbGF0ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgVmlld0NoaWxkcmVuKE11bHRpVmlld0NhbGVuZGFyQ29tcG9uZW50KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgUXVlcnlMaXN0KVxuXSwgRGF0ZVJhbmdlUG9wdXBDb21wb25lbnQucHJvdG90eXBlLCBcInZpZXdDYWxlbmRhclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgQ29udGVudENoaWxkcmVuKE11bHRpVmlld0NhbGVuZGFyQ29tcG9uZW50KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgUXVlcnlMaXN0KVxuXSwgRGF0ZVJhbmdlUG9wdXBDb21wb25lbnQucHJvdG90eXBlLCBcImNvbnRlbnRDYWxlbmRhclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgRGF0ZVJhbmdlUG9wdXBDb21wb25lbnQucHJvdG90eXBlLCBcImFuaW1hdGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEVsZW1lbnRSZWYpXG5dLCBEYXRlUmFuZ2VQb3B1cENvbXBvbmVudC5wcm90b3R5cGUsIFwiYW5jaG9yXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBEYXRlUmFuZ2VQb3B1cENvbXBvbmVudC5wcm90b3R5cGUsIFwiYW5jaG9yQWxpZ25cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIERhdGVSYW5nZVBvcHVwQ29tcG9uZW50LnByb3RvdHlwZSwgXCJhcHBlbmRUb1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgRGF0ZVJhbmdlUG9wdXBDb21wb25lbnQucHJvdG90eXBlLCBcImNvbGxpc2lvblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgRGF0ZVJhbmdlUG9wdXBDb21wb25lbnQucHJvdG90eXBlLCBcInBvcHVwQWxpZ25cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIERhdGVSYW5nZVBvcHVwQ29tcG9uZW50LnByb3RvdHlwZSwgXCJtYXJnaW5cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIE91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXG5dLCBEYXRlUmFuZ2VQb3B1cENvbXBvbmVudC5wcm90b3R5cGUsIFwib3BlblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbl0sIERhdGVSYW5nZVBvcHVwQ29tcG9uZW50LnByb3RvdHlwZSwgXCJjbG9zZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgT3V0cHV0KCdibHVyJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbl0sIERhdGVSYW5nZVBvcHVwQ29tcG9uZW50LnByb3RvdHlwZSwgXCJvbkJsdXJcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIE91dHB1dCgnZm9jdXMnKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxuXSwgRGF0ZVJhbmdlUG9wdXBDb21wb25lbnQucHJvdG90eXBlLCBcIm9uRm9jdXNcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIE91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXG5dLCBEYXRlUmFuZ2VQb3B1cENvbXBvbmVudC5wcm90b3R5cGUsIFwiY2FuY2VsXCIsIHZvaWQgMCk7XG5EYXRlUmFuZ2VQb3B1cENvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIGV4cG9ydEFzOiAna2VuZG8tZGF0ZXJhbmdlLXBvcHVwJyxcbiAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1kYXRlcmFuZ2UtcG9wdXAnLFxuICAgICAgICB0ZW1wbGF0ZTogYFxuICAgICAgICA8bmctY29udGFpbmVyICNjb250YWluZXI+PC9uZy1jb250YWluZXI+XG4gICAgICAgIDxuZy10ZW1wbGF0ZSAjZGVmYXVsdFRlbXBsYXRlPlxuICAgICAgICAgICAgPGtlbmRvLW11bHRpdmlld2NhbGVuZGFyIGtlbmRvRGF0ZVJhbmdlU2VsZWN0aW9uPjwva2VuZG8tbXVsdGl2aWV3Y2FsZW5kYXI+XG4gICAgICAgIDwvbmctdGVtcGxhdGU+XG4gICAgYFxuICAgIH0pLFxuICAgIF9fcGFyYW0oNCwgT3B0aW9uYWwoKSksIF9fcGFyYW0oNCwgSW5qZWN0KFJUTCkpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbUG9wdXBTZXJ2aWNlLFxuICAgICAgICBEYXRlUmFuZ2VTZXJ2aWNlLFxuICAgICAgICBDaGFuZ2VEZXRlY3RvclJlZixcbiAgICAgICAgTmdab25lLCBCb29sZWFuXSlcbl0sIERhdGVSYW5nZVBvcHVwQ29tcG9uZW50KTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBLZW5kbyBVSSBEYXRlUmFuZ2UgY29tcG9uZW50IGZvciBBbmd1bGFyLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogX0BDb21wb25lbnQoe1xuICogc2VsZWN0b3I6ICdteS1hcHAnLFxuICogdGVtcGxhdGU6IGBcbiAqICA8a2VuZG8tZGF0ZXJhbmdlPlxuICogICAgICA8a2VuZG8tZGF0ZWlucHV0IGtlbmRvRGF0ZVJhbmdlU3RhcnRJbnB1dCBbKHZhbHVlKV09XCJkYXRlUmFuZ2Uuc3RhcnRcIj48L2tlbmRvLWRhdGVpbnB1dD5cbiAqICAgICAgPGtlbmRvLWRhdGVpbnB1dCBrZW5kb0RhdGVSYW5nZUVuZElucHV0IFsodmFsdWUpXT1cImRhdGVSYW5nZS5lbmRcIj48L2tlbmRvLWRhdGVpbnB1dD5cbiAqICA8L2tlbmRvLWRhdGVyYW5nZT5cbiAqIGBcbiAqIH0pXG4gKiBleHBvcnQgY2xhc3MgQXBwQ29tcG9uZW50IHtcbiAqICAgcHVibGljIGRhdGVSYW5nZTogYW55ID0geyBzdGFydDogbnVsbCwgZW5kOiBudWxsIH07XG4gKiB9XG4gKiBgYGBcbiAqL1xubGV0IERhdGVSYW5nZUNvbXBvbmVudCA9IGNsYXNzIERhdGVSYW5nZUNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaGlkZGVuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNob3dEZWZhdWx0ID0gZmFsc2U7XG4gICAgICAgIHZhbGlkYXRlUGFja2FnZShwYWNrYWdlTWV0YWRhdGEpO1xuICAgIH1cbiAgICBnZXQgaGFzQ29udGVudFBvcHVwKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250ZW50UG9wdXAubGVuZ3RoID4gMDtcbiAgICB9XG4gICAgbmdBZnRlckNvbnRlbnRJbml0KCkge1xuICAgICAgICB0aGlzLnNob3dEZWZhdWx0ID0gIXRoaXMuaGFzQ29udGVudFBvcHVwO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbiA9IHRoaXMuY29udGVudFBvcHVwLmNoYW5nZXMuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc2hvd0RlZmF1bHQgPSAhdGhpcy5oYXNDb250ZW50UG9wdXA7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgaWYgKHRoaXMuc3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgfVxufTtcbl9fZGVjb3JhdGUoW1xuICAgIENvbnRlbnRDaGlsZHJlbihEYXRlUmFuZ2VQb3B1cENvbXBvbmVudCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFF1ZXJ5TGlzdClcbl0sIERhdGVSYW5nZUNvbXBvbmVudC5wcm90b3R5cGUsIFwiY29udGVudFBvcHVwXCIsIHZvaWQgMCk7XG5EYXRlUmFuZ2VDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBwcm92aWRlcnM6IFtEYXRlUmFuZ2VTZXJ2aWNlXSxcbiAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1kYXRlcmFuZ2UnLFxuICAgICAgICB0ZW1wbGF0ZTogYFxuICAgICAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XG4gICAgICAgIDxrZW5kby1kYXRlcmFuZ2UtcG9wdXAgKm5nSWY9XCJzaG93RGVmYXVsdFwiPjwva2VuZG8tZGF0ZXJhbmdlLXBvcHVwPlxuICAgIGBcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBEYXRlUmFuZ2VDb21wb25lbnQpO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgRGF0ZVJhbmdlSW5wdXQge1xuICAgIGNvbnN0cnVjdG9yKGFjdGl2ZVJhbmdlRW5kLCBkYXRlUmFuZ2VTZXJ2aWNlLCBpbnB1dCwgZWxlbWVudCwgcmVuZGVyZXIsIHpvbmUpIHtcbiAgICAgICAgdGhpcy5hY3RpdmVSYW5nZUVuZCA9IGFjdGl2ZVJhbmdlRW5kO1xuICAgICAgICB0aGlzLmRhdGVSYW5nZVNlcnZpY2UgPSBkYXRlUmFuZ2VTZXJ2aWNlO1xuICAgICAgICB0aGlzLmlucHV0ID0gaW5wdXQ7XG4gICAgICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgICAgICAgdGhpcy56b25lID0gem9uZTtcbiAgICAgICAgdGhpcy5uYXZpZ2F0ZUNhbGVuZGFyT25Gb2N1cyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnBvcHVwU3Vic2NyaXB0aW9ucyA9IG5ldyBTdWJzY3JpcHRpb24oKCkgPT4geyB9KTtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zID0gbmV3IFN1YnNjcmlwdGlvbigoKSA9PiB7IH0pO1xuICAgIH1cbiAgICBnZXQgaXNBY3RpdmVFbmQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGVSYW5nZVNlcnZpY2UuYWN0aXZlUmFuZ2VFbmQgPT09IHRoaXMuYWN0aXZlUmFuZ2VFbmQ7XG4gICAgfVxuICAgIGdldCBwb3B1cENhbGVuZGFyQWN0aXZhdGVkKCkge1xuICAgICAgICBjb25zdCBwb3B1cCA9IHRoaXMuZGF0ZVJhbmdlU2VydmljZS5kYXRlUmFuZ2VQb3B1cCQudmFsdWU7XG4gICAgICAgIHJldHVybiBpc1ByZXNlbnQocG9wdXApICYmIGlzUHJlc2VudChwb3B1cC5jYWxlbmRhcik7XG4gICAgfVxuICAgIGluaXQoKSB7XG4gICAgICAgIGlmICh0aGlzLmlucHV0LnZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLmRhdGVSYW5nZVNlcnZpY2Uuc2V0UmFuZ2UodGhpcy5nZXRSYW5nZSh0aGlzLmlucHV0LnZhbHVlKSk7XG4gICAgICAgIH1cbiAgICAgICAgW1xuICAgICAgICAgICAgdGhpcy5pbnB1dC5vbkJsdXIuc3Vic2NyaWJlKCgpID0+IHRoaXMuZGVhY3RpdmF0ZSgpKSxcbiAgICAgICAgICAgIHRoaXMuaW5wdXQub25Gb2N1cy5waXBlKGZpbHRlcigoKSA9PiAhdGhpcy5wb3B1cENhbGVuZGFyQWN0aXZhdGVkKSkuc3Vic2NyaWJlKCgpID0+IHRoaXMuYWN0aXZhdGUoKSksXG4gICAgICAgICAgICB0aGlzLmlucHV0LnZhbHVlVXBkYXRlLnN1YnNjcmliZSh2YWx1ZSA9PiB0aGlzLnVwZGF0ZVJhbmdlKHZhbHVlLCAnY2hhbmdlJykpLFxuICAgICAgICAgICAgdGhpcy5kYXRlUmFuZ2VTZXJ2aWNlLmFjdGl2ZVJhbmdlRW5kJC5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm5hdmlnYXRlQ2FsZW5kYXJPbkZvY3VzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZm9jdXNBY3RpdmVEYXRlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMudG9nZ2xlQWN0aXZlQ2xhc3ModGhpcy5pc0FjdGl2ZUVuZCk7XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHRoaXMuZGF0ZVJhbmdlU2VydmljZS5kYXRlUmFuZ2VQb3B1cCQuc3Vic2NyaWJlKHBvcHVwID0+IHRoaXMuaW5pdFBvcHVwKHBvcHVwKSksXG4gICAgICAgICAgICB0aGlzLmRhdGVSYW5nZVNlcnZpY2UucmFuZ2UkLnN1YnNjcmliZShyYW5nZSA9PiB0aGlzLnVwZGF0ZUlucHV0VmFsdWUocmFuZ2UpKSxcbiAgICAgICAgICAgIGZyb21FdmVudCh0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudCwgJ2NsaWNrJykuc3Vic2NyaWJlKCgpID0+IHRoaXMuYWN0aXZhdGUoKSksXG4gICAgICAgICAgICBmcm9tRXZlbnQodGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQsICdrZXlkb3duJykuc3Vic2NyaWJlKChldmVudCkgPT4gdGhpcy50b2dnbGVQb3B1cChldmVudCB8fCB7fSkpXG4gICAgICAgIF0ubWFwKHMgPT4gdGhpcy5zdWJzY3JpcHRpb25zLmFkZChzKSk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy51bnN1YnNjcmliZSgpO1xuICAgICAgICB0aGlzLnVuc3Vic2NyaWJlUG9wdXAoKTtcbiAgICB9XG4gICAgaW5pdFBvcHVwKHBvcHVwKSB7XG4gICAgICAgIGlmICghcG9wdXApIHtcbiAgICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmVQb3B1cCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcG9wdXAuYW5jaG9yKSB7XG4gICAgICAgICAgICBwb3B1cC5hbmNob3IgPSB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudDtcbiAgICAgICAgfVxuICAgICAgICBbXG4gICAgICAgICAgICBwb3B1cC5jYW5jZWwuc3Vic2NyaWJlKCgpID0+IHRoaXMuaXNBY3RpdmVFbmQgJiYgdGhpcy5pbnB1dC5mb2N1cygpKSxcbiAgICAgICAgICAgIHBvcHVwLm9uRm9jdXMuc3Vic2NyaWJlKCgpID0+IHRoaXMudG9nZ2xlQWN0aXZlQ2xhc3ModGhpcy5pc0FjdGl2ZUVuZCkpLFxuICAgICAgICAgICAgcG9wdXAub25CbHVyLnN1YnNjcmliZSgoKSA9PiB0aGlzLmRlYWN0aXZhdGUoKSlcbiAgICAgICAgXS5tYXAocyA9PiB0aGlzLnBvcHVwU3Vic2NyaXB0aW9ucy5hZGQocykpO1xuICAgIH1cbiAgICB1bnN1YnNjcmliZVBvcHVwKCkge1xuICAgICAgICB0aGlzLnBvcHVwU3Vic2NyaXB0aW9ucy51bnN1YnNjcmliZSgpO1xuICAgICAgICB0aGlzLnBvcHVwU3Vic2NyaXB0aW9ucyA9IG5ldyBTdWJzY3JpcHRpb24oKCkgPT4geyB9KTtcbiAgICB9XG4gICAgYWN0aXZhdGUoKSB7XG4gICAgICAgIHRoaXMuZGF0ZVJhbmdlU2VydmljZS5zZXRBY3RpdmVSYW5nZUVuZCh0aGlzLmFjdGl2ZVJhbmdlRW5kKTtcbiAgICAgICAgdGhpcy5kYXRlUmFuZ2VTZXJ2aWNlLmFjdGl2YXRlUG9wdXAoKTtcbiAgICB9XG4gICAgZGVhY3RpdmF0ZSgpIHtcbiAgICAgICAgdGhpcy56b25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlUmFuZ2UodGhpcy5pbnB1dC52YWx1ZSwgJ2JsdXInKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5kYXRlUmFuZ2VTZXJ2aWNlLmhhc0FjdGl2ZUNvbXBvbmVudCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy50b2dnbGVBY3RpdmVDbGFzcyhmYWxzZSk7XG4gICAgICAgICAgICAgICAgdGhpcy56b25lLnJ1bigoKSA9PiB0aGlzLmRhdGVSYW5nZVNlcnZpY2UuZGVhY3RpdmF0ZVBvcHVwKCkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB1cGRhdGVSYW5nZSh2YWx1ZSwgY29ycmVjdE9uKSB7XG4gICAgICAgIGNvbnN0IHJhbmdlID0gdGhpcy5nZXRSYW5nZSh2YWx1ZSwgY29ycmVjdE9uKTtcbiAgICAgICAgaWYgKHJhbmdlKSB7XG4gICAgICAgICAgICB0aGlzLmZvY3VzQWN0aXZlRGF0ZSgpO1xuICAgICAgICAgICAgdGhpcy5kYXRlUmFuZ2VTZXJ2aWNlLnNldFJhbmdlKHJhbmdlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0b2dnbGVQb3B1cCh7IGFsdEtleSwga2V5Q29kZSB9KSB7XG4gICAgICAgIGlmIChrZXlDb2RlID09PSBLZXlzLkVzY2FwZSkge1xuICAgICAgICAgICAgdGhpcy5kYXRlUmFuZ2VTZXJ2aWNlLmNhbmNlbFBvcHVwKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYWx0S2V5ICYmIGtleUNvZGUgPT09IEtleXMuQXJyb3dEb3duKSB7XG4gICAgICAgICAgICB0aGlzLmRhdGVSYW5nZVNlcnZpY2UuYWN0aXZhdGVQb3B1cCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvY3VzQWN0aXZlRGF0ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuaW5wdXQudmFsdWUgJiYgdGhpcy5pc0FjdGl2ZUVuZCkge1xuICAgICAgICAgICAgdGhpcy5kYXRlUmFuZ2VTZXJ2aWNlLnNldEZvY3VzZWREYXRlKGNsb25lRGF0ZSh0aGlzLmlucHV0LnZhbHVlKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdG9nZ2xlQWN0aXZlQ2xhc3Moc2hvdykge1xuICAgICAgICBjb25zdCBhY3Rpb24gPSBzaG93ID8gJ2FkZENsYXNzJyA6ICdyZW1vdmVDbGFzcyc7XG4gICAgICAgIGNvbnN0IG5hdGl2ZUVsZW1lbnQgPSB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudDtcbiAgICAgICAgaWYgKG5hdGl2ZUVsZW1lbnQgJiYgbmF0aXZlRWxlbWVudC5xdWVyeVNlbGVjdG9yKSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyW2FjdGlvbl0obmF0aXZlRWxlbWVudC5xdWVyeVNlbGVjdG9yKCcuay1kYXRlaW5wdXQtd3JhcCcpLCAnay1zdGF0ZS1mb2N1c2VkJyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogQSBkaXJlY3RpdmUgd2hpY2ggbWFuYWdlcyB0aGUgZW5kIHJhbmdlIHNlbGVjdGlvbi5cbiAqXG4gKiA+IFlvdSBjYW4gdXNlIHRoZSBEYXRlUmFuZ2VFbmRJbnB1dERpcmVjdGl2ZSBvbmx5IHdpdGggYSBEYXRlSW5wdXQgY29tcG9uZW50LlxuICovXG5sZXQgRGF0ZVJhbmdlRW5kSW5wdXREaXJlY3RpdmUgPSBjbGFzcyBEYXRlUmFuZ2VFbmRJbnB1dERpcmVjdGl2ZSBleHRlbmRzIERhdGVSYW5nZUlucHV0IHtcbiAgICBjb25zdHJ1Y3RvcihyYW5nZVNlcnZpY2UsIGRhdGVJbnB1dCwgZWxlbWVudCwgcmVuZGVyZXIsIHpvbmUpIHtcbiAgICAgICAgc3VwZXIoJ2VuZCcsIHJhbmdlU2VydmljZSwgZGF0ZUlucHV0LCBlbGVtZW50LCByZW5kZXJlciwgem9uZSk7XG4gICAgICAgIHRoaXMucmFuZ2VTZXJ2aWNlID0gcmFuZ2VTZXJ2aWNlO1xuICAgICAgICB0aGlzLmRhdGVJbnB1dCA9IGRhdGVJbnB1dDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZmllcyB0aGUgbmF2aWdhdGlvbiBiZWhhdmlvciBvZiB0aGUgY2FsZW5kYXIgd2hlbiB0aGUgYWN0aXZlIGVuZCBpcyBjaGFuZ2VkIG9uIGlucHV0IGZvY3VzLiBXaGVuIGVuYWJsZWQsXG4gICAgICAgICAqIHRoZSBjYWxlbmRhciBuYXZpZ2F0ZXMgdG8gdGhlIHZhbHVlIG9mIHRoZSBmb2N1c2VkIGlucHV0LiBPdGhlcndpc2UsIHRoZSBjYWxlbmRhciBkaXNwbGF5cyB0aGUgbGFzdCBwaWNrZWQgZGF0ZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQnkgZGVmYXVsdCwgdGhlIGF1dG9tYXRpYyBuYXZpZ2F0aW9uIGJlaGF2aW9yIG9uIGlucHV0IGZvY3VzIGlzIGRpc2FibGVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiBgYGB0c1xuICAgICAgICAgKiBfQENvbXBvbmVudCh7XG4gICAgICAgICAqIHNlbGVjdG9yOiAnbXktYXBwJyxcbiAgICAgICAgICogdGVtcGxhdGU6IGBcbiAgICAgICAgICogIDxoNT5Ub2dnbGUgaW5wdXQgZm9jdXMgdG8gc2VlIHRoZSBjYWxlbmRhciBuYXZpZ2F0aW5nIGJldHdlZW4gcmFuZ2UgZW5kcy48L2g1PlxuICAgICAgICAgKiAgPGtlbmRvLWRhdGVyYW5nZT5cbiAgICAgICAgICogICAgICA8a2VuZG8tZGF0ZWlucHV0IGtlbmRvRGF0ZVJhbmdlU3RhcnRJbnB1dCBbbmF2aWdhdGVDYWxlbmRhck9uRm9jdXNdPVwidHJ1ZVwiIFsodmFsdWUpXT1cInN0YXJ0XCI+PC9rZW5kby1kYXRlaW5wdXQ+XG4gICAgICAgICAqICAgICAgPGtlbmRvLWRhdGVpbnB1dCBrZW5kb0RhdGVSYW5nZUVuZElucHV0IFtuYXZpZ2F0ZUNhbGVuZGFyT25Gb2N1c109XCJ0cnVlXCIgWyh2YWx1ZSldPVwiZW5kXCI+PC9rZW5kby1kYXRlaW5wdXQ+XG4gICAgICAgICAqICA8L2tlbmRvLWRhdGVyYW5nZT5cbiAgICAgICAgICogYFxuICAgICAgICAgKiB9KVxuICAgICAgICAgKiBleHBvcnQgY2xhc3MgQXBwQ29tcG9uZW50IHtcbiAgICAgICAgICogICBwdWJsaWMgc3RhcnQ6IERhdGUgPSBuZXcgRGF0ZSgyMDE4LCAzLCAxMCk7XG4gICAgICAgICAqICAgcHVibGljIGVuZDogRGF0ZSA9IG5ldyBEYXRlKDIwMTgsIDEwLCAyMCk7XG4gICAgICAgICAqIH1cbiAgICAgICAgICogYGBgXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm5hdmlnYXRlQ2FsZW5kYXJPbkZvY3VzID0gZmFsc2U7XG4gICAgfVxuICAgIG5nT25Jbml0KCkge1xuICAgICAgICB0aGlzLnJhbmdlU2VydmljZS5yZWdpc3RlckVuZElucHV0KHRoaXMuZGF0ZUlucHV0KTtcbiAgICAgICAgc3VwZXIuaW5pdCgpO1xuICAgIH1cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgc3VwZXIuZGVzdHJveSgpO1xuICAgIH1cbiAgICBnZXRSYW5nZSh2YWx1ZSwgY29ycmVjdE9uKSB7XG4gICAgICAgIGNvbnN0IHsgbWluLCBtYXggfSA9IHRoaXMuZGF0ZUlucHV0O1xuICAgICAgICBpZiAoIWlzSW5SYW5nZSh2YWx1ZSwgbWluLCBtYXgpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IHN0YXJ0IH0gPSB0aGlzLnJhbmdlU2VydmljZS5zZWxlY3Rpb25SYW5nZSB8fCBFTVBUWV9TRUxFQ1RJT05SQU5HRTtcbiAgICAgICAgY29uc3Qgc2hvdWxkQ2xhbXAgPSB0aGlzLmF1dG9Db3JyZWN0T24gPT09IGNvcnJlY3RPbiAmJiBpc1ByZXNlbnQodmFsdWUpICYmIHZhbHVlIDwgc3RhcnQ7XG4gICAgICAgIHJldHVybiBzaG91bGRDbGFtcCA/IGNsYW1wUmFuZ2UodmFsdWUpIDogeyBzdGFydCwgZW5kOiBjbG9uZURhdGUodmFsdWUpIH07XG4gICAgfVxuICAgIHVwZGF0ZUlucHV0VmFsdWUocmFuZ2UkJDEpIHtcbiAgICAgICAgY29uc3QgeyBlbmQgfSA9IHJhbmdlJCQxIHx8IEVNUFRZX1NFTEVDVElPTlJBTkdFO1xuICAgICAgICBjb25zdCB7IG1pbiwgbWF4IH0gPSB0aGlzLmRhdGVJbnB1dDtcbiAgICAgICAgaWYgKGlzRXF1YWwodGhpcy5kYXRlSW5wdXQudmFsdWUsIGVuZCkgfHwgIWlzSW5SYW5nZShlbmQsIG1pbiwgbWF4KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGF0ZUlucHV0LndyaXRlVmFsdWUoY2xvbmVEYXRlKGVuZCkpO1xuICAgICAgICB0aGlzLmRhdGVJbnB1dC5ub3RpZnkoKTtcbiAgICB9XG59O1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgRGF0ZVJhbmdlRW5kSW5wdXREaXJlY3RpdmUucHJvdG90eXBlLCBcImF1dG9Db3JyZWN0T25cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBEYXRlUmFuZ2VFbmRJbnB1dERpcmVjdGl2ZS5wcm90b3R5cGUsIFwibmF2aWdhdGVDYWxlbmRhck9uRm9jdXNcIiwgdm9pZCAwKTtcbkRhdGVSYW5nZUVuZElucHV0RGlyZWN0aXZlID0gX19kZWNvcmF0ZShbXG4gICAgRGlyZWN0aXZlKHtcbiAgICAgICAgc2VsZWN0b3I6ICdba2VuZG9EYXRlUmFuZ2VFbmRJbnB1dF0nXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtEYXRlUmFuZ2VTZXJ2aWNlLFxuICAgICAgICBEYXRlSW5wdXRDb21wb25lbnQsXG4gICAgICAgIEVsZW1lbnRSZWYsXG4gICAgICAgIFJlbmRlcmVyMixcbiAgICAgICAgTmdab25lXSlcbl0sIERhdGVSYW5nZUVuZElucHV0RGlyZWN0aXZlKTtcblxuLyoqXG4gKiBBIGRpcmVjdGl2ZSB3aGljaCBtYW5hZ2VzIHRoZSBzdGFydCBzZWxlY3Rpb24gcmFuZ2UuXG4gKlxuICogPiBZb3UgY2FuIHVzZSB0aGUgRGF0ZVJhbmdlU3RhcnRJbnB1dERpcmVjdGl2ZSBvbmx5IHdpdGggYSBEYXRlSW5wdXQgY29tcG9uZW50LlxuICovXG5sZXQgRGF0ZVJhbmdlU3RhcnRJbnB1dERpcmVjdGl2ZSA9IGNsYXNzIERhdGVSYW5nZVN0YXJ0SW5wdXREaXJlY3RpdmUgZXh0ZW5kcyBEYXRlUmFuZ2VJbnB1dCB7XG4gICAgY29uc3RydWN0b3IocmFuZ2VTZXJ2aWNlLCBkYXRlSW5wdXQsIGVsZW1lbnQsIHJlbmRlcmVyLCB6b25lKSB7XG4gICAgICAgIHN1cGVyKCdzdGFydCcsIHJhbmdlU2VydmljZSwgZGF0ZUlucHV0LCBlbGVtZW50LCByZW5kZXJlciwgem9uZSk7XG4gICAgICAgIHRoaXMucmFuZ2VTZXJ2aWNlID0gcmFuZ2VTZXJ2aWNlO1xuICAgICAgICB0aGlzLmRhdGVJbnB1dCA9IGRhdGVJbnB1dDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZmllcyB0aGUgbmF2aWdhdGlvbiBiZWhhdmlvciBvZiB0aGUgY2FsZW5kYXIgd2hlbiB0aGUgYWN0aXZlIGVuZCBpcyBjaGFuZ2VkIG9uIGlucHV0IGZvY3VzLlxuICAgICAgICAgKiBXaGVuIGVuYWJsZWQsIHRoZSBjYWxlbmRhciBuYXZpZ2F0ZXMgdG8gdGhlIHZhbHVlIG9mIHRoZSBmb2N1c2VkIGlucHV0LiBPdGhlcndpc2UsIHRoZSBjYWxlbmRhclxuICAgICAgICAgKiBkaXNwbGF5cyB0aGUgbGFzdCBwaWNrZWQgZGF0ZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQnkgZGVmYXVsdCwgdGhlIGF1dG9tYXRpYyBuYXZpZ2F0aW9uIGJlaGF2aW9yIG9uIGlucHV0IGZvY3VzIGlzIGRpc2FibGVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiBgYGB0c1xuICAgICAgICAgKiBfQENvbXBvbmVudCh7XG4gICAgICAgICAqIHNlbGVjdG9yOiAnbXktYXBwJyxcbiAgICAgICAgICogdGVtcGxhdGU6IGBcbiAgICAgICAgICogIDxoNT5Ub2dnbGUgaW5wdXQgZm9jdXMgdG8gc2VlIHRoZSBjYWxlbmRhciBuYXZpZ2F0aW5nIGJldHdlZW4gcmFuZ2UgZW5kcy48L2g1PlxuICAgICAgICAgKiAgPGtlbmRvLWRhdGVyYW5nZT5cbiAgICAgICAgICogICAgICA8a2VuZG8tZGF0ZWlucHV0IGtlbmRvRGF0ZVJhbmdlU3RhcnRJbnB1dCBbbmF2aWdhdGVDYWxlbmRhck9uRm9jdXNdPVwidHJ1ZVwiIFsodmFsdWUpXT1cInN0YXJ0XCI+PC9rZW5kby1kYXRlaW5wdXQ+XG4gICAgICAgICAqICAgICAgPGtlbmRvLWRhdGVpbnB1dCBrZW5kb0RhdGVSYW5nZUVuZElucHV0IFtuYXZpZ2F0ZUNhbGVuZGFyT25Gb2N1c109XCJ0cnVlXCIgWyh2YWx1ZSldPVwiZW5kXCI+PC9rZW5kby1kYXRlaW5wdXQ+XG4gICAgICAgICAqICA8L2tlbmRvLWRhdGVyYW5nZT5cbiAgICAgICAgICogYFxuICAgICAgICAgKiB9KVxuICAgICAgICAgKiBleHBvcnQgY2xhc3MgQXBwQ29tcG9uZW50IHtcbiAgICAgICAgICogICBwdWJsaWMgc3RhcnQ6IERhdGUgPSBuZXcgRGF0ZSgyMDE4LCAzLCAxMCk7XG4gICAgICAgICAqICAgcHVibGljIGVuZDogRGF0ZSA9IG5ldyBEYXRlKDIwMTgsIDEwLCAyMCk7XG4gICAgICAgICAqIH1cbiAgICAgICAgICogYGBgXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm5hdmlnYXRlQ2FsZW5kYXJPbkZvY3VzID0gZmFsc2U7XG4gICAgfVxuICAgIG5nT25Jbml0KCkge1xuICAgICAgICB0aGlzLnJhbmdlU2VydmljZS5yZWdpc3RlclN0YXJ0SW5wdXQodGhpcy5kYXRlSW5wdXQpO1xuICAgICAgICBzdXBlci5pbml0KCk7XG4gICAgfVxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICBzdXBlci5kZXN0cm95KCk7XG4gICAgfVxuICAgIGdldFJhbmdlKHZhbHVlLCBjb3JyZWN0T24pIHtcbiAgICAgICAgY29uc3QgeyBtaW4sIG1heCB9ID0gdGhpcy5kYXRlSW5wdXQ7XG4gICAgICAgIGlmICghaXNJblJhbmdlKHZhbHVlLCBtaW4sIG1heCkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgZW5kIH0gPSB0aGlzLnJhbmdlU2VydmljZS5zZWxlY3Rpb25SYW5nZSB8fCBFTVBUWV9TRUxFQ1RJT05SQU5HRTtcbiAgICAgICAgY29uc3Qgc2hvdWxkQ2xhbXAgPSB0aGlzLmF1dG9Db3JyZWN0T24gPT09IGNvcnJlY3RPbiAmJiBlbmQgJiYgdmFsdWUgPiBlbmQ7XG4gICAgICAgIHJldHVybiBzaG91bGRDbGFtcCA/IGNsYW1wUmFuZ2UodmFsdWUpIDogeyBzdGFydDogY2xvbmVEYXRlKHZhbHVlKSwgZW5kIH07XG4gICAgfVxuICAgIHVwZGF0ZUlucHV0VmFsdWUocmFuZ2UkJDEpIHtcbiAgICAgICAgY29uc3QgeyBzdGFydCB9ID0gcmFuZ2UkJDEgfHwgRU1QVFlfU0VMRUNUSU9OUkFOR0U7XG4gICAgICAgIGNvbnN0IHsgbWluLCBtYXggfSA9IHRoaXMuZGF0ZUlucHV0O1xuICAgICAgICBpZiAoaXNFcXVhbCh0aGlzLmRhdGVJbnB1dC52YWx1ZSwgc3RhcnQpIHx8ICFpc0luUmFuZ2Uoc3RhcnQsIG1pbiwgbWF4KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGF0ZUlucHV0LndyaXRlVmFsdWUoY2xvbmVEYXRlKHN0YXJ0KSk7XG4gICAgICAgIHRoaXMuZGF0ZUlucHV0Lm5vdGlmeSgpO1xuICAgIH1cbn07XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBEYXRlUmFuZ2VTdGFydElucHV0RGlyZWN0aXZlLnByb3RvdHlwZSwgXCJhdXRvQ29ycmVjdE9uXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgRGF0ZVJhbmdlU3RhcnRJbnB1dERpcmVjdGl2ZS5wcm90b3R5cGUsIFwibmF2aWdhdGVDYWxlbmRhck9uRm9jdXNcIiwgdm9pZCAwKTtcbkRhdGVSYW5nZVN0YXJ0SW5wdXREaXJlY3RpdmUgPSBfX2RlY29yYXRlKFtcbiAgICBEaXJlY3RpdmUoe1xuICAgICAgICBzZWxlY3RvcjogJ1trZW5kb0RhdGVSYW5nZVN0YXJ0SW5wdXRdJ1xuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbRGF0ZVJhbmdlU2VydmljZSxcbiAgICAgICAgRGF0ZUlucHV0Q29tcG9uZW50LFxuICAgICAgICBFbGVtZW50UmVmLFxuICAgICAgICBSZW5kZXJlcjIsXG4gICAgICAgIE5nWm9uZV0pXG5dLCBEYXRlUmFuZ2VTdGFydElucHV0RGlyZWN0aXZlKTtcblxuLyoqXG4gKiBBIGRpcmVjdGl2ZSB3aGljaCBtYW5hZ2VzIHRoZSBNdWx0aVZpZXdDYWxlbmRhciByYW5nZSBzZWxlY3Rpb24uXG4gKi9cbmxldCBEYXRlUmFuZ2VTZWxlY3Rpb25EaXJlY3RpdmUgPSBjbGFzcyBEYXRlUmFuZ2VTZWxlY3Rpb25EaXJlY3RpdmUge1xuICAgIGNvbnN0cnVjdG9yKGNhbGVuZGFyLCBjZHIsIGVsZW1lbnQsIHJlbmRlcmVyLCBkYXRlUmFuZ2VTZXJ2aWNlKSB7XG4gICAgICAgIHRoaXMuY2FsZW5kYXIgPSBjYWxlbmRhcjtcbiAgICAgICAgdGhpcy5jZHIgPSBjZHI7XG4gICAgICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICAgIHRoaXMuZGF0ZVJhbmdlU2VydmljZSA9IGRhdGVSYW5nZVNlcnZpY2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVjaWZpZXMgdGhlIGF1dG8tY29ycmVjdGlvbiBiZWhhdmlvci4gSWYgdGhlIHN0YXJ0IGRhdGUgaXMgZ3JlYXRlciB0aGFuIHRoZSBlbmQgZGF0ZSxcbiAgICAgICAgICogdGhlIGRpcmVjdGl2ZSBmaXhlcyB0aGUgZGF0ZSByYW5nZSB0byBhIHNpbmdsZSBkYXRlIGVpdGhlciBvbiBpbnB1dCBjaGFuZ2Ugb3Igb24gYmx1clxuICAgICAgICAgKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGF1dG9jb3JyZWN0X2RhdGVyYW5nZSAlfSN0b2MtY29uZmlndXJpbmctdGhlLWNhbGVuZGFyLXNlbGVjdGlvbi1kaXJlY3RpdmUpKS5cbiAgICAgICAgICpcbiAgICAgICAgICogQnkgZGVmYXVsdCwgdGhlIGF1dG8tY29ycmVjdGlvbiBpcyB0cmlnZ2VyZWQgb24gY2hhbmdlLlxuICAgICAgICAgKiBUbyBkaXNhYmxlIHRoaXMgYmVoYXZpb3IsIHNldCB0aGUgYGF1dG9Db3JyZWN0T25gIHByb3BlcnR5IHRvIGBub25lYC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYXV0b0NvcnJlY3RPbiA9ICdjaGFuZ2UnO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgd2hlbiB0aGUgYWN0aXZlIHJhbmdlIGVuZCBpcyBjaGFuZ2VkLiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG9cbiAgICAgICAgICogdGhlIHNlY3Rpb24gb24gW2V2ZW50c10oeyUgc2x1ZyBvdmVydmlld19tdWx0aXZpZXdjYWxlbmRhciAlfSN0b2MtZXZlbnRzKS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYWN0aXZlUmFuZ2VFbmRDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyB3aGVuIHRoZSBzZWxlY3Rpb24gcmFuZ2UgaXMgY2hhbmdlZC4gRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvXG4gICAgICAgICAqIHRoZSBzZWN0aW9uIG9uIFtldmVudHNdKHslIHNsdWcgb3ZlcnZpZXdfbXVsdGl2aWV3Y2FsZW5kYXIgJX0jdG9jLWV2ZW50cykuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNlbGVjdGlvblJhbmdlQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLmNhbGVuZGFyU3Vic2NyaXB0aW9ucyA9IG5ldyBTdWJzY3JpcHRpb24oKCkgPT4geyB9KTtcbiAgICAgICAgdGhpcy5kYXRlUmFuZ2VTZXJ2aWNlID0gdGhpcy5kYXRlUmFuZ2VTZXJ2aWNlIHx8IG5ldyBEYXRlUmFuZ2VTZXJ2aWNlKCk7XG4gICAgICAgIHJlbmRlcmVyLnNldEF0dHJpYnV0ZShlbGVtZW50Lm5hdGl2ZUVsZW1lbnQsICdhcmlhLW11bHRpc2VsZWN0YWJsZScsICd0cnVlJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgb3Igc2V0cyB0aGUgc2VsZWN0aW9uIHJhbmdlIG9mIHRoZSBjYWxlbmRhci4gV2hlbiBhIG5ldyByYW5nZSBpcyBzZXQsXG4gICAgICogdGhlIGNvbm5lY3RlZCBEYXRlUmFuZ2VTZXJ2aWNlIG5vdGlmaWVzIGFsbCByZWxhdGVkIHBhcnRpZXMuXG4gICAgICovXG4gICAgZ2V0IHNlbGVjdGlvblJhbmdlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxlbmRhciA/IHRoaXMuY2FsZW5kYXIuc2VsZWN0aW9uUmFuZ2UgOiBudWxsO1xuICAgIH1cbiAgICBzZXQgc2VsZWN0aW9uUmFuZ2UocmFuZ2UkJDEpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzRXF1YWxDYWxlbmRhclJhbmdlKHJhbmdlJCQxKSkge1xuICAgICAgICAgICAgdGhpcy5zZXRTZWxlY3Rpb25SYW5nZShyYW5nZSQkMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc0VxdWFsUmFuZ2UodGhpcy5kYXRlUmFuZ2VTZXJ2aWNlLnNlbGVjdGlvblJhbmdlLCByYW5nZSQkMSkpIHtcbiAgICAgICAgICAgIHRoaXMuZGF0ZVJhbmdlU2VydmljZS5zZXRSYW5nZShyYW5nZSQkMSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51cGRhdGVGb2N1c2VkRGF0ZShyYW5nZSQkMSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgb3Igc2V0cyB0aGUgYWN0aXZlIGVuZCBvZiB0aGUgc2VsZWN0aW9uIHJhbmdlLiBUaGlzIG9wdGlvbiBkZXRlcm1pbmVzIHdoaWNoIHJhbmdlIGVuZCB3aWxsIGJlIHVwZGF0ZWQgb25cbiAgICAgKiB1c2VyIGludGVyYWN0aW9uLiBXaGVuIGEgbmV3IGFjdGl2ZSBlbmQgaXMgc2V0LCB0aGUgY29ubmVjdGVkIERhdGVSYW5nZVNlcnZpY2Ugbm90aWZpZXMgYWxsIHJlbGF0ZWQgcGFydGllcy5cbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBTcGVjaWZpZXMgd2hpY2ggZW5kIG9mIHRoZSBzZWxlY3Rpb24gcmFuZ2Ugd2lsbCBiZSBtYXJrZWQgYXMgYWN0aXZlLiBUaGUgYWN0aXZlIGVuZCBnZXRzIG1vZGlmaWVkIHVwb24gdXNlclxuICAgICAqIGludGVyYWN0aW9uLiBXaGVuIGEgbmV3IGFjdGl2ZSBlbmQgaXMgc2V0LCB0aGUgd2lyZWQgRGF0ZVJhbmdlU2VydmljZSBub3RpZmllcyBhbGwgcmVsYXRlZCBjb21wb25lbnRzLiBGb3JcbiAgICAgKiBleGFtcGxlLCB0aGUgc3RhcnQgYW5kIGVuZCBEYXRlSW5wdXQgY29tcG9uZW50cy5cbiAgICAgKlxuICAgICAqID4gSWYgdGhlIHNlbGVjdGlvbiByYW5nZSBpcyB1bmRlZmluZWQsIHRoZSB2YWx1ZSBpcyBpZ25vcmVkLlxuICAgICAqL1xuICAgIGdldCBhY3RpdmVSYW5nZUVuZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsZW5kYXIuYWN0aXZlUmFuZ2VFbmQ7XG4gICAgfVxuICAgIHNldCBhY3RpdmVSYW5nZUVuZChhY3RpdmVSYW5nZSkge1xuICAgICAgICBpZiAodGhpcy5kYXRlUmFuZ2VTZXJ2aWNlLmFjdGl2ZVJhbmdlRW5kID09PSBhY3RpdmVSYW5nZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2FsZW5kYXIuYWN0aXZlUmFuZ2VFbmQgPSBhY3RpdmVSYW5nZTtcbiAgICAgICAgdGhpcy5kYXRlUmFuZ2VTZXJ2aWNlLnNldEFjdGl2ZVJhbmdlRW5kKGFjdGl2ZVJhbmdlKTtcbiAgICB9XG4gICAgZ2V0IGNhbGVuZGFyUmFuZ2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbGVjdGlvblJhbmdlIHx8IEVNUFRZX1NFTEVDVElPTlJBTkdFO1xuICAgIH1cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgY29uc3QgY2FsZW5kYXIgPSB0aGlzLmNhbGVuZGFyO1xuICAgICAgICBjb25zdCBkYXRlUmFuZ2VTZXJ2aWNlID0gdGhpcy5kYXRlUmFuZ2VTZXJ2aWNlO1xuICAgICAgICBjYWxlbmRhci5taW4gPSBlaXRoZXIoZGF0ZVJhbmdlU2VydmljZS5taW4sIGNhbGVuZGFyLm1pbik7XG4gICAgICAgIGNhbGVuZGFyLm1heCA9IGVpdGhlcihkYXRlUmFuZ2VTZXJ2aWNlLm1heCwgY2FsZW5kYXIubWF4KTtcbiAgICAgICAgdGhpcy5hZGRTdWJzY3JpcHRpb25zKGNhbGVuZGFyLmNlbGxFbnRlci5zdWJzY3JpYmUoKHZhbHVlKSA9PiB0aGlzLmhhbmRsZUhvdmVyKHZhbHVlKSksIGNhbGVuZGFyLnZhbHVlQ2hhbmdlLnN1YnNjcmliZSgodmFsdWUpID0+IHRoaXMuaGFuZGxlQ2hhbmdlKHZhbHVlKSksIGRhdGVSYW5nZVNlcnZpY2UuZm9jdXNlZERhdGUkLnN1YnNjcmliZShmb2N1c2VkRGF0ZSA9PiB7XG4gICAgICAgICAgICBpZiAoIWlzRXF1YWwoY2FsZW5kYXIuZm9jdXNlZERhdGUsIGZvY3VzZWREYXRlKSkge1xuICAgICAgICAgICAgICAgIGNhbGVuZGFyLmZvY3VzZWREYXRlID0gZm9jdXNlZERhdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLCBkYXRlUmFuZ2VTZXJ2aWNlLmFjdGl2ZVJhbmdlRW5kJC5zdWJzY3JpYmUocmFuZ2VFbmQgPT4ge1xuICAgICAgICAgICAgaWYgKGNhbGVuZGFyLmFjdGl2ZVJhbmdlRW5kID09PSByYW5nZUVuZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhbGVuZGFyLmFjdGl2ZVJhbmdlRW5kID0gcmFuZ2VFbmQ7XG4gICAgICAgICAgICB0aGlzLmFjdGl2ZVJhbmdlRW5kQ2hhbmdlLmVtaXQocmFuZ2VFbmQpO1xuICAgICAgICAgICAgdGhpcy5jZHIubWFya0ZvckNoZWNrKCk7XG4gICAgICAgIH0pLCBkYXRlUmFuZ2VTZXJ2aWNlLnJhbmdlJC5zdWJzY3JpYmUocmFuZ2UkJDEgPT4ge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmlzRXF1YWxDYWxlbmRhclJhbmdlKHJhbmdlJCQxKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWNjZXB0QW5kRW1pdChyYW5nZSQkMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUZvY3VzZWREYXRlKHJhbmdlJCQxKTtcbiAgICAgICAgfSksIGZyb21FdmVudCh0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudCwgJ2JsdXInKS5zdWJzY3JpYmUoKCkgPT4gdGhpcy5oYW5kbGVCbHVyKCkpKTtcbiAgICB9XG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuY2FsZW5kYXJTdWJzY3JpcHRpb25zLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxuICAgIGFkZFN1YnNjcmlwdGlvbnMoLi4uc3Vic2NyaXB0aW9ucykge1xuICAgICAgICBzdWJzY3JpcHRpb25zLm1hcChzID0+IHRoaXMuY2FsZW5kYXJTdWJzY3JpcHRpb25zLmFkZChzKSk7XG4gICAgfVxuICAgIGlzRXF1YWxDYWxlbmRhclJhbmdlKHJhbmdlJCQxKSB7XG4gICAgICAgIHJldHVybiBpc0VxdWFsUmFuZ2UodGhpcy5jYWxlbmRhci5zZWxlY3Rpb25SYW5nZSwgcmFuZ2UkJDEpO1xuICAgIH1cbiAgICBoYW5kbGVCbHVyKCkge1xuICAgICAgICBjb25zdCB7IHN0YXJ0LCBlbmQgfSA9IHRoaXMuY2FsZW5kYXJSYW5nZTtcbiAgICAgICAgY29uc3QgYXV0b0NvcnJlY3QgPSB0aGlzLmF1dG9Db3JyZWN0T24gPT09ICdibHVyJyAmJiBzdGFydCAhPT0gbnVsbCAmJiBlbmQgIT09IG51bGwgJiYgZW5kIDwgc3RhcnQ7XG4gICAgICAgIGlmIChhdXRvQ29ycmVjdCkge1xuICAgICAgICAgICAgdGhpcy5kYXRlUmFuZ2VTZXJ2aWNlLnNldFJhbmdlKGNsYW1wUmFuZ2Uoc3RhcnQpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBoYW5kbGVDaGFuZ2UodmFsdWUpIHtcbiAgICAgICAgY29uc3Qgc2VydmljZSA9IHRoaXMuZGF0ZVJhbmdlU2VydmljZTtcbiAgICAgICAgY29uc3QgYXV0b0NvcnJlY3QgPSB0aGlzLmF1dG9Db3JyZWN0T24gPT09ICdjaGFuZ2UnICYmIHRoaXMuc2hvdWxkQXV0b0NvcnJlY3QodmFsdWUpO1xuICAgICAgICBjb25zdCBhY3RpdmVFbmQgPSB0aGlzLmNhbGVuZGFyLmFjdGl2ZVJhbmdlRW5kICE9PSAnZW5kJyA/ICdlbmQnIDogKGF1dG9Db3JyZWN0ID8gJ2VuZCcgOiAnc3RhcnQnKTtcbiAgICAgICAgY29uc3QgcmFuZ2UkJDEgPSBhdXRvQ29ycmVjdCA/IGNsYW1wUmFuZ2UodmFsdWUpIDogdGhpcy51cGRhdGVSYW5nZSh2YWx1ZSk7XG4gICAgICAgIGlmICghaXNFcXVhbFJhbmdlKHNlcnZpY2Uuc2VsZWN0aW9uUmFuZ2UsIHJhbmdlJCQxKSkge1xuICAgICAgICAgICAgdGhpcy5hY2NlcHRBbmRFbWl0KHJhbmdlJCQxKTtcbiAgICAgICAgICAgIHNlcnZpY2Uuc2V0QWN0aXZlUmFuZ2VFbmQoYWN0aXZlRW5kKTtcbiAgICAgICAgICAgIHNlcnZpY2Uuc2V0UmFuZ2UocmFuZ2UkJDEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhbmRsZUhvdmVyKHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLmhhc0NvbXBsZXRlUmFuZ2UoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgc3RhcnQsIGVuZCB9ID0gdGhpcy5jYWxlbmRhclJhbmdlO1xuICAgICAgICBjb25zdCBhY3RpdmVSYW5nZUVuZCA9IHRoaXMuY2FsZW5kYXIuYWN0aXZlUmFuZ2VFbmQ7XG4gICAgICAgIGNvbnN0IHVwZGF0ZVJhbmdlID0gKHN0YXJ0ICYmIGFjdGl2ZVJhbmdlRW5kID09PSAnZW5kJykgfHwgKGVuZCAmJiBhY3RpdmVSYW5nZUVuZCA9PT0gJ3N0YXJ0Jyk7XG4gICAgICAgIGlmICh1cGRhdGVSYW5nZSkge1xuICAgICAgICAgICAgdGhpcy5zZXRTZWxlY3Rpb25SYW5nZSh0aGlzLnVwZGF0ZVJhbmdlKHZhbHVlKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaGFzQ29tcGxldGVSYW5nZSgpIHtcbiAgICAgICAgY29uc3QgeyBzdGFydCwgZW5kIH0gPSB0aGlzLmRhdGVSYW5nZVNlcnZpY2Uuc2VsZWN0aW9uUmFuZ2UgfHwgRU1QVFlfU0VMRUNUSU9OUkFOR0U7XG4gICAgICAgIHJldHVybiBCb29sZWFuKHN0YXJ0KSAmJiBCb29sZWFuKGVuZCk7XG4gICAgfVxuICAgIHNob3VsZEF1dG9Db3JyZWN0KHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IHsgZW5kLCBzdGFydCB9ID0gdGhpcy5jYWxlbmRhclJhbmdlO1xuICAgICAgICBpZiAodGhpcy5jYWxlbmRhci5hY3RpdmVSYW5nZUVuZCAhPT0gJ2VuZCcpIHtcbiAgICAgICAgICAgIHJldHVybiBlbmQgIT09IG51bGwgJiYgdmFsdWUgPiBlbmQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gc3RhcnQgIT09IG51bGwgJiYgdmFsdWUgPCBzdGFydDtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGVGb2N1c2VkRGF0ZShyYW5nZSQkMSkge1xuICAgICAgICBpZiAoIXJhbmdlJCQxIHx8IHRoaXMuZGF0ZVJhbmdlU2VydmljZS5mb2N1c2VkRGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGF0ZVJhbmdlU2VydmljZS5zZXRGb2N1c2VkRGF0ZShyYW5nZSQkMS5zdGFydCB8fCByYW5nZSQkMS5lbmQpO1xuICAgIH1cbiAgICB1cGRhdGVSYW5nZSh2YWx1ZSkge1xuICAgICAgICBjb25zdCB7IGVuZCwgc3RhcnQgfSA9IHRoaXMuY2FsZW5kYXJSYW5nZTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsZW5kYXIuYWN0aXZlUmFuZ2VFbmQgIT09ICdlbmQnID8gKHsgc3RhcnQ6IHZhbHVlLCBlbmQgfSkgOiAoeyBzdGFydCwgZW5kOiB2YWx1ZSB9KTtcbiAgICB9XG4gICAgc2V0U2VsZWN0aW9uUmFuZ2UocmFuZ2UkJDEpIHtcbiAgICAgICAgdGhpcy5jYWxlbmRhci5zZWxlY3Rpb25SYW5nZSA9IHJhbmdlJCQxO1xuICAgICAgICB0aGlzLmNhbGVuZGFyLndyaXRlVmFsdWUobnVsbCk7XG4gICAgfVxuICAgIGFjY2VwdEFuZEVtaXQocmFuZ2UkJDEpIHtcbiAgICAgICAgdGhpcy5zZXRTZWxlY3Rpb25SYW5nZShyYW5nZSQkMSk7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uUmFuZ2VDaGFuZ2UuZW1pdChyYW5nZSQkMSk7XG4gICAgfVxufTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIERhdGVSYW5nZVNlbGVjdGlvbkRpcmVjdGl2ZS5wcm90b3R5cGUsIFwiYXV0b0NvcnJlY3RPblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW09iamVjdF0pXG5dLCBEYXRlUmFuZ2VTZWxlY3Rpb25EaXJlY3RpdmUucHJvdG90eXBlLCBcInNlbGVjdGlvblJhbmdlXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW1N0cmluZ10pXG5dLCBEYXRlUmFuZ2VTZWxlY3Rpb25EaXJlY3RpdmUucHJvdG90eXBlLCBcImFjdGl2ZVJhbmdlRW5kXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbl0sIERhdGVSYW5nZVNlbGVjdGlvbkRpcmVjdGl2ZS5wcm90b3R5cGUsIFwiYWN0aXZlUmFuZ2VFbmRDaGFuZ2VcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIE91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXG5dLCBEYXRlUmFuZ2VTZWxlY3Rpb25EaXJlY3RpdmUucHJvdG90eXBlLCBcInNlbGVjdGlvblJhbmdlQ2hhbmdlXCIsIHZvaWQgMCk7XG5EYXRlUmFuZ2VTZWxlY3Rpb25EaXJlY3RpdmUgPSBfX2RlY29yYXRlKFtcbiAgICBEaXJlY3RpdmUoe1xuICAgICAgICBzZWxlY3RvcjogJ1trZW5kb0RhdGVSYW5nZVNlbGVjdGlvbl0nXG4gICAgfSksXG4gICAgX19wYXJhbSg0LCBPcHRpb25hbCgpKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW011bHRpVmlld0NhbGVuZGFyQ29tcG9uZW50LFxuICAgICAgICBDaGFuZ2VEZXRlY3RvclJlZixcbiAgICAgICAgRWxlbWVudFJlZixcbiAgICAgICAgUmVuZGVyZXIyLFxuICAgICAgICBEYXRlUmFuZ2VTZXJ2aWNlXSlcbl0sIERhdGVSYW5nZVNlbGVjdGlvbkRpcmVjdGl2ZSk7XG5cbi8qIHRzbGludDpkaXNhYmxlOmRpcmVjdGl2ZS1jbGFzcy1zdWZmaXggZGlyZWN0aXZlLXNlbGVjdG9yICovXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgS0Zvck9mQ29udGV4dCB7XG4gICAgY29uc3RydWN0b3IoJGltcGxpY2l0LCBrRm9yT2YsIGluZGV4LCBjb3VudCkge1xuICAgICAgICB0aGlzLiRpbXBsaWNpdCA9ICRpbXBsaWNpdDtcbiAgICAgICAgdGhpcy5rRm9yT2YgPSBrRm9yT2Y7XG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgdGhpcy5jb3VudCA9IGNvdW50O1xuICAgIH1cbiAgICBnZXQgZmlyc3QoKSB7IHJldHVybiB0aGlzLmluZGV4ID09PSAwOyB9XG4gICAgZ2V0IGxhc3QoKSB7IHJldHVybiB0aGlzLmluZGV4ID09PSB0aGlzLmNvdW50IC0gMTsgfVxuICAgIGdldCBldmVuKCkgeyByZXR1cm4gdGhpcy5pbmRleCAlIDIgPT09IDA7IH1cbiAgICBnZXQgb2RkKCkgeyByZXR1cm4gIXRoaXMuZXZlbjsgfVxufVxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmxldCBLRm9yT2YgPSBjbGFzcyBLRm9yT2Yge1xuICAgIGNvbnN0cnVjdG9yKF92aWV3Q29udGFpbmVyLCBfdGVtcGxhdGUsIF9kaWZmZXJzKSB7XG4gICAgICAgIHRoaXMuX3ZpZXdDb250YWluZXIgPSBfdmlld0NvbnRhaW5lcjtcbiAgICAgICAgdGhpcy5fdGVtcGxhdGUgPSBfdGVtcGxhdGU7XG4gICAgICAgIHRoaXMuX2RpZmZlcnMgPSBfZGlmZmVycztcbiAgICAgICAgdGhpcy5fZGlmZmVyID0gbnVsbDtcbiAgICB9XG4gICAgc2V0IGtGb3JUZW1wbGF0ZSh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX3RlbXBsYXRlID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbmdPbkNoYW5nZXMoY2hhbmdlcykge1xuICAgICAgICBpZiAoJ2tGb3JPZicgaW4gY2hhbmdlcykge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBjaGFuZ2VzLmtGb3JPZi5jdXJyZW50VmFsdWU7XG4gICAgICAgICAgICBpZiAodGhpcy5fZGlmZmVyIHx8ICF2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGlmZmVyID0gdGhpcy5fZGlmZmVycy5maW5kKHZhbHVlKS5jcmVhdGUodGhpcy5rRm9yVHJhY2tCeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IGZpbmQgYSBkaWZmZXIgc3VwcG9ydGluZyBvYmplY3QgJyR7dmFsdWV9JyBvZiB0eXBlICcke2dldFR5cGVOYW1lRm9yRGVidWdnaW5nKHZhbHVlKX0nLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIG5nRG9DaGVjaygpIHtcbiAgICAgICAgaWYgKHRoaXMuX2RpZmZlcikge1xuICAgICAgICAgICAgY29uc3QgY2hhbmdlcyA9IHRoaXMuX2RpZmZlci5kaWZmKHRoaXMua0Zvck9mKTtcbiAgICAgICAgICAgIGlmIChjaGFuZ2VzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYXBwbHlDaGFuZ2VzKGNoYW5nZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIF9hcHBseUNoYW5nZXMoY2hhbmdlcykge1xuICAgICAgICBpZiAoIWlzRG9jdW1lbnRBdmFpbGFibGUoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZpZXdDb250YWluZXJMZW5ndGggPSB0aGlzLl92aWV3Q29udGFpbmVyLmxlbmd0aDtcbiAgICAgICAgY29uc3QgZGF0YUxlbmd0aCA9IHRoaXMua0Zvck9mLmxlbmd0aDtcbiAgICAgICAgY29uc3QgdHVwbGVzID0ge307XG4gICAgICAgIGNoYW5nZXMuZm9yRWFjaE9wZXJhdGlvbigocmVjb3JkLCBfLCBjdXJyZW50SW5kZXgpID0+IHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50SW5kZXggIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0dXBsZXNbY3VycmVudEluZGV4XSA9IHJlY29yZC5pdGVtO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHZpZXdDb250YWluZXJMZW5ndGg7IGkgPCBkYXRhTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuX3ZpZXdDb250YWluZXIuY3JlYXRlRW1iZWRkZWRWaWV3KHRoaXMuX3RlbXBsYXRlLCBuZXcgS0Zvck9mQ29udGV4dChudWxsLCB0aGlzLmtGb3JPZiwgLTEsIC0xKSwgaSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuX3ZpZXdDb250YWluZXIubGVuZ3RoOyBpID4gZGF0YUxlbmd0aDsgaS0tKSB7XG4gICAgICAgICAgICB0aGlzLl92aWV3Q29udGFpbmVyLnJlbW92ZShpIC0gMSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl92aWV3Q29udGFpbmVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCB2aWV3ID0gdGhpcy5fdmlld0NvbnRhaW5lci5nZXQoaSk7XG4gICAgICAgICAgICB2aWV3LmNvbnRleHQuaW5kZXggPSBpO1xuICAgICAgICAgICAgdmlldy5jb250ZXh0LmNvdW50ID0gbGVuZ3RoO1xuICAgICAgICAgICAgdmlldy5jb250ZXh0LiRpbXBsaWNpdCA9IHR1cGxlc1tpXSB8fCBudWxsO1xuICAgICAgICB9XG4gICAgfVxufTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIEtGb3JPZi5wcm90b3R5cGUsIFwia0Zvck9mXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbilcbl0sIEtGb3JPZi5wcm90b3R5cGUsIFwia0ZvclRyYWNrQnlcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFRlbXBsYXRlUmVmKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW1RlbXBsYXRlUmVmXSlcbl0sIEtGb3JPZi5wcm90b3R5cGUsIFwia0ZvclRlbXBsYXRlXCIsIG51bGwpO1xuS0Zvck9mID0gX19kZWNvcmF0ZShbXG4gICAgRGlyZWN0aXZlKHsgc2VsZWN0b3I6ICdba0Zvcl1ba0Zvck9mXScgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtWaWV3Q29udGFpbmVyUmVmLFxuICAgICAgICBUZW1wbGF0ZVJlZixcbiAgICAgICAgSXRlcmFibGVEaWZmZXJzXSlcbl0sIEtGb3JPZik7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuZnVuY3Rpb24gZ2V0VHlwZU5hbWVGb3JEZWJ1Z2dpbmcodHlwZSkge1xuICAgIHJldHVybiB0eXBlLm5hbWUgfHwgdHlwZW9mIHR5cGU7XG59XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5sZXQgSGVhZGVyQ29tcG9uZW50ID0gY2xhc3MgSGVhZGVyQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcihidXMsIGNkciwgbG9jYWxpemF0aW9uLCBpbnRsLCBkaXNhYmxlZERhdGVzU2VydmljZSkge1xuICAgICAgICB0aGlzLmJ1cyA9IGJ1cztcbiAgICAgICAgdGhpcy5jZHIgPSBjZHI7XG4gICAgICAgIHRoaXMubG9jYWxpemF0aW9uID0gbG9jYWxpemF0aW9uO1xuICAgICAgICB0aGlzLmludGwgPSBpbnRsO1xuICAgICAgICB0aGlzLmRpc2FibGVkRGF0ZXNTZXJ2aWNlID0gZGlzYWJsZWREYXRlc1NlcnZpY2U7XG4gICAgICAgIHRoaXMubmF2aWdhdGUgPSB0cnVlO1xuICAgICAgICB0aGlzLnRvZGF5QXZhaWxhYmxlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5taW4gPSBuZXcgRGF0ZShNSU5fREFURSk7XG4gICAgICAgIHRoaXMubWF4ID0gbmV3IERhdGUoTUFYX0RBVEUpO1xuICAgICAgICB0aGlzLnJhbmdlTGVuZ3RoID0gMTtcbiAgICAgICAgdGhpcy5pc1ByZXZEaXNhYmxlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuaXNOZXh0RGlzYWJsZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLnNob3dOYXZpZ2F0aW9uQnV0dG9ucyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnRvZGF5QnV0dG9uQ2xpY2sgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMucHJldkJ1dHRvbkNsaWNrID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLm5leHRCdXR0b25DbGljayA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5nZXRDb21wb25lbnRDbGFzcyA9IHRydWU7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucyA9IG5ldyBTdWJzY3JpcHRpb24oKTtcbiAgICB9XG4gICAgbmdPbkluaXQoKSB7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9uc1xuICAgICAgICAgICAgLmFkZCh0aGlzLmludGwuY2hhbmdlcy5zdWJzY3JpYmUodGhpcy5pbnRsQ2hhbmdlLmJpbmQodGhpcykpKVxuICAgICAgICAgICAgLmFkZCh0aGlzLmxvY2FsaXphdGlvbi5jaGFuZ2VzLnN1YnNjcmliZSh0aGlzLmwxMG5DaGFuZ2UuYmluZCh0aGlzKSkpXG4gICAgICAgICAgICAuYWRkKHRoaXMuZGlzYWJsZWREYXRlc1NlcnZpY2UuY2hhbmdlcy5zdWJzY3JpYmUodGhpcy5zZXRUb2RheUF2YWlsYWJpbGl0eS5iaW5kKHRoaXMpKSk7XG4gICAgfVxuICAgIG5nT25DaGFuZ2VzKF8pIHtcbiAgICAgICAgY29uc3Qgc2VydmljZSA9IHRoaXMuYnVzLnNlcnZpY2UodGhpcy5hY3RpdmVWaWV3KTtcbiAgICAgICAgaWYgKCFzZXJ2aWNlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hY3RpdmVWaWV3VmFsdWUgPSBDYWxlbmRhclZpZXdFbnVtW3RoaXMuYWN0aXZlVmlld107XG4gICAgICAgIHRoaXMudG9kYXlNZXNzYWdlID0gdGhpcy5sb2NhbGl6YXRpb24uZ2V0KCd0b2RheScpO1xuICAgICAgICB0aGlzLnNldFRvZGF5QXZhaWxhYmlsaXR5KCk7XG4gICAgICAgIHRoaXMubmF2aWdhdGUgPSB0aGlzLmJ1cy5jYW5Nb3ZlVXAodGhpcy5hY3RpdmVWaWV3KTtcbiAgICAgICAgdGhpcy50aXRsZSA9IHRoaXMuZ2V0VGl0bGUoKTtcbiAgICB9XG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy51bnN1YnNjcmliZSgpO1xuICAgIH1cbiAgICBoYW5kbGVUb2RheUNsaWNrKCkge1xuICAgICAgICBpZiAoIXRoaXMudG9kYXlBdmFpbGFibGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJ1cy5tb3ZlVG9Cb3R0b20odGhpcy5hY3RpdmVWaWV3KTtcbiAgICAgICAgdGhpcy50b2RheUJ1dHRvbkNsaWNrLmVtaXQoZGF0ZUluUmFuZ2UoZ2V0VG9kYXkoKSwgdGhpcy5taW4sIHRoaXMubWF4KSk7XG4gICAgfVxuICAgIGhhbmRsZU5hdmlnYXRpb24oKSB7XG4gICAgICAgIGlmICghdGhpcy5uYXZpZ2F0ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYnVzLm1vdmVVcCh0aGlzLmFjdGl2ZVZpZXcpO1xuICAgIH1cbiAgICBpbnRsQ2hhbmdlKCkge1xuICAgICAgICBpZiAodGhpcy5jdXJyZW50RGF0ZSAmJiB0aGlzLmJ1cy5zZXJ2aWNlKHRoaXMuYWN0aXZlVmlldykpIHtcbiAgICAgICAgICAgIHRoaXMudGl0bGUgPSB0aGlzLmdldFRpdGxlKCk7XG4gICAgICAgICAgICB0aGlzLmNkci5tYXJrRm9yQ2hlY2soKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsMTBuQ2hhbmdlKCkge1xuICAgICAgICB0aGlzLnByZXZCdXR0b25UaXRsZSA9IHRoaXMubG9jYWxpemF0aW9uLmdldCgncHJldkJ1dHRvblRpdGxlJyk7XG4gICAgICAgIHRoaXMubmV4dEJ1dHRvblRpdGxlID0gdGhpcy5sb2NhbGl6YXRpb24uZ2V0KCduZXh0QnV0dG9uVGl0bGUnKTtcbiAgICAgICAgdGhpcy50b2RheU1lc3NhZ2UgPSB0aGlzLmxvY2FsaXphdGlvbi5nZXQoJ3RvZGF5Jyk7XG4gICAgICAgIHRoaXMuY2RyLm1hcmtGb3JDaGVjaygpO1xuICAgIH1cbiAgICBnZXRUaXRsZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmN1cnJlbnREYXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2VydmljZSA9IHRoaXMuYnVzLnNlcnZpY2UodGhpcy5hY3RpdmVWaWV3KTtcbiAgICAgICAgY29uc3QgdGFrZSA9IHRoaXMucmFuZ2VMZW5ndGggLSAxO1xuICAgICAgICBjb25zdCB0aXRsZSA9IHNlcnZpY2UudGl0bGUodGhpcy5jdXJyZW50RGF0ZSk7XG4gICAgICAgIGNvbnN0IG5leHREYXRlID0gc2VydmljZS5hZGRUb0RhdGUodGhpcy5jdXJyZW50RGF0ZSwgdGFrZSk7XG4gICAgICAgIGlmICh0YWtlIDwgMSB8fCAhc2VydmljZS5pc0luUmFuZ2UobmV4dERhdGUsIHRoaXMubWluLCB0aGlzLm1heCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aXRsZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYCR7dGl0bGV9IC0gJHtzZXJ2aWNlLnRpdGxlKG5leHREYXRlKX1gO1xuICAgIH1cbiAgICBzZXRUb2RheUF2YWlsYWJpbGl0eSgpIHtcbiAgICAgICAgY29uc3QgdG9kYXkgPSBnZXRUb2RheSgpO1xuICAgICAgICBjb25zdCBpc1RvZGF5SW5SYW5nZSA9IGlzSW5SYW5nZSh0b2RheSwgZ2V0RGF0ZSh0aGlzLm1pbiksIGdldERhdGUodGhpcy5tYXgpKTtcbiAgICAgICAgY29uc3QgaXNEaXNhYmxlZCA9IHRoaXMuZGlzYWJsZWREYXRlc1NlcnZpY2UuaXNEYXRlRGlzYWJsZWQodG9kYXkpO1xuICAgICAgICB0aGlzLnRvZGF5QXZhaWxhYmxlID0gaXNUb2RheUluUmFuZ2UgJiYgIWlzRGlzYWJsZWQ7XG4gICAgICAgIHRoaXMuY2RyLm1hcmtGb3JDaGVjaygpO1xuICAgIH1cbn07XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBIZWFkZXJDb21wb25lbnQucHJvdG90eXBlLCBcImFjdGl2ZVZpZXdcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIERhdGUpXG5dLCBIZWFkZXJDb21wb25lbnQucHJvdG90eXBlLCBcImN1cnJlbnREYXRlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBEYXRlKVxuXSwgSGVhZGVyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJtaW5cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIERhdGUpXG5dLCBIZWFkZXJDb21wb25lbnQucHJvdG90eXBlLCBcIm1heFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgSGVhZGVyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJyYW5nZUxlbmd0aFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgVGVtcGxhdGVSZWYpXG5dLCBIZWFkZXJDb21wb25lbnQucHJvdG90eXBlLCBcInRlbXBsYXRlUmVmXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgSGVhZGVyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJpc1ByZXZEaXNhYmxlZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIEhlYWRlckNvbXBvbmVudC5wcm90b3R5cGUsIFwiaXNOZXh0RGlzYWJsZWRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBIZWFkZXJDb21wb25lbnQucHJvdG90eXBlLCBcInNob3dOYXZpZ2F0aW9uQnV0dG9uc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbl0sIEhlYWRlckNvbXBvbmVudC5wcm90b3R5cGUsIFwidG9kYXlCdXR0b25DbGlja1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbl0sIEhlYWRlckNvbXBvbmVudC5wcm90b3R5cGUsIFwicHJldkJ1dHRvbkNsaWNrXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBPdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxuXSwgSGVhZGVyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJuZXh0QnV0dG9uQ2xpY2tcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RCaW5kaW5nKFwiY2xhc3Muay1jYWxlbmRhci1oZWFkZXJcIiksXG4gICAgSG9zdEJpbmRpbmcoXCJjbGFzcy5rLWhzdGFja1wiKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIEhlYWRlckNvbXBvbmVudC5wcm90b3R5cGUsIFwiZ2V0Q29tcG9uZW50Q2xhc3NcIiwgdm9pZCAwKTtcbkhlYWRlckNvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tY2FsZW5kYXItaGVhZGVyJyxcbiAgICAgICAgdGVtcGxhdGU6IGBcbiAgICA8c3BhbiBjbGFzcz1cImstYnV0dG9uIGstZmxhdCBrLXRpdGxlIGstY2FsZW5kYXItdGl0bGVcIiBbY2xhc3Muay1zdGF0ZS1kaXNhYmxlZF09XCIhbmF2aWdhdGVcIlxuICAgICAgICBba2VuZG9FdmVudHNPdXRzaWRlQW5ndWxhcl09XCJ7XG4gICAgICAgICAgICBjbGljazogaGFuZGxlTmF2aWdhdGlvblxuICAgICAgICB9XCJcbiAgICAgICAgW3Njb3BlXT1cInRoaXNcIj5cbiAgICAgICAgPG5nLXRlbXBsYXRlIFtuZ0lmXT1cIiF0ZW1wbGF0ZVJlZlwiPnt7dGl0bGV9fTwvbmctdGVtcGxhdGU+XG4gICAgICAgIDxuZy10ZW1wbGF0ZVxuICAgICAgICAgICAgW25nSWZdPVwidGVtcGxhdGVSZWZcIlxuICAgICAgICAgICAgW25nVGVtcGxhdGVPdXRsZXRdPVwidGVtcGxhdGVSZWZcIlxuICAgICAgICAgICAgW25nVGVtcGxhdGVPdXRsZXRDb250ZXh0XT1cInsgJGltcGxpY2l0OiB0aXRsZSwgYWN0aXZlVmlldzogYWN0aXZlVmlld1ZhbHVlLCBkYXRlOiBjdXJyZW50RGF0ZSB9XCJcbiAgICAgICAgPjwvbmctdGVtcGxhdGU+XG4gICAgPC9zcGFuPlxuICAgIDxzcGFuIGNsYXNzPVwiay1zcGFjZXJcIj48L3NwYW4+XG4gICAgPHNwYW4gY2xhc3M9XCJrLWNhbGVuZGFyLW5hdiBrLWhzdGFja1wiPlxuICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICAqbmdJZj1cInNob3dOYXZpZ2F0aW9uQnV0dG9uc1wiXG4gICAgICAgICAgICBjbGFzcz1cImstYnV0dG9uIGstZmxhdCBrLWljb24tYnV0dG9uIGstcHJldi12aWV3XCJcbiAgICAgICAgICAgIHR5cGU9XCJidXR0b25cIlxuICAgICAgICAgICAgW2F0dHIuYXJpYS1kaXNhYmxlZF09XCJpc1ByZXZEaXNhYmxlZFwiXG4gICAgICAgICAgICBbZGlzYWJsZWRdPVwiaXNQcmV2RGlzYWJsZWRcIlxuICAgICAgICAgICAgW3RpdGxlXT1cInByZXZCdXR0b25UaXRsZVwiXG4gICAgICAgICAgICAoY2xpY2spPVwicHJldkJ1dHRvbkNsaWNrLmVtaXQoKVwiXG4gICAgICAgID5cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiay1pY29uIGstaS1hcnJvdy02MC1sZWZ0XCI+PC9zcGFuPlxuICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgPHNwYW5cbiAgICAgICAgICAgIGNsYXNzPVwiay10b2RheSBrLW5hdi10b2RheVwiXG4gICAgICAgICAgICBbY2xhc3Muay1zdGF0ZS1kaXNhYmxlZF09XCIhdG9kYXlBdmFpbGFibGVcIlxuICAgICAgICAgICAgW2tlbmRvRXZlbnRzT3V0c2lkZUFuZ3VsYXJdPVwie1xuICAgICAgICAgICAgICAgIGNsaWNrOiBoYW5kbGVUb2RheUNsaWNrXG4gICAgICAgICAgICB9XCJcbiAgICAgICAgICAgIFtzY29wZV09XCJ0aGlzXCJcbiAgICAgICAgPlxuICAgICAgICAgICAge3sgdG9kYXlNZXNzYWdlIH19XG4gICAgICAgIDwvc3Bhbj5cbiAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgKm5nSWY9XCJzaG93TmF2aWdhdGlvbkJ1dHRvbnNcIlxuICAgICAgICAgICAgY2xhc3M9XCJrLWJ1dHRvbiBrLWZsYXQgay1pY29uLWJ1dHRvbiBrLW5leHQtdmlld1wiXG4gICAgICAgICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgICAgIFthdHRyLmFyaWEtZGlzYWJsZWRdPVwiaXNOZXh0RGlzYWJsZWRcIlxuICAgICAgICAgICAgW2Rpc2FibGVkXT1cImlzTmV4dERpc2FibGVkXCJcbiAgICAgICAgICAgIFt0aXRsZV09XCJuZXh0QnV0dG9uVGl0bGVcIlxuICAgICAgICAgICAgKGNsaWNrKT1cIm5leHRCdXR0b25DbGljay5lbWl0KClcIlxuICAgICAgICA+XG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cImstaWNvbiBrLWktYXJyb3ctNjAtcmlnaHRcIj48L3NwYW4+XG4gICAgICAgIDwvYnV0dG9uPlxuICAgIDwvc3Bhbj5cbiAgYFxuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQnVzVmlld1NlcnZpY2UsXG4gICAgICAgIENoYW5nZURldGVjdG9yUmVmLFxuICAgICAgICBMb2NhbGl6YXRpb25TZXJ2aWNlLFxuICAgICAgICBJbnRsU2VydmljZSxcbiAgICAgICAgRGlzYWJsZWREYXRlc1NlcnZpY2VdKVxuXSwgSGVhZGVyQ29tcG9uZW50KTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmxldCBWaWV3Q29tcG9uZW50ID0gY2xhc3MgVmlld0NvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoYnVzLCBpbnRsLCBjZHIsIGVsZW1lbnQsIHpvbmUsIHJlbmRlcmVyLCBkaXNhYmxlZERhdGVzU2VydmljZSkge1xuICAgICAgICB0aGlzLmJ1cyA9IGJ1cztcbiAgICAgICAgdGhpcy5pbnRsID0gaW50bDtcbiAgICAgICAgdGhpcy5jZHIgPSBjZHI7XG4gICAgICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICAgIHRoaXMuem9uZSA9IHpvbmU7XG4gICAgICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgICAgICAgdGhpcy5kaXNhYmxlZERhdGVzU2VydmljZSA9IGRpc2FibGVkRGF0ZXNTZXJ2aWNlO1xuICAgICAgICB0aGlzLmRpcmVjdGlvbiA9ICd2ZXJ0aWNhbCc7XG4gICAgICAgIHRoaXMuaXNBY3RpdmUgPSB0cnVlO1xuICAgICAgICB0aGlzLnNlbGVjdGVkRGF0ZXMgPSBbXTtcbiAgICAgICAgdGhpcy5jZWxsQ2xpY2sgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMud2Vla051bWJlckNlbGxDbGljayA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5jZWxsRW50ZXIgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuY2VsbExlYXZlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLmNvbFNwYW4gPSAwO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMgPSBuZXcgU3Vic2NyaXB0aW9uKCk7XG4gICAgICAgIHRoaXMuZG9tRXZlbnRzID0gW107XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5hZGQodGhpcy5pbnRsLmNoYW5nZXMuc3Vic2NyaWJlKHRoaXMuaW50bENoYW5nZS5iaW5kKHRoaXMpKSk7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5hZGQodGhpcy5kaXNhYmxlZERhdGVzU2VydmljZS5jaGFuZ2VzLnN1YnNjcmliZSh0aGlzLmRpc2FibGVkRGF0ZXNDaGFuZ2UuYmluZCh0aGlzKSkpO1xuICAgIH1cbiAgICBnZXQgd2Vla051bWJlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2hvd1dlZWtOdW1iZXJzICYmIHRoaXMuYWN0aXZlVmlldyA9PT0gQ2FsZW5kYXJWaWV3RW51bS5tb250aDtcbiAgICB9XG4gICAgc2V0IHdlZWtOdW1iZXIoc2hvd1dlZWtOdW1iZXJzKSB7XG4gICAgICAgIHRoaXMuc2hvd1dlZWtOdW1iZXJzID0gc2hvd1dlZWtOdW1iZXJzO1xuICAgIH1cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgaWYgKHRoaXMuZWxlbWVudCkge1xuICAgICAgICAgICAgdGhpcy56b25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmJpbmRFdmVudHMoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXMpIHtcbiAgICAgICAgdGhpcy5zZXJ2aWNlID0gdGhpcy5idXMuc2VydmljZSh0aGlzLmFjdGl2ZVZpZXcpO1xuICAgICAgICBpZiAoIXRoaXMuc2VydmljZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29sU3BhbiA9IHRoaXMuc2VydmljZS5yb3dMZW5ndGgoeyBwcmVwZW5kQ2VsbDogdGhpcy53ZWVrTnVtYmVyIH0pO1xuICAgICAgICB0aGlzLnRpdGxlID0gdGhpcy5zZXJ2aWNlLnRpdGxlKHRoaXMudmlld0RhdGUpO1xuICAgICAgICB0aGlzLnVwZGF0ZURhdGEoKTtcbiAgICAgICAgaWYgKGNoYW5nZXMuYWN0aXZlVmlldykge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50Q2VsbEluZGV4ID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIHRoaXMuZG9tRXZlbnRzLmZvckVhY2godW5zdWJzY3JpYmVDYWxsYmFjayA9PiB1bnN1YnNjcmliZUNhbGxiYWNrKCkpO1xuICAgIH1cbiAgICBpc0hvcml6b250YWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRpcmVjdGlvbiA9PT0gJ2hvcml6b250YWwnO1xuICAgIH1cbiAgICBpc01vbnRoVmlldygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWN0aXZlVmlldyA9PT0gQ2FsZW5kYXJWaWV3RW51bS5tb250aDtcbiAgICB9XG4gICAgc2hvdWxkUmVuZGVyQ2VsbENvbnRlbnQoY2VsbEN0eCkge1xuICAgICAgICByZXR1cm4gaXNQcmVzZW50KGNlbGxDdHgpICYmICEoIXRoaXMuaXNIb3Jpem9udGFsKCkgJiYgY2VsbEN0eC5pc090aGVyTW9udGgpO1xuICAgIH1cbiAgICBmaXJzdERhdGUocm93Q3R4KSB7XG4gICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuZmlyc3RXZWVrRGF0ZUNvbnRleHQocm93Q3R4KTtcbiAgICAgICAgcmV0dXJuIGN0eCA/IGN0eC52YWx1ZSA6IG51bGw7XG4gICAgfVxuICAgIGdldFdlZWtOdW1iZXIoZGF0ZSkge1xuICAgICAgICBpZiAoIXRoaXMud2Vla051bWJlcikge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdlZWtJblllYXIoZGF0ZSwgdGhpcy5pbnRsLmZpcnN0RGF5KCkpO1xuICAgIH1cbiAgICBnZXRXZWVrTnVtYmVyQ29udGV4dChyb3dDdHgpIHtcbiAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5maXJzdFdlZWtEYXRlQ29udGV4dChyb3dDdHgpO1xuICAgICAgICBpZiAoIXRoaXMud2Vla051bWJlciB8fCAhY3R4KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB3ZWVrTnVtYmVyID0gd2Vla0luWWVhcihjdHgudmFsdWUsIHRoaXMuaW50bC5maXJzdERheSgpKS50b1N0cmluZygpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZm9ybWF0dGVkVmFsdWU6IHdlZWtOdW1iZXIsXG4gICAgICAgICAgICBpZDogbnVsbCxcbiAgICAgICAgICAgIGlzRm9jdXNlZDogZmFsc2UsXG4gICAgICAgICAgICBpc1NlbGVjdGVkOiBmYWxzZSxcbiAgICAgICAgICAgIGlzV2Vla2VuZDogZmFsc2UsXG4gICAgICAgICAgICB0aXRsZTogd2Vla051bWJlcixcbiAgICAgICAgICAgIHZhbHVlOiBjbG9uZURhdGUoY3R4LnZhbHVlKVxuICAgICAgICB9O1xuICAgIH1cbiAgICBnZXRTdHlsZXMoY29udGV4dCkge1xuICAgICAgICBjb25zdCB7IGlzUmFuZ2VFbmQsIGlzUmFuZ2VTdGFydCB9ID0gY29udGV4dDtcbiAgICAgICAgY29uc3QgaXNFbmRBY3RpdmUgPSB0aGlzLmFjdGl2ZVJhbmdlRW5kID09PSAnZW5kJyAmJiBpc1JhbmdlRW5kO1xuICAgICAgICBjb25zdCBpc1N0YXJ0QWN0aXZlID0gdGhpcy5hY3RpdmVSYW5nZUVuZCA9PT0gJ3N0YXJ0JyAmJiBpc1JhbmdlU3RhcnQ7XG4gICAgICAgIHJldHVybiBzdHJpbmdpZnlDbGFzc09iamVjdCh7XG4gICAgICAgICAgICAnay1yYW5nZS1lbmQnOiAhY29udGV4dC5pc090aGVyTW9udGggJiYgaXNSYW5nZUVuZCxcbiAgICAgICAgICAgICdrLXJhbmdlLW1pZCc6ICFjb250ZXh0LmlzT3RoZXJNb250aCAmJiBjb250ZXh0LmlzUmFuZ2VNaWQsXG4gICAgICAgICAgICAnay1yYW5nZS1zcGxpdC1lbmQnOiAhY29udGV4dC5pc090aGVyTW9udGggJiYgY29udGV4dC5pc1JhbmdlU3BsaXRFbmQsXG4gICAgICAgICAgICAnay1yYW5nZS1zcGxpdC1zdGFydCc6ICFjb250ZXh0LmlzT3RoZXJNb250aCAmJiBjb250ZXh0LmlzUmFuZ2VTcGxpdFN0YXJ0LFxuICAgICAgICAgICAgJ2stcmFuZ2Utc3RhcnQnOiAhY29udGV4dC5pc090aGVyTW9udGggJiYgaXNSYW5nZVN0YXJ0LFxuICAgICAgICAgICAgJ2stc3RhdGUtYWN0aXZlJzogaXNTdGFydEFjdGl2ZSB8fCBpc0VuZEFjdGl2ZSxcbiAgICAgICAgICAgICdrLXN0YXRlLWZvY3VzZWQnOiAhY29udGV4dC5pc090aGVyTW9udGggJiYgdGhpcy5pc0FjdGl2ZSAmJiBjb250ZXh0LmlzRm9jdXNlZCxcbiAgICAgICAgICAgICdrLXN0YXRlLXNlbGVjdGVkJzogIWNvbnRleHQuaXNPdGhlck1vbnRoICYmIChjb250ZXh0LmlzU2VsZWN0ZWQgfHwgaXNSYW5nZVN0YXJ0IHx8IGlzUmFuZ2VFbmQpLFxuICAgICAgICAgICAgJ2stdG9kYXknOiAhY29udGV4dC5pc090aGVyTW9udGggJiYgY29udGV4dC5pc1RvZGF5LFxuICAgICAgICAgICAgJ2std2Vla2VuZCc6IGNvbnRleHQuaXNXZWVrZW5kLFxuICAgICAgICAgICAgJ2stc3RhdGUtZGlzYWJsZWQnOiBjb250ZXh0LmlzRGlzYWJsZWQsXG4gICAgICAgICAgICAnay1vdGhlci1tb250aCc6IGNvbnRleHQuaXNPdGhlck1vbnRoXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB0YWJsZUNlbGxJbmRleChyb3dJbmRleCwgY2VsbEluZGV4KSB7XG4gICAgICAgIHJldHVybiBgJHtyb3dJbmRleH06JHtjZWxsSW5kZXh9YDtcbiAgICB9XG4gICAgaGFuZGxlV2Vla051bWJlckNsaWNrKHdlZWspIHtcbiAgICAgICAgY29uc3QgYXZhaWxhYmxlRGF0ZXMgPSB3ZWVrLm1hcChpdGVtID0+IGl0ZW0udmFsdWUpLmZpbHRlcihkYXRlID0+ICF0aGlzLmRpc2FibGVkRGF0ZXNTZXJ2aWNlLmlzRGF0ZURpc2FibGVkKGRhdGUpKTtcbiAgICAgICAgdGhpcy53ZWVrTnVtYmVyQ2VsbENsaWNrLmVtaXQoYXZhaWxhYmxlRGF0ZXMpO1xuICAgIH1cbiAgICBmaXJzdFdlZWtEYXRlQ29udGV4dChyb3dDdHgpIHtcbiAgICAgICAgaWYgKCF0aGlzLndlZWtOdW1iZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGxldCBpZHggPSAwO1xuICAgICAgICBsZXQgY3R4ID0gdGhpcy5zaG91bGRSZW5kZXJDZWxsQ29udGVudChyb3dDdHhbaWR4XSkgPyByb3dDdHhbaWR4XSA6IG51bGw7XG4gICAgICAgIHdoaWxlICghY3R4ICYmIGlkeCA8IHJvd0N0eC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IGNlbGxDdHggPSByb3dDdHhbKytpZHhdO1xuICAgICAgICAgICAgY3R4ID0gdGhpcy5zaG91bGRSZW5kZXJDZWxsQ29udGVudChjZWxsQ3R4KSA/IGNlbGxDdHggOiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjdHg7XG4gICAgfVxuICAgIHVwZGF0ZURhdGEoKSB7XG4gICAgICAgIGNvbnN0IHRpbWUgPSBsYXN0KHRoaXMuc2VsZWN0ZWREYXRlcykgfHwgZ2V0VG9kYXkoKTtcbiAgICAgICAgY29uc3Qgdmlld0RhdGUgPSBzZXRUaW1lKHRoaXMudmlld0RhdGUsIHRpbWUpO1xuICAgICAgICB0aGlzLmRhdGEgPSB0aGlzLnNlcnZpY2UuZGF0YSh7XG4gICAgICAgICAgICBjZWxsVUlEOiB0aGlzLmNlbGxVSUQsXG4gICAgICAgICAgICBmb2N1c2VkRGF0ZTogdGhpcy5mb2N1c2VkRGF0ZSxcbiAgICAgICAgICAgIGlzQWN0aXZlVmlldzogIXRoaXMuYnVzLmNhbk1vdmVEb3duKHRoaXMuYWN0aXZlVmlldyksXG4gICAgICAgICAgICBtYXg6IHRoaXMubWF4LFxuICAgICAgICAgICAgbWluOiB0aGlzLm1pbixcbiAgICAgICAgICAgIHNlbGVjdGVkRGF0ZXM6IHRoaXMuc2VsZWN0ZWREYXRlcyxcbiAgICAgICAgICAgIHNlbGVjdGlvblJhbmdlOiB0aGlzLnNlbGVjdGlvblJhbmdlLFxuICAgICAgICAgICAgdmlld0RhdGU6IHZpZXdEYXRlLFxuICAgICAgICAgICAgaXNEYXRlRGlzYWJsZWQ6IHRoaXMuZGlzYWJsZWREYXRlc1NlcnZpY2UuaXNEYXRlRGlzYWJsZWQsXG4gICAgICAgICAgICBkaXJlY3Rpb246IHRoaXMuZGlyZWN0aW9uXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpbnRsQ2hhbmdlKCkge1xuICAgICAgICB0aGlzLnVwZGF0ZURhdGEoKTtcbiAgICAgICAgdGhpcy5jZHIubWFya0ZvckNoZWNrKCk7XG4gICAgfVxuICAgIGRpc2FibGVkRGF0ZXNDaGFuZ2UoKSB7XG4gICAgICAgIHRoaXMudXBkYXRlRGF0YSgpO1xuICAgICAgICB0aGlzLmNkci5tYXJrRm9yQ2hlY2soKTtcbiAgICB9XG4gICAgYmluZEV2ZW50cygpIHtcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50O1xuICAgICAgICB0aGlzLmRvbUV2ZW50cy5wdXNoKHRoaXMucmVuZGVyZXIubGlzdGVuKGVsZW1lbnQsICdtb3VzZW92ZXInLCB0aGlzLmNlbGxNb3VzZW92ZXJIYW5kbGVyLmJpbmQodGhpcykpLCB0aGlzLnJlbmRlcmVyLmxpc3RlbihlbGVtZW50LCAnbW91c2VsZWF2ZScsIHRoaXMubW91c2VMZWF2ZUhhbmRsZXIuYmluZCh0aGlzKSksIHRoaXMucmVuZGVyZXIubGlzdGVuKGVsZW1lbnQsICdjbGljaycsIHRoaXMuY2xpY2tIYW5kbGVyLmJpbmQodGhpcykpKTtcbiAgICB9XG4gICAgY2xpY2tIYW5kbGVyKGFyZ3MpIHtcbiAgICAgICAgY29uc3QgY2VsbCA9IHRoaXMuY2xvc2VzdENlbGwoYXJncyk7XG4gICAgICAgIGlmICghY2VsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGluZGV4ID0gY2VsbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtY2VsbC1pbmRleCcpO1xuICAgICAgICBjb25zdCBjZWxsQ29udGV4dCA9IHRoaXMuY2VsbEJ5SW5kZXgoaW5kZXgpO1xuICAgICAgICBpZiAoIWNlbGxDb250ZXh0LmlzRGlzYWJsZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgY3RybEtleSwgbWV0YUtleSwgc2hpZnRLZXkgfSA9IGFyZ3M7XG4gICAgICAgICAgICB0aGlzLmNlbGxDbGljay5lbWl0KHtcbiAgICAgICAgICAgICAgICBkYXRlOiBjZWxsQ29udGV4dC52YWx1ZSxcbiAgICAgICAgICAgICAgICBtb2RpZmllcnM6IHsgY3RybEtleSwgbWV0YUtleSwgc2hpZnRLZXkgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbW91c2VMZWF2ZUhhbmRsZXIoKSB7XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRDZWxsSW5kZXgpIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdENlbGxMZWF2ZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNlbGxNb3VzZW92ZXJIYW5kbGVyKGFyZ3MpIHtcbiAgICAgICAgY29uc3QgY2VsbCA9IHRoaXMuY2xvc2VzdENlbGwoYXJncyk7XG4gICAgICAgIGlmIChjZWxsKSB7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IGNlbGwuZ2V0QXR0cmlidXRlKCdkYXRhLWNlbGwtaW5kZXgnKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnRDZWxsSW5kZXggJiYgdGhpcy5jdXJyZW50Q2VsbEluZGV4ICE9PSBpbmRleCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdENlbGxMZWF2ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLmNlbGxCeUluZGV4KGluZGV4KS52YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuY2VsbEVudGVyLmVtaXQodmFsdWUpO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50Q2VsbEluZGV4ID0gaW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5jdXJyZW50Q2VsbEluZGV4KSB7XG4gICAgICAgICAgICB0aGlzLmVtaXRDZWxsTGVhdmUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjbG9zZXN0Q2VsbChldmVudEFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIGNsb3Nlc3RJblNjb3BlKGV2ZW50QXJncy50YXJnZXQsIG5vZGUgPT4gbm9kZS5oYXNBdHRyaWJ1dGUoJ2RhdGEtY2VsbC1pbmRleCcpLCB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudCk7XG4gICAgfVxuICAgIGVtaXRDZWxsTGVhdmUoKSB7XG4gICAgICAgIGNvbnN0IGl0ZW0gPSB0aGlzLmNlbGxCeUluZGV4KHRoaXMuY3VycmVudENlbGxJbmRleCk7XG4gICAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgICAgICB0aGlzLmNlbGxMZWF2ZS5lbWl0KGl0ZW0udmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY3VycmVudENlbGxJbmRleCA9IG51bGw7XG4gICAgfVxuICAgIGNlbGxCeUluZGV4KGluZGV4KSB7XG4gICAgICAgIGNvbnN0IFtyb3dJbmRleCwgY2VsbEluZGV4XSA9IGluZGV4LnNwbGl0KCc6Jyk7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFbcm93SW5kZXhdW2NlbGxJbmRleF07XG4gICAgfVxufTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFZpZXdDb21wb25lbnQucHJvdG90eXBlLCBcImRpcmVjdGlvblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIFZpZXdDb21wb25lbnQucHJvdG90eXBlLCBcImlzQWN0aXZlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBWaWV3Q29tcG9uZW50LnByb3RvdHlwZSwgXCJhY3RpdmVWaWV3XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBWaWV3Q29tcG9uZW50LnByb3RvdHlwZSwgXCJjZWxsVUlEXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBEYXRlKVxuXSwgVmlld0NvbXBvbmVudC5wcm90b3R5cGUsIFwiZm9jdXNlZERhdGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIERhdGUpXG5dLCBWaWV3Q29tcG9uZW50LnByb3RvdHlwZSwgXCJ2aWV3RGF0ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgVmlld0NvbXBvbmVudC5wcm90b3R5cGUsIFwiYWN0aXZlUmFuZ2VFbmRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFZpZXdDb21wb25lbnQucHJvdG90eXBlLCBcInNlbGVjdGlvblJhbmdlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBEYXRlKVxuXSwgVmlld0NvbXBvbmVudC5wcm90b3R5cGUsIFwibWluXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBEYXRlKVxuXSwgVmlld0NvbXBvbmVudC5wcm90b3R5cGUsIFwibWF4XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSlcbl0sIFZpZXdDb21wb25lbnQucHJvdG90eXBlLCBcInNlbGVjdGVkRGF0ZXNcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQm9vbGVhbl0pXG5dLCBWaWV3Q29tcG9uZW50LnByb3RvdHlwZSwgXCJ3ZWVrTnVtYmVyXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgVmlld0NvbXBvbmVudC5wcm90b3R5cGUsIFwidmlld0luZGV4XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBUZW1wbGF0ZVJlZilcbl0sIFZpZXdDb21wb25lbnQucHJvdG90eXBlLCBcInRlbXBsYXRlUmVmXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBUZW1wbGF0ZVJlZilcbl0sIFZpZXdDb21wb25lbnQucHJvdG90eXBlLCBcIndlZWtOdW1iZXJUZW1wbGF0ZVJlZlwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbl0sIFZpZXdDb21wb25lbnQucHJvdG90eXBlLCBcImNlbGxDbGlja1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbl0sIFZpZXdDb21wb25lbnQucHJvdG90eXBlLCBcIndlZWtOdW1iZXJDZWxsQ2xpY2tcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIE91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXG5dLCBWaWV3Q29tcG9uZW50LnByb3RvdHlwZSwgXCJjZWxsRW50ZXJcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIE91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXG5dLCBWaWV3Q29tcG9uZW50LnByb3RvdHlwZSwgXCJjZWxsTGVhdmVcIiwgdm9pZCAwKTtcblZpZXdDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBzZWxlY3RvcjogJ1trZW5kb0NhbGVuZGFyVmlld10nLFxuICAgICAgICB0ZW1wbGF0ZTogYFxuICAgIDxuZy10ZW1wbGF0ZSAjZW1wdHlDZWxsPjx0ZCBjbGFzcz1cImstZW1wdHkgay1jYWxlbmRhci10ZFwiPiZuYnNwOzwvdGQ+PC9uZy10ZW1wbGF0ZT5cbiAgICA8dHIgKm5nSWY9XCIhaXNIb3Jpem9udGFsKClcIiBjbGFzcz1cImstY2FsZW5kYXItdHJcIiByb2xlPVwicm93XCI+PHRoIGNsYXNzPVwiay1jYWxlbmRhci1jYXB0aW9uXCIgc2NvcGU9XCJjb2xcIiBbY29sU3Bhbl09XCJjb2xTcGFuXCI+e3t0aXRsZX19PC90aD48L3RyPlxuICAgIDx0ciAqa0Zvcj1cImxldCByb3cgb2YgZGF0YTsgbGV0IHJvd0luZGV4ID0gaW5kZXhcIiBjbGFzcz1cImstY2FsZW5kYXItdHJcIiByb2xlPVwicm93XCI+XG4gICAgICAgIDxuZy10ZW1wbGF0ZSBbbmdJZl09XCJ3ZWVrTnVtYmVyXCI+XG4gICAgICAgICAgICA8dGRcbiAgICAgICAgICAgICAgICBjbGFzcz1cImstYWx0IGstY2FsZW5kYXItdGRcIlxuICAgICAgICAgICAgICAgICpuZ0lmPVwiZmlyc3REYXRlKHJvdyk7IGVsc2UgZW1wdHlDZWxsXCJcbiAgICAgICAgICAgICAgICBba2VuZG9FdmVudHNPdXRzaWRlQW5ndWxhcl09XCJ7XG4gICAgICAgICAgICAgICAgICAgIGNsaWNrOiBoYW5kbGVXZWVrTnVtYmVyQ2xpY2suYmluZCh0aGlzLCByb3cpXG4gICAgICAgICAgICAgICAgfVwiXG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgPG5nLXRlbXBsYXRlIFtuZ0lmXT1cIiF3ZWVrTnVtYmVyVGVtcGxhdGVSZWZcIj5cbiAgICAgICAgICAgICAgICAgICAge3tnZXRXZWVrTnVtYmVyKGZpcnN0RGF0ZShyb3cpKX19XG4gICAgICAgICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICAgICAgICAgICAgICA8bmctdGVtcGxhdGVcbiAgICAgICAgICAgICAgICAgICAgW25nSWZdPVwid2Vla051bWJlclRlbXBsYXRlUmVmXCJcbiAgICAgICAgICAgICAgICAgICAgW25nVGVtcGxhdGVPdXRsZXRdPVwid2Vla051bWJlclRlbXBsYXRlUmVmXCJcbiAgICAgICAgICAgICAgICAgICAgW25nVGVtcGxhdGVPdXRsZXRDb250ZXh0XT1cIntcbiAgICAgICAgICAgICAgICAgICAgICAgICRpbXBsaWNpdDogZmlyc3REYXRlKHJvdyksXG4gICAgICAgICAgICAgICAgICAgICAgICBjZWxsQ29udGV4dDogZ2V0V2Vla051bWJlckNvbnRleHQocm93KVxuICAgICAgICAgICAgICAgICAgICB9XCJcbiAgICAgICAgICAgICAgICA+PC9uZy10ZW1wbGF0ZT5cbiAgICAgICAgICAgIDwvdGQ+XG4gICAgICAgIDwvbmctdGVtcGxhdGU+XG4gICAgICAgIDxuZy1jb250YWluZXIgKmtGb3I9XCJsZXQgY2VsbCBvZiByb3c7IGxldCBjZWxsSW5kZXggPSBpbmRleFwiPlxuICAgICAgICAgICAgPHRkIGNsYXNzPVwiay1jYWxlbmRhci10ZFwiXG4gICAgICAgICAgICAgICAgKm5nSWY9XCJzaG91bGRSZW5kZXJDZWxsQ29udGVudChjZWxsKTsgZWxzZSBlbXB0eUNlbGxcIlxuICAgICAgICAgICAgICAgIHJvbGU9XCJncmlkY2VsbFwiXG4gICAgICAgICAgICAgICAgW2F0dHIuaWRdPVwiY2VsbC5pZFwiXG4gICAgICAgICAgICAgICAgW2F0dHIuZGF0YS1jZWxsLWluZGV4XT1cInRhYmxlQ2VsbEluZGV4KHJvd0luZGV4LCBjZWxsSW5kZXgpXCJcbiAgICAgICAgICAgICAgICBbYXR0ci5hcmlhLXNlbGVjdGVkXT1cImNlbGwuaXNTZWxlY3RlZCB8fCBjZWxsLmlzUmFuZ2VTdGFydCB8fCBjZWxsLmlzUmFuZ2VNaWQgfHwgY2VsbC5pc1JhbmdlRW5kXCJcbiAgICAgICAgICAgICAgICBbYXR0ci5hcmlhLWRpc2FibGVkXT1cImNlbGwuaXNEaXNhYmxlZFwiXG4gICAgICAgICAgICAgICAgW25nQ2xhc3NdPVwiZ2V0U3R5bGVzKGNlbGwpXCJcbiAgICAgICAgICAgICAgICBbdGl0bGVdPVwiY2VsbC50aXRsZVwiXG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJrLWxpbmtcIj5cbiAgICAgICAgICAgICAgICAgICAgPG5nLXRlbXBsYXRlIFtuZ0lmXT1cIiF0ZW1wbGF0ZVJlZlwiPnt7Y2VsbC5mb3JtYXR0ZWRWYWx1ZX19PC9uZy10ZW1wbGF0ZT5cbiAgICAgICAgICAgICAgICAgICAgPG5nLXRlbXBsYXRlXG4gICAgICAgICAgICAgICAgICAgICAgICAqbmdJZj1cInRlbXBsYXRlUmVmXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIFtuZ1RlbXBsYXRlT3V0bGV0XT1cInRlbXBsYXRlUmVmXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIFtuZ1RlbXBsYXRlT3V0bGV0Q29udGV4dF09XCJ7ICRpbXBsaWNpdDogY2VsbC52YWx1ZSwgY2VsbENvbnRleHQ6IGNlbGwgfVwiXG4gICAgICAgICAgICAgICAgICAgID48L25nLXRlbXBsYXRlPlxuICAgICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgIDwvdGQ+XG4gICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgIDwvdHI+XG4gIGBcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0J1c1ZpZXdTZXJ2aWNlLFxuICAgICAgICBJbnRsU2VydmljZSxcbiAgICAgICAgQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gICAgICAgIEVsZW1lbnRSZWYsXG4gICAgICAgIE5nWm9uZSxcbiAgICAgICAgUmVuZGVyZXIyLFxuICAgICAgICBEaXNhYmxlZERhdGVzU2VydmljZV0pXG5dLCBWaWV3Q29tcG9uZW50KTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKlxuICogVGhlIGV4cG9ydGVkIHBhY2thZ2UgbW9kdWxlLlxuICpcbiAqIFRoZSBwYWNrYWdlIGV4cG9ydHM6XG4gKiAtIGBIZWFkZXJDb21wb25lbnRgJm1kYXNoO1RoZSBjb21wb25lbnQgdGhhdCByZW5kZXJzIHRoZSBVSSBmb3IgdmVydGljYWwgbmF2aWdhdGlvbi5cbiAqIC0gYFZpZXdDb21wb25lbnRgJm1kYXNoO1RoZSBjb21wb25lbnQgdGhhdCByZW5kZXJzIHRoZSBhY3RpdmUgQ2FsZW5kYXIgdmlldy5cbiAqL1xubGV0IENhbGVuZGFyQ29tbW9uTW9kdWxlID0gY2xhc3MgQ2FsZW5kYXJDb21tb25Nb2R1bGUge1xufTtcbkNhbGVuZGFyQ29tbW9uTW9kdWxlID0gX19kZWNvcmF0ZShbXG4gICAgTmdNb2R1bGUoe1xuICAgICAgICBkZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgICAgIEtGb3JPZixcbiAgICAgICAgICAgIEhlYWRlckNvbXBvbmVudCxcbiAgICAgICAgICAgIFZpZXdDb21wb25lbnRcbiAgICAgICAgXSxcbiAgICAgICAgZXhwb3J0czogW1xuICAgICAgICAgICAgS0Zvck9mLFxuICAgICAgICAgICAgSGVhZGVyQ29tcG9uZW50LFxuICAgICAgICAgICAgVmlld0NvbXBvbmVudFxuICAgICAgICBdLFxuICAgICAgICBpbXBvcnRzOiBbQ29tbW9uTW9kdWxlLCBFdmVudHNNb2R1bGVdXG4gICAgfSlcbl0sIENhbGVuZGFyQ29tbW9uTW9kdWxlKTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKlxuICogVGhlIGV4cG9ydGVkIHBhY2thZ2UgbW9kdWxlLlxuICpcbiAqIFRoZSBwYWNrYWdlIGV4cG9ydHM6XG4gKiAtIGBDZWxsVGVtcGxhdGVEaXJlY3RpdmVgJm1kYXNoO1RoZSBtb250aCBjZWxsIHRlbXBsYXRlIGRpcmVjdGl2ZS5cbiAqIC0gYE1vbnRoQ2VsbFRlbXBsYXRlRGlyZWN0aXZlYCZtZGFzaDtUaGUgbW9udGggY2VsbCB0ZW1wbGF0ZSBkaXJlY3RpdmUuXG4gKiAtIGBZZWFyQ2VsbFRlbXBsYXRlRGlyZWN0aXZlYCZtZGFzaDtUaGUgeWVhciBjZWxsIHRlbXBsYXRlIGRpcmVjdGl2ZS5cbiAqIC0gYERlY2FkZUNlbGxUZW1wbGF0ZURpcmVjdGl2ZWAmbWRhc2g7VGhlIGRlY2FkZSBjZWxsIHRlbXBsYXRlIGRpcmVjdGl2ZS5cbiAqIC0gYENlbnR1cnlDZWxsVGVtcGxhdGVEaXJlY3RpdmVgJm1kYXNoO1RoZSBjZW50dXJ5IGNlbGwgdGVtcGxhdGUgZGlyZWN0aXZlLlxuICogLSBgV2Vla051bWJlckNlbGxUZW1wbGF0ZURpcmVjdGl2ZWAmbWRhc2g7VGhlIG1vbnRoIHdlZWsgbnVtYmVyIGNlbGwgdGVtcGxhdGUgZGlyZWN0aXZlLlxuICogLSBgSGVhZGVyVGl0bGVUZW1wbGF0ZURpcmVjdGl2ZWAmbWRhc2g7VGhlIGhlYWRlciB0aXRsZSB0ZW1wbGF0ZSBkaXJlY3RpdmUuXG4gKiAtIGBOYXZpZ2F0aW9uSXRlbVRlbXBsYXRlRGlyZWN0aXZlYCZtZGFzaDtUaGUgbmF2aWdhdGlvbiBpdGVtIHRlbXBsYXRlIGRpcmVjdGl2ZS5cbiAqL1xubGV0IFRlbXBsYXRlc01vZHVsZSA9IGNsYXNzIFRlbXBsYXRlc01vZHVsZSB7XG59O1xuVGVtcGxhdGVzTW9kdWxlID0gX19kZWNvcmF0ZShbXG4gICAgTmdNb2R1bGUoe1xuICAgICAgICBkZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgICAgIENlbGxUZW1wbGF0ZURpcmVjdGl2ZSxcbiAgICAgICAgICAgIE1vbnRoQ2VsbFRlbXBsYXRlRGlyZWN0aXZlLFxuICAgICAgICAgICAgWWVhckNlbGxUZW1wbGF0ZURpcmVjdGl2ZSxcbiAgICAgICAgICAgIERlY2FkZUNlbGxUZW1wbGF0ZURpcmVjdGl2ZSxcbiAgICAgICAgICAgIENlbnR1cnlDZWxsVGVtcGxhdGVEaXJlY3RpdmUsXG4gICAgICAgICAgICBXZWVrTnVtYmVyQ2VsbFRlbXBsYXRlRGlyZWN0aXZlLFxuICAgICAgICAgICAgSGVhZGVyVGl0bGVUZW1wbGF0ZURpcmVjdGl2ZSxcbiAgICAgICAgICAgIE5hdmlnYXRpb25JdGVtVGVtcGxhdGVEaXJlY3RpdmVcbiAgICAgICAgXSxcbiAgICAgICAgZXhwb3J0czogW1xuICAgICAgICAgICAgQ2VsbFRlbXBsYXRlRGlyZWN0aXZlLFxuICAgICAgICAgICAgTW9udGhDZWxsVGVtcGxhdGVEaXJlY3RpdmUsXG4gICAgICAgICAgICBZZWFyQ2VsbFRlbXBsYXRlRGlyZWN0aXZlLFxuICAgICAgICAgICAgRGVjYWRlQ2VsbFRlbXBsYXRlRGlyZWN0aXZlLFxuICAgICAgICAgICAgQ2VudHVyeUNlbGxUZW1wbGF0ZURpcmVjdGl2ZSxcbiAgICAgICAgICAgIFdlZWtOdW1iZXJDZWxsVGVtcGxhdGVEaXJlY3RpdmUsXG4gICAgICAgICAgICBIZWFkZXJUaXRsZVRlbXBsYXRlRGlyZWN0aXZlLFxuICAgICAgICAgICAgTmF2aWdhdGlvbkl0ZW1UZW1wbGF0ZURpcmVjdGl2ZVxuICAgICAgICBdXG4gICAgfSlcbl0sIFRlbXBsYXRlc01vZHVsZSk7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBNZXNzYWdlcyBleHRlbmRzIENvbXBvbmVudE1lc3NhZ2VzIHtcbn1cbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIE1lc3NhZ2VzLnByb3RvdHlwZSwgXCJ0b2RheVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgTWVzc2FnZXMucHJvdG90eXBlLCBcInByZXZCdXR0b25UaXRsZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgTWVzc2FnZXMucHJvdG90eXBlLCBcIm5leHRCdXR0b25UaXRsZVwiLCB2b2lkIDApO1xuXG52YXIgTXVsdGlWaWV3Q2FsZW5kYXJMb2NhbGl6ZWRNZXNzYWdlc0RpcmVjdGl2ZV8xO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmxldCBNdWx0aVZpZXdDYWxlbmRhckxvY2FsaXplZE1lc3NhZ2VzRGlyZWN0aXZlID0gTXVsdGlWaWV3Q2FsZW5kYXJMb2NhbGl6ZWRNZXNzYWdlc0RpcmVjdGl2ZV8xID0gY2xhc3MgTXVsdGlWaWV3Q2FsZW5kYXJMb2NhbGl6ZWRNZXNzYWdlc0RpcmVjdGl2ZSBleHRlbmRzIE1lc3NhZ2VzIHtcbiAgICBjb25zdHJ1Y3RvcihzZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuc2VydmljZSA9IHNlcnZpY2U7XG4gICAgfVxufTtcbk11bHRpVmlld0NhbGVuZGFyTG9jYWxpemVkTWVzc2FnZXNEaXJlY3RpdmUgPSBNdWx0aVZpZXdDYWxlbmRhckxvY2FsaXplZE1lc3NhZ2VzRGlyZWN0aXZlXzEgPSBfX2RlY29yYXRlKFtcbiAgICBEaXJlY3RpdmUoe1xuICAgICAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBwcm92aWRlOiBNZXNzYWdlcyxcbiAgICAgICAgICAgICAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBNdWx0aVZpZXdDYWxlbmRhckxvY2FsaXplZE1lc3NhZ2VzRGlyZWN0aXZlXzEpIC8vIHRzbGludDpkaXNhYmxlLWxpbmU6bm8tZm9yd2FyZC1yZWZcbiAgICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgc2VsZWN0b3I6ICdba2VuZG9NdWx0aVZpZXdDYWxlbmRhckxvY2FsaXplZE1lc3NhZ2VzXSdcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0xvY2FsaXphdGlvblNlcnZpY2VdKVxuXSwgTXVsdGlWaWV3Q2FsZW5kYXJMb2NhbGl6ZWRNZXNzYWdlc0RpcmVjdGl2ZSk7XG5cbnZhciBNdWx0aVZpZXdDYWxlbmRhckN1c3RvbU1lc3NhZ2VzQ29tcG9uZW50XzE7XG4vKipcbiAqIEN1c3RvbSBjb21wb25lbnQgbWVzc2FnZXMgb3ZlcnJpZGUgZGVmYXVsdCBjb21wb25lbnQgbWVzc2FnZXMgKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBnbG9iYWxpemF0aW9uX2RhdGVpbnB1dHMgJX0jdG9jLWN1c3RvbS1tZXNzYWdlcykpLlxuICovXG5sZXQgTXVsdGlWaWV3Q2FsZW5kYXJDdXN0b21NZXNzYWdlc0NvbXBvbmVudCA9IE11bHRpVmlld0NhbGVuZGFyQ3VzdG9tTWVzc2FnZXNDb21wb25lbnRfMSA9IGNsYXNzIE11bHRpVmlld0NhbGVuZGFyQ3VzdG9tTWVzc2FnZXNDb21wb25lbnQgZXh0ZW5kcyBNZXNzYWdlcyB7XG4gICAgY29uc3RydWN0b3Ioc2VydmljZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnNlcnZpY2UgPSBzZXJ2aWNlO1xuICAgIH1cbiAgICBnZXQgb3ZlcnJpZGUoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn07XG5NdWx0aVZpZXdDYWxlbmRhckN1c3RvbU1lc3NhZ2VzQ29tcG9uZW50ID0gTXVsdGlWaWV3Q2FsZW5kYXJDdXN0b21NZXNzYWdlc0NvbXBvbmVudF8xID0gX19kZWNvcmF0ZShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgcHJvdmlkZXJzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcHJvdmlkZTogTWVzc2FnZXMsXG4gICAgICAgICAgICAgICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gTXVsdGlWaWV3Q2FsZW5kYXJDdXN0b21NZXNzYWdlc0NvbXBvbmVudF8xKSAvLyB0c2xpbnQ6ZGlzYWJsZS1saW5lOm5vLWZvcndhcmQtcmVmXG4gICAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tbXVsdGl2aWV3Y2FsZW5kYXItbWVzc2FnZXMnLFxuICAgICAgICB0ZW1wbGF0ZTogYGBcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0xvY2FsaXphdGlvblNlcnZpY2VdKVxuXSwgTXVsdGlWaWV3Q2FsZW5kYXJDdXN0b21NZXNzYWdlc0NvbXBvbmVudCk7XG5cbi8qKlxuICogVGhlIHBhY2thZ2UgZXhwb3J0czpcbiAqIC0gYENlbGxUZW1wbGF0ZURpcmVjdGl2ZWAmbWRhc2g7VGhlIG1vbnRoIGNlbGwgdGVtcGxhdGUgZGlyZWN0aXZlLlxuICogLSBgTW9udGhDZWxsVGVtcGxhdGVEaXJlY3RpdmVgJm1kYXNoO1RoZSBtb250aCBjZWxsIHRlbXBsYXRlIGRpcmVjdGl2ZS5cbiAqIC0gYFllYXJDZWxsVGVtcGxhdGVEaXJlY3RpdmVgJm1kYXNoO1RoZSB5ZWFyIGNlbGwgdGVtcGxhdGUgZGlyZWN0aXZlLlxuICogLSBgRGVjYWRlQ2VsbFRlbXBsYXRlRGlyZWN0aXZlYCZtZGFzaDtUaGUgZGVjYWRlIGNlbGwgdGVtcGxhdGUgZGlyZWN0aXZlLlxuICogLSBgQ2VudHVyeUNlbGxUZW1wbGF0ZURpcmVjdGl2ZWAmbWRhc2g7VGhlIGNlbnR1cnkgY2VsbCB0ZW1wbGF0ZSBkaXJlY3RpdmUuXG4gKiAtIGBXZWVrTnVtYmVyQ2VsbFRlbXBsYXRlRGlyZWN0aXZlYCZtZGFzaDtUaGUgbW9udGggd2VlayBudW1iZXIgY2VsbCB0ZW1wbGF0ZSBkaXJlY3RpdmUuXG4gKiAtIGBIZWFkZXJUaXRsZVRlbXBsYXRlRGlyZWN0aXZlYCZtZGFzaDtUaGUgaGVhZGVyIHRpdGxlIHRlbXBsYXRlIGRpcmVjdGl2ZS5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYHRzLW5vLXJ1blxuICogLy8gSW1wb3J0IHRoZSBNdWx0aVZpZXdDYWxlbmRhciBtb2R1bGVcbiAqIGltcG9ydCB7IE11bHRpVmlld0NhbGVuZGFyTW9kdWxlIH0gZnJvbSAnQHByb2dyZXNzL2tlbmRvLWFuZ3VsYXItZGF0ZWlucHV0cyc7XG4gKlxuICogLy8gVGhlIGJyb3dzZXIgcGxhdGZvcm0gd2l0aCBhIGNvbXBpbGVyXG4gKiBpbXBvcnQgeyBwbGF0Zm9ybUJyb3dzZXJEeW5hbWljIH0gZnJvbSAnQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3Nlci1keW5hbWljJztcbiAqXG4gKiBpbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuICpcbiAqIC8vIEltcG9ydCB0aGUgYXBwIGNvbXBvbmVudFxuICogaW1wb3J0IHsgQXBwQ29tcG9uZW50IH0gZnJvbSAnLi9hcHAuY29tcG9uZW50JztcbiAqXG4gKiAvLyBEZWZpbmUgdGhlIGFwcCBtb2R1bGVcbiAqIF9ATmdNb2R1bGUoe1xuICogICAgIGRlY2xhcmF0aW9uczogW0FwcENvbXBvbmVudF0sIC8vIGRlY2xhcmUgYXBwIGNvbXBvbmVudFxuICogICAgIGltcG9ydHM6ICAgICAgW0Jyb3dzZXJNb2R1bGUsIE11bHRpVmlld0NhbGVuZGFyTW9kdWxlXSwgLy8gaW1wb3J0IE11bHRpVmlld0NhbGVuZGFyIG1vZHVsZVxuICogICAgIGJvb3RzdHJhcDogICAgW0FwcENvbXBvbmVudF1cbiAqIH0pXG4gKiBleHBvcnQgY2xhc3MgQXBwTW9kdWxlIHt9XG4gKlxuICogLy8gQ29tcGlsZSBhbmQgbGF1bmNoIHRoZSBtb2R1bGVcbiAqIHBsYXRmb3JtQnJvd3NlckR5bmFtaWMoKS5ib290c3RyYXBNb2R1bGUoQXBwTW9kdWxlKTtcbiAqL1xubGV0IE11bHRpVmlld0NhbGVuZGFyTW9kdWxlID0gY2xhc3MgTXVsdGlWaWV3Q2FsZW5kYXJNb2R1bGUge1xufTtcbk11bHRpVmlld0NhbGVuZGFyTW9kdWxlID0gX19kZWNvcmF0ZShbXG4gICAgTmdNb2R1bGUoe1xuICAgICAgICBkZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgICAgIEhvcml6b250YWxWaWV3TGlzdENvbXBvbmVudCxcbiAgICAgICAgICAgIE11bHRpVmlld0NhbGVuZGFyTG9jYWxpemVkTWVzc2FnZXNEaXJlY3RpdmUsXG4gICAgICAgICAgICBNdWx0aVZpZXdDYWxlbmRhckN1c3RvbU1lc3NhZ2VzQ29tcG9uZW50LFxuICAgICAgICAgICAgTXVsdGlWaWV3Q2FsZW5kYXJDb21wb25lbnRcbiAgICAgICAgXSxcbiAgICAgICAgZXhwb3J0czogW1xuICAgICAgICAgICAgSG9yaXpvbnRhbFZpZXdMaXN0Q29tcG9uZW50LFxuICAgICAgICAgICAgTXVsdGlWaWV3Q2FsZW5kYXJMb2NhbGl6ZWRNZXNzYWdlc0RpcmVjdGl2ZSxcbiAgICAgICAgICAgIE11bHRpVmlld0NhbGVuZGFyQ3VzdG9tTWVzc2FnZXNDb21wb25lbnQsXG4gICAgICAgICAgICBNdWx0aVZpZXdDYWxlbmRhckNvbXBvbmVudCxcbiAgICAgICAgICAgIENhbGVuZGFyQ29tbW9uTW9kdWxlLFxuICAgICAgICAgICAgVGVtcGxhdGVzTW9kdWxlXG4gICAgICAgIF0sXG4gICAgICAgIGltcG9ydHM6IFtDb21tb25Nb2R1bGUsIENhbGVuZGFyQ29tbW9uTW9kdWxlLCBJbnRsTW9kdWxlLCBUZW1wbGF0ZXNNb2R1bGUsIFBvcHVwTW9kdWxlXSxcbiAgICAgICAgcHJvdmlkZXJzOiBbXG4gICAgICAgICAgICBOYXZpZ2F0aW9uU2VydmljZSxcbiAgICAgICAgICAgIENlbnR1cnlWaWV3U2VydmljZSxcbiAgICAgICAgICAgIERlY2FkZVZpZXdTZXJ2aWNlLFxuICAgICAgICAgICAgTW9udGhWaWV3U2VydmljZSxcbiAgICAgICAgICAgIFllYXJWaWV3U2VydmljZSxcbiAgICAgICAgICAgIFdlZWtOYW1lc1NlcnZpY2VcbiAgICAgICAgXVxuICAgIH0pXG5dLCBNdWx0aVZpZXdDYWxlbmRhck1vZHVsZSk7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBDYWxlbmRhck1lc3NhZ2VzIGV4dGVuZHMgQ29tcG9uZW50TWVzc2FnZXMge1xufVxuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgQ2FsZW5kYXJNZXNzYWdlcy5wcm90b3R5cGUsIFwidG9kYXlcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIENhbGVuZGFyTWVzc2FnZXMucHJvdG90eXBlLCBcInByZXZCdXR0b25UaXRsZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgQ2FsZW5kYXJNZXNzYWdlcy5wcm90b3R5cGUsIFwibmV4dEJ1dHRvblRpdGxlXCIsIHZvaWQgMCk7XG5cbnZhciBDYWxlbmRhckxvY2FsaXplZE1lc3NhZ2VzRGlyZWN0aXZlXzE7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xubGV0IENhbGVuZGFyTG9jYWxpemVkTWVzc2FnZXNEaXJlY3RpdmUgPSBDYWxlbmRhckxvY2FsaXplZE1lc3NhZ2VzRGlyZWN0aXZlXzEgPSBjbGFzcyBDYWxlbmRhckxvY2FsaXplZE1lc3NhZ2VzRGlyZWN0aXZlIGV4dGVuZHMgQ2FsZW5kYXJNZXNzYWdlcyB7XG4gICAgY29uc3RydWN0b3Ioc2VydmljZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnNlcnZpY2UgPSBzZXJ2aWNlO1xuICAgIH1cbn07XG5DYWxlbmRhckxvY2FsaXplZE1lc3NhZ2VzRGlyZWN0aXZlID0gQ2FsZW5kYXJMb2NhbGl6ZWRNZXNzYWdlc0RpcmVjdGl2ZV8xID0gX19kZWNvcmF0ZShbXG4gICAgRGlyZWN0aXZlKHtcbiAgICAgICAgcHJvdmlkZXJzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcHJvdmlkZTogQ2FsZW5kYXJNZXNzYWdlcyxcbiAgICAgICAgICAgICAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBDYWxlbmRhckxvY2FsaXplZE1lc3NhZ2VzRGlyZWN0aXZlXzEpIC8vIHRzbGludDpkaXNhYmxlLWxpbmU6bm8tZm9yd2FyZC1yZWZcbiAgICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgc2VsZWN0b3I6ICdba2VuZG9DYWxlbmRhckxvY2FsaXplZE1lc3NhZ2VzXSdcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0xvY2FsaXphdGlvblNlcnZpY2VdKVxuXSwgQ2FsZW5kYXJMb2NhbGl6ZWRNZXNzYWdlc0RpcmVjdGl2ZSk7XG5cbnZhciBDYWxlbmRhckN1c3RvbU1lc3NhZ2VzQ29tcG9uZW50XzE7XG4vKipcbiAqIEN1c3RvbSBjb21wb25lbnQgbWVzc2FnZXMgb3ZlcnJpZGUgZGVmYXVsdCBjb21wb25lbnQgbWVzc2FnZXMgKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBnbG9iYWxpemF0aW9uX2RhdGVpbnB1dHMgJX0jdG9jLWN1c3RvbS1tZXNzYWdlcykpLlxuICovXG5sZXQgQ2FsZW5kYXJDdXN0b21NZXNzYWdlc0NvbXBvbmVudCA9IENhbGVuZGFyQ3VzdG9tTWVzc2FnZXNDb21wb25lbnRfMSA9IGNsYXNzIENhbGVuZGFyQ3VzdG9tTWVzc2FnZXNDb21wb25lbnQgZXh0ZW5kcyBDYWxlbmRhck1lc3NhZ2VzIHtcbiAgICBjb25zdHJ1Y3RvcihzZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuc2VydmljZSA9IHNlcnZpY2U7XG4gICAgfVxuICAgIGdldCBvdmVycmlkZSgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufTtcbkNhbGVuZGFyQ3VzdG9tTWVzc2FnZXNDb21wb25lbnQgPSBDYWxlbmRhckN1c3RvbU1lc3NhZ2VzQ29tcG9uZW50XzEgPSBfX2RlY29yYXRlKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBwcm92aWRlOiBDYWxlbmRhck1lc3NhZ2VzLFxuICAgICAgICAgICAgICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IENhbGVuZGFyQ3VzdG9tTWVzc2FnZXNDb21wb25lbnRfMSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1jYWxlbmRhci1tZXNzYWdlcycsXG4gICAgICAgIHRlbXBsYXRlOiBgYFxuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbTG9jYWxpemF0aW9uU2VydmljZV0pXG5dLCBDYWxlbmRhckN1c3RvbU1lc3NhZ2VzQ29tcG9uZW50KTtcblxuY29uc3QgQ09NUE9ORU5UX0RJUkVDVElWRVMgPSBbXG4gICAgVmlydHVhbGl6YXRpb25Db21wb25lbnRcbl07XG4vKipcbiAqIEBoaWRkZW5cbiAqXG4gKiBSZXByZXNlbnRzIHRoZSBbTmdNb2R1bGVdKHt7IHNpdGUuZGF0YS51cmxzLmFuZ3VsYXJbJ25nbW9kdWxlYXBpJ10gfX0pXG4gKiBkZWZpbml0aW9uIGZvciB0aGUgVmlydHVhbGl6YXRpb24gY29tcG9uZW50LlxuICovXG5sZXQgVmlydHVhbGl6YXRpb25Nb2R1bGUgPSBjbGFzcyBWaXJ0dWFsaXphdGlvbk1vZHVsZSB7XG59O1xuVmlydHVhbGl6YXRpb25Nb2R1bGUgPSBfX2RlY29yYXRlKFtcbiAgICBOZ01vZHVsZSh7XG4gICAgICAgIGRlY2xhcmF0aW9uczogW0NPTVBPTkVOVF9ESVJFQ1RJVkVTXSxcbiAgICAgICAgZXhwb3J0czogW0NPTVBPTkVOVF9ESVJFQ1RJVkVTXSxcbiAgICAgICAgaW1wb3J0czogW0NvbW1vbk1vZHVsZV1cbiAgICB9KVxuXSwgVmlydHVhbGl6YXRpb25Nb2R1bGUpO1xuXG4vKipcbiAqIFRoZSBleHBvcnRlZCBwYWNrYWdlIG1vZHVsZS5cbiAqXG4gKiBUaGUgcGFja2FnZSBleHBvcnRzOlxuICogLSBgQ2VsbFRlbXBsYXRlRGlyZWN0aXZlYCZtZGFzaDtUaGUgbW9udGggY2VsbCB0ZW1wbGF0ZSBkaXJlY3RpdmUuXG4gKiAtIGBNb250aENlbGxUZW1wbGF0ZURpcmVjdGl2ZWAmbWRhc2g7VGhlIG1vbnRoIGNlbGwgdGVtcGxhdGUgZGlyZWN0aXZlLlxuICogLSBgWWVhckNlbGxUZW1wbGF0ZURpcmVjdGl2ZWAmbWRhc2g7VGhlIHllYXIgY2VsbCB0ZW1wbGF0ZSBkaXJlY3RpdmUuXG4gKiAtIGBEZWNhZGVDZWxsVGVtcGxhdGVEaXJlY3RpdmVgJm1kYXNoO1RoZSBkZWNhZGUgY2VsbCB0ZW1wbGF0ZSBkaXJlY3RpdmUuXG4gKiAtIGBDZW50dXJ5Q2VsbFRlbXBsYXRlRGlyZWN0aXZlYCZtZGFzaDtUaGUgY2VudHVyeSBjZWxsIHRlbXBsYXRlIGRpcmVjdGl2ZS5cbiAqIC0gYFdlZWtOdW1iZXJDZWxsVGVtcGxhdGVEaXJlY3RpdmVgJm1kYXNoO1RoZSBtb250aCB3ZWVrIG51bWJlciBjZWxsIHRlbXBsYXRlIGRpcmVjdGl2ZS5cbiAqIC0gYEhlYWRlclRpdGxlVGVtcGxhdGVEaXJlY3RpdmVgJm1kYXNoO1RoZSBoZWFkZXIgdGl0bGUgdGVtcGxhdGUgZGlyZWN0aXZlLlxuICogLSBgTmF2aWdhdGlvbkl0ZW1UZW1wbGF0ZURpcmVjdGl2ZWAmbWRhc2g7VGhlIG5hdmlnYXRpb24gaXRlbSB0ZW1wbGF0ZSBkaXJlY3RpdmUuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGB0cy1uby1ydW5cbiAqIC8vIEltcG9ydCB0aGUgQ2FsZW5kYXIgbW9kdWxlXG4gKiBpbXBvcnQgeyBDYWxlbmRhck1vZHVsZSB9IGZyb20gJ0Bwcm9ncmVzcy9rZW5kby1hbmd1bGFyLWRhdGVpbnB1dHMnO1xuICpcbiAqIC8vIFRoZSBicm93c2VyIHBsYXRmb3JtIHdpdGggYSBjb21waWxlclxuICogaW1wb3J0IHsgcGxhdGZvcm1Ccm93c2VyRHluYW1pYyB9IGZyb20gJ0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXItZHluYW1pYyc7XG4gKlxuICogaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbiAqXG4gKiAvLyBJbXBvcnQgdGhlIGFwcCBjb21wb25lbnRcbiAqIGltcG9ydCB7IEFwcENvbXBvbmVudCB9IGZyb20gJy4vYXBwLmNvbXBvbmVudCc7XG4gKlxuICogLy8gRGVmaW5lIHRoZSBhcHAgbW9kdWxlXG4gKiBfQE5nTW9kdWxlKHtcbiAqICAgICBkZWNsYXJhdGlvbnM6IFtBcHBDb21wb25lbnRdLCAvLyBkZWNsYXJlIGFwcCBjb21wb25lbnRcbiAqICAgICBpbXBvcnRzOiAgICAgIFtCcm93c2VyTW9kdWxlLCBDYWxlbmRhck1vZHVsZV0sIC8vIGltcG9ydCBDYWxlbmRhciBtb2R1bGVcbiAqICAgICBib290c3RyYXA6ICAgIFtBcHBDb21wb25lbnRdXG4gKiB9KVxuICogZXhwb3J0IGNsYXNzIEFwcE1vZHVsZSB7fVxuICpcbiAqIC8vIENvbXBpbGUgYW5kIGxhdW5jaCB0aGUgbW9kdWxlXG4gKiBwbGF0Zm9ybUJyb3dzZXJEeW5hbWljKCkuYm9vdHN0cmFwTW9kdWxlKEFwcE1vZHVsZSk7XG4gKlxuICogYGBgXG4gKi9cbmxldCBDYWxlbmRhck1vZHVsZSA9IGNsYXNzIENhbGVuZGFyTW9kdWxlIHtcbn07XG5DYWxlbmRhck1vZHVsZSA9IF9fZGVjb3JhdGUoW1xuICAgIE5nTW9kdWxlKHtcbiAgICAgICAgZGVjbGFyYXRpb25zOiBbXG4gICAgICAgICAgICBDYWxlbmRhckNvbXBvbmVudCxcbiAgICAgICAgICAgIE5hdmlnYXRpb25Db21wb25lbnQsXG4gICAgICAgICAgICBDYWxlbmRhckN1c3RvbU1lc3NhZ2VzQ29tcG9uZW50LFxuICAgICAgICAgICAgQ2FsZW5kYXJMb2NhbGl6ZWRNZXNzYWdlc0RpcmVjdGl2ZSxcbiAgICAgICAgICAgIFZpZXdMaXN0Q29tcG9uZW50XG4gICAgICAgIF0sXG4gICAgICAgIGV4cG9ydHM6IFtcbiAgICAgICAgICAgIENhbGVuZGFyQ29tcG9uZW50LFxuICAgICAgICAgICAgTmF2aWdhdGlvbkNvbXBvbmVudCxcbiAgICAgICAgICAgIENhbGVuZGFyQ3VzdG9tTWVzc2FnZXNDb21wb25lbnQsXG4gICAgICAgICAgICBDYWxlbmRhckxvY2FsaXplZE1lc3NhZ2VzRGlyZWN0aXZlLFxuICAgICAgICAgICAgVmlld0xpc3RDb21wb25lbnQsXG4gICAgICAgICAgICBDYWxlbmRhckNvbW1vbk1vZHVsZSxcbiAgICAgICAgICAgIFRlbXBsYXRlc01vZHVsZVxuICAgICAgICBdLFxuICAgICAgICBpbXBvcnRzOiBbXG4gICAgICAgICAgICBDb21tb25Nb2R1bGUsXG4gICAgICAgICAgICBDYWxlbmRhckNvbW1vbk1vZHVsZSxcbiAgICAgICAgICAgIE11bHRpVmlld0NhbGVuZGFyTW9kdWxlLFxuICAgICAgICAgICAgSW50bE1vZHVsZSxcbiAgICAgICAgICAgIFRlbXBsYXRlc01vZHVsZSxcbiAgICAgICAgICAgIFZpcnR1YWxpemF0aW9uTW9kdWxlLFxuICAgICAgICAgICAgRXZlbnRzTW9kdWxlLFxuICAgICAgICAgICAgUmVzaXplU2Vuc29yTW9kdWxlXG4gICAgICAgIF0sXG4gICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAgQ2FsZW5kYXJET01TZXJ2aWNlLFxuICAgICAgICAgICAgQ2VudHVyeVZpZXdTZXJ2aWNlLFxuICAgICAgICAgICAgRGVjYWRlVmlld1NlcnZpY2UsXG4gICAgICAgICAgICBNb250aFZpZXdTZXJ2aWNlLFxuICAgICAgICAgICAgWWVhclZpZXdTZXJ2aWNlLFxuICAgICAgICAgICAgV2Vla05hbWVzU2VydmljZVxuICAgICAgICBdXG4gICAgfSlcbl0sIENhbGVuZGFyTW9kdWxlKTtcblxuLyoqXG4gKiBUaGUgZXhwb3J0ZWQgcGFja2FnZSBtb2R1bGUuXG4gKlxuICogVGhlIHBhY2thZ2UgZXhwb3J0czpcbiAqIC0gYENhbGVuZGFyTW9kdWxlYCZtZGFzaDtUaGUgY2FsZW5kYXIgbW9kdWxlLlxuICogLSBgTXVsdGlWaWV3Q2FsZW5kYXJNb2R1bGVgJm1kYXNoO1RoZSBtdWx0aS12aWV3IGNhbGVuZGFyIG1vZHVsZS5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYHRzLW5vLXJ1blxuICogLy8gSW1wb3J0IHRoZSBDYWxlbmRhcnMgbW9kdWxlXG4gKiBpbXBvcnQgeyBDYWxlbmRhcnNNb2R1bGUgfSBmcm9tICdAcHJvZ3Jlc3Mva2VuZG8tYW5ndWxhci1kYXRlaW5wdXRzJztcbiAqXG4gKiAvLyBUaGUgYnJvd3NlciBwbGF0Zm9ybSB3aXRoIGEgY29tcGlsZXJcbiAqIGltcG9ydCB7IHBsYXRmb3JtQnJvd3NlckR5bmFtaWMgfSBmcm9tICdAYW5ndWxhci9wbGF0Zm9ybS1icm93c2VyLWR5bmFtaWMnO1xuICpcbiAqIGltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG4gKlxuICogLy8gSW1wb3J0IHRoZSBhcHAgY29tcG9uZW50XG4gKiBpbXBvcnQgeyBBcHBDb21wb25lbnQgfSBmcm9tICcuL2FwcC5jb21wb25lbnQnO1xuICpcbiAqIC8vIERlZmluZSB0aGUgYXBwIG1vZHVsZVxuICogX0BOZ01vZHVsZSh7XG4gKiAgICAgZGVjbGFyYXRpb25zOiBbQXBwQ29tcG9uZW50XSwgLy8gZGVjbGFyZSBhcHAgY29tcG9uZW50XG4gKiAgICAgaW1wb3J0czogICAgICBbQnJvd3Nlck1vZHVsZSwgQ2FsZW5kYXJzTW9kdWxlXSwgLy8gaW1wb3J0IHRoZSBDYWxlbmRhcnMgbW9kdWxlXG4gKiAgICAgYm9vdHN0cmFwOiAgICBbQXBwQ29tcG9uZW50XVxuICogfSlcbiAqIGV4cG9ydCBjbGFzcyBBcHBNb2R1bGUge31cbiAqXG4gKiAvLyBDb21waWxlIGFuZCBsYXVuY2ggdGhlIG1vZHVsZVxuICogcGxhdGZvcm1Ccm93c2VyRHluYW1pYygpLmJvb3RzdHJhcE1vZHVsZShBcHBNb2R1bGUpO1xuICpcbiAqIGBgYFxuICovXG5sZXQgQ2FsZW5kYXJzTW9kdWxlID0gY2xhc3MgQ2FsZW5kYXJzTW9kdWxlIHtcbn07XG5DYWxlbmRhcnNNb2R1bGUgPSBfX2RlY29yYXRlKFtcbiAgICBOZ01vZHVsZSh7XG4gICAgICAgIGV4cG9ydHM6IFtcbiAgICAgICAgICAgIENhbGVuZGFyTW9kdWxlLFxuICAgICAgICAgICAgTXVsdGlWaWV3Q2FsZW5kYXJNb2R1bGVcbiAgICAgICAgXSxcbiAgICAgICAgaW1wb3J0czogW1xuICAgICAgICAgICAgQ2FsZW5kYXJNb2R1bGUsXG4gICAgICAgICAgICBNdWx0aVZpZXdDYWxlbmRhck1vZHVsZVxuICAgICAgICBdXG4gICAgfSlcbl0sIENhbGVuZGFyc01vZHVsZSk7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBEYXRlSW5wdXRNZXNzYWdlcyBleHRlbmRzIENvbXBvbmVudE1lc3NhZ2VzIHtcbn1cbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIERhdGVJbnB1dE1lc3NhZ2VzLnByb3RvdHlwZSwgXCJkZWNyZW1lbnRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIERhdGVJbnB1dE1lc3NhZ2VzLnByb3RvdHlwZSwgXCJpbmNyZW1lbnRcIiwgdm9pZCAwKTtcblxudmFyIERhdGVJbnB1dExvY2FsaXplZE1lc3NhZ2VzRGlyZWN0aXZlXzE7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xubGV0IERhdGVJbnB1dExvY2FsaXplZE1lc3NhZ2VzRGlyZWN0aXZlID0gRGF0ZUlucHV0TG9jYWxpemVkTWVzc2FnZXNEaXJlY3RpdmVfMSA9IGNsYXNzIERhdGVJbnB1dExvY2FsaXplZE1lc3NhZ2VzRGlyZWN0aXZlIGV4dGVuZHMgRGF0ZUlucHV0TWVzc2FnZXMge1xuICAgIGNvbnN0cnVjdG9yKHNlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5zZXJ2aWNlID0gc2VydmljZTtcbiAgICB9XG59O1xuRGF0ZUlucHV0TG9jYWxpemVkTWVzc2FnZXNEaXJlY3RpdmUgPSBEYXRlSW5wdXRMb2NhbGl6ZWRNZXNzYWdlc0RpcmVjdGl2ZV8xID0gX19kZWNvcmF0ZShbXG4gICAgRGlyZWN0aXZlKHtcbiAgICAgICAgcHJvdmlkZXJzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcHJvdmlkZTogRGF0ZUlucHV0TWVzc2FnZXMsXG4gICAgICAgICAgICAgICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gRGF0ZUlucHV0TG9jYWxpemVkTWVzc2FnZXNEaXJlY3RpdmVfMSkgLy8gdHNsaW50OmRpc2FibGUtbGluZTpuby1mb3J3YXJkLXJlZlxuICAgICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBzZWxlY3RvcjogJ1trZW5kb0RhdGVJbnB1dExvY2FsaXplZE1lc3NhZ2VzXSdcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0xvY2FsaXphdGlvblNlcnZpY2VdKVxuXSwgRGF0ZUlucHV0TG9jYWxpemVkTWVzc2FnZXNEaXJlY3RpdmUpO1xuXG52YXIgRGF0ZUlucHV0Q3VzdG9tTWVzc2FnZXNDb21wb25lbnRfMTtcbi8qKlxuICogQ3VzdG9tIGNvbXBvbmVudCBtZXNzYWdlcyBvdmVycmlkZSBkZWZhdWx0IGNvbXBvbmVudCBtZXNzYWdlcyAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGdsb2JhbGl6YXRpb25fZGF0ZWlucHV0cyAlfSN0b2MtY3VzdG9tLW1lc3NhZ2VzKSkuXG4gKi9cbmxldCBEYXRlSW5wdXRDdXN0b21NZXNzYWdlc0NvbXBvbmVudCA9IERhdGVJbnB1dEN1c3RvbU1lc3NhZ2VzQ29tcG9uZW50XzEgPSBjbGFzcyBEYXRlSW5wdXRDdXN0b21NZXNzYWdlc0NvbXBvbmVudCBleHRlbmRzIERhdGVJbnB1dE1lc3NhZ2VzIHtcbiAgICBjb25zdHJ1Y3RvcihzZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuc2VydmljZSA9IHNlcnZpY2U7XG4gICAgfVxuICAgIGdldCBvdmVycmlkZSgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufTtcbkRhdGVJbnB1dEN1c3RvbU1lc3NhZ2VzQ29tcG9uZW50ID0gRGF0ZUlucHV0Q3VzdG9tTWVzc2FnZXNDb21wb25lbnRfMSA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHByb3ZpZGU6IERhdGVJbnB1dE1lc3NhZ2VzLFxuICAgICAgICAgICAgICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IERhdGVJbnB1dEN1c3RvbU1lc3NhZ2VzQ29tcG9uZW50XzEpIC8vIHRzbGludDpkaXNhYmxlLWxpbmU6bm8tZm9yd2FyZC1yZWZcbiAgICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1kYXRlaW5wdXQtbWVzc2FnZXMnLFxuICAgICAgICB0ZW1wbGF0ZTogYGBcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0xvY2FsaXphdGlvblNlcnZpY2VdKVxuXSwgRGF0ZUlucHV0Q3VzdG9tTWVzc2FnZXNDb21wb25lbnQpO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIFtOZ01vZHVsZV0oe3sgc2l0ZS5kYXRhLnVybHMuYW5ndWxhclsnbmdtb2R1bGVhcGknXSB9fSlcbiAqIGRlZmluaXRpb24gZm9yIHRoZSBEYXRlSW5wdXQgY29tcG9uZW50LlxuICovXG5sZXQgRGF0ZUlucHV0TW9kdWxlID0gY2xhc3MgRGF0ZUlucHV0TW9kdWxlIHtcbn07XG5EYXRlSW5wdXRNb2R1bGUgPSBfX2RlY29yYXRlKFtcbiAgICBOZ01vZHVsZSh7XG4gICAgICAgIGRlY2xhcmF0aW9uczogW1xuICAgICAgICAgICAgRGF0ZUlucHV0Q29tcG9uZW50LFxuICAgICAgICAgICAgRGF0ZUlucHV0Q3VzdG9tTWVzc2FnZXNDb21wb25lbnQsXG4gICAgICAgICAgICBEYXRlSW5wdXRMb2NhbGl6ZWRNZXNzYWdlc0RpcmVjdGl2ZVxuICAgICAgICBdLFxuICAgICAgICBleHBvcnRzOiBbXG4gICAgICAgICAgICBEYXRlSW5wdXRDb21wb25lbnQsXG4gICAgICAgICAgICBEYXRlSW5wdXRDdXN0b21NZXNzYWdlc0NvbXBvbmVudCxcbiAgICAgICAgICAgIERhdGVJbnB1dExvY2FsaXplZE1lc3NhZ2VzRGlyZWN0aXZlXG4gICAgICAgIF0sXG4gICAgICAgIGltcG9ydHM6IFtDb21tb25Nb2R1bGUsIEludGxNb2R1bGUsIEV2ZW50c01vZHVsZV1cbiAgICB9KVxuXSwgRGF0ZUlucHV0TW9kdWxlKTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIERhdGVQaWNrZXJNZXNzYWdlcyBleHRlbmRzIENvbXBvbmVudE1lc3NhZ2VzIHtcbn1cbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIERhdGVQaWNrZXJNZXNzYWdlcy5wcm90b3R5cGUsIFwidG9kYXlcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIERhdGVQaWNrZXJNZXNzYWdlcy5wcm90b3R5cGUsIFwidG9nZ2xlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBEYXRlUGlja2VyTWVzc2FnZXMucHJvdG90eXBlLCBcInByZXZCdXR0b25UaXRsZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgRGF0ZVBpY2tlck1lc3NhZ2VzLnByb3RvdHlwZSwgXCJuZXh0QnV0dG9uVGl0bGVcIiwgdm9pZCAwKTtcblxudmFyIERhdGVQaWNrZXJMb2NhbGl6ZWRNZXNzYWdlc0RpcmVjdGl2ZV8xO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmxldCBEYXRlUGlja2VyTG9jYWxpemVkTWVzc2FnZXNEaXJlY3RpdmUgPSBEYXRlUGlja2VyTG9jYWxpemVkTWVzc2FnZXNEaXJlY3RpdmVfMSA9IGNsYXNzIERhdGVQaWNrZXJMb2NhbGl6ZWRNZXNzYWdlc0RpcmVjdGl2ZSBleHRlbmRzIERhdGVQaWNrZXJNZXNzYWdlcyB7XG4gICAgY29uc3RydWN0b3Ioc2VydmljZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnNlcnZpY2UgPSBzZXJ2aWNlO1xuICAgIH1cbn07XG5EYXRlUGlja2VyTG9jYWxpemVkTWVzc2FnZXNEaXJlY3RpdmUgPSBEYXRlUGlja2VyTG9jYWxpemVkTWVzc2FnZXNEaXJlY3RpdmVfMSA9IF9fZGVjb3JhdGUoW1xuICAgIERpcmVjdGl2ZSh7XG4gICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHByb3ZpZGU6IERhdGVQaWNrZXJNZXNzYWdlcyxcbiAgICAgICAgICAgICAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBEYXRlUGlja2VyTG9jYWxpemVkTWVzc2FnZXNEaXJlY3RpdmVfMSkgLy8gdHNsaW50OmRpc2FibGUtbGluZTpuby1mb3J3YXJkLXJlZlxuICAgICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBzZWxlY3RvcjogJ1trZW5kb0RhdGVQaWNrZXJMb2NhbGl6ZWRNZXNzYWdlc10nXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtMb2NhbGl6YXRpb25TZXJ2aWNlXSlcbl0sIERhdGVQaWNrZXJMb2NhbGl6ZWRNZXNzYWdlc0RpcmVjdGl2ZSk7XG5cbnZhciBEYXRlUGlja2VyQ3VzdG9tTWVzc2FnZXNDb21wb25lbnRfMTtcbi8qKlxuICogQ3VzdG9tIGNvbXBvbmVudCBtZXNzYWdlcyBvdmVycmlkZSBkZWZhdWx0IGNvbXBvbmVudCBtZXNzYWdlcyAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGdsb2JhbGl6YXRpb25fZGF0ZWlucHV0cyAlfSN0b2MtY3VzdG9tLW1lc3NhZ2VzKSkuXG4gKi9cbmxldCBEYXRlUGlja2VyQ3VzdG9tTWVzc2FnZXNDb21wb25lbnQgPSBEYXRlUGlja2VyQ3VzdG9tTWVzc2FnZXNDb21wb25lbnRfMSA9IGNsYXNzIERhdGVQaWNrZXJDdXN0b21NZXNzYWdlc0NvbXBvbmVudCBleHRlbmRzIERhdGVQaWNrZXJNZXNzYWdlcyB7XG4gICAgY29uc3RydWN0b3Ioc2VydmljZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnNlcnZpY2UgPSBzZXJ2aWNlO1xuICAgIH1cbiAgICBnZXQgb3ZlcnJpZGUoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn07XG5EYXRlUGlja2VyQ3VzdG9tTWVzc2FnZXNDb21wb25lbnQgPSBEYXRlUGlja2VyQ3VzdG9tTWVzc2FnZXNDb21wb25lbnRfMSA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHByb3ZpZGU6IERhdGVQaWNrZXJNZXNzYWdlcyxcbiAgICAgICAgICAgICAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBEYXRlUGlja2VyQ3VzdG9tTWVzc2FnZXNDb21wb25lbnRfMSkgLy8gdHNsaW50OmRpc2FibGUtbGluZTpuby1mb3J3YXJkLXJlZlxuICAgICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLWRhdGVwaWNrZXItbWVzc2FnZXMnLFxuICAgICAgICB0ZW1wbGF0ZTogYGBcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0xvY2FsaXphdGlvblNlcnZpY2VdKVxuXSwgRGF0ZVBpY2tlckN1c3RvbU1lc3NhZ2VzQ29tcG9uZW50KTtcblxuY29uc3QgybUwJGUgPSB0b3VjaEVuYWJsZWQ7XG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIFtOZ01vZHVsZV0oe3sgc2l0ZS5kYXRhLnVybHMuYW5ndWxhclsnbmdtb2R1bGVhcGknXSB9fSlcbiAqIGRlZmluaXRpb24gZm9yIHRoZSBEYXRlUGlja2VyIGNvbXBvbmVudC5cbiAqL1xubGV0IERhdGVQaWNrZXJNb2R1bGUgPSBjbGFzcyBEYXRlUGlja2VyTW9kdWxlIHtcbn07XG5EYXRlUGlja2VyTW9kdWxlID0gX19kZWNvcmF0ZShbXG4gICAgTmdNb2R1bGUoe1xuICAgICAgICBkZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgICAgIERhdGVQaWNrZXJDb21wb25lbnQsXG4gICAgICAgICAgICBEYXRlUGlja2VyQ3VzdG9tTWVzc2FnZXNDb21wb25lbnQsXG4gICAgICAgICAgICBEYXRlUGlja2VyTG9jYWxpemVkTWVzc2FnZXNEaXJlY3RpdmVcbiAgICAgICAgXSxcbiAgICAgICAgZXhwb3J0czogW1xuICAgICAgICAgICAgRGF0ZVBpY2tlckNvbXBvbmVudCxcbiAgICAgICAgICAgIERhdGVQaWNrZXJDdXN0b21NZXNzYWdlc0NvbXBvbmVudCxcbiAgICAgICAgICAgIERhdGVQaWNrZXJMb2NhbGl6ZWRNZXNzYWdlc0RpcmVjdGl2ZSxcbiAgICAgICAgICAgIFRlbXBsYXRlc01vZHVsZVxuICAgICAgICBdLFxuICAgICAgICBpbXBvcnRzOiBbXG4gICAgICAgICAgICBDb21tb25Nb2R1bGUsXG4gICAgICAgICAgICBEYXRlSW5wdXRNb2R1bGUsXG4gICAgICAgICAgICBDYWxlbmRhck1vZHVsZSxcbiAgICAgICAgICAgIEludGxNb2R1bGUsXG4gICAgICAgICAgICBQb3B1cE1vZHVsZSxcbiAgICAgICAgICAgIFRlbXBsYXRlc01vZHVsZSxcbiAgICAgICAgICAgIEV2ZW50c01vZHVsZVxuICAgICAgICBdLFxuICAgICAgICBwcm92aWRlcnM6IFt7IHByb3ZpZGU6IFRPVUNIX0VOQUJMRUQsIHVzZVZhbHVlOiDJtTAkZSB9XVxuICAgIH0pXG5dLCBEYXRlUGlja2VyTW9kdWxlKTtcblxuY29uc3QgQ09NUE9ORU5UX0RJUkVDVElWRVMkMSA9IFtcbiAgICBEYXRlUmFuZ2VDb21wb25lbnQsXG4gICAgRGF0ZVJhbmdlUG9wdXBDb21wb25lbnQsXG4gICAgRGF0ZVJhbmdlUG9wdXBUZW1wbGF0ZURpcmVjdGl2ZSxcbiAgICBEYXRlUmFuZ2VTZWxlY3Rpb25EaXJlY3RpdmUsXG4gICAgRGF0ZVJhbmdlU3RhcnRJbnB1dERpcmVjdGl2ZSxcbiAgICBEYXRlUmFuZ2VFbmRJbnB1dERpcmVjdGl2ZVxuXTtcbmNvbnN0IENPTVBPTkVOVF9NT0RVTEVTID0gW1xuICAgIE11bHRpVmlld0NhbGVuZGFyTW9kdWxlLFxuICAgIERhdGVJbnB1dE1vZHVsZSxcbiAgICBQb3B1cE1vZHVsZSxcbiAgICBFdmVudHNNb2R1bGVcbl07XG4vKipcbiAqIFRoZSBleHBvcnRlZCBwYWNrYWdlIG1vZHVsZS5cbiAqXG4gKiBUaGUgcGFja2FnZSBleHBvcnRzOlxuICogLSBgRGF0ZVJhbmdlQ29tcG9uZW50YCZtZGFzaDtUaGUgRGF0ZVJhbmdlIGNvbXBvbmVudCBjbGFzcy5cbiAqIC0gYERhdGVSYW5nZVBvcHVwQ29tcG9uZW50YCZtZGFzaDtUaGUgRGF0ZVJhbmdlUG9wdXAgY29tcG9uZW50IGNsYXNzLlxuICogLSBgRGF0ZVJhbmdlU2VsZWN0aW9uRGlyZWN0aXZlYCZtZGFzaDtUaGUgTXVsdGl2aWV3Q2FsZW5kYXIgZGF0ZSByYW5nZSBzZWxlY3Rpb24gZGlyZWN0aXZlLlxuICogLSBgRGF0ZVJhbmdlRW5kSW5wdXREaXJlY3RpdmVgJm1kYXNoO1RoZSBlbmQgRGF0ZUlucHV0IGRhdGUgcmFuZ2Ugc2VsZWN0aW9uIGRpcmVjdGl2ZS5cbiAqIC0gYERhdGVSYW5nZVN0YXJ0SW5wdXREaXJlY3RpdmVgJm1kYXNoO1RoZSBzdGFydCBEYXRlSW5wdXQgZGF0ZSByYW5nZSBzZWxlY3Rpb24gZGlyZWN0aXZlLlxuICogLSBgRGF0ZVJhbmdlUG9wdXBUZW1wbGF0ZURpcmVjdGl2ZWAmbWRhc2g7VGhlIERhdGVSYW5nZVBvcHVwIGNvbnRlbnQgdGVtcGxhdGUgZGlyZWN0aXZlLlxuICogLSBgTXVsdGlWaWV3Q2FsZW5kYXJNb2R1bGVgJm1kYXNoO1RoZSBNdWx0aVZpZXdDYWxlbmRhciBtb2R1bGUuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGB0cy1uby1ydW5cbiAqIC8vIEltcG9ydCB0aGUgRGF0ZVJhbmdlIG1vZHVsZVxuICogaW1wb3J0IHsgRGF0ZVJhbmdlTW9kdWxlIH0gZnJvbSAnQHByb2dyZXNzL2tlbmRvLWFuZ3VsYXItZGF0ZWlucHV0cyc7XG4gKlxuICogLy8gVGhlIGJyb3dzZXIgcGxhdGZvcm0gd2l0aCBhIGNvbXBpbGVyXG4gKiBpbXBvcnQgeyBwbGF0Zm9ybUJyb3dzZXJEeW5hbWljIH0gZnJvbSAnQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3Nlci1keW5hbWljJztcbiAqXG4gKiBpbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuICpcbiAqIC8vIEltcG9ydCB0aGUgYXBwIGNvbXBvbmVudFxuICogaW1wb3J0IHsgQXBwQ29tcG9uZW50IH0gZnJvbSAnLi9hcHAuY29tcG9uZW50JztcbiAqXG4gKiAvLyBEZWZpbmUgdGhlIGFwcCBtb2R1bGVcbiAqIF9ATmdNb2R1bGUoe1xuICogICAgIGRlY2xhcmF0aW9uczogW0FwcENvbXBvbmVudF0sIC8vIGRlY2xhcmUgYXBwIGNvbXBvbmVudFxuICogICAgIGltcG9ydHM6ICAgICAgW0Jyb3dzZXJNb2R1bGUsIERhdGVSYW5nZU1vZHVsZV0sIC8vIGltcG9ydCBEYXRlUmFuZ2UgbW9kdWxlXG4gKiAgICAgYm9vdHN0cmFwOiAgICBbQXBwQ29tcG9uZW50XVxuICogfSlcbiAqIGV4cG9ydCBjbGFzcyBBcHBNb2R1bGUge31cbiAqXG4gKiAvLyBDb21waWxlIGFuZCBsYXVuY2ggdGhlIG1vZHVsZVxuICogcGxhdGZvcm1Ccm93c2VyRHluYW1pYygpLmJvb3RzdHJhcE1vZHVsZShBcHBNb2R1bGUpO1xuICpcbiAqIGBgYFxuICovXG5sZXQgRGF0ZVJhbmdlTW9kdWxlID0gY2xhc3MgRGF0ZVJhbmdlTW9kdWxlIHtcbn07XG5EYXRlUmFuZ2VNb2R1bGUgPSBfX2RlY29yYXRlKFtcbiAgICBOZ01vZHVsZSh7XG4gICAgICAgIGRlY2xhcmF0aW9uczogW0NPTVBPTkVOVF9ESVJFQ1RJVkVTJDFdLFxuICAgICAgICBleHBvcnRzOiBbQ09NUE9ORU5UX0RJUkVDVElWRVMkMV0sXG4gICAgICAgIGltcG9ydHM6IFtDb21tb25Nb2R1bGUsIENPTVBPTkVOVF9NT0RVTEVTXVxuICAgIH0pXG5dLCBEYXRlUmFuZ2VNb2R1bGUpO1xuXG5jb25zdCBkaXYkMSA9IGRvbUNvbnRhaW5lckZhY3RvcnkoJ2RpdicpO1xuY29uc3QgdWwkMSA9IGRvbUNvbnRhaW5lckZhY3RvcnkoJ3VsJyk7XG5jb25zdCBsaSQxID0gZG9tQ29udGFpbmVyRmFjdG9yeSgnbGknKTtcbmNvbnN0IGxpc3RJdGVtID0gKCkgPT4gbGkkMSgnPHNwYW4+MDI8L3NwYW4+JywgJ2staXRlbScpO1xuY29uc3QgbGlzdCA9ICgpID0+IHVsJDEoW2xpc3RJdGVtKCldLCAnay1yZXNldCcpO1xuY29uc3Qgc2Nyb2xsYWJsZSQxID0gKCkgPT4gKGRpdiQxKFtsaXN0KCldLCAnay10aW1lLWNvbnRhaW5lciBrLWNvbnRlbnQgay1zY3JvbGxhYmxlJykpO1xuY29uc3QgdGltZUxpc3RXcmFwcGVyID0gKCkgPT4ge1xuICAgIGlmICghaXNEb2N1bWVudEF2YWlsYWJsZSgpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gZGl2JDEoW2RpdiQxKFtzY3JvbGxhYmxlJDEoKV0sICdrLXRpbWUtbGlzdCcpXSwgJ2stdGltZS1saXN0LXdyYXBwZXInLCB7IGxlZnQ6ICctMTAwMDBweCcsIHBvc2l0aW9uOiAnYWJzb2x1dGUnIH0pO1xufTtcbmNvbnN0IFRJTUVMSVNUX1dSQVBQRVIgPSB0aW1lTGlzdFdyYXBwZXIoKTtcbi8qKlxuICogQGhpZGRlblxuICovXG5sZXQgVGltZVBpY2tlckRPTVNlcnZpY2UgPSBjbGFzcyBUaW1lUGlja2VyRE9NU2VydmljZSB7XG4gICAgZW5zdXJlSGVpZ2h0cygpIHtcbiAgICAgICAgaWYgKHRoaXMudGltZUxpc3RIZWlnaHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2FsY3VsYXRlSGVpZ2h0cygpO1xuICAgIH1cbiAgICBjYWxjdWxhdGVIZWlnaHRzKGNvbnRhaW5lcikge1xuICAgICAgICBpZiAoIWlzRG9jdW1lbnRBdmFpbGFibGUoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxpc3RDb250YWluZXIgPSBjb250YWluZXIgJiYgY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoJy5rLXRpbWUtbGlzdC1jb250YWluZXInKTtcbiAgICAgICAgY29uc3QgaG9zdENvbnRhaW5lciA9IGxpc3RDb250YWluZXIgfHwgZG9jdW1lbnQuYm9keTtcbiAgICAgICAgY29uc3Qgd3JhcHBlciA9IGhvc3RDb250YWluZXIuYXBwZW5kQ2hpbGQoVElNRUxJU1RfV1JBUFBFUik7XG4gICAgICAgIHRoaXMudGltZUxpc3RIZWlnaHQgPSB3cmFwcGVyLnF1ZXJ5U2VsZWN0b3IoJy5rLXNjcm9sbGFibGUnKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQ7XG4gICAgICAgIHRoaXMuaXRlbUhlaWdodCA9IHdyYXBwZXIucXVlcnlTZWxlY3RvcignbGknKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQ7XG4gICAgICAgIGhvc3RDb250YWluZXIucmVtb3ZlQ2hpbGQod3JhcHBlcik7XG4gICAgfVxuICAgIGlzQWN0aXZlKGVsZW1lbnQpIHtcbiAgICAgICAgaWYgKCFpc0RvY3VtZW50QXZhaWxhYmxlKCkgfHwgIWVsZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKGVsZW1lbnQubmF0aXZlRWxlbWVudCB8fCBlbGVtZW50KSA9PT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgICB9XG59O1xuVGltZVBpY2tlckRPTVNlcnZpY2UgPSBfX2RlY29yYXRlKFtcbiAgICBJbmplY3RhYmxlKClcbl0sIFRpbWVQaWNrZXJET01TZXJ2aWNlKTtcblxuY29uc3QgSE9VUlNfSU5fREFZID0gMjQ7XG5jb25zdCBjbGFtcFRvUmFuZ2UgPSAocmFuZ2VWYWx1ZSkgPT4gKHZhbHVlKSA9PiB2YWx1ZSAlIHJhbmdlVmFsdWU7XG5jb25zdCBjbGFtcCA9IGNsYW1wVG9SYW5nZShIT1VSU19JTl9EQVkpO1xuY29uc3Qgc3RlcHBlciA9IChzdGFydCwgc3RlcCkgPT4gKGlkeCkgPT4gY2xhbXAoc3RhcnQgKyAoaWR4ICogc3RlcCkpO1xuY29uc3QgZGlzdGFuY2VGcm9tTWluID0gKHZhbHVlLCBtaW4pID0+IGNsYW1wKEhPVVJTX0lOX0RBWSArIHZhbHVlIC0gbWluKTtcbmNvbnN0IGxpbWl0ID0gKGJvcmRlclZhbHVlKSA9PiAoYmFycmllciwgdmFsdWUpID0+IHtcbiAgICBjb25zdCB1c2VCYXJyaWVyID0gIXZhbHVlIHx8IGdldERhdGUoYmFycmllcikuZ2V0VGltZSgpID09PSBnZXREYXRlKHZhbHVlKS5nZXRUaW1lKCk7XG4gICAgcmV0dXJuIHVzZUJhcnJpZXIgPyBiYXJyaWVyIDogc2V0SG91cnMoYmFycmllciwgYm9yZGVyVmFsdWUpO1xufTtcbmNvbnN0IGxpbWl0RG93biA9IGxpbWl0KDApO1xuY29uc3QgbGltaXRVcCA9IGxpbWl0KEhPVVJTX0lOX0RBWSAtIDEpO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmxldCBIb3Vyc1NlcnZpY2UgPSBjbGFzcyBIb3Vyc1NlcnZpY2Uge1xuICAgIGNvbnN0cnVjdG9yKGludGwpIHtcbiAgICAgICAgdGhpcy5pbnRsID0gaW50bDtcbiAgICAgICAgdGhpcy5ib3VuZFJhbmdlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaW5zZXJ0VW5kaXZpZGVkTWF4ID0gZmFsc2U7XG4gICAgfVxuICAgIGFwcGx5KHZhbHVlLCBjYW5kaWRhdGUpIHtcbiAgICAgICAgcmV0dXJuIHNldEhvdXJzKHZhbHVlLCBjYW5kaWRhdGUuZ2V0SG91cnMoKSk7XG4gICAgfVxuICAgIGNvbmZpZ3VyZShzZXR0aW5ncykge1xuICAgICAgICBjb25zdCB7IGJvdW5kUmFuZ2UgPSB0aGlzLmJvdW5kUmFuZ2UsIGluc2VydFVuZGl2aWRlZE1heCA9IHRoaXMuaW5zZXJ0VW5kaXZpZGVkTWF4LCBtaW4gPSB0aGlzLm1pbiwgbWF4ID0gdGhpcy5tYXgsIHBhcnQsIHN0ZXAgPSB0aGlzLnN0ZXAgfSA9IHNldHRpbmdzO1xuICAgICAgICB0aGlzLmJvdW5kUmFuZ2UgPSBib3VuZFJhbmdlO1xuICAgICAgICB0aGlzLmluc2VydFVuZGl2aWRlZE1heCA9IGluc2VydFVuZGl2aWRlZE1heDtcbiAgICAgICAgdGhpcy50b0xpc3RJdGVtID0gKGhvdXIpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGUgPSBzZXRIb3VycyhNSUROSUdIVF9EQVRFLCBob3VyKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdGV4dDogdGhpcy5pbnRsLmZvcm1hdERhdGUoZGF0ZSwgcGFydC5wYXR0ZXJuKSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogZGF0ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5taW4gPSBtaW47XG4gICAgICAgIHRoaXMubWF4ID0gbWF4O1xuICAgICAgICB0aGlzLnN0ZXAgPSBzdGVwO1xuICAgIH1cbiAgICBkYXRhKHNlbGVjdGVkVmFsdWUpIHtcbiAgICAgICAgY29uc3QgW21pbl0gPSB0aGlzLnJhbmdlKHNlbGVjdGVkVmFsdWUpO1xuICAgICAgICBjb25zdCBnZXRIb3VyID0gc3RlcHBlcihtaW4sIHRoaXMuc3RlcCk7XG4gICAgICAgIGNvbnN0IGNvbnZlcnRUb0l0ZW0gPSAoaWR4KSA9PiAodGhpcy50b0xpc3RJdGVtKGdldEhvdXIoaWR4KSkpO1xuICAgICAgICBjb25zdCBkYXRhID0gcmFuZ2UoMCwgdGhpcy5jb3VudEZyb21NaW4oc2VsZWN0ZWRWYWx1ZSkpLm1hcChjb252ZXJ0VG9JdGVtKTtcbiAgICAgICAgdGhpcy5hZGRMYXN0KGRhdGEpO1xuICAgICAgICB0aGlzLmFkZE1pc3NpbmcoZGF0YSwgc2VsZWN0ZWRWYWx1ZSk7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICBpc1JhbmdlQ2hhbmdlZChtaW4sIG1heCkge1xuICAgICAgICByZXR1cm4gIWlzRXF1YWwodGhpcy5taW4sIG1pbikgfHwgIWlzRXF1YWwodGhpcy5tYXgsIG1heCk7XG4gICAgfVxuICAgIGxpbWl0UmFuZ2UobWluLCBtYXgsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJvdW5kUmFuZ2UgPyBbbGltaXREb3duKG1pbiwgdmFsdWUpLCBsaW1pdFVwKG1heCwgdmFsdWUpXSA6IFttaW4sIG1heF07XG4gICAgfVxuICAgIHRvdGFsKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGxhc3QkJDEgPSB0aGlzLmluc2VydFVuZGl2aWRlZE1heCAmJiB0aGlzLmlzTGFzdE1pc3NpbmcodmFsdWUpID8gMSA6IDA7XG4gICAgICAgIGNvbnN0IG1pc3NpbmcgPSB0aGlzLmlzTWlzc2luZyh2YWx1ZSkgPyAxIDogMDtcbiAgICAgICAgcmV0dXJuIHRoaXMuY291bnRGcm9tTWluKHZhbHVlKSArIG1pc3NpbmcgKyBsYXN0JCQxO1xuICAgIH1cbiAgICBzZWxlY3RlZEluZGV4KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBNYXRoLmNlaWwodGhpcy5kaXZpZGVCeVN0ZXAodmFsdWUpKTtcbiAgICB9XG4gICAgdmFsdWVJbkxpc3QodmFsdWUpIHtcbiAgICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWF0Y2hNYXggPSB0aGlzLmluc2VydFVuZGl2aWRlZE1heCAmJiB0aGlzLmxhc3RIb3VyKHZhbHVlKSA9PT0gdmFsdWUuZ2V0SG91cnMoKTtcbiAgICAgICAgcmV0dXJuIG1hdGNoTWF4IHx8ICF0aGlzLmlzTWlzc2luZyh2YWx1ZSk7XG4gICAgfVxuICAgIGFkZExhc3QoZGF0YSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuaW5zZXJ0VW5kaXZpZGVkTWF4ICYmIHRoaXMuaXNMYXN0TWlzc2luZyh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGRhdGEucHVzaCh0aGlzLnRvTGlzdEl0ZW0odGhpcy5sYXN0SG91cih2YWx1ZSkpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgYWRkTWlzc2luZyhkYXRhLCB2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy52YWx1ZUluTGlzdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1pc3NpbmdJdGVtID0gdGhpcy50b0xpc3RJdGVtKHZhbHVlLmdldEhvdXJzKCkpO1xuICAgICAgICBkYXRhLnNwbGljZSh0aGlzLnNlbGVjdGVkSW5kZXgodmFsdWUpLCAwLCBtaXNzaW5nSXRlbSk7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICBjb3VudEZyb21NaW4odmFsdWUpIHtcbiAgICAgICAgY29uc3QgW21pbiwgbWF4XSA9IHRoaXMucmFuZ2UodmFsdWUpO1xuICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihkaXN0YW5jZUZyb21NaW4obWF4LCBtaW4pIC8gdGhpcy5zdGVwKSArIDE7IC8qIGluY2x1ZGUgbWluICovXG4gICAgfVxuICAgIGlzTWlzc2luZyh2YWx1ZSkge1xuICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0ZWRJbmRleCh2YWx1ZSkgIT09IHRoaXMuZGl2aWRlQnlTdGVwKHZhbHVlKTtcbiAgICB9XG4gICAgaXNMYXN0TWlzc2luZyh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc01pc3Npbmcoc2V0SG91cnModGhpcy5tYXgsIHRoaXMubGFzdEhvdXIodmFsdWUpKSk7XG4gICAgfVxuICAgIGRpdmlkZUJ5U3RlcCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gZGlzdGFuY2VGcm9tTWluKHZhbHVlLmdldEhvdXJzKCksIHRoaXMubWluLmdldEhvdXJzKCkpIC8gdGhpcy5zdGVwO1xuICAgIH1cbiAgICBsYXN0SG91cih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5yYW5nZSh2YWx1ZSlbMV07XG4gICAgfVxuICAgIHJhbmdlKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IFttaW4sIG1heF0gPSB0aGlzLmxpbWl0UmFuZ2UodGhpcy5taW4sIHRoaXMubWF4LCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiBbbWluLmdldEhvdXJzKCksIG1heC5nZXRIb3VycygpXTtcbiAgICB9XG59O1xuSG91cnNTZXJ2aWNlID0gX19kZWNvcmF0ZShbXG4gICAgSW5qZWN0YWJsZSgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbSW50bFNlcnZpY2VdKVxuXSwgSG91cnNTZXJ2aWNlKTtcblxuY29uc3QgTUlOVVRFU19JTl9IT1VSID0gNjA7XG5jb25zdCBjbGFtcFRvUmFuZ2UkMSA9IChyYW5nZVZhbHVlKSA9PiAodmFsdWUpID0+IHZhbHVlICUgcmFuZ2VWYWx1ZTtcbmNvbnN0IGNsYW1wJDEgPSBjbGFtcFRvUmFuZ2UkMShNSU5VVEVTX0lOX0hPVVIpO1xuY29uc3Qgc3RlcHBlciQxID0gKHN0YXJ0LCBzdGVwKSA9PiAoaWR4KSA9PiBjbGFtcCQxKHN0YXJ0ICsgKGlkeCAqIHN0ZXApKTtcbmNvbnN0IGRpc3RhbmNlRnJvbU1pbiQxID0gKHZhbHVlLCBtaW4pID0+IGNsYW1wJDEoTUlOVVRFU19JTl9IT1VSICsgdmFsdWUgLSBtaW4pO1xuY29uc3QgbGltaXQkMSA9IChib3JkZXJWYWx1ZSkgPT4gKGJhcnJpZXIsIHZhbHVlKSA9PiB7XG4gICAgY29uc3QgdXNlQmFycmllciA9ICF2YWx1ZSB8fCBiYXJyaWVyLmdldEhvdXJzKCkgPT09IHZhbHVlLmdldEhvdXJzKCk7XG4gICAgcmV0dXJuIHVzZUJhcnJpZXIgPyBiYXJyaWVyIDogc2V0TWludXRlcyhiYXJyaWVyLCBib3JkZXJWYWx1ZSk7XG59O1xuY29uc3QgbGltaXREb3duJDEgPSBsaW1pdCQxKDApO1xuY29uc3QgbGltaXRVcCQxID0gbGltaXQkMShNSU5VVEVTX0lOX0hPVVIgLSAxKTtcbi8qKlxuICogQGhpZGRlblxuICovXG5sZXQgTWludXRlc1NlcnZpY2UgPSBjbGFzcyBNaW51dGVzU2VydmljZSB7XG4gICAgY29uc3RydWN0b3IoaW50bCkge1xuICAgICAgICB0aGlzLmludGwgPSBpbnRsO1xuICAgICAgICB0aGlzLmluc2VydFVuZGl2aWRlZE1heCA9IGZhbHNlO1xuICAgIH1cbiAgICBhcHBseSh2YWx1ZSwgY2FuZGlkYXRlKSB7XG4gICAgICAgIHJldHVybiBzZXRNaW51dGVzKHZhbHVlLCBjYW5kaWRhdGUuZ2V0TWludXRlcygpKTtcbiAgICB9XG4gICAgY29uZmlndXJlKHNldHRpbmdzKSB7XG4gICAgICAgIGNvbnN0IHsgaW5zZXJ0VW5kaXZpZGVkTWF4ID0gdGhpcy5pbnNlcnRVbmRpdmlkZWRNYXgsIG1pbiA9IHRoaXMubWluLCBtYXggPSB0aGlzLm1heCwgcGFydCwgc3RlcCA9IHRoaXMuc3RlcCB9ID0gc2V0dGluZ3M7XG4gICAgICAgIHRoaXMuaW5zZXJ0VW5kaXZpZGVkTWF4ID0gaW5zZXJ0VW5kaXZpZGVkTWF4O1xuICAgICAgICB0aGlzLnRvTGlzdEl0ZW0gPSAobWludXRlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBkYXRlID0gc2V0TWludXRlcyhNSUROSUdIVF9EQVRFLCBtaW51dGUpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0ZXh0OiB0aGlzLmludGwuZm9ybWF0RGF0ZShkYXRlLCBwYXJ0LnBhdHRlcm4pLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBkYXRlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLm1pbiA9IG1pbjtcbiAgICAgICAgdGhpcy5tYXggPSBtYXg7XG4gICAgICAgIHRoaXMuc3RlcCA9IHN0ZXA7XG4gICAgfVxuICAgIGRhdGEoc2VsZWN0ZWRWYWx1ZSkge1xuICAgICAgICBjb25zdCBbbWluXSA9IHRoaXMucmFuZ2Uoc2VsZWN0ZWRWYWx1ZSk7XG4gICAgICAgIGNvbnN0IGdldE1pbnV0ZSA9IHN0ZXBwZXIkMShtaW4sIHRoaXMuc3RlcCk7XG4gICAgICAgIGNvbnN0IGNvbnZlcnRUb0l0ZW0gPSAoaWR4KSA9PiAodGhpcy50b0xpc3RJdGVtKGdldE1pbnV0ZShpZHgpKSk7XG4gICAgICAgIGNvbnN0IGRhdGEgPSByYW5nZSgwLCB0aGlzLmNvdW50RnJvbU1pbihzZWxlY3RlZFZhbHVlKSkubWFwKGNvbnZlcnRUb0l0ZW0pO1xuICAgICAgICB0aGlzLmFkZExhc3QoZGF0YSk7XG4gICAgICAgIHRoaXMuYWRkTWlzc2luZyhkYXRhLCBzZWxlY3RlZFZhbHVlKTtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIGlzUmFuZ2VDaGFuZ2VkKG1pbiwgbWF4KSB7XG4gICAgICAgIHJldHVybiAhaXNFcXVhbCh0aGlzLm1pbiwgbWluKSB8fCAhaXNFcXVhbCh0aGlzLm1heCwgbWF4KTtcbiAgICB9XG4gICAgbGltaXRSYW5nZShtaW4sIG1heCwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIFtsaW1pdERvd24kMShtaW4sIHZhbHVlKSwgbGltaXRVcCQxKG1heCwgdmFsdWUpXTtcbiAgICB9XG4gICAgdG90YWwodmFsdWUpIHtcbiAgICAgICAgY29uc3QgbGFzdCQkMSA9IHRoaXMuaW5zZXJ0VW5kaXZpZGVkTWF4ICYmIHRoaXMuaXNMYXN0TWlzc2luZyh2YWx1ZSkgPyAxIDogMDtcbiAgICAgICAgY29uc3QgbWlzc2luZyA9IHRoaXMuaXNNaXNzaW5nKHZhbHVlKSA/IDEgOiAwO1xuICAgICAgICByZXR1cm4gdGhpcy5jb3VudEZyb21NaW4odmFsdWUpICsgbWlzc2luZyArIGxhc3QkJDE7XG4gICAgfVxuICAgIHNlbGVjdGVkSW5kZXgodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguY2VpbCh0aGlzLmRpdmlkZUJ5U3RlcCh2YWx1ZSkpO1xuICAgIH1cbiAgICB2YWx1ZUluTGlzdCh2YWx1ZSkge1xuICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtYXRjaE1heCA9IHRoaXMuaW5zZXJ0VW5kaXZpZGVkTWF4ICYmIHRoaXMubGFzdE1pbnV0ZSh2YWx1ZSkgPT09IHZhbHVlLmdldE1pbnV0ZXMoKTtcbiAgICAgICAgcmV0dXJuIG1hdGNoTWF4IHx8ICF0aGlzLmlzTWlzc2luZyh2YWx1ZSk7XG4gICAgfVxuICAgIGFkZExhc3QoZGF0YSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuaW5zZXJ0VW5kaXZpZGVkTWF4ICYmIHRoaXMuaXNMYXN0TWlzc2luZyh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGRhdGEucHVzaCh0aGlzLnRvTGlzdEl0ZW0odGhpcy5sYXN0TWludXRlKHZhbHVlKSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICBhZGRNaXNzaW5nKGRhdGEsIHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLnZhbHVlSW5MaXN0KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWlzc2luZ0l0ZW0gPSB0aGlzLnRvTGlzdEl0ZW0odmFsdWUuZ2V0TWludXRlcygpKTtcbiAgICAgICAgZGF0YS5zcGxpY2UodGhpcy5zZWxlY3RlZEluZGV4KHZhbHVlKSwgMCwgbWlzc2luZ0l0ZW0pO1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgY291bnRGcm9tTWluKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IFttaW4sIG1heF0gPSB0aGlzLnJhbmdlKHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IoZGlzdGFuY2VGcm9tTWluJDEobWF4LCBtaW4pIC8gdGhpcy5zdGVwKSArIDE7IC8qIGluY2x1ZGUgbWluICovXG4gICAgfVxuICAgIGlzTWlzc2luZyh2YWx1ZSkge1xuICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0ZWRJbmRleCh2YWx1ZSkgIT09IHRoaXMuZGl2aWRlQnlTdGVwKHZhbHVlKTtcbiAgICB9XG4gICAgaXNMYXN0TWlzc2luZyh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc01pc3Npbmcoc2V0TWludXRlcyh0aGlzLm1heCwgdGhpcy5sYXN0TWludXRlKHZhbHVlKSkpO1xuICAgIH1cbiAgICBkaXZpZGVCeVN0ZXAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGRpc3RhbmNlRnJvbU1pbiQxKHZhbHVlLmdldE1pbnV0ZXMoKSwgdGhpcy5taW4uZ2V0TWludXRlcygpKSAvIHRoaXMuc3RlcDtcbiAgICB9XG4gICAgbGFzdE1pbnV0ZSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5yYW5nZSh2YWx1ZSlbMV07XG4gICAgfVxuICAgIHJhbmdlKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IFttaW4sIG1heF0gPSB0aGlzLmxpbWl0UmFuZ2UodGhpcy5taW4sIHRoaXMubWF4LCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiBbbWluLmdldE1pbnV0ZXMoKSwgbWF4LmdldE1pbnV0ZXMoKV07XG4gICAgfVxufTtcbk1pbnV0ZXNTZXJ2aWNlID0gX19kZWNvcmF0ZShbXG4gICAgSW5qZWN0YWJsZSgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbSW50bFNlcnZpY2VdKVxuXSwgTWludXRlc1NlcnZpY2UpO1xuXG5jb25zdCBTRUNPTkRTX0lOX0hPVVIgPSA2MDtcbmNvbnN0IGNsYW1wVG9SYW5nZSQyID0gKHJhbmdlVmFsdWUpID0+ICh2YWx1ZSkgPT4gdmFsdWUgJSByYW5nZVZhbHVlO1xuY29uc3QgY2xhbXAkMiA9IGNsYW1wVG9SYW5nZSQyKFNFQ09ORFNfSU5fSE9VUik7XG5jb25zdCBzdGVwcGVyJDIgPSAoc3RhcnQsIHN0ZXApID0+IChpZHgpID0+IGNsYW1wJDIoc3RhcnQgKyAoaWR4ICogc3RlcCkpO1xuY29uc3QgZGlzdGFuY2VGcm9tTWluJDIgPSAodmFsdWUsIG1pbikgPT4gY2xhbXAkMihTRUNPTkRTX0lOX0hPVVIgKyB2YWx1ZSAtIG1pbik7XG5jb25zdCBsaW1pdCQyID0gKGJvcmRlclZhbHVlKSA9PiAoYmFycmllciwgdmFsdWUpID0+IHtcbiAgICBjb25zdCB1c2VCYXJyaWVyID0gIXZhbHVlIHx8IGJhcnJpZXIuZ2V0SG91cnMoKSA9PT0gdmFsdWUuZ2V0SG91cnMoKSAmJiBiYXJyaWVyLmdldE1pbnV0ZXMoKSA9PT0gdmFsdWUuZ2V0TWludXRlcygpO1xuICAgIHJldHVybiB1c2VCYXJyaWVyID8gYmFycmllciA6IHNldFNlY29uZHMoYmFycmllciwgYm9yZGVyVmFsdWUpO1xufTtcbmNvbnN0IGxpbWl0RG93biQyID0gbGltaXQkMigwKTtcbmNvbnN0IGxpbWl0VXAkMiA9IGxpbWl0JDIoU0VDT05EU19JTl9IT1VSIC0gMSk7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xubGV0IFNlY29uZHNTZXJ2aWNlID0gY2xhc3MgU2Vjb25kc1NlcnZpY2Uge1xuICAgIGNvbnN0cnVjdG9yKGludGwpIHtcbiAgICAgICAgdGhpcy5pbnRsID0gaW50bDtcbiAgICAgICAgdGhpcy5pbnNlcnRVbmRpdmlkZWRNYXggPSBmYWxzZTtcbiAgICB9XG4gICAgYXBwbHkodmFsdWUsIGNhbmRpZGF0ZSkge1xuICAgICAgICByZXR1cm4gc2V0U2Vjb25kcyh2YWx1ZSwgY2FuZGlkYXRlLmdldFNlY29uZHMoKSk7XG4gICAgfVxuICAgIGNvbmZpZ3VyZShzZXR0aW5ncykge1xuICAgICAgICBjb25zdCB7IGluc2VydFVuZGl2aWRlZE1heCA9IHRoaXMuaW5zZXJ0VW5kaXZpZGVkTWF4LCBtaW4gPSB0aGlzLm1pbiwgbWF4ID0gdGhpcy5tYXgsIHBhcnQsIHN0ZXAgPSB0aGlzLnN0ZXAgfSA9IHNldHRpbmdzO1xuICAgICAgICB0aGlzLmluc2VydFVuZGl2aWRlZE1heCA9IGluc2VydFVuZGl2aWRlZE1heDtcbiAgICAgICAgdGhpcy50b0xpc3RJdGVtID0gKHNlY29uZCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZGF0ZSA9IHNldFNlY29uZHMoTUlETklHSFRfREFURSwgc2Vjb25kKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdGV4dDogdGhpcy5pbnRsLmZvcm1hdERhdGUoZGF0ZSwgcGFydC5wYXR0ZXJuKSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogZGF0ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5taW4gPSBtaW47XG4gICAgICAgIHRoaXMubWF4ID0gbWF4O1xuICAgICAgICB0aGlzLnN0ZXAgPSBzdGVwO1xuICAgIH1cbiAgICBkYXRhKHNlbGVjdGVkVmFsdWUpIHtcbiAgICAgICAgY29uc3QgW21pbl0gPSB0aGlzLnJhbmdlKHNlbGVjdGVkVmFsdWUpO1xuICAgICAgICBjb25zdCBnZXRTZWNvbmQgPSBzdGVwcGVyJDIobWluLCB0aGlzLnN0ZXApO1xuICAgICAgICBjb25zdCBjb252ZXJ0VG9JdGVtID0gKGlkeCkgPT4gKHRoaXMudG9MaXN0SXRlbShnZXRTZWNvbmQoaWR4KSkpO1xuICAgICAgICBjb25zdCBkYXRhID0gcmFuZ2UoMCwgdGhpcy5jb3VudEZyb21NaW4oc2VsZWN0ZWRWYWx1ZSkpLm1hcChjb252ZXJ0VG9JdGVtKTtcbiAgICAgICAgdGhpcy5hZGRMYXN0KGRhdGEpO1xuICAgICAgICB0aGlzLmFkZE1pc3NpbmcoZGF0YSwgc2VsZWN0ZWRWYWx1ZSk7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICBpc1JhbmdlQ2hhbmdlZChtaW4sIG1heCkge1xuICAgICAgICByZXR1cm4gIWlzRXF1YWwodGhpcy5taW4sIG1pbikgfHwgIWlzRXF1YWwodGhpcy5tYXgsIG1heCk7XG4gICAgfVxuICAgIGxpbWl0UmFuZ2UobWluLCBtYXgsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBbbGltaXREb3duJDIobWluLCB2YWx1ZSksIGxpbWl0VXAkMihtYXgsIHZhbHVlKV07XG4gICAgfVxuICAgIHRvdGFsKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGxhc3QkJDEgPSB0aGlzLmluc2VydFVuZGl2aWRlZE1heCAmJiB0aGlzLmlzTGFzdE1pc3NpbmcodmFsdWUpID8gMSA6IDA7XG4gICAgICAgIGNvbnN0IG1pc3NpbmcgPSB0aGlzLmlzTWlzc2luZyh2YWx1ZSkgPyAxIDogMDtcbiAgICAgICAgcmV0dXJuIHRoaXMuY291bnRGcm9tTWluKHZhbHVlKSArIG1pc3NpbmcgKyBsYXN0JCQxO1xuICAgIH1cbiAgICBzZWxlY3RlZEluZGV4KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBNYXRoLmNlaWwodGhpcy5kaXZpZGVCeVN0ZXAodmFsdWUpKTtcbiAgICB9XG4gICAgdmFsdWVJbkxpc3QodmFsdWUpIHtcbiAgICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWF0Y2hNYXggPSB0aGlzLmluc2VydFVuZGl2aWRlZE1heCAmJiB0aGlzLmxhc3RTZWNvbmQodmFsdWUpID09PSB2YWx1ZS5nZXRTZWNvbmRzKCk7XG4gICAgICAgIHJldHVybiBtYXRjaE1heCB8fCAhdGhpcy5pc01pc3NpbmcodmFsdWUpO1xuICAgIH1cbiAgICBkaXZpZGVCeVN0ZXAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGRpc3RhbmNlRnJvbU1pbiQyKHZhbHVlLmdldFNlY29uZHMoKSwgdGhpcy5taW4uZ2V0U2Vjb25kcygpKSAvIHRoaXMuc3RlcDtcbiAgICB9XG4gICAgYWRkTGFzdChkYXRhLCB2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5pbnNlcnRVbmRpdmlkZWRNYXggJiYgdGhpcy5pc0xhc3RNaXNzaW5nKHZhbHVlKSkge1xuICAgICAgICAgICAgZGF0YS5wdXNoKHRoaXMudG9MaXN0SXRlbSh0aGlzLmxhc3RTZWNvbmQodmFsdWUpKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIGFkZE1pc3NpbmcoZGF0YSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMudmFsdWVJbkxpc3QodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtaXNzaW5nSXRlbSA9IHRoaXMudG9MaXN0SXRlbSh2YWx1ZS5nZXRTZWNvbmRzKCkpO1xuICAgICAgICBkYXRhLnNwbGljZSh0aGlzLnNlbGVjdGVkSW5kZXgodmFsdWUpLCAwLCBtaXNzaW5nSXRlbSk7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICBjb3VudEZyb21NaW4odmFsdWUpIHtcbiAgICAgICAgY29uc3QgW21pbiwgbWF4XSA9IHRoaXMucmFuZ2UodmFsdWUpO1xuICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihkaXN0YW5jZUZyb21NaW4kMihtYXgsIG1pbikgLyB0aGlzLnN0ZXApICsgMTsgLyogaW5jbHVkZSBtaW4gKi9cbiAgICB9XG4gICAgaXNNaXNzaW5nKHZhbHVlKSB7XG4gICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3RlZEluZGV4KHZhbHVlKSAhPT0gdGhpcy5kaXZpZGVCeVN0ZXAodmFsdWUpO1xuICAgIH1cbiAgICBpc0xhc3RNaXNzaW5nKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzTWlzc2luZyhzZXRTZWNvbmRzKHRoaXMubWF4LCB0aGlzLmxhc3RTZWNvbmQodmFsdWUpKSk7XG4gICAgfVxuICAgIGxhc3RTZWNvbmQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmFuZ2UodmFsdWUpWzFdO1xuICAgIH1cbiAgICByYW5nZSh2YWx1ZSkge1xuICAgICAgICBjb25zdCBbbWluLCBtYXhdID0gdGhpcy5saW1pdFJhbmdlKHRoaXMubWluLCB0aGlzLm1heCwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gW21pbi5nZXRTZWNvbmRzKCksIG1heC5nZXRTZWNvbmRzKCldO1xuICAgIH1cbn07XG5TZWNvbmRzU2VydmljZSA9IF9fZGVjb3JhdGUoW1xuICAgIEluamVjdGFibGUoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0ludGxTZXJ2aWNlXSlcbl0sIFNlY29uZHNTZXJ2aWNlKTtcblxuY29uc3QgTUlMTElTRUNPTkRTX0lOX1NFQ09ORCA9IDEwMDA7XG5jb25zdCBjbGFtcFRvUmFuZ2UkMyA9IChyYW5nZVZhbHVlKSA9PiAodmFsdWUpID0+IHZhbHVlICUgcmFuZ2VWYWx1ZTtcbmNvbnN0IGNsYW1wJDMgPSBjbGFtcFRvUmFuZ2UkMyhNSUxMSVNFQ09ORFNfSU5fU0VDT05EKTtcbmNvbnN0IHN0ZXBwZXIkMyA9IChzdGFydCwgc3RlcCkgPT4gKGlkeCkgPT4gY2xhbXAkMyhzdGFydCArIChpZHggKiBzdGVwKSk7XG5jb25zdCBkaXN0YW5jZUZyb21NaW4kMyA9ICh2YWx1ZSwgbWluKSA9PiBjbGFtcCQzKE1JTExJU0VDT05EU19JTl9TRUNPTkQgKyB2YWx1ZSAtIG1pbik7XG5jb25zdCBsaW1pdCQzID0gKGJvcmRlclZhbHVlKSA9PiAoYmFycmllciwgdmFsdWUpID0+IHtcbiAgICBjb25zdCB1c2VCYXJyaWVyID0gIXZhbHVlIHx8XG4gICAgICAgIChiYXJyaWVyLmdldEhvdXJzKCkgPT09IHZhbHVlLmdldEhvdXJzKCkgJiZcbiAgICAgICAgICAgIGJhcnJpZXIuZ2V0TWludXRlcygpID09PSB2YWx1ZS5nZXRNaW51dGVzKCkgJiZcbiAgICAgICAgICAgIGJhcnJpZXIuZ2V0U2Vjb25kcygpID09PSB2YWx1ZS5nZXRTZWNvbmRzKCkpO1xuICAgIHJldHVybiB1c2VCYXJyaWVyID8gYmFycmllciA6IHNldE1pbGxpc2Vjb25kcyhiYXJyaWVyLCBib3JkZXJWYWx1ZSk7XG59O1xuY29uc3QgbGltaXREb3duJDMgPSBsaW1pdCQzKDApO1xuY29uc3QgbGltaXRVcCQzID0gbGltaXQkMyhNSUxMSVNFQ09ORFNfSU5fU0VDT05EIC0gMSk7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xubGV0IE1pbGxpc2Vjb25kc1NlcnZpY2UgPSBjbGFzcyBNaWxsaXNlY29uZHNTZXJ2aWNlIHtcbiAgICBjb25zdHJ1Y3RvcihpbnRsKSB7XG4gICAgICAgIHRoaXMuaW50bCA9IGludGw7XG4gICAgICAgIHRoaXMuaW5zZXJ0VW5kaXZpZGVkTWF4ID0gZmFsc2U7XG4gICAgfVxuICAgIGFwcGx5KHZhbHVlLCBjYW5kaWRhdGUpIHtcbiAgICAgICAgcmV0dXJuIHNldE1pbGxpc2Vjb25kcyh2YWx1ZSwgY2FuZGlkYXRlLmdldE1pbGxpc2Vjb25kcygpKTtcbiAgICB9XG4gICAgY29uZmlndXJlKHNldHRpbmdzKSB7XG4gICAgICAgIGNvbnN0IHsgaW5zZXJ0VW5kaXZpZGVkTWF4ID0gdGhpcy5pbnNlcnRVbmRpdmlkZWRNYXgsIG1pbiA9IHRoaXMubWluLCBtYXggPSB0aGlzLm1heCwgc3RlcCA9IHRoaXMuc3RlcCB9ID0gc2V0dGluZ3M7XG4gICAgICAgIHRoaXMuaW5zZXJ0VW5kaXZpZGVkTWF4ID0gaW5zZXJ0VW5kaXZpZGVkTWF4O1xuICAgICAgICB0aGlzLnRvTGlzdEl0ZW0gPSAobWlsbGlzZWNvbmQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGUgPSBzZXRNaWxsaXNlY29uZHMoTUlETklHSFRfREFURSwgbWlsbGlzZWNvbmQpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0ZXh0OiB0aGlzLmludGwuZm9ybWF0RGF0ZShkYXRlLCBcIlNTU1wiKSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogZGF0ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5taW4gPSBtaW47XG4gICAgICAgIHRoaXMubWF4ID0gbWF4O1xuICAgICAgICB0aGlzLnN0ZXAgPSBzdGVwO1xuICAgIH1cbiAgICBkYXRhKHNlbGVjdGVkVmFsdWUpIHtcbiAgICAgICAgY29uc3QgW21pbl0gPSB0aGlzLnJhbmdlKHNlbGVjdGVkVmFsdWUpO1xuICAgICAgICBjb25zdCBnZXRNaWxsaXNlY29uZCA9IHN0ZXBwZXIkMyhtaW4sIHRoaXMuc3RlcCk7XG4gICAgICAgIGNvbnN0IGNvbnZlcnRUb0l0ZW0gPSAoaWR4KSA9PiAodGhpcy50b0xpc3RJdGVtKGdldE1pbGxpc2Vjb25kKGlkeCkpKTtcbiAgICAgICAgY29uc3QgZGF0YSA9IHJhbmdlKDAsIHRoaXMuY291bnRGcm9tTWluKHNlbGVjdGVkVmFsdWUpKS5tYXAoY29udmVydFRvSXRlbSk7XG4gICAgICAgIHRoaXMuYWRkTGFzdChkYXRhKTtcbiAgICAgICAgdGhpcy5hZGRNaXNzaW5nKGRhdGEsIHNlbGVjdGVkVmFsdWUpO1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgaXNSYW5nZUNoYW5nZWQobWluLCBtYXgpIHtcbiAgICAgICAgcmV0dXJuICFpc0VxdWFsKHRoaXMubWluLCBtaW4pIHx8ICFpc0VxdWFsKHRoaXMubWF4LCBtYXgpO1xuICAgIH1cbiAgICBsaW1pdFJhbmdlKG1pbiwgbWF4LCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gW2xpbWl0RG93biQzKG1pbiwgdmFsdWUpLCBsaW1pdFVwJDMobWF4LCB2YWx1ZSldO1xuICAgIH1cbiAgICB0b3RhbCh2YWx1ZSkge1xuICAgICAgICBjb25zdCBsYXN0JCQxID0gdGhpcy5pbnNlcnRVbmRpdmlkZWRNYXggJiYgdGhpcy5pc0xhc3RNaXNzaW5nKHZhbHVlKSA/IDEgOiAwO1xuICAgICAgICBjb25zdCBtaXNzaW5nID0gdGhpcy5pc01pc3NpbmcodmFsdWUpID8gMSA6IDA7XG4gICAgICAgIHJldHVybiB0aGlzLmNvdW50RnJvbU1pbih2YWx1ZSkgKyBtaXNzaW5nICsgbGFzdCQkMTtcbiAgICB9XG4gICAgc2VsZWN0ZWRJbmRleCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gTWF0aC5jZWlsKHRoaXMuZGl2aWRlQnlTdGVwKHZhbHVlKSk7XG4gICAgfVxuICAgIHZhbHVlSW5MaXN0KHZhbHVlKSB7XG4gICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1hdGNoTWF4ID0gdGhpcy5pbnNlcnRVbmRpdmlkZWRNYXggJiYgdGhpcy5sYXN0TWlsbGlzZWNvbmQodmFsdWUpID09PSB2YWx1ZS5nZXRNaWxsaXNlY29uZHMoKTtcbiAgICAgICAgcmV0dXJuIG1hdGNoTWF4IHx8ICF0aGlzLmlzTWlzc2luZyh2YWx1ZSk7XG4gICAgfVxuICAgIGRpdmlkZUJ5U3RlcCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gZGlzdGFuY2VGcm9tTWluJDModmFsdWUuZ2V0TWlsbGlzZWNvbmRzKCksIHRoaXMubWluLmdldE1pbGxpc2Vjb25kcygpKSAvIHRoaXMuc3RlcDtcbiAgICB9XG4gICAgYWRkTGFzdChkYXRhLCB2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5pbnNlcnRVbmRpdmlkZWRNYXggJiYgdGhpcy5pc0xhc3RNaXNzaW5nKHZhbHVlKSkge1xuICAgICAgICAgICAgZGF0YS5wdXNoKHRoaXMudG9MaXN0SXRlbSh0aGlzLmxhc3RNaWxsaXNlY29uZCh2YWx1ZSkpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgYWRkTWlzc2luZyhkYXRhLCB2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy52YWx1ZUluTGlzdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1pc3NpbmdJdGVtID0gdGhpcy50b0xpc3RJdGVtKHZhbHVlLmdldE1pbGxpc2Vjb25kcygpKTtcbiAgICAgICAgZGF0YS5zcGxpY2UodGhpcy5zZWxlY3RlZEluZGV4KHZhbHVlKSwgMCwgbWlzc2luZ0l0ZW0pO1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgY291bnRGcm9tTWluKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IFttaW4sIG1heF0gPSB0aGlzLnJhbmdlKHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IoZGlzdGFuY2VGcm9tTWluJDMobWF4LCBtaW4pIC8gdGhpcy5zdGVwKSArIDE7IC8qIGluY2x1ZGUgbWluICovXG4gICAgfVxuICAgIGlzTWlzc2luZyh2YWx1ZSkge1xuICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0ZWRJbmRleCh2YWx1ZSkgIT09IHRoaXMuZGl2aWRlQnlTdGVwKHZhbHVlKTtcbiAgICB9XG4gICAgaXNMYXN0TWlzc2luZyh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc01pc3Npbmcoc2V0TWlsbGlzZWNvbmRzKHRoaXMubWF4LCB0aGlzLmxhc3RNaWxsaXNlY29uZCh2YWx1ZSkpKTtcbiAgICB9XG4gICAgbGFzdE1pbGxpc2Vjb25kKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJhbmdlKHZhbHVlKVsxXTtcbiAgICB9XG4gICAgcmFuZ2UodmFsdWUpIHtcbiAgICAgICAgY29uc3QgW21pbiwgbWF4XSA9IHRoaXMubGltaXRSYW5nZSh0aGlzLm1pbiwgdGhpcy5tYXgsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIFttaW4uZ2V0TWlsbGlzZWNvbmRzKCksIG1heC5nZXRNaWxsaXNlY29uZHMoKV07XG4gICAgfVxufTtcbk1pbGxpc2Vjb25kc1NlcnZpY2UgPSBfX2RlY29yYXRlKFtcbiAgICBJbmplY3RhYmxlKCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtJbnRsU2VydmljZV0pXG5dLCBNaWxsaXNlY29uZHNTZXJ2aWNlKTtcblxuY29uc3Qgc2V0SG91cnMkMSA9IChkYXRlLCBob3VycykgPT4ge1xuICAgIGNvbnN0IGNsb25lID0gY2xvbmVEYXRlKGRhdGUpO1xuICAgIGNsb25lLnNldEhvdXJzKGhvdXJzKTtcbiAgICByZXR1cm4gY2xvbmU7XG59O1xuY29uc3QgaXNBTSA9ICh2YWx1ZSkgPT4gdmFsdWUgIT09IG51bGwgJiYgdmFsdWUgPCAxMjtcbmNvbnN0IGlzUE0gPSAodmFsdWUpID0+IHZhbHVlICE9PSBudWxsICYmICghdmFsdWUgfHwgdmFsdWUgPiAxMSk7XG5jb25zdCBpblJhbmdlID0gKHZhbHVlLCBtaW4sIG1heCkgPT4gKCghbWluICYmICFtYXgpIHx8ICh2YWx1ZSA+PSBtaW4gJiYgdmFsdWUgPD0gbWF4KSk7XG5jb25zdCBpblJldmVyc2VSYW5nZSA9ICh2YWx1ZSwgbWluLCBtYXgpID0+ICgoIW1pbiAmJiAhbWF4KSB8fCB2YWx1ZSA+PSBtaW4gfHwgdmFsdWUgPD0gbWF4KTtcbi8qKlxuICogQGhpZGRlblxuICovXG5sZXQgRGF5UGVyaW9kU2VydmljZSA9IGNsYXNzIERheVBlcmlvZFNlcnZpY2Uge1xuICAgIGNvbnN0cnVjdG9yKGludGwpIHtcbiAgICAgICAgdGhpcy5pbnRsID0gaW50bDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGFwcGx5KHZhbHVlLCBjYW5kaWRhdGUpIHtcbiAgICAgICAgY29uc3QgaG91ciA9IHZhbHVlLmdldEhvdXJzKCk7XG4gICAgICAgIGNvbnN0IGhvdXJBTSA9IGlzQU0oaG91cik7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZUFNID0gaXNBTShjYW5kaWRhdGUuZ2V0SG91cnMoKSk7XG4gICAgICAgIGlmICgoaG91ckFNICYmIGNhbmRpZGF0ZUFNKSB8fCAoIWhvdXJBTSAmJiAhY2FuZGlkYXRlQU0pKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgW21pbiwgbWF4ID0gMjRdID0gdGhpcy5ub3JtYWxpemVkUmFuZ2UoKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gaG91ciArIChjYW5kaWRhdGVBTSA/IC0xMiA6IDEyKTtcbiAgICAgICAgcmV0dXJuIHNldEhvdXJzJDEodmFsdWUsIE1hdGgubWluKE1hdGgubWF4KG1pbiwgcmVzdWx0KSwgKG1heCB8fCAyNCkpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGNvbmZpZ3VyZShzZXR0aW5ncykge1xuICAgICAgICBjb25zdCB7IG1pbiA9IHRoaXMubWluLCBtYXggPSB0aGlzLm1heCwgcGFydCA9IHRoaXMucGFydCB9ID0gc2V0dGluZ3M7XG4gICAgICAgIHRoaXMubWluID0gbWluO1xuICAgICAgICB0aGlzLm1heCA9IG1heDtcbiAgICAgICAgdGhpcy5wYXJ0ID0gcGFydDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGRhdGEoXykge1xuICAgICAgICBjb25zdCBuYW1lcyA9IHRoaXMucGFydC5uYW1lcztcbiAgICAgICAgaWYgKCFuYW1lcykge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRhdGEgPSBbXTtcbiAgICAgICAgY29uc3QgW21pbiwgbWF4XSA9IHRoaXMubm9ybWFsaXplZFJhbmdlKCk7XG4gICAgICAgIGNvbnN0IGRheVBlcmlvZCA9IHRoaXMuaW50bC5kYXRlRm9ybWF0TmFtZXMobmFtZXMpO1xuICAgICAgICBpZiAoaXNBTShtaW4pKSB7XG4gICAgICAgICAgICBkYXRhLnB1c2goeyB0ZXh0OiBkYXlQZXJpb2QuYW0sIHZhbHVlOiBzZXRIb3VycyQxKHRoaXMubWluLCBtaW4pIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1BNKG1heCkpIHtcbiAgICAgICAgICAgIGRhdGEucHVzaCh7IHRleHQ6IGRheVBlcmlvZC5wbSwgdmFsdWU6IHNldEhvdXJzJDEodGhpcy5taW4sIE1hdGgubWF4KDEyLCBtYXgpKSB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5taW4uZ2V0SG91cnMoKSAhPT0gbWluID8gZGF0YS5yZXZlcnNlKCkgOiBkYXRhO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgaXNSYW5nZUNoYW5nZWQoXywgX18pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgbGltaXRSYW5nZShtaW4sIG1heCwgXykge1xuICAgICAgICByZXR1cm4gW21pbiwgbWF4XTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHRvdGFsKCkge1xuICAgICAgICBjb25zdCBbbWluLCBtYXhdID0gdGhpcy5ub3JtYWxpemVkUmFuZ2UoKTtcbiAgICAgICAgaWYgKCFtaW4gJiYgIW1heCkge1xuICAgICAgICAgICAgcmV0dXJuIDI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1pbiA+IDExIHx8IG1heCA8IDEyKSB7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHNlbGVjdGVkSW5kZXgodmFsdWUpIHtcbiAgICAgICAgaWYgKCF0aGlzLnZhbHVlSW5MaXN0KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGluZGV4ID0gTWF0aC5mbG9vcih2YWx1ZS5nZXRIb3VycygpIC8gMTIpO1xuICAgICAgICByZXR1cm4gdGhpcy5taW4uZ2V0SG91cnMoKSA9PT0gdGhpcy5ub3JtYWxpemVkUmFuZ2UoKVswXSA/IGluZGV4IDogKGluZGV4ID09PSAwID8gMSA6IDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgdmFsdWVJbkxpc3QodmFsdWUpIHtcbiAgICAgICAgY29uc3QgcmV2ZXJzZSA9IHRoaXMubWluLmdldEhvdXJzKCkgIT09IHRoaXMubm9ybWFsaXplZFJhbmdlKClbMF07XG4gICAgICAgIGNvbnN0IGlzSW5SYW5nZSA9IHJldmVyc2UgPyBpblJldmVyc2VSYW5nZSA6IGluUmFuZ2U7XG4gICAgICAgIHJldHVybiBpc0luUmFuZ2UodmFsdWUuZ2V0SG91cnMoKSwgdGhpcy5taW4uZ2V0SG91cnMoKSwgdGhpcy5tYXguZ2V0SG91cnMoKSk7XG4gICAgfVxuICAgIG5vcm1hbGl6ZWRSYW5nZSgpIHtcbiAgICAgICAgY29uc3QgbWluSG91ciA9IHRoaXMubWluLmdldEhvdXJzKCk7XG4gICAgICAgIGNvbnN0IG1heEhvdXIgPSB0aGlzLm1heC5nZXRIb3VycygpO1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgTWF0aC5taW4obWluSG91ciwgbWF4SG91ciksXG4gICAgICAgICAgICBNYXRoLm1heChtaW5Ib3VyLCBtYXhIb3VyKVxuICAgICAgICBdO1xuICAgIH1cbn07XG5EYXlQZXJpb2RTZXJ2aWNlID0gX19kZWNvcmF0ZShbXG4gICAgSW5qZWN0YWJsZSgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbSW50bFNlcnZpY2VdKVxuXSwgRGF5UGVyaW9kU2VydmljZSk7XG5cbmNvbnN0IFNOQVBfVEhSRVNIT0xEID0gMC4wNTsgLy8lIG9mIHRoZSBpdGVtIGhlaWdodFxuY29uc3QgU0NST0xMX1RIUkVTSE9MRCA9IDI7IC8vPCAycHggdGhyZXNob2xkXG5jb25zdCBuaWwgPSAoKSA9PiAobnVsbCk7XG5jb25zdCBnZXR0ZXJzID0ge1xuICAgIDM1OiAoZGF0YSwgXykgPT4gZGF0YVtkYXRhLmxlbmd0aCAtIDFdLFxuICAgIDM2OiAoZGF0YSwgXykgPT4gZGF0YVswXSxcbiAgICAzODogKGRhdGEsIGluZGV4KSA9PiBkYXRhW2luZGV4IC0gMV0sXG4gICAgNDA6IChkYXRhLCBpbmRleCkgPT4gZGF0YVtpbmRleCArIDFdXG59O1xuY29uc3Qgc2VydmljZXMkMSA9IHtcbiAgICBbVElNRV9QQVJULmRheXBlcmlvZF06IERheVBlcmlvZFNlcnZpY2UsXG4gICAgW1RJTUVfUEFSVC5ob3VyXTogSG91cnNTZXJ2aWNlLFxuICAgIFtUSU1FX1BBUlQubWludXRlXTogTWludXRlc1NlcnZpY2UsXG4gICAgW1RJTUVfUEFSVC5zZWNvbmRdOiBTZWNvbmRzU2VydmljZSxcbiAgICBbVElNRV9QQVJULm1pbGxpc2Vjb25kXTogTWlsbGlzZWNvbmRzU2VydmljZVxufTtcbi8qKlxuICogQGhpZGRlblxuICovXG5sZXQgVGltZUxpc3RDb21wb25lbnQgPSBjbGFzcyBUaW1lTGlzdENvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoZWxlbWVudCwgaW5qZWN0b3IsIGRvbSwgcmVuZGVyZXIsIHpvbmUpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICAgICAgdGhpcy5pbmplY3RvciA9IGluamVjdG9yO1xuICAgICAgICB0aGlzLmRvbSA9IGRvbTtcbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgICAgICB0aGlzLnpvbmUgPSB6b25lO1xuICAgICAgICB0aGlzLm1pbiA9IGNsb25lRGF0ZShNSUROSUdIVF9EQVRFKTtcbiAgICAgICAgdGhpcy5tYXggPSBjbG9uZURhdGUoTUFYX1RJTUUpO1xuICAgICAgICB0aGlzLnN0ZXAgPSAxO1xuICAgICAgICB0aGlzLmRpc2FibGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMudmFsdWVDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50Q2xhc3MgPSB0cnVlO1xuICAgICAgICB0aGlzLmFuaW1hdGVUb0luZGV4ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5pc0FjdGl2ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnNraXAgPSAwO1xuICAgICAgICB0aGlzLnRvdGFsID0gNjA7XG4gICAgICAgIHRoaXMuZGF0YSA9IFtdO1xuICAgICAgICB0aGlzLmluZGV4VG9TY3JvbGwgPSAtMTtcbiAgICAgICAgdGhpcy5kb21FdmVudHMgPSBbXTtcbiAgICB9XG4gICAgZ2V0IHRhYkluZGV4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kaXNhYmxlZCA/IHVuZGVmaW5lZCA6IDA7XG4gICAgfVxuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXMpIHtcbiAgICAgICAgaWYgKGNoYW5nZXMucGFydCkge1xuICAgICAgICAgICAgdGhpcy5zZXJ2aWNlID0gdGhpcy5pbmplY3Rvci5nZXQoc2VydmljZXMkMVt0aGlzLnBhcnQudHlwZV0pO1xuICAgICAgICAgICAgdGhpcy5zZXJ2aWNlLmNvbmZpZ3VyZSh0aGlzLnNlcnZpY2VTZXR0aW5ncygpKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMudmFsdWU7XG4gICAgICAgIGNvbnN0IHZhbHVlQ2hhbmdlcyA9IGNoYW5nZXMudmFsdWUgfHwge307XG4gICAgICAgIGNvbnN0IFttaW4sIG1heF0gPSB0aGlzLnNlcnZpY2UubGltaXRSYW5nZSh0aGlzLm1pbiwgdGhpcy5tYXgsIHZhbHVlKTtcbiAgICAgICAgaWYgKHRoaXMuc2VydmljZS5pc1JhbmdlQ2hhbmdlZChtaW4sIG1heCkgfHwgY2hhbmdlcy5taW4gfHwgY2hhbmdlcy5tYXggfHwgY2hhbmdlcy5zdGVwKSB7XG4gICAgICAgICAgICB0aGlzLmRhdGEgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuc2VydmljZS5jb25maWd1cmUodGhpcy5zZXJ2aWNlU2V0dGluZ3MoeyBtaW4sIG1heCB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2tpcCB0aGUgcmVuZGVyaW5nIG9mIHRoZSBsaXN0IHdoZW5ldmVyIHBvc3NpYmxlXG4gICAgICAgIGlmICghdGhpcy5kYXRhLmxlbmd0aCB8fCB0aGlzLmhhc01pc3NpbmdWYWx1ZSh2YWx1ZUNoYW5nZXMpKSB7XG4gICAgICAgICAgICB0aGlzLmFuaW1hdGVUb0luZGV4ID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmRhdGEgPSB0aGlzLnNlcnZpY2UuZGF0YSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hbmltYXRlVG9JbmRleCA9IHRoaXMuYW5pbWF0ZVRvSW5kZXggJiYgdGhpcy50ZXh0SGFzQ2hhbmdlZCh2YWx1ZUNoYW5nZXMpO1xuICAgICAgICB0aGlzLnRvdGFsID0gdGhpcy5zZXJ2aWNlLnRvdGFsKHZhbHVlKTtcbiAgICAgICAgdGhpcy5pbmRleFRvU2Nyb2xsID0gdGhpcy5zZWxlY3RlZEluZGV4KHZhbHVlKTtcbiAgICB9XG4gICAgbmdPbkluaXQoKSB7XG4gICAgICAgIHRoaXMuYW5pbWF0ZVRvSW5kZXggPSB0cnVlO1xuICAgICAgICB0aGlzLmRvbS5lbnN1cmVIZWlnaHRzKCk7XG4gICAgICAgIHRoaXMuaXRlbUhlaWdodCA9IHRoaXMuZG9tLml0ZW1IZWlnaHQ7XG4gICAgICAgIHRoaXMubGlzdEhlaWdodCA9IHRoaXMuZG9tLnRpbWVMaXN0SGVpZ2h0O1xuICAgICAgICB0aGlzLnRvcE9mZnNldCA9ICh0aGlzLmxpc3RIZWlnaHQgLSB0aGlzLml0ZW1IZWlnaHQpIC8gMjtcbiAgICAgICAgdGhpcy5ib3R0b21PZmZzZXQgPSB0aGlzLmxpc3RIZWlnaHQgLSB0aGlzLml0ZW1IZWlnaHQ7XG4gICAgICAgIHRoaXMudG9wVGhyZXNob2xkID0gdGhpcy5pdGVtSGVpZ2h0ICogU05BUF9USFJFU0hPTEQ7XG4gICAgICAgIHRoaXMuYm90dG9tVGhyZXNob2xkID0gdGhpcy5pdGVtSGVpZ2h0ICogKDEgLSBTTkFQX1RIUkVTSE9MRCk7XG4gICAgICAgIGNvbnN0IHRyYW5zbGF0ZSA9IGB0cmFuc2xhdGVZKCR7dGhpcy50b3BPZmZzZXR9cHgpYDtcbiAgICAgICAgdGhpcy5zdHlsZSA9IHsgdHJhbnNmb3JtOiB0cmFuc2xhdGUsICctbXMtdHJhbnNmb3JtJzogdHJhbnNsYXRlIH07XG4gICAgICAgIGlmICh0aGlzLmVsZW1lbnQpIHtcbiAgICAgICAgICAgIHRoaXMuem9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5iaW5kRXZlbnRzKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5zY3JvbGxTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgdGhpcy5kb21FdmVudHMuZm9yRWFjaCh1bmJpbmRDYWxsYmFjayA9PiB1bmJpbmRDYWxsYmFjaygpKTtcbiAgICB9XG4gICAgbmdBZnRlclZpZXdJbml0KCkge1xuICAgICAgICB0aGlzLnNjcm9sbE9uY2UoKGluZGV4KSA9PiB0aGlzLnZpcnR1YWxpemF0aW9uLnNjcm9sbFRvSW5kZXgoaW5kZXgpKTtcbiAgICB9XG4gICAgbmdBZnRlclZpZXdDaGVja2VkKCkge1xuICAgICAgICB0aGlzLnNjcm9sbE9uY2UoKGluZGV4KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBhY3Rpb24gPSB0aGlzLmFuaW1hdGVUb0luZGV4ID8gJ2FuaW1hdGVUb0luZGV4JyA6ICdzY3JvbGxUb0luZGV4JztcbiAgICAgICAgICAgIHRoaXMudmlydHVhbGl6YXRpb25bYWN0aW9uXShpbmRleCk7XG4gICAgICAgICAgICB0aGlzLmFuaW1hdGVUb0luZGV4ID0gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGhhbmRsZUNoYW5nZShkYXRhSXRlbSkge1xuICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSB0aGlzLnNlcnZpY2UuYXBwbHkodGhpcy52YWx1ZSwgZGF0YUl0ZW0udmFsdWUpO1xuICAgICAgICBpZiAodGhpcy52YWx1ZS5nZXRUaW1lKCkgPT09IGNhbmRpZGF0ZS5nZXRUaW1lKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmluZGV4VG9TY3JvbGwgPSB0aGlzLmRhdGEuaW5kZXhPZihkYXRhSXRlbSk7XG4gICAgICAgIHRoaXMudmFsdWUgPSBjYW5kaWRhdGU7XG4gICAgICAgIHRoaXMudmFsdWVDaGFuZ2UuZW1pdChjYW5kaWRhdGUpO1xuICAgIH1cbiAgICBoYW5kbGVJdGVtQ2xpY2soYXJncykge1xuICAgICAgICBjb25zdCBpdGVtID0gY2xvc2VzdEluU2NvcGUoYXJncy50YXJnZXQsIG5vZGUgPT4gbm9kZS5oYXNBdHRyaWJ1dGUoJ2RhdGEtdGltZWxpc3QtaXRlbS1pbmRleCcpLCB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudCk7XG4gICAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IGl0ZW0uZ2V0QXR0cmlidXRlKCdkYXRhLXRpbWVsaXN0LWl0ZW0taW5kZXgnKTtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlQ2hhbmdlKHRoaXMuZGF0YVtpbmRleF0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZvY3VzZXMgdGhlIGhvc3QgZWxlbWVudCBvZiB0aGUgVGltZUxpc3QuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHRzXG4gICAgICogX0BDb21wb25lbnQoe1xuICAgICAqIHNlbGVjdG9yOiAnbXktYXBwJyxcbiAgICAgKiB0ZW1wbGF0ZTogYFxuICAgICAqICA8YnV0dG9uIChjbGljayk9XCJ0aW1lbGlzdC5mb2N1cygpXCI+Rm9jdXMgVGltZUxpc3Q8L2J1dHRvbj5cbiAgICAgKiAgPGtlbmRvLXRpbWVsaXN0ICN0aW1lbGlzdD48L2tlbmRvLXRpbWVsaXN0PlxuICAgICAqIGBcbiAgICAgKiB9KVxuICAgICAqIGV4cG9ydCBjbGFzcyBBcHBDb21wb25lbnQgeyB9XG4gICAgICogYGBgXG4gICAgICovXG4gICAgZm9jdXMoKSB7XG4gICAgICAgIGlmICghdGhpcy5lbGVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQuZm9jdXMoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQmx1cnMgdGhlIFRpbWVMaXN0IGNvbXBvbmVudC5cbiAgICAgKi9cbiAgICBibHVyKCkge1xuICAgICAgICBpZiAoIXRoaXMuZWxlbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LmJsdXIoKTtcbiAgICB9XG4gICAgaXRlbU9mZnNldChzY3JvbGxUb3ApIHtcbiAgICAgICAgY29uc3QgdmFsdWVJbmRleCA9IHRoaXMuc2VsZWN0ZWRJbmRleCh0aGlzLnZhbHVlKTtcbiAgICAgICAgY29uc3QgYWN0aXZlSW5kZXggPSB0aGlzLnZpcnR1YWxpemF0aW9uLmFjdGl2ZUluZGV4KCk7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IHRoaXMudmlydHVhbGl6YXRpb24uaXRlbU9mZnNldChhY3RpdmVJbmRleCk7XG4gICAgICAgIGNvbnN0IGRpc3RhbmNlID0gTWF0aC5hYnMoTWF0aC5jZWlsKHNjcm9sbFRvcCkgLSBvZmZzZXQpO1xuICAgICAgICBpZiAodmFsdWVJbmRleCA9PT0gYWN0aXZlSW5kZXggJiYgZGlzdGFuY2UgPCBTQ1JPTExfVEhSRVNIT0xEKSB7XG4gICAgICAgICAgICByZXR1cm4gb2Zmc2V0O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNjcm9sbFVwID0gdmFsdWVJbmRleCA+IGFjdGl2ZUluZGV4O1xuICAgICAgICBjb25zdCBtb3ZlVG9OZXh0ID0gc2Nyb2xsVXAgJiYgZGlzdGFuY2UgPj0gdGhpcy5ib3R0b21UaHJlc2hvbGQgfHwgIXNjcm9sbFVwICYmIGRpc3RhbmNlID4gdGhpcy50b3BUaHJlc2hvbGQ7XG4gICAgICAgIHJldHVybiBtb3ZlVG9OZXh0ID8gdGhpcy52aXJ0dWFsaXphdGlvbi5pdGVtT2Zmc2V0KGFjdGl2ZUluZGV4ICsgMSkgOiBvZmZzZXQ7XG4gICAgfVxuICAgIGhhc01pc3NpbmdWYWx1ZSh7IHByZXZpb3VzVmFsdWUsIGN1cnJlbnRWYWx1ZSB9KSB7XG4gICAgICAgIGNvbnN0IGlzUHJldmlvdXNNaXNzaW5nID0gcHJldmlvdXNWYWx1ZSAmJiAhdGhpcy5zZXJ2aWNlLnZhbHVlSW5MaXN0KHByZXZpb3VzVmFsdWUpO1xuICAgICAgICBjb25zdCBpc0N1cnJlbnRNaXNzaW5nID0gY3VycmVudFZhbHVlICYmICF0aGlzLnNlcnZpY2UudmFsdWVJbkxpc3QoY3VycmVudFZhbHVlKTtcbiAgICAgICAgcmV0dXJuIGlzUHJldmlvdXNNaXNzaW5nIHx8IGlzQ3VycmVudE1pc3Npbmc7XG4gICAgfVxuICAgIHNjcm9sbE9uY2UoYWN0aW9uKSB7XG4gICAgICAgIGlmICh0aGlzLmluZGV4VG9TY3JvbGwgIT09IC0xKSB7XG4gICAgICAgICAgICBhY3Rpb24odGhpcy5pbmRleFRvU2Nyb2xsKTtcbiAgICAgICAgICAgIHRoaXMuaW5kZXhUb1Njcm9sbCA9IC0xO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNlcnZpY2VTZXR0aW5ncyhzZXR0aW5ncykge1xuICAgICAgICBjb25zdCBkZWZhdWx0cyA9IHtcbiAgICAgICAgICAgIGJvdW5kUmFuZ2U6IGZhbHNlLFxuICAgICAgICAgICAgaW5zZXJ0VW5kaXZpZGVkTWF4OiBmYWxzZSxcbiAgICAgICAgICAgIG1heDogdGhpcy5tYXgsXG4gICAgICAgICAgICBtaW46IHRoaXMubWluLFxuICAgICAgICAgICAgcGFydDogdGhpcy5wYXJ0LFxuICAgICAgICAgICAgc3RlcDogdGhpcy5zdGVwXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRzLCBzZXR0aW5ncyk7XG4gICAgICAgIHJlc3VsdC5ib3VuZFJhbmdlID0gcmVzdWx0LnBhcnQudHlwZSAhPT0gJ2hvdXInO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBzZWxlY3RlZEluZGV4KHZhbHVlKSB7XG4gICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5zZXJ2aWNlLnNlbGVjdGVkSW5kZXgodmFsdWUpO1xuICAgIH1cbiAgICB0ZXh0SGFzQ2hhbmdlZCh7IHByZXZpb3VzVmFsdWUsIGN1cnJlbnRWYWx1ZSB9KSB7XG4gICAgICAgIGlmICghcHJldmlvdXNWYWx1ZSB8fCAhY3VycmVudFZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb2xkRGF0YSA9IHRoaXMuZGF0YVt0aGlzLnNlbGVjdGVkSW5kZXgocHJldmlvdXNWYWx1ZSldO1xuICAgICAgICBjb25zdCBuZXdEYXRhID0gdGhpcy5kYXRhW3RoaXMuc2VsZWN0ZWRJbmRleChjdXJyZW50VmFsdWUpXTtcbiAgICAgICAgcmV0dXJuIG9sZERhdGEgJiYgbmV3RGF0YSAmJiBvbGREYXRhLnRleHQgIT09IG5ld0RhdGEudGV4dDtcbiAgICB9XG4gICAgaGFuZGxlS2V5RG93bihlKSB7XG4gICAgICAgIGNvbnN0IGdldHRlciA9IGdldHRlcnNbZS5rZXlDb2RlXSB8fCBuaWw7XG4gICAgICAgIGNvbnN0IGRhdGFJdGVtID0gZ2V0dGVyKHRoaXMuZGF0YSwgdGhpcy5zZXJ2aWNlLnNlbGVjdGVkSW5kZXgodGhpcy52YWx1ZSkpO1xuICAgICAgICBpZiAoZGF0YUl0ZW0pIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlQ2hhbmdlKGRhdGFJdGVtKTtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBiaW5kRXZlbnRzKCkge1xuICAgICAgICB0aGlzLnNjcm9sbFN1YnNjcmlwdGlvbiA9IHRoaXMudmlydHVhbGl6YXRpb25cbiAgICAgICAgICAgIC5zY3JvbGwkKClcbiAgICAgICAgICAgIC5waXBlKGRlYm91bmNlVGltZSgxMDApLCBtYXAoKGUpID0+IGUudGFyZ2V0LnNjcm9sbFRvcCksIG1hcCgodG9wKSA9PiB0aGlzLml0ZW1PZmZzZXQodG9wKSksIG1hcCgoaXRlbU9mZnNldCkgPT4gdGhpcy52aXJ0dWFsaXphdGlvbi5pdGVtSW5kZXgoaXRlbU9mZnNldCkpKVxuICAgICAgICAgICAgLnN1YnNjcmliZShpbmRleCA9PiB7XG4gICAgICAgICAgICB0aGlzLnZpcnR1YWxpemF0aW9uLnNjcm9sbFRvSW5kZXgoaW5kZXgpO1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVDaGFuZ2UodGhpcy5kYXRhW2luZGV4XSk7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgIHRoaXMuZG9tRXZlbnRzLnB1c2godGhpcy5yZW5kZXJlci5saXN0ZW4oZWxlbWVudCwgJ21vdXNlb3ZlcicsICgpID0+ICF0aGlzLmlzQWN0aXZlICYmIHRoaXMuZm9jdXMoKSksIHRoaXMucmVuZGVyZXIubGlzdGVuKGVsZW1lbnQsICdjbGljaycsICgpID0+IHRoaXMuZm9jdXMoKSksIHRoaXMucmVuZGVyZXIubGlzdGVuKGVsZW1lbnQsICdibHVyJywgKCkgPT4gdGhpcy5pc0FjdGl2ZSA9IGZhbHNlKSwgdGhpcy5yZW5kZXJlci5saXN0ZW4oZWxlbWVudCwgJ2ZvY3VzJywgKCkgPT4gdGhpcy5pc0FjdGl2ZSA9IHRydWUpLCB0aGlzLnJlbmRlcmVyLmxpc3RlbihlbGVtZW50LCAna2V5ZG93bicsIHRoaXMuaGFuZGxlS2V5RG93bi5iaW5kKHRoaXMpKSk7XG4gICAgfVxufTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIERhdGUpXG5dLCBUaW1lTGlzdENvbXBvbmVudC5wcm90b3R5cGUsIFwibWluXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBEYXRlKVxuXSwgVGltZUxpc3RDb21wb25lbnQucHJvdG90eXBlLCBcIm1heFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgVGltZUxpc3RDb21wb25lbnQucHJvdG90eXBlLCBcInBhcnRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIFRpbWVMaXN0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJzdGVwXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgVGltZUxpc3RDb21wb25lbnQucHJvdG90eXBlLCBcImRpc2FibGVkXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBEYXRlKVxuXSwgVGltZUxpc3RDb21wb25lbnQucHJvdG90eXBlLCBcInZhbHVlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBPdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxuXSwgVGltZUxpc3RDb21wb25lbnQucHJvdG90eXBlLCBcInZhbHVlQ2hhbmdlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBWaWV3Q2hpbGQoVmlydHVhbGl6YXRpb25Db21wb25lbnQsIHsgc3RhdGljOiB0cnVlIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBWaXJ0dWFsaXphdGlvbkNvbXBvbmVudClcbl0sIFRpbWVMaXN0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJ2aXJ0dWFsaXphdGlvblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSG9zdEJpbmRpbmcoXCJhdHRyLnRhYmluZGV4XCIpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIFRpbWVMaXN0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJ0YWJJbmRleFwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RCaW5kaW5nKFwiY2xhc3Muay10aW1lLWxpc3RcIiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBUaW1lTGlzdENvbXBvbmVudC5wcm90b3R5cGUsIFwiY29tcG9uZW50Q2xhc3NcIiwgdm9pZCAwKTtcblRpbWVMaXN0Q29tcG9uZW50ID0gX19kZWNvcmF0ZShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgc2VsZWN0b3I6ICdrZW5kby10aW1lbGlzdCcsXG4gICAgICAgIHRlbXBsYXRlOiBgXG4gICAgPGtlbmRvLXZpcnR1YWxpemF0aW9uXG4gICAgICAgIFtza2lwXT1cInNraXBcIlxuICAgICAgICBbdGFrZV09XCJ0b3RhbFwiXG4gICAgICAgIFt0b3RhbF09XCJ0b3RhbFwiXG4gICAgICAgIFtpdGVtSGVpZ2h0XT1cIml0ZW1IZWlnaHRcIlxuICAgICAgICBbbWF4U2Nyb2xsRGlmZmVyZW5jZV09XCJsaXN0SGVpZ2h0XCJcbiAgICAgICAgW3RvcE9mZnNldF09XCJ0b3BPZmZzZXRcIlxuICAgICAgICBbYm90dG9tT2Zmc2V0XT1cImJvdHRvbU9mZnNldFwiXG4gICAgICAgIGNsYXNzPVwiay10aW1lLWNvbnRhaW5lclwiXG4gICAgICAgIHJvbGU9XCJwcmVzZW50YXRpb25cIlxuICAgICAgICB0YWJpbmRleD1cIi0xXCJcbiAgICA+XG4gICAgICAgIDx1bCBbbmdTdHlsZV09XCJzdHlsZVwiIGNsYXNzPVwiay1yZXNldFwiXG4gICAgICAgICAgICBba2VuZG9FdmVudHNPdXRzaWRlQW5ndWxhcl09XCJ7XG4gICAgICAgICAgICAgICAgY2xpY2s6IGhhbmRsZUl0ZW1DbGlja1xuICAgICAgICAgICAgfVwiXG4gICAgICAgICAgICBbc2NvcGVdPVwidGhpc1wiXG4gICAgICAgID5cbiAgICAgICAgICAgIDxsaSAqbmdGb3I9XCJsZXQgaXRlbSBvZiBkYXRhOyBsZXQgaW5kZXggPSBpbmRleDtcIiBjbGFzcz1cImstaXRlbVwiXG4gICAgICAgICAgICAgICAgW2F0dHIuZGF0YS10aW1lbGlzdC1pdGVtLWluZGV4XT1cImluZGV4XCI+XG4gICAgICAgICAgICAgICAgPHNwYW4+e3tpdGVtLnRleHR9fTwvc3Bhbj5cbiAgICAgICAgICAgIDwvbGk+XG4gICAgICAgIDwvdWw+XG4gICAgPC9rZW5kby12aXJ0dWFsaXphdGlvbj5cbiAgYFxuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbRWxlbWVudFJlZixcbiAgICAgICAgSW5qZWN0b3IsXG4gICAgICAgIFRpbWVQaWNrZXJET01TZXJ2aWNlLFxuICAgICAgICBSZW5kZXJlcjIsXG4gICAgICAgIE5nWm9uZV0pXG5dLCBUaW1lTGlzdENvbXBvbmVudCk7XG5cbmNvbnN0IGlzRXF1YWxUaWxsTWludXRlID0gKHZhbHVlLCBtaW4pID0+IHZhbHVlLmdldEhvdXJzKCkgPT09IG1pbi5nZXRIb3VycygpICYmIHZhbHVlLmdldE1pbnV0ZXMoKSA9PT0gbWluLmdldE1pbnV0ZXMoKTtcbmNvbnN0IGlzRXF1YWxUaWxsU2Vjb25kID0gKHZhbHVlLCBtaW4pID0+IGlzRXF1YWxUaWxsTWludXRlKHZhbHVlLCBtaW4pICYmIHZhbHVlLmdldFNlY29uZHMoKSA9PT0gbWluLmdldFNlY29uZHMoKTtcbmNvbnN0IGlzRXF1YWxUaWxsTWlsbGlzZWNvbmQgPSAodmFsdWUsIG1pbikgPT4gaXNFcXVhbFRpbGxTZWNvbmQodmFsdWUsIG1pbikgJiYgdmFsdWUuZ2V0TWlsbGlzZWNvbmRzKCkgPT09IG1pbi5nZXRNaWxsaXNlY29uZHMoKTtcbmNvbnN0IMm1MyQ3ID0gKHZhbHVlKSA9PiB2YWx1ZS5nZXRIb3VycygpLCDJtTQkMiA9IChfLCBtaW4pID0+IG1pbi5nZXRIb3VycygpLCDJtTUkMSA9ICh2YWx1ZSkgPT4gdmFsdWUuZ2V0TWludXRlcygpLCDJtTYkMSA9ICh2YWx1ZSwgbWluKSA9PiBpc0VxdWFsVGlsbE1pbnV0ZSh2YWx1ZSwgbWluKSA/IG1pbi5nZXRNaW51dGVzKCkgOiAwLCDJtTckMSA9ICh2YWx1ZSkgPT4gdmFsdWUuZ2V0U2Vjb25kcygpLCDJtTgkMSA9ICh2YWx1ZSwgbWluKSA9PiBpc0VxdWFsVGlsbFNlY29uZCh2YWx1ZSwgbWluKSA/IG1pbi5nZXRTZWNvbmRzKCkgOiAwLCDJtTkkMSA9ICh2YWx1ZSkgPT4gdmFsdWUuZ2V0TWlsbGlzZWNvbmRzKCksIMm1MTAkMSA9ICh2YWx1ZSwgbWluKSA9PiBpc0VxdWFsVGlsbE1pbGxpc2Vjb25kKHZhbHVlLCBtaW4pID8gbWluLmdldE1pbGxpc2Vjb25kcygpIDogMDtcbmNvbnN0IGRlZmF1bHRHZXR0ZXJzID0gW1xuICAgIHtcbiAgICAgICAgdHlwZTogVElNRV9QQVJULmhvdXIsXG4gICAgICAgIGdldHRlcjogybUzJDcsXG4gICAgICAgIG1pbkdldHRlcjogybU0JDJcbiAgICB9LCB7XG4gICAgICAgIHR5cGU6IFRJTUVfUEFSVC5taW51dGUsXG4gICAgICAgIGdldHRlcjogybU1JDEsXG4gICAgICAgIG1pbkdldHRlcjogybU2JDFcbiAgICB9LCB7XG4gICAgICAgIHR5cGU6IFRJTUVfUEFSVC5zZWNvbmQsXG4gICAgICAgIGdldHRlcjogybU3JDEsXG4gICAgICAgIG1pbkdldHRlcjogybU4JDFcbiAgICB9LCB7XG4gICAgICAgIHR5cGU6IFRJTUVfUEFSVC5taWxsaXNlY29uZCxcbiAgICAgICAgZ2V0dGVyOiDJtTkkMSxcbiAgICAgICAgbWluR2V0dGVyOiDJtTEwJDFcbiAgICB9XG5dO1xuY29uc3QgbGVmdCA9IGdldHRlciA9PiAob3JpZ2luLCBfKSA9PiBnZXR0ZXIob3JpZ2luKTtcbmNvbnN0IHJpZ2h0ID0gZ2V0dGVyID0+IChfLCBjYW5kaWRhdGUpID0+IGdldHRlcihjYW5kaWRhdGUpO1xuY29uc3QgY29udmVydFRvT2JqZWN0ID0gKHBhcnRzKSA9PiBwYXJ0cy5yZWR1Y2UoKG9iaiwgcCkgPT4geyBvYmpbcC50eXBlXSA9IHAudHlwZTsgcmV0dXJuIG9iajsgfSwge30pO1xuY29uc3QgZ2V0dGVyQnlQYXJ0ID0gcGFydHMgPT4gZyA9PiBwYXJ0c1tnLnR5cGVdID8gcmlnaHQoZy5nZXR0ZXIpIDogbGVmdChnLmdldHRlcik7XG5jb25zdCBnZXR0ZXJzRmFjdG9yeSA9IGdldHRlcnMgPT4gcGFydHMgPT4gKGdldHRlcnMubWFwKGdldHRlckJ5UGFydChjb252ZXJ0VG9PYmplY3QocGFydHMpKSkpO1xuY29uc3Qgc25hcFZhbHVlID0gKGdldHRlciwgbWluR2V0dGVyLCBzdGVwKSA9PiAoZGF0ZSwgbWluKSA9PiB7XG4gICAgY29uc3QgdmFsdWUgPSBnZXR0ZXIoZGF0ZSk7XG4gICAgY29uc3QgbWluVmFsdWUgPSBtaW5HZXR0ZXIoZGF0ZSwgbWluKTtcbiAgICBjb25zdCByZXN0ID0gdmFsdWUgLSBtaW5WYWx1ZTtcbiAgICBpZiAocmVzdCA8IDApIHtcbiAgICAgICAgcmV0dXJuIG1pblZhbHVlO1xuICAgIH1cbiAgICBjb25zdCBtb2QgPSByZXN0ICUgc3RlcDtcbiAgICByZXR1cm4gdmFsdWUgLSBtb2QgKyAobW9kID4gc3RlcCAvIDIgPyBzdGVwIDogMCk7XG59O1xuY29uc3Qgc25hcHBlcnNGYWN0b3J5ID0gKGdldHRlcnMpID0+IHN0ZXBzID0+IChnZXR0ZXJzLm1hcChnID0+IHtcbiAgICBjb25zdCBzdGVwID0gc3RlcHNbZy50eXBlXTtcbiAgICByZXR1cm4gc3RlcCA/IHNuYXBWYWx1ZShnLmdldHRlciwgZy5taW5HZXR0ZXIsIHN0ZXApIDogZy5nZXR0ZXI7XG59KSk7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgZ2VuZXJhdGVHZXR0ZXJzID0gZ2V0dGVyc0ZhY3RvcnkoZGVmYXVsdEdldHRlcnMpO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGdlbmVyYXRlU25hcHBlcnMgPSBzbmFwcGVyc0ZhY3RvcnkoZGVmYXVsdEdldHRlcnMpO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IHZhbHVlTWVyZ2VyID0gZ2V0dGVycyA9PiAob3JpZ2luLCBjYW5kaWRhdGUpID0+IHtcbiAgICBvcmlnaW4uc2V0SG91cnMoLi4uZ2V0dGVycy5tYXAoZyA9PiBnKG9yaWdpbiwgY2FuZGlkYXRlKSkpO1xuICAgIHJldHVybiBvcmlnaW47XG59O1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IHNuYXBUaW1lID0gc25hcHBlcnMgPT4gKGNhbmRpZGF0ZSwgbWluKSA9PiB7XG4gICAgY29uc3QgZGF0ZSA9IGNsb25lRGF0ZShjYW5kaWRhdGUpO1xuICAgIGRhdGUuc2V0SG91cnMoLi4uc25hcHBlcnMubWFwKHMgPT4gcyhkYXRlLCBtaW4pKSk7XG4gICAgcmV0dXJuIGRhdGU7XG59O1xuXG5jb25zdCBsaXN0UmVkdWNlciA9IChzdGF0ZSwgbGlzdCwgaWR4LCBhbGwpID0+IHtcbiAgICBpZiAoc3RhdGUubGVuZ3RoIHx8ICFsaXN0LmlzQWN0aXZlKSB7XG4gICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9XG4gICAgcmV0dXJuIFt7XG4gICAgICAgICAgICBuZXh0OiBhbGxbaWR4ICsgMV0gfHwgbGlzdCxcbiAgICAgICAgICAgIHByZXY6IGFsbFtpZHggLSAxXSB8fCBsaXN0XG4gICAgICAgIH1dO1xufTtcbnZhciBEaXJlY3Rpb247XG4oZnVuY3Rpb24gKERpcmVjdGlvbikge1xuICAgIERpcmVjdGlvbltEaXJlY3Rpb25bXCJMZWZ0XCJdID0gMF0gPSBcIkxlZnRcIjtcbiAgICBEaXJlY3Rpb25bRGlyZWN0aW9uW1wiUmlnaHRcIl0gPSAxXSA9IFwiUmlnaHRcIjtcbn0pKERpcmVjdGlvbiB8fCAoRGlyZWN0aW9uID0ge30pKTtcbi8qKlxuICogQGhpZGRlblxuICpcbiAqIFJlcHJlc2VudHMgdGhlIEtlbmRvIFVJIFRpbWVTZWxlY3RvciBjb21wb25lbnQgZm9yIEFuZ3VsYXIuXG4gKi9cbmxldCBUaW1lU2VsZWN0b3JDb21wb25lbnQgPSBjbGFzcyBUaW1lU2VsZWN0b3JDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGxvY2FsaXphdGlvbiwgY2RyLCBlbGVtZW50LCBpbnRsLCBkb20sIHpvbmUsIHJlbmRlcmVyLCBwaWNrZXJTZXJ2aWNlKSB7XG4gICAgICAgIHRoaXMubG9jYWxpemF0aW9uID0gbG9jYWxpemF0aW9uO1xuICAgICAgICB0aGlzLmNkciA9IGNkcjtcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICAgICAgdGhpcy5pbnRsID0gaW50bDtcbiAgICAgICAgdGhpcy5kb20gPSBkb207XG4gICAgICAgIHRoaXMuem9uZSA9IHpvbmU7XG4gICAgICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgICAgICAgdGhpcy5waWNrZXJTZXJ2aWNlID0gcGlja2VyU2VydmljZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBoaWRkZW5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY29tcG9uZW50Q2xhc3MgPSB0cnVlO1xuICAgICAgICAvKipcbiAgICAgICAgICogU3BlY2lmaWVzIHRoZSB0aW1lIGZvcm1hdCB1c2VkIHRvIGRpc3BsYXkgdGhlIHRpbWUgbGlzdCBjb2x1bW5zLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5mb3JtYXQgPSAndCc7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVjaWZpZXMgdGhlIHNtYWxsZXN0IHZhbGlkIHRpbWUgdmFsdWUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm1pbiA9IGNsb25lRGF0ZShNSU5fVElNRSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVjaWZpZXMgdGhlIGJpZ2dlc3QgdmFsaWQgdGltZSB2YWx1ZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubWF4ID0gY2xvbmVEYXRlKE1BWF9USU1FKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERldGVybWluZXMgd2hldGhlciB0byBkaXNwbGF5IHRoZSAqKkNhbmNlbCoqIGJ1dHRvbiBpbiB0aGUgcG9wdXAuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNhbmNlbEJ1dHRvbiA9IHRydWU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgdG8gZGlzcGxheSB0aGUgKipTZXQqKiBidXR0b24gaW4gdGhlIHBvcHVwLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zZXRCdXR0b24gPSB0cnVlO1xuICAgICAgICAvKipcbiAgICAgICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRvIGRpc3BsYXkgdGhlICoqTm93KiogYnV0dG9uIGluIHRoZSBwb3B1cC5cbiAgICAgICAgICpcbiAgICAgICAgICogPiBJZiB0aGUgY3VycmVudCB0aW1lIGlzIG91dCBvZiByYW5nZSBvciB0aGUgaW5jcmVtZW50YWwgc3RlcCBpcyBncmVhdGVyIHRoYW4gYDFgLCB0aGUgKipOb3cqKiBidXR0b24gd2lsbCBiZSBoaWRkZW4uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm5vd0J1dHRvbiA9IHRydWU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXRzIG9yIGdldHMgdGhlIGBkaXNhYmxlZGAgcHJvcGVydHkgb2YgdGhlIFRpbWVTZWxlY3RvciBhbmQgZGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBjb21wb25lbnQgaXMgYWN0aXZlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kaXNhYmxlZCA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogU3BlY2lmaWVzIHRoZSB2YWx1ZSBvZiB0aGUgVGltZVNlbGVjdG9yIGNvbXBvbmVudC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudmFsdWUgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgZWFjaCB0aW1lIHRoZSB1c2VyIHNlbGVjdHMgYSBuZXcgdmFsdWUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnZhbHVlQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgZWFjaCB0aW1lIHRoZSB1c2VyIGNhbmNlbHMgdGhlIHNlbGVjdGVkIHZhbHVlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy52YWx1ZVJlamVjdCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5pc0FjdGl2ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnNob3dOb3dCdXR0b24gPSB0cnVlO1xuICAgICAgICB0aGlzLl9hY3RpdmVMaXN0SW5kZXggPSAtMTtcbiAgICAgICAgdGhpcy5fc3RlcHMgPSB7fTtcbiAgICAgICAgdGhpcy5kb21FdmVudHMgPSBbXTtcbiAgICAgICAgaWYgKHRoaXMucGlja2VyU2VydmljZSkge1xuICAgICAgICAgICAgdGhpcy5waWNrZXJTZXJ2aWNlLnRpbWVTZWxlY3RvciA9IHRoaXM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGdldCBkaXNhYmxlZENsYXNzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kaXNhYmxlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29uZmlndXJlcyB0aGUgaW5jcmVtZW50YWwgc3RlcHMgb2YgdGhlIFRpbWVTZWxlY3Rvci5cbiAgICAgKlxuICAgICAqIFRoZSBhdmFpbGFibGUgb3B0aW9ucyBhcmU6XG4gICAgICogLSBgaG91cjogTnVtYmVyYCZtZGFzaDtDb250cm9scyB0aGUgaW5jcmVtZW50YWwgc3RlcCBvZiB0aGUgaG91ciB2YWx1ZS5cbiAgICAgKiAtIGBtaW51dGU6IE51bWJlcmAmbWRhc2g7Q29udHJvbHMgdGhlIGluY3JlbWVudGFsIHN0ZXAgb2YgdGhlIG1pbnV0ZSB2YWx1ZS5cbiAgICAgKiAtIGBzZWNvbmQ6IE51bWJlcmAmbWRhc2g7Q29udHJvbHMgdGhlIGluY3JlbWVudGFsIHN0ZXAgb2YgdGhlIHNlY29uZCB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiBfQENvbXBvbmVudCh7XG4gICAgICogc2VsZWN0b3I6ICdteS1hcHAnLFxuICAgICAqIHRlbXBsYXRlOiBgXG4gICAgICogIDxrZW5kby10aW1lc2VsZWN0b3IgZm9ybWF0PVwiSEg6bW06c3NcIiBbc3RlcHNdPVwic3RlcHNcIj48L2tlbmRvLXRpbWVzZWxlY3Rvcj5cbiAgICAgKiBgXG4gICAgICogfSlcbiAgICAgKiBleHBvcnQgY2xhc3MgQXBwQ29tcG9uZW50IHtcbiAgICAgKiAgIHB1YmxpYyBzdGVwcyA9IHsgaG91cjogMiwgbWludXRlOiAxNSwgc2Vjb25kOiAxNSB9O1xuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqID4gSWYgdGhlIGluY3JlbWVudGFsIHN0ZXAgaXMgZ3JlYXRlciB0aGFuIGAxYCwgdGhlICoqTm93KiogYnV0dG9uIHdpbGwgYmUgaGlkZGVuLlxuICAgICAqL1xuICAgIHNldCBzdGVwcyhzdGVwcykge1xuICAgICAgICB0aGlzLl9zdGVwcyA9IHN0ZXBzIHx8IHt9O1xuICAgIH1cbiAgICBnZXQgc3RlcHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdGVwcztcbiAgICB9XG4gICAgc2V0IGN1cnJlbnQodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fY3VycmVudCA9IHRpbWVJblJhbmdlKHRoaXMuc25hcFRpbWUoY2xvbmVEYXRlKHZhbHVlIHx8IE1JRE5JR0hUX0RBVEUpLCB0aGlzLm1pbiksIHRoaXMubWluLCB0aGlzLm1heCk7XG4gICAgICAgIGlmICghTmdab25lLmlzSW5Bbmd1bGFyWm9uZSgpKSB7XG4gICAgICAgICAgICB0aGlzLmNkci5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGN1cnJlbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jdXJyZW50O1xuICAgIH1cbiAgICBnZXQgYWN0aXZlTGlzdEluZGV4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWN0aXZlTGlzdEluZGV4O1xuICAgIH1cbiAgICBzZXQgYWN0aXZlTGlzdEluZGV4KHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX2FjdGl2ZUxpc3RJbmRleCA9IHZhbHVlO1xuICAgICAgICBpZiAoIXRoaXMudGltZUxpc3RXcmFwcGVycyB8fCAhdGhpcy50aW1lTGlzdFdyYXBwZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudGltZUxpc3RXcmFwcGVycy5mb3JFYWNoKGxpc3RXcmFwcGVyID0+IHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIucmVtb3ZlQ2xhc3MobGlzdFdyYXBwZXIubmF0aXZlRWxlbWVudCwgJ2stc3RhdGUtZm9jdXNlZCcpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHZhbHVlID49IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGxpc3RJbmRleCA9IHRoaXMubGlzdEluZGV4KHZhbHVlKTtcbiAgICAgICAgICAgIGNvbnN0IGZvY3VzZWRXcmFwcGVyID0gdGhpcy50aW1lTGlzdFdyYXBwZXJzLnRvQXJyYXkoKVtsaXN0SW5kZXhdO1xuICAgICAgICAgICAgaWYgKGZvY3VzZWRXcmFwcGVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5hZGRDbGFzcyhmb2N1c2VkV3JhcHBlci5uYXRpdmVFbGVtZW50LCAnay1zdGF0ZS1mb2N1c2VkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIG5nT25Jbml0KCkge1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMgPSB0aGlzLmludGwuY2hhbmdlcy5zdWJzY3JpYmUodGhpcy5pbnRsQ2hhbmdlLmJpbmQodGhpcykpO1xuICAgICAgICBpZiAodGhpcy5sb2NhbGl6YXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5hZGQodGhpcy5sb2NhbGl6YXRpb25cbiAgICAgICAgICAgICAgICAuY2hhbmdlc1xuICAgICAgICAgICAgICAgIC5zdWJzY3JpYmUoKCkgPT4gdGhpcy5jZHIubWFya0ZvckNoZWNrKCkpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRvbS5jYWxjdWxhdGVIZWlnaHRzKHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50KTtcbiAgICAgICAgdGhpcy5pbml0KCk7XG4gICAgICAgIHRoaXMuYmluZEV2ZW50cygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgbmdPbkNoYW5nZXMoXykge1xuICAgICAgICB0aGlzLmluaXQoKTtcbiAgICB9XG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIGlmICh0aGlzLnN1YnNjcmlwdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy51bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnBpY2tlclNlcnZpY2UpIHtcbiAgICAgICAgICAgIHRoaXMucGlja2VyU2VydmljZS50aW1lU2VsZWN0b3IgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZG9tRXZlbnRzLmZvckVhY2godW5iaW5kQ2FsbGJhY2sgPT4gdW5iaW5kQ2FsbGJhY2soKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZvY3VzZXMgdGhlIFRpbWVTZWxlY3RvciBjb21wb25lbnQuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHRzXG4gICAgICogX0BDb21wb25lbnQoe1xuICAgICAqIHNlbGVjdG9yOiAnbXktYXBwJyxcbiAgICAgKiB0ZW1wbGF0ZTogYFxuICAgICAqICA8YnV0dG9uIChjbGljayk9XCJ0aW1lc2VsZWN0b3IuZm9jdXMoKVwiPkZvY3VzIHRpbWUgcGlja2VyPC9idXR0b24+XG4gICAgICogIDxrZW5kby10aW1lc2VsZWN0b3IgI3RpbWVzZWxlY3Rvcj48L2tlbmRvLXRpbWVzZWxlY3Rvcj5cbiAgICAgKiBgXG4gICAgICogfSlcbiAgICAgKiBleHBvcnQgY2xhc3MgQXBwQ29tcG9uZW50IHsgfVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGZvY3VzKCkge1xuICAgICAgICBjb25zdCBsaXN0ID0gdGhpcy50aW1lTGlzdHMuZmlyc3Q7XG4gICAgICAgIGlmICghbGlzdCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxpc3QuZm9jdXMoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQmx1cnMgdGhlIFRpbWVTZWxlY3RvciBjb21wb25lbnQuXG4gICAgICovXG4gICAgYmx1cigpIHtcbiAgICAgICAgY29uc3QgbGlzdCA9IHRoaXMudGltZUxpc3RzLmZpcnN0O1xuICAgICAgICBpZiAoIWxpc3QpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsaXN0LmJsdXIoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGhhbmRsZUFjY2VwdCgpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVDaGFuZ2UodGhpcy5tZXJnZVZhbHVlKGNsb25lRGF0ZSh0aGlzLnZhbHVlIHx8IGdldERhdGUoZ2V0Tm93KCkpKSwgdGhpcy5jdXJyZW50KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBoYW5kbGVOb3coKSB7XG4gICAgICAgIHRoaXMuY3VycmVudCA9IGdldE5vdygpO1xuICAgICAgICB0aGlzLmhhbmRsZUNoYW5nZSh0aGlzLmN1cnJlbnQpO1xuICAgICAgICB0aGlzLmNkci5tYXJrRm9yQ2hlY2soKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGhhbmRsZVJlamVjdCgpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50ID0gdGhpcy52YWx1ZTtcbiAgICAgICAgdGhpcy52YWx1ZVJlamVjdC5lbWl0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBoYW5kbGVGb2N1cyhhcmdzKSB7XG4gICAgICAgIGlmICh0aGlzLmlzQWN0aXZlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pc0FjdGl2ZSA9IHRydWU7XG4gICAgICAgIHRoaXMuZW1pdEZvY3VzKGFyZ3MpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgaGFuZGxlTGlzdEZvY3VzKGFyZ3MpIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSBwYXJzZUludChhcmdzLnRhcmdldC5nZXRBdHRyaWJ1dGUoJ2RhdGEtdGltZWxpc3QtaW5kZXgnKSwgMTApO1xuICAgICAgICB0aGlzLmFjdGl2ZUxpc3RJbmRleCA9IGluZGV4O1xuICAgICAgICB0aGlzLmhhbmRsZUZvY3VzKGFyZ3MpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgaGFuZGxlQmx1cihhcmdzKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRUYXJnZXQgPSBjdXJyZW50Rm9jdXNUYXJnZXQoYXJncyk7XG4gICAgICAgIGlmIChjdXJyZW50VGFyZ2V0ICYmIHRoaXMuY29udGFpbnNFbGVtZW50KGN1cnJlbnRUYXJnZXQpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hY3RpdmVMaXN0SW5kZXggPSAtMTtcbiAgICAgICAgdGhpcy5pc0FjdGl2ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmVtaXRCbHVyKGFyZ3MpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgY29udGFpbnNFbGVtZW50KGVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIEJvb2xlYW4oY2xvc2VzdChlbGVtZW50LCBub2RlID0+IG5vZGUgPT09IHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50KSk7XG4gICAgfVxuICAgIHBhcnRTdGVwKHBhcnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RlcHNbcGFydC50eXBlXSB8fCAxO1xuICAgIH1cbiAgICBpbml0KGNoYW5nZXMpIHtcbiAgICAgICAgaWYgKCFjaGFuZ2VzIHx8IGhhc0NoYW5nZShjaGFuZ2VzLCAnZm9ybWF0JykpIHtcbiAgICAgICAgICAgIHRoaXMuZGF0ZUZvcm1hdFBhcnRzID0gdGhpcy5pbnRsLnNwbGl0RGF0ZUZvcm1hdCh0aGlzLmZvcm1hdCk7XG4gICAgICAgICAgICB0aGlzLm1lcmdlVmFsdWUgPSB2YWx1ZU1lcmdlcihnZW5lcmF0ZUdldHRlcnModGhpcy5kYXRlRm9ybWF0UGFydHMpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNoYW5nZXMgfHwgaGFzQ2hhbmdlKGNoYW5nZXMsICdzdGVwcycpKSB7XG4gICAgICAgICAgICB0aGlzLnNuYXBUaW1lID0gc25hcFRpbWUoZ2VuZXJhdGVTbmFwcGVycyh0aGlzLnN0ZXBzKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjaGFuZ2VzIHx8IGhhc0NoYW5nZShjaGFuZ2VzLCAndmFsdWUnKSkge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50ID0gdGhpcy52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNob3dOb3dCdXR0b24gPSAhdGhpcy5oYXNTdGVwcygpICYmIHRoaXMubm93QnV0dG9uICYmIGlzSW5UaW1lUmFuZ2UoZ2V0Tm93KCksIHRoaXMubWluLCB0aGlzLm1heCk7XG4gICAgfVxuICAgIGZvY3VzTGlzdChkaXIpIHtcbiAgICAgICAgaWYgKCF0aGlzLnRpbWVMaXN0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRpbWVMaXN0cy5yZWR1Y2UobGlzdFJlZHVjZXIsIFtdKVxuICAgICAgICAgICAgLm1hcChzdGF0ZSA9PiBkaXIgPT09IERpcmVjdGlvbi5SaWdodCA/IHN0YXRlLm5leHQgOiBzdGF0ZS5wcmV2KVxuICAgICAgICAgICAgLm1hcChsaXN0ID0+IGxpc3QgJiYgbGlzdC5mb2N1cygpKTtcbiAgICB9XG4gICAgaGFuZGxlQ2hhbmdlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy52YWx1ZUNoYW5nZS5lbWl0KGNsb25lRGF0ZSh2YWx1ZSkpO1xuICAgIH1cbiAgICBoYXNBY3RpdmVCdXR0b24oKSB7XG4gICAgICAgIGlmICghdGhpcy5hY2NlcHQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW3RoaXMuYWNjZXB0LCB0aGlzLmNhbmNlbCwgdGhpcy5ub3ddLnJlZHVjZSgoaXNBY3RpdmUsIGVsKSA9PiBpc0FjdGl2ZSB8fCB0aGlzLmRvbS5pc0FjdGl2ZShlbCksIGZhbHNlKTtcbiAgICB9XG4gICAgaGFzU3RlcHMoKSB7XG4gICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyh0aGlzLnN0ZXBzKTtcbiAgICAgICAgcmV0dXJuIGtleXMubGVuZ3RoICE9PSBrZXlzLnJlZHVjZSgoYWNjLCBrKSA9PiBhY2MgKyB0aGlzLnN0ZXBzW2tdLCAwKTtcbiAgICB9XG4gICAgaW50bENoYW5nZSgpIHtcbiAgICAgICAgdGhpcy5kYXRlRm9ybWF0UGFydHMgPSB0aGlzLmludGwuc3BsaXREYXRlRm9ybWF0KHRoaXMuZm9ybWF0KTtcbiAgICAgICAgdGhpcy5tZXJnZVZhbHVlID0gdmFsdWVNZXJnZXIoZ2VuZXJhdGVHZXR0ZXJzKHRoaXMuZGF0ZUZvcm1hdFBhcnRzKSk7XG4gICAgICAgIHRoaXMuY2RyLm1hcmtGb3JDaGVjaygpO1xuICAgIH1cbiAgICBiaW5kRXZlbnRzKCkge1xuICAgICAgICBpZiAodGhpcy5lbGVtZW50KSB7XG4gICAgICAgICAgICB0aGlzLnpvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZG9tRXZlbnRzLnB1c2godGhpcy5yZW5kZXJlci5saXN0ZW4odGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQsICdrZXlkb3duJywgdGhpcy5oYW5kbGVLZXlkb3duLmJpbmQodGhpcykpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhbmRsZUtleWRvd24oYXJncykge1xuICAgICAgICBjb25zdCB7IGtleUNvZGUsIGFsdEtleSB9ID0gYXJncztcbiAgICAgICAgLy8gcmVzZXJ2ZSB0aGUgYWx0ICsgYXJyb3cga2V5IGNvbW1hbmRzIGZvciB0aGUgcGlja2VyXG4gICAgICAgIGNvbnN0IGFycm93S2V5UHJlc3NlZCA9IFtLZXlzLkFycm93TGVmdCwgS2V5cy5BcnJvd1JpZ2h0XS5pbmRleE9mKGtleUNvZGUpICE9PSAtMTtcbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLnBpY2tlclNlcnZpY2UpICYmIGFycm93S2V5UHJlc3NlZCAmJiBhbHRLZXkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoa2V5Q29kZSA9PT0gS2V5cy5FbnRlciAmJiAhdGhpcy5oYXNBY3RpdmVCdXR0b24oKSkge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVBY2NlcHQoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChrZXlDb2RlID09PSBLZXlzLkFycm93TGVmdCB8fCBrZXlDb2RlID09PSBLZXlzLkFycm93UmlnaHQpIHtcbiAgICAgICAgICAgIHRoaXMuZm9jdXNMaXN0KGtleUNvZGUgPT09IEtleXMuQXJyb3dMZWZ0ID8gRGlyZWN0aW9uLkxlZnQgOiBEaXJlY3Rpb24uUmlnaHQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVtaXRCbHVyKGFyZ3MpIHtcbiAgICAgICAgaWYgKHRoaXMucGlja2VyU2VydmljZSkge1xuICAgICAgICAgICAgdGhpcy5waWNrZXJTZXJ2aWNlLm9uQmx1ci5lbWl0KGFyZ3MpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVtaXRGb2N1cyhhcmdzKSB7XG4gICAgICAgIGlmICh0aGlzLnBpY2tlclNlcnZpY2UpIHtcbiAgICAgICAgICAgIHRoaXMucGlja2VyU2VydmljZS5vbkZvY3VzLmVtaXQoYXJncyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGlzdEluZGV4KHBhcnRJbmRleCkge1xuICAgICAgICBsZXQgbGlzdElkeCA9IDA7XG4gICAgICAgIGxldCBwYXJ0SWR4ID0gMDtcbiAgICAgICAgd2hpbGUgKHBhcnRJZHggPCBwYXJ0SW5kZXgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRhdGVGb3JtYXRQYXJ0c1twYXJ0SWR4XS50eXBlICE9PSAnbGl0ZXJhbCcpIHtcbiAgICAgICAgICAgICAgICBsaXN0SWR4Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJ0SWR4Kys7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxpc3RJZHg7XG4gICAgfVxufTtcbl9fZGVjb3JhdGUoW1xuICAgIFZpZXdDaGlsZCgnYWNjZXB0JywgeyBzdGF0aWM6IGZhbHNlIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFbGVtZW50UmVmKVxuXSwgVGltZVNlbGVjdG9yQ29tcG9uZW50LnByb3RvdHlwZSwgXCJhY2NlcHRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIFZpZXdDaGlsZCgnY2FuY2VsJywgeyBzdGF0aWM6IGZhbHNlIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFbGVtZW50UmVmKVxuXSwgVGltZVNlbGVjdG9yQ29tcG9uZW50LnByb3RvdHlwZSwgXCJjYW5jZWxcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIFZpZXdDaGlsZCgnbm93JywgeyBzdGF0aWM6IGZhbHNlIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFbGVtZW50UmVmKVxuXSwgVGltZVNlbGVjdG9yQ29tcG9uZW50LnByb3RvdHlwZSwgXCJub3dcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIFZpZXdDaGlsZHJlbihUaW1lTGlzdENvbXBvbmVudCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFF1ZXJ5TGlzdClcbl0sIFRpbWVTZWxlY3RvckNvbXBvbmVudC5wcm90b3R5cGUsIFwidGltZUxpc3RzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBWaWV3Q2hpbGRyZW4oJ2xpc3RXcmFwcGVyJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFF1ZXJ5TGlzdClcbl0sIFRpbWVTZWxlY3RvckNvbXBvbmVudC5wcm90b3R5cGUsIFwidGltZUxpc3RXcmFwcGVyc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLmstdGltZXNlbGVjdG9yJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBUaW1lU2VsZWN0b3JDb21wb25lbnQucHJvdG90eXBlLCBcImNvbXBvbmVudENsYXNzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBIb3N0QmluZGluZygnY2xhc3Muay1zdGF0ZS1kaXNhYmxlZCcpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBUaW1lU2VsZWN0b3JDb21wb25lbnQucHJvdG90eXBlLCBcImRpc2FibGVkQ2xhc3NcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBUaW1lU2VsZWN0b3JDb21wb25lbnQucHJvdG90eXBlLCBcImZvcm1hdFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRGF0ZSlcbl0sIFRpbWVTZWxlY3RvckNvbXBvbmVudC5wcm90b3R5cGUsIFwibWluXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBEYXRlKVxuXSwgVGltZVNlbGVjdG9yQ29tcG9uZW50LnByb3RvdHlwZSwgXCJtYXhcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBUaW1lU2VsZWN0b3JDb21wb25lbnQucHJvdG90eXBlLCBcImNhbmNlbEJ1dHRvblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIFRpbWVTZWxlY3RvckNvbXBvbmVudC5wcm90b3R5cGUsIFwic2V0QnV0dG9uXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgVGltZVNlbGVjdG9yQ29tcG9uZW50LnByb3RvdHlwZSwgXCJub3dCdXR0b25cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBUaW1lU2VsZWN0b3JDb21wb25lbnQucHJvdG90eXBlLCBcImRpc2FibGVkXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbT2JqZWN0XSlcbl0sIFRpbWVTZWxlY3RvckNvbXBvbmVudC5wcm90b3R5cGUsIFwic3RlcHNcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBEYXRlKVxuXSwgVGltZVNlbGVjdG9yQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ2YWx1ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbl0sIFRpbWVTZWxlY3RvckNvbXBvbmVudC5wcm90b3R5cGUsIFwidmFsdWVDaGFuZ2VcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIE91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXG5dLCBUaW1lU2VsZWN0b3JDb21wb25lbnQucHJvdG90eXBlLCBcInZhbHVlUmVqZWN0XCIsIHZvaWQgMCk7XG5UaW1lU2VsZWN0b3JDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICAgICAgZXhwb3J0QXM6ICdrZW5kby10aW1lc2VsZWN0b3InLFxuICAgICAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgICAgIExvY2FsaXphdGlvblNlcnZpY2UsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcHJvdmlkZTogTDEwTl9QUkVGSVgsXG4gICAgICAgICAgICAgICAgdXNlVmFsdWU6ICdrZW5kby50aW1lc2VsZWN0b3InXG4gICAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tdGltZXNlbGVjdG9yJyxcbiAgICAgICAgdGVtcGxhdGU6IGBcbiAgICAgICAgPG5nLWNvbnRhaW5lciBrZW5kb1RpbWVTZWxlY3RvckxvY2FsaXplZE1lc3NhZ2VzXG4gICAgICAgICAgICBpMThuLWFjY2VwdD1cImtlbmRvLnRpbWVzZWxlY3Rvci5hY2NlcHR8VGhlIEFjY2VwdCBidXR0b24gdGV4dCBpbiB0aGUgdGltZXNlbGVjdG9yIGNvbXBvbmVudFwiXG4gICAgICAgICAgICBhY2NlcHQ9XCJTZXRcIlxuXG4gICAgICAgICAgICBpMThuLWFjY2VwdExhYmVsPVwia2VuZG8udGltZXNlbGVjdG9yLmFjY2VwdExhYmVsfFRoZSBsYWJlbCBmb3IgdGhlIEFjY2VwdCBidXR0b24gaW4gdGhlIHRpbWVzZWxlY3RvciBjb21wb25lbnRcIlxuICAgICAgICAgICAgYWNjZXB0TGFiZWw9XCJTZXQgdGltZVwiXG5cbiAgICAgICAgICAgIGkxOG4tY2FuY2VsPVwia2VuZG8udGltZXNlbGVjdG9yLmNhbmNlbHxUaGUgQ2FuY2VsIGJ1dHRvbiB0ZXh0IGluIHRoZSB0aW1lc2VsZWN0b3IgY29tcG9uZW50XCJcbiAgICAgICAgICAgIGNhbmNlbD1cIkNhbmNlbFwiXG5cbiAgICAgICAgICAgIGkxOG4tY2FuY2VsTGFiZWw9XCJrZW5kby50aW1lc2VsZWN0b3IuY2FuY2VsTGFiZWx8VGhlIGxhYmVsIGZvciB0aGUgQ2FuY2VsIGJ1dHRvbiBpbiB0aGUgdGltZXNlbGVjdG9yIGNvbXBvbmVudFwiXG4gICAgICAgICAgICBjYW5jZWxMYWJlbD1cIkNhbmNlbCBjaGFuZ2VzXCJcblxuICAgICAgICAgICAgaTE4bi1ub3c9XCJrZW5kby50aW1lc2VsZWN0b3Iubm93fFRoZSBOb3cgYnV0dG9uIHRleHQgaW4gdGhlIHRpbWVzZWxlY3RvciBjb21wb25lbnRcIlxuICAgICAgICAgICAgbm93PVwiTm93XCJcblxuICAgICAgICAgICAgaTE4bi1ub3dMYWJlbD1cImtlbmRvLnRpbWVzZWxlY3Rvci5ub3dMYWJlbHxUaGUgbGFiZWwgZm9yIHRoZSBOb3cgYnV0dG9uIGluIHRoZSB0aW1lc2VsZWN0b3IgY29tcG9uZW50XCJcbiAgICAgICAgICAgIG5vd0xhYmVsPVwiU2VsZWN0IG5vd1wiXG4gICAgICAgID5cbiAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJrLXRpbWUtaGVhZGVyXCI+XG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cImstdGl0bGUgay10aW1lc2VsZWN0b3ItdGl0bGVcIj5cbiAgICAgICAgICAgICAgICB7eyBpbnRsLmZvcm1hdERhdGUoY3VycmVudCwgZm9ybWF0KSB9fVxuICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgICAgICNub3dcbiAgICAgICAgICAgICAgICAqbmdJZj1cInNob3dOb3dCdXR0b25cIlxuICAgICAgICAgICAgICAgIGNsYXNzPVwiay1idXR0b24gay1mbGF0IGstdGltZS1ub3dcIiB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgICAgICAgICBbYXR0ci50aXRsZV09XCJsb2NhbGl6YXRpb24uZ2V0KCdub3dMYWJlbCcpXCJcbiAgICAgICAgICAgICAgICBbYXR0ci5hcmlhLWxhYmVsXT1cImxvY2FsaXphdGlvbi5nZXQoJ25vd0xhYmVsJylcIlxuICAgICAgICAgICAgICAgIFtrZW5kb0V2ZW50c091dHNpZGVBbmd1bGFyXT1cIntcbiAgICAgICAgICAgICAgICAgICAgY2xpY2s6IGhhbmRsZU5vdyxcbiAgICAgICAgICAgICAgICAgICAgZm9jdXM6IGhhbmRsZUZvY3VzLFxuICAgICAgICAgICAgICAgICAgICBibHVyOiBoYW5kbGVCbHVyXG4gICAgICAgICAgICAgICAgfVwiXG4gICAgICAgICAgICAgICAgW3Njb3BlXT1cInRoaXNcIlxuICAgICAgICAgICAgICAgIFtkaXNhYmxlZF09XCJkaXNhYmxlZFwiXG4gICAgICAgICAgICA+e3tsb2NhbGl6YXRpb24uZ2V0KCdub3cnKX19PC9idXR0b24+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzPVwiay10aW1lLWxpc3QtY29udGFpbmVyXCI+XG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cImstdGltZS1oaWdobGlnaHRcIj48L3NwYW4+XG4gICAgICAgICAgICA8bmctdGVtcGxhdGUgbmdGb3IgW25nRm9yT2ZdPVwiZGF0ZUZvcm1hdFBhcnRzXCIgbGV0LXBhcnQgbGV0LWlkeD1cImluZGV4XCI+XG4gICAgICAgICAgICAgICAgPGRpdlxuICAgICAgICAgICAgICAgICAgICAjbGlzdFdyYXBwZXJcbiAgICAgICAgICAgICAgICAgICAgY2xhc3M9XCJrLXRpbWUtbGlzdC13cmFwcGVyXCJcbiAgICAgICAgICAgICAgICAgICAgcm9sZT1cInByZXNlbnRhdGlvblwiIHRhYmluZGV4PVwiLTFcIlxuICAgICAgICAgICAgICAgICAgICAqbmdJZj1cInBhcnQudHlwZSAhPT0gJ2xpdGVyYWwnXCJcbiAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiay10aXRsZSBrLXRpbWVzZWxlY3Rvci10aXRsZVwiPnt7aW50bC5kYXRlRmllbGROYW1lKHBhcnQpfX08L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgIDxrZW5kby10aW1lbGlzdFxuICAgICAgICAgICAgICAgICAgICAgICAgW21pbl09XCJtaW5cIlxuICAgICAgICAgICAgICAgICAgICAgICAgW21heF09XCJtYXhcIlxuICAgICAgICAgICAgICAgICAgICAgICAgW3BhcnRdPVwicGFydFwiXG4gICAgICAgICAgICAgICAgICAgICAgICBbc3RlcF09XCJwYXJ0U3RlcChwYXJ0KVwiXG4gICAgICAgICAgICAgICAgICAgICAgICBbZGlzYWJsZWRdPVwiZGlzYWJsZWRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgWyh2YWx1ZSldPVwiY3VycmVudFwiXG4gICAgICAgICAgICAgICAgICAgICAgICBba2VuZG9FdmVudHNPdXRzaWRlQW5ndWxhcl09XCJ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9jdXM6IGhhbmRsZUxpc3RGb2N1cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBibHVyOiBoYW5kbGVCbHVyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XCJcbiAgICAgICAgICAgICAgICAgICAgICAgIFtzY29wZV09XCJ0aGlzXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIFthdHRyLmRhdGEtdGltZWxpc3QtaW5kZXhdPVwiaWR4XCJcbiAgICAgICAgICAgICAgICAgICAgPjwva2VuZG8tdGltZWxpc3Q+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImstdGltZS1zZXBhcmF0b3JcIiAqbmdJZj1cInBhcnQudHlwZSA9PT0gJ2xpdGVyYWwnXCI+XG4gICAgICAgICAgICAgICAgICAgIHt7cGFydC5wYXR0ZXJufX1cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvbmctdGVtcGxhdGU+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzPVwiay10aW1lLWZvb3RlciBrLWFjdGlvbi1idXR0b25zXCIgKm5nSWY9XCJzZXRCdXR0b24gfHwgY2FuY2VsQnV0dG9uXCI+XG4gICAgICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICAgICAgI2NhbmNlbFxuICAgICAgICAgICAgICAgICpuZ0lmPVwiY2FuY2VsQnV0dG9uXCJcbiAgICAgICAgICAgICAgICBjbGFzcz1cImstYnV0dG9uIGstdGltZS1jYW5jZWxcIiB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgICAgICAgICBbYXR0ci50aXRsZV09XCJsb2NhbGl6YXRpb24uZ2V0KCdjYW5jZWxMYWJlbCcpXCJcbiAgICAgICAgICAgICAgICBbYXR0ci5hcmlhLWxhYmVsXT1cImxvY2FsaXphdGlvbi5nZXQoJ2NhbmNlbExhYmVsJylcIlxuICAgICAgICAgICAgICAgIFtrZW5kb0V2ZW50c091dHNpZGVBbmd1bGFyXT1cIntcbiAgICAgICAgICAgICAgICAgICAgY2xpY2s6IGhhbmRsZVJlamVjdCxcbiAgICAgICAgICAgICAgICAgICAgZm9jdXM6IGhhbmRsZUZvY3VzLFxuICAgICAgICAgICAgICAgICAgICBibHVyOiBoYW5kbGVCbHVyXG4gICAgICAgICAgICAgICAgfVwiXG4gICAgICAgICAgICAgICAgW3Njb3BlXT1cInRoaXNcIlxuICAgICAgICAgICAgICAgIFtkaXNhYmxlZF09XCJkaXNhYmxlZFwiXG4gICAgICAgICAgICA+e3tsb2NhbGl6YXRpb24uZ2V0KCdjYW5jZWwnKX19PC9idXR0b24+XG4gICAgICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICAgICAgI2FjY2VwdFxuICAgICAgICAgICAgICAgICpuZ0lmPVwic2V0QnV0dG9uXCJcbiAgICAgICAgICAgICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgICAgICAgICBjbGFzcz1cImstdGltZS1hY2NlcHQgay1idXR0b24gay1wcmltYXJ5XCJcbiAgICAgICAgICAgICAgICBbYXR0ci50aXRsZV09XCJsb2NhbGl6YXRpb24uZ2V0KCdhY2NlcHRMYWJlbCcpXCJcbiAgICAgICAgICAgICAgICBbYXR0ci5hcmlhLWxhYmVsXT1cImxvY2FsaXphdGlvbi5nZXQoJ2FjY2VwdExhYmVsJylcIlxuICAgICAgICAgICAgICAgIFtrZW5kb0V2ZW50c091dHNpZGVBbmd1bGFyXT1cIntcbiAgICAgICAgICAgICAgICAgICAgY2xpY2s6IGhhbmRsZUFjY2VwdCxcbiAgICAgICAgICAgICAgICAgICAgZm9jdXM6IGhhbmRsZUZvY3VzLFxuICAgICAgICAgICAgICAgICAgICBibHVyOiBoYW5kbGVCbHVyXG4gICAgICAgICAgICAgICAgfVwiXG4gICAgICAgICAgICAgICAgW3Njb3BlXT1cInRoaXNcIlxuICAgICAgICAgICAgICAgIFtkaXNhYmxlZF09XCJkaXNhYmxlZFwiXG4gICAgICAgICAgICA+e3tsb2NhbGl6YXRpb24uZ2V0KCdhY2NlcHQnKX19PC9idXR0b24+XG4gICAgICAgIDwvZGl2PlxuICAgIGBcbiAgICB9KSxcbiAgICBfX3BhcmFtKDcsIE9wdGlvbmFsKCkpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbTG9jYWxpemF0aW9uU2VydmljZSxcbiAgICAgICAgQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gICAgICAgIEVsZW1lbnRSZWYsXG4gICAgICAgIEludGxTZXJ2aWNlLFxuICAgICAgICBUaW1lUGlja2VyRE9NU2VydmljZSxcbiAgICAgICAgTmdab25lLFxuICAgICAgICBSZW5kZXJlcjIsXG4gICAgICAgIFBpY2tlclNlcnZpY2VdKVxuXSwgVGltZVNlbGVjdG9yQ29tcG9uZW50KTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIFRpbWVQaWNrZXJNZXNzYWdlcyBleHRlbmRzIENvbXBvbmVudE1lc3NhZ2VzIHtcbn1cbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFRpbWVQaWNrZXJNZXNzYWdlcy5wcm90b3R5cGUsIFwiYWNjZXB0XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBUaW1lUGlja2VyTWVzc2FnZXMucHJvdG90eXBlLCBcImFjY2VwdExhYmVsXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBUaW1lUGlja2VyTWVzc2FnZXMucHJvdG90eXBlLCBcImNhbmNlbFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgVGltZVBpY2tlck1lc3NhZ2VzLnByb3RvdHlwZSwgXCJjYW5jZWxMYWJlbFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgVGltZVBpY2tlck1lc3NhZ2VzLnByb3RvdHlwZSwgXCJub3dcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFRpbWVQaWNrZXJNZXNzYWdlcy5wcm90b3R5cGUsIFwibm93TGFiZWxcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFRpbWVQaWNrZXJNZXNzYWdlcy5wcm90b3R5cGUsIFwidG9nZ2xlXCIsIHZvaWQgMCk7XG5cbnZhciBUaW1lUGlja2VyTG9jYWxpemVkTWVzc2FnZXNEaXJlY3RpdmVfMTtcbi8qKlxuICogQGhpZGRlblxuICovXG5sZXQgVGltZVBpY2tlckxvY2FsaXplZE1lc3NhZ2VzRGlyZWN0aXZlID0gVGltZVBpY2tlckxvY2FsaXplZE1lc3NhZ2VzRGlyZWN0aXZlXzEgPSBjbGFzcyBUaW1lUGlja2VyTG9jYWxpemVkTWVzc2FnZXNEaXJlY3RpdmUgZXh0ZW5kcyBUaW1lUGlja2VyTWVzc2FnZXMge1xuICAgIGNvbnN0cnVjdG9yKHNlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5zZXJ2aWNlID0gc2VydmljZTtcbiAgICB9XG59O1xuVGltZVBpY2tlckxvY2FsaXplZE1lc3NhZ2VzRGlyZWN0aXZlID0gVGltZVBpY2tlckxvY2FsaXplZE1lc3NhZ2VzRGlyZWN0aXZlXzEgPSBfX2RlY29yYXRlKFtcbiAgICBEaXJlY3RpdmUoe1xuICAgICAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBwcm92aWRlOiBUaW1lUGlja2VyTWVzc2FnZXMsXG4gICAgICAgICAgICAgICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gVGltZVBpY2tlckxvY2FsaXplZE1lc3NhZ2VzRGlyZWN0aXZlXzEpIC8vIHRzbGludDpkaXNhYmxlLWxpbmU6bm8tZm9yd2FyZC1yZWZcbiAgICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgc2VsZWN0b3I6ICdba2VuZG9UaW1lUGlja2VyTG9jYWxpemVkTWVzc2FnZXNdJ1xuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbTG9jYWxpemF0aW9uU2VydmljZV0pXG5dLCBUaW1lUGlja2VyTG9jYWxpemVkTWVzc2FnZXNEaXJlY3RpdmUpO1xuXG52YXIgVGltZVBpY2tlckN1c3RvbU1lc3NhZ2VzQ29tcG9uZW50XzE7XG4vKipcbiAqIEN1c3RvbSBjb21wb25lbnQgbWVzc2FnZXMgb3ZlcnJpZGUgZGVmYXVsdCBjb21wb25lbnQgbWVzc2FnZXMgKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBnbG9iYWxpemF0aW9uX2RhdGVpbnB1dHMgJX0jdG9jLWN1c3RvbS1tZXNzYWdlcykpLlxuICovXG5sZXQgVGltZVBpY2tlckN1c3RvbU1lc3NhZ2VzQ29tcG9uZW50ID0gVGltZVBpY2tlckN1c3RvbU1lc3NhZ2VzQ29tcG9uZW50XzEgPSBjbGFzcyBUaW1lUGlja2VyQ3VzdG9tTWVzc2FnZXNDb21wb25lbnQgZXh0ZW5kcyBUaW1lUGlja2VyTWVzc2FnZXMge1xuICAgIGNvbnN0cnVjdG9yKHNlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5zZXJ2aWNlID0gc2VydmljZTtcbiAgICB9XG4gICAgZ2V0IG92ZXJyaWRlKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59O1xuVGltZVBpY2tlckN1c3RvbU1lc3NhZ2VzQ29tcG9uZW50ID0gVGltZVBpY2tlckN1c3RvbU1lc3NhZ2VzQ29tcG9uZW50XzEgPSBfX2RlY29yYXRlKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBwcm92aWRlOiBUaW1lUGlja2VyTWVzc2FnZXMsXG4gICAgICAgICAgICAgICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gVGltZVBpY2tlckN1c3RvbU1lc3NhZ2VzQ29tcG9uZW50XzEpIC8vIHRzbGludDpkaXNhYmxlLWxpbmU6bm8tZm9yd2FyZC1yZWZcbiAgICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgc2VsZWN0b3I6ICdrZW5kby10aW1lcGlja2VyLW1lc3NhZ2VzJyxcbiAgICAgICAgdGVtcGxhdGU6IGBgXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtMb2NhbGl6YXRpb25TZXJ2aWNlXSlcbl0sIFRpbWVQaWNrZXJDdXN0b21NZXNzYWdlc0NvbXBvbmVudCk7XG5cbnZhciBUaW1lU2VsZWN0b3JMb2NhbGl6ZWRNZXNzYWdlc0RpcmVjdGl2ZV8xO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmxldCBUaW1lU2VsZWN0b3JMb2NhbGl6ZWRNZXNzYWdlc0RpcmVjdGl2ZSA9IFRpbWVTZWxlY3RvckxvY2FsaXplZE1lc3NhZ2VzRGlyZWN0aXZlXzEgPSBjbGFzcyBUaW1lU2VsZWN0b3JMb2NhbGl6ZWRNZXNzYWdlc0RpcmVjdGl2ZSBleHRlbmRzIFRpbWVQaWNrZXJNZXNzYWdlcyB7XG4gICAgY29uc3RydWN0b3Ioc2VydmljZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnNlcnZpY2UgPSBzZXJ2aWNlO1xuICAgIH1cbn07XG5UaW1lU2VsZWN0b3JMb2NhbGl6ZWRNZXNzYWdlc0RpcmVjdGl2ZSA9IFRpbWVTZWxlY3RvckxvY2FsaXplZE1lc3NhZ2VzRGlyZWN0aXZlXzEgPSBfX2RlY29yYXRlKFtcbiAgICBEaXJlY3RpdmUoe1xuICAgICAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBwcm92aWRlOiBUaW1lUGlja2VyTWVzc2FnZXMsXG4gICAgICAgICAgICAgICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gVGltZVNlbGVjdG9yTG9jYWxpemVkTWVzc2FnZXNEaXJlY3RpdmVfMSkgLy8gdHNsaW50OmRpc2FibGUtbGluZTpuby1mb3J3YXJkLXJlZlxuICAgICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBzZWxlY3RvcjogJ1trZW5kb1RpbWVTZWxlY3RvckxvY2FsaXplZE1lc3NhZ2VzXSdcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0xvY2FsaXphdGlvblNlcnZpY2VdKVxuXSwgVGltZVNlbGVjdG9yTG9jYWxpemVkTWVzc2FnZXNEaXJlY3RpdmUpO1xuXG52YXIgVGltZVNlbGVjdG9yQ3VzdG9tTWVzc2FnZXNDb21wb25lbnRfMTtcbi8qKlxuICogQGhpZGRlblxuICpcbiAqIEN1c3RvbSBjb21wb25lbnQgbWVzc2FnZXMgb3ZlcnJpZGUgZGVmYXVsdCBjb21wb25lbnQgbWVzc2FnZXMuXG4gKi9cbmxldCBUaW1lU2VsZWN0b3JDdXN0b21NZXNzYWdlc0NvbXBvbmVudCA9IFRpbWVTZWxlY3RvckN1c3RvbU1lc3NhZ2VzQ29tcG9uZW50XzEgPSBjbGFzcyBUaW1lU2VsZWN0b3JDdXN0b21NZXNzYWdlc0NvbXBvbmVudCBleHRlbmRzIFRpbWVQaWNrZXJNZXNzYWdlcyB7XG4gICAgY29uc3RydWN0b3Ioc2VydmljZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnNlcnZpY2UgPSBzZXJ2aWNlO1xuICAgIH1cbiAgICBnZXQgb3ZlcnJpZGUoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn07XG5UaW1lU2VsZWN0b3JDdXN0b21NZXNzYWdlc0NvbXBvbmVudCA9IFRpbWVTZWxlY3RvckN1c3RvbU1lc3NhZ2VzQ29tcG9uZW50XzEgPSBfX2RlY29yYXRlKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBwcm92aWRlOiBUaW1lUGlja2VyTWVzc2FnZXMsXG4gICAgICAgICAgICAgICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gVGltZVNlbGVjdG9yQ3VzdG9tTWVzc2FnZXNDb21wb25lbnRfMSkgLy8gdHNsaW50OmRpc2FibGUtbGluZTpuby1mb3J3YXJkLXJlZlxuICAgICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLXRpbWVzZWxlY3Rvci1tZXNzYWdlcycsXG4gICAgICAgIHRlbXBsYXRlOiBgYFxuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbTG9jYWxpemF0aW9uU2VydmljZV0pXG5dLCBUaW1lU2VsZWN0b3JDdXN0b21NZXNzYWdlc0NvbXBvbmVudCk7XG5cbmNvbnN0IENPTVBPTkVOVF9ESVJFQ1RJVkVTJDIgPSBbXG4gICAgVGltZVBpY2tlckxvY2FsaXplZE1lc3NhZ2VzRGlyZWN0aXZlLFxuICAgIFRpbWVMaXN0Q29tcG9uZW50LFxuICAgIFRpbWVQaWNrZXJDdXN0b21NZXNzYWdlc0NvbXBvbmVudCxcbiAgICBUaW1lUGlja2VyQ29tcG9uZW50LFxuICAgIFRpbWVTZWxlY3RvckxvY2FsaXplZE1lc3NhZ2VzRGlyZWN0aXZlLFxuICAgIFRpbWVTZWxlY3RvckN1c3RvbU1lc3NhZ2VzQ29tcG9uZW50LFxuICAgIFRpbWVTZWxlY3RvckNvbXBvbmVudFxuXTtcbmNvbnN0IENPTVBPTkVOVF9NT0RVTEVTJDEgPSBbXG4gICAgRGF0ZUlucHV0TW9kdWxlLFxuICAgIEludGxNb2R1bGUsXG4gICAgUG9wdXBNb2R1bGUsXG4gICAgVmlydHVhbGl6YXRpb25Nb2R1bGUsXG4gICAgRXZlbnRzTW9kdWxlXG5dO1xuY29uc3QgybUwJG8gPSB0b3VjaEVuYWJsZWQ7XG5jb25zdCBwcm92aWRlcnMgPSBbXG4gICAgVGltZVBpY2tlckRPTVNlcnZpY2UsXG4gICAgSG91cnNTZXJ2aWNlLFxuICAgIE1pbnV0ZXNTZXJ2aWNlLFxuICAgIFNlY29uZHNTZXJ2aWNlLFxuICAgIE1pbGxpc2Vjb25kc1NlcnZpY2UsXG4gICAgRGF5UGVyaW9kU2VydmljZSxcbiAgICB7XG4gICAgICAgIHByb3ZpZGU6IFRPVUNIX0VOQUJMRUQsXG4gICAgICAgIHVzZVZhbHVlOiDJtTAkb1xuICAgIH1cbl07XG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIFtOZ01vZHVsZV0oe3sgc2l0ZS5kYXRhLnVybHMuYW5ndWxhclsnbmdtb2R1bGVhcGknXSB9fSlcbiAqIGRlZmluaXRpb24gZm9yIHRoZSBUaW1lUGlja2VyIGNvbXBvbmVudC5cbiAqL1xubGV0IFRpbWVQaWNrZXJNb2R1bGUgPSBjbGFzcyBUaW1lUGlja2VyTW9kdWxlIHtcbn07XG5UaW1lUGlja2VyTW9kdWxlID0gX19kZWNvcmF0ZShbXG4gICAgTmdNb2R1bGUoe1xuICAgICAgICBkZWNsYXJhdGlvbnM6IFtDT01QT05FTlRfRElSRUNUSVZFUyQyXSxcbiAgICAgICAgZXhwb3J0czogW0NPTVBPTkVOVF9ESVJFQ1RJVkVTJDJdLFxuICAgICAgICBpbXBvcnRzOiBbQ29tbW9uTW9kdWxlLCAuLi5DT01QT05FTlRfTU9EVUxFUyQxXSxcbiAgICAgICAgcHJvdmlkZXJzOiBwcm92aWRlcnNcbiAgICB9KVxuXSwgVGltZVBpY2tlck1vZHVsZSk7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBNZXNzYWdlcyQxIGV4dGVuZHMgQ29tcG9uZW50TWVzc2FnZXMge1xufVxuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgTWVzc2FnZXMkMS5wcm90b3R5cGUsIFwidG9nZ2xlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBNZXNzYWdlcyQxLnByb3RvdHlwZSwgXCJkYXRlVGFiXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBNZXNzYWdlcyQxLnByb3RvdHlwZSwgXCJkYXRlVGFiTGFiZWxcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIE1lc3NhZ2VzJDEucHJvdG90eXBlLCBcInRpbWVUYWJcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIE1lc3NhZ2VzJDEucHJvdG90eXBlLCBcInRpbWVUYWJMYWJlbFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgTWVzc2FnZXMkMS5wcm90b3R5cGUsIFwiYWNjZXB0XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBNZXNzYWdlcyQxLnByb3RvdHlwZSwgXCJhY2NlcHRMYWJlbFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgTWVzc2FnZXMkMS5wcm90b3R5cGUsIFwiY2FuY2VsXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBNZXNzYWdlcyQxLnByb3RvdHlwZSwgXCJjYW5jZWxMYWJlbFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgTWVzc2FnZXMkMS5wcm90b3R5cGUsIFwidG9kYXlcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIE1lc3NhZ2VzJDEucHJvdG90eXBlLCBcIm5vd1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgTWVzc2FnZXMkMS5wcm90b3R5cGUsIFwibm93TGFiZWxcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIE1lc3NhZ2VzJDEucHJvdG90eXBlLCBcInByZXZCdXR0b25UaXRsZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgTWVzc2FnZXMkMS5wcm90b3R5cGUsIFwibmV4dEJ1dHRvblRpdGxlXCIsIHZvaWQgMCk7XG5cbnZhciBEYXRlVGltZVBpY2tlckN1c3RvbU1lc3NhZ2VzQ29tcG9uZW50XzE7XG4vKipcbiAqIEN1c3RvbSBjb21wb25lbnQgbWVzc2FnZXMgb3ZlcnJpZGUgZGVmYXVsdCBjb21wb25lbnQgbWVzc2FnZXMgKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBnbG9iYWxpemF0aW9uX2RhdGVpbnB1dHMgJX0jdG9jLWN1c3RvbS1tZXNzYWdlcykpLlxuICovXG5sZXQgRGF0ZVRpbWVQaWNrZXJDdXN0b21NZXNzYWdlc0NvbXBvbmVudCA9IERhdGVUaW1lUGlja2VyQ3VzdG9tTWVzc2FnZXNDb21wb25lbnRfMSA9IGNsYXNzIERhdGVUaW1lUGlja2VyQ3VzdG9tTWVzc2FnZXNDb21wb25lbnQgZXh0ZW5kcyBNZXNzYWdlcyQxIHtcbiAgICBjb25zdHJ1Y3RvcihzZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuc2VydmljZSA9IHNlcnZpY2U7XG4gICAgfVxuICAgIGdldCBvdmVycmlkZSgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufTtcbkRhdGVUaW1lUGlja2VyQ3VzdG9tTWVzc2FnZXNDb21wb25lbnQgPSBEYXRlVGltZVBpY2tlckN1c3RvbU1lc3NhZ2VzQ29tcG9uZW50XzEgPSBfX2RlY29yYXRlKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBwcm92aWRlOiBNZXNzYWdlcyQxLFxuICAgICAgICAgICAgICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IERhdGVUaW1lUGlja2VyQ3VzdG9tTWVzc2FnZXNDb21wb25lbnRfMSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1kYXRldGltZXBpY2tlci1tZXNzYWdlcycsXG4gICAgICAgIHRlbXBsYXRlOiBgYFxuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbTG9jYWxpemF0aW9uU2VydmljZV0pXG5dLCBEYXRlVGltZVBpY2tlckN1c3RvbU1lc3NhZ2VzQ29tcG9uZW50KTtcblxudmFyIExvY2FsaXplZE1lc3NhZ2VzRGlyZWN0aXZlXzE7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xubGV0IExvY2FsaXplZE1lc3NhZ2VzRGlyZWN0aXZlID0gTG9jYWxpemVkTWVzc2FnZXNEaXJlY3RpdmVfMSA9IGNsYXNzIExvY2FsaXplZE1lc3NhZ2VzRGlyZWN0aXZlIGV4dGVuZHMgTWVzc2FnZXMkMSB7XG4gICAgY29uc3RydWN0b3Ioc2VydmljZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnNlcnZpY2UgPSBzZXJ2aWNlO1xuICAgIH1cbn07XG5Mb2NhbGl6ZWRNZXNzYWdlc0RpcmVjdGl2ZSA9IExvY2FsaXplZE1lc3NhZ2VzRGlyZWN0aXZlXzEgPSBfX2RlY29yYXRlKFtcbiAgICBEaXJlY3RpdmUoe1xuICAgICAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBwcm92aWRlOiBNZXNzYWdlcyQxLFxuICAgICAgICAgICAgICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IExvY2FsaXplZE1lc3NhZ2VzRGlyZWN0aXZlXzEpXG4gICAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIHNlbGVjdG9yOiAnW2tlbmRvRGF0ZVRpbWVQaWNrZXJMb2NhbGl6ZWRNZXNzYWdlc10nXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtMb2NhbGl6YXRpb25TZXJ2aWNlXSlcbl0sIExvY2FsaXplZE1lc3NhZ2VzRGlyZWN0aXZlKTtcblxuY29uc3QgQ09NUE9ORU5UX0RJUkVDVElWRVMkMyA9IFtcbiAgICBEYXRlVGltZVBpY2tlckNvbXBvbmVudCxcbiAgICBEYXRlVGltZVBpY2tlckN1c3RvbU1lc3NhZ2VzQ29tcG9uZW50LFxuICAgIExvY2FsaXplZE1lc3NhZ2VzRGlyZWN0aXZlXG5dO1xuY29uc3QgybUwJHAgPSB0b3VjaEVuYWJsZWQ7XG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIFtOZ01vZHVsZV0oe3sgc2l0ZS5kYXRhLnVybHMuYW5ndWxhclsnbmdtb2R1bGVhcGknXSB9fSlcbiAqIGRlZmluaXRpb24gZm9yIHRoZSBEYXRlVGltZVBpY2tlciBjb21wb25lbnQuXG4gKi9cbmxldCBEYXRlVGltZVBpY2tlck1vZHVsZSA9IGNsYXNzIERhdGVUaW1lUGlja2VyTW9kdWxlIHtcbn07XG5EYXRlVGltZVBpY2tlck1vZHVsZSA9IF9fZGVjb3JhdGUoW1xuICAgIE5nTW9kdWxlKHtcbiAgICAgICAgZGVjbGFyYXRpb25zOiBbXG4gICAgICAgICAgICAuLi5DT01QT05FTlRfRElSRUNUSVZFUyQzXG4gICAgICAgIF0sXG4gICAgICAgIGV4cG9ydHM6IFtcbiAgICAgICAgICAgIC4uLkNPTVBPTkVOVF9ESVJFQ1RJVkVTJDMsXG4gICAgICAgICAgICBUZW1wbGF0ZXNNb2R1bGVcbiAgICAgICAgXSxcbiAgICAgICAgaW1wb3J0czogW1xuICAgICAgICAgICAgQ29tbW9uTW9kdWxlLFxuICAgICAgICAgICAgSW50bE1vZHVsZSxcbiAgICAgICAgICAgIERhdGVJbnB1dE1vZHVsZSxcbiAgICAgICAgICAgIENhbGVuZGFyTW9kdWxlLFxuICAgICAgICAgICAgVGltZVBpY2tlck1vZHVsZSxcbiAgICAgICAgICAgIFBvcHVwTW9kdWxlLFxuICAgICAgICAgICAgRXZlbnRzTW9kdWxlLFxuICAgICAgICAgICAgVGVtcGxhdGVzTW9kdWxlXG4gICAgICAgIF0sXG4gICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAgeyBwcm92aWRlOiBUT1VDSF9FTkFCTEVELCB1c2VWYWx1ZTogybUwJHAgfVxuICAgICAgICBdXG4gICAgfSlcbl0sIERhdGVUaW1lUGlja2VyTW9kdWxlKTtcblxuY29uc3QgQ09NUE9ORU5UX01PRFVMRVMkMiA9IFtcbiAgICBDYWxlbmRhcnNNb2R1bGUsXG4gICAgRGF0ZUlucHV0TW9kdWxlLFxuICAgIERhdGVQaWNrZXJNb2R1bGUsXG4gICAgVGltZVBpY2tlck1vZHVsZSxcbiAgICBEYXRlUmFuZ2VNb2R1bGUsXG4gICAgRGF0ZVRpbWVQaWNrZXJNb2R1bGVcbl07XG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIFtOZ01vZHVsZV0oe3sgc2l0ZS5kYXRhLnVybHMuYW5ndWxhclsnbmdtb2R1bGVhcGknXSB9fSlcbiAqIGRlZmluaXRpb24gZm9yIHRoZSBEYXRlIElucHV0cyBjb21wb25lbnRzLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBgdHMtbm8tcnVuXG4gKiAvLyBJbXBvcnQgdGhlIERhdGUgSW5wdXRzIG1vZHVsZVxuICogaW1wb3J0IHsgRGF0ZUlucHV0c01vZHVsZSB9IGZyb20gJ0Bwcm9ncmVzcy9rZW5kby1hbmd1bGFyLWRhdGVpbnB1dHMnO1xuICpcbiAqIC8vIFRoZSBicm93c2VyIHBsYXRmb3JtIHdpdGggYSBjb21waWxlclxuICogaW1wb3J0IHsgcGxhdGZvcm1Ccm93c2VyRHluYW1pYyB9IGZyb20gJ0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXItZHluYW1pYyc7XG4gKlxuICogaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbiAqXG4gKiAvLyBJbXBvcnQgdGhlIGFwcCBjb21wb25lbnRcbiAqIGltcG9ydCB7IEFwcENvbXBvbmVudCB9IGZyb20gJy4vYXBwLmNvbXBvbmVudCc7XG4gKlxuICogLy8gRGVmaW5lIHRoZSBhcHAgbW9kdWxlXG4gKiBfQE5nTW9kdWxlKHtcbiAqICAgICBkZWNsYXJhdGlvbnM6IFtBcHBDb21wb25lbnRdLCAvLyBkZWNsYXJlIHRoZSBhcHAgY29tcG9uZW50XG4gKiAgICAgaW1wb3J0czogICAgICBbQnJvd3Nlck1vZHVsZSwgRGF0ZUlucHV0c01vZHVsZV0sIC8vIGltcG9ydCB0aGUgRGF0ZSBJbnB1dHMgbW9kdWxlXG4gKiAgICAgYm9vdHN0cmFwOiAgICBbQXBwQ29tcG9uZW50XVxuICogfSlcbiAqIGV4cG9ydCBjbGFzcyBBcHBNb2R1bGUge31cbiAqXG4gKiAvLyBDb21waWxlIGFuZCBsYXVuY2ggdGhlIG1vZHVsZVxuICogcGxhdGZvcm1Ccm93c2VyRHluYW1pYygpLmJvb3RzdHJhcE1vZHVsZShBcHBNb2R1bGUpO1xuICpcbiAqIGBgYFxuICovXG5sZXQgRGF0ZUlucHV0c01vZHVsZSA9IGNsYXNzIERhdGVJbnB1dHNNb2R1bGUge1xufTtcbkRhdGVJbnB1dHNNb2R1bGUgPSBfX2RlY29yYXRlKFtcbiAgICBOZ01vZHVsZSh7XG4gICAgICAgIGV4cG9ydHM6IENPTVBPTkVOVF9NT0RVTEVTJDIsXG4gICAgICAgIGltcG9ydHM6IENPTVBPTkVOVF9NT0RVTEVTJDJcbiAgICB9KVxuXSwgRGF0ZUlucHV0c01vZHVsZSk7XG5cbi8qKlxuICogR2VuZXJhdGVkIGJ1bmRsZSBpbmRleC4gRG8gbm90IGVkaXQuXG4gKi9cblxuZXhwb3J0IHsgQ2FsZW5kYXJDb21tb25Nb2R1bGUsIENBTEVOREFSX1JBTkdFX1ZBTElEQVRPUlMsIENBTEVOREFSX1ZBTFVFX0FDQ0VTU09SLCBLRU5ET19JTlBVVF9QUk9WSURFUiwgS0Zvck9mLCBLRm9yT2ZDb250ZXh0LCBIZWFkZXJDb21wb25lbnQsIEhvcml6b250YWxWaWV3TGlzdENvbXBvbmVudCwgQ2FsZW5kYXJNZXNzYWdlcywgTXVsdGlWaWV3Q2FsZW5kYXJDdXN0b21NZXNzYWdlc0NvbXBvbmVudCwgTWVzc2FnZXMsIFJBTkdFX0NBTEVOREFSX1JBTkdFX1ZBTElEQVRPUlMsIFJBTkdFX0NBTEVOREFSX1ZBTFVFX0FDQ0VTU09SLCBOYXZpZ2F0aW9uQ29tcG9uZW50LCBCdXNWaWV3U2VydmljZSwgQ2VudHVyeVZpZXdTZXJ2aWNlLCBEZWNhZGVWaWV3U2VydmljZSwgRGlzYWJsZWREYXRlc1NlcnZpY2UsIENhbGVuZGFyRE9NU2VydmljZSwgTW9udGhWaWV3U2VydmljZSwgTmF2aWdhdGlvblNlcnZpY2UsIFNjcm9sbFN5bmNTZXJ2aWNlLCBTZWxlY3Rpb25TZXJ2aWNlLCBXZWVrTmFtZXNTZXJ2aWNlLCBZZWFyVmlld1NlcnZpY2UsIFRlbXBsYXRlc01vZHVsZSwgQ2VsbFRlbXBsYXRlRGlyZWN0aXZlLCBDZW50dXJ5Q2VsbFRlbXBsYXRlRGlyZWN0aXZlLCBEZWNhZGVDZWxsVGVtcGxhdGVEaXJlY3RpdmUsIEhlYWRlclRpdGxlVGVtcGxhdGVEaXJlY3RpdmUsIE1vbnRoQ2VsbFRlbXBsYXRlRGlyZWN0aXZlLCBOYXZpZ2F0aW9uSXRlbVRlbXBsYXRlRGlyZWN0aXZlLCBXZWVrTnVtYmVyQ2VsbFRlbXBsYXRlRGlyZWN0aXZlLCBZZWFyQ2VsbFRlbXBsYXRlRGlyZWN0aXZlLCBWaWV3TGlzdENvbXBvbmVudCwgVmlld0NvbXBvbmVudCwgUGlja2VyU2VydmljZSwgRGF0ZUlucHV0TWVzc2FnZXMsIERhdGVQaWNrZXJNZXNzYWdlcywgRGF0ZVJhbmdlSW5wdXQsIERhdGVSYW5nZVBvcHVwVGVtcGxhdGVEaXJlY3RpdmUsIERhdGVUaW1lUGlja2VyQ3VzdG9tTWVzc2FnZXNDb21wb25lbnQsIExvY2FsaXplZE1lc3NhZ2VzRGlyZWN0aXZlLCBNZXNzYWdlcyQxLCBUaW1lUGlja2VyTWVzc2FnZXMsIFRpbWVQaWNrZXJDdXN0b21NZXNzYWdlc0NvbXBvbmVudCwgVGltZVNlbGVjdG9yQ3VzdG9tTWVzc2FnZXNDb21wb25lbnQsIERheVBlcmlvZFNlcnZpY2UsIFRpbWVQaWNrZXJET01TZXJ2aWNlLCBIb3Vyc1NlcnZpY2UsIE1pbGxpc2Vjb25kc1NlcnZpY2UsIE1pbnV0ZXNTZXJ2aWNlLCBTZWNvbmRzU2VydmljZSwgVGltZUxpc3RDb21wb25lbnQsIFRpbWVTZWxlY3RvckNvbXBvbmVudCwgVE9VQ0hfRU5BQkxFRCwgU2Nyb2xsZXJTZXJ2aWNlLCBERUZBVUxUX1NDUk9MTEVSX0ZBQ1RPUlksIFNDUk9MTEVSX0ZBQ1RPUllfVE9LRU4sIFZpcnR1YWxpemF0aW9uQ29tcG9uZW50LCBWaXJ0dWFsaXphdGlvbk1vZHVsZSwgQ2FsZW5kYXJDb21wb25lbnQsIERhdGVJbnB1dENvbXBvbmVudCwgRGF0ZVBpY2tlckNvbXBvbmVudCwgVGltZVBpY2tlckNvbXBvbmVudCwgRGF0ZVRpbWVQaWNrZXJDb21wb25lbnQsIE11bHRpVmlld0NhbGVuZGFyQ29tcG9uZW50LCBEYXRlUmFuZ2VDb21wb25lbnQsIERhdGVSYW5nZVBvcHVwQ29tcG9uZW50LCBEYXRlUmFuZ2VFbmRJbnB1dERpcmVjdGl2ZSwgRGF0ZVJhbmdlU3RhcnRJbnB1dERpcmVjdGl2ZSwgRGF0ZVJhbmdlU2VsZWN0aW9uRGlyZWN0aXZlLCBDYWxlbmRhck1vZHVsZSwgQ2FsZW5kYXJzTW9kdWxlLCBEYXRlSW5wdXRNb2R1bGUsIERhdGVQaWNrZXJNb2R1bGUsIERhdGVJbnB1dHNNb2R1bGUsIFRpbWVQaWNrZXJNb2R1bGUsIERhdGVUaW1lUGlja2VyTW9kdWxlLCBNdWx0aVZpZXdDYWxlbmRhck1vZHVsZSwgRGF0ZVJhbmdlTW9kdWxlLCBEYXRlUmFuZ2VTZXJ2aWNlLCBDYWxlbmRhckN1c3RvbU1lc3NhZ2VzQ29tcG9uZW50LCBEYXRlSW5wdXRDdXN0b21NZXNzYWdlc0NvbXBvbmVudCwgRGF0ZVBpY2tlckN1c3RvbU1lc3NhZ2VzQ29tcG9uZW50LCBQcmV2ZW50YWJsZUV2ZW50LCBDYWxlbmRhckxvY2FsaXplZE1lc3NhZ2VzRGlyZWN0aXZlLCBNdWx0aVZpZXdDYWxlbmRhckxvY2FsaXplZE1lc3NhZ2VzRGlyZWN0aXZlLCBEYXRlSW5wdXRMb2NhbGl6ZWRNZXNzYWdlc0RpcmVjdGl2ZSwgRGF0ZVBpY2tlckxvY2FsaXplZE1lc3NhZ2VzRGlyZWN0aXZlLCBUaW1lUGlja2VyTG9jYWxpemVkTWVzc2FnZXNEaXJlY3RpdmUsIFRpbWVTZWxlY3RvckxvY2FsaXplZE1lc3NhZ2VzRGlyZWN0aXZlIH07XG4iXX0=","map":null,"metadata":{},"sourceType":"module"}