{"ast":null,"code":"import BaseSurface from '../core/surface';\nimport { createPromise, promiseAll, bindEvents, elementSize, unbindEvents } from '../util';\nimport RootNode from './root-node';\nimport ShapesQuadTree from '../search/shapes-quad-tree';\nimport SurfaceCursor from './surface-cursor';\nimport ArcNode from './arc-node';\nimport CircleNode from './circle-node';\nimport GroupNode from './group-node';\nimport ImageNode from './image-node';\nimport MultiPathNode from './multi-path-node';\nimport PathNode from './path-node';\nimport RectNode from './rect-node';\nimport TextNode from './text-node';\nimport NODE_MAP from './node-map';\nNODE_MAP.Arc = ArcNode;\nNODE_MAP.Circle = CircleNode;\nNODE_MAP.Group = GroupNode;\nNODE_MAP.Image = ImageNode;\nNODE_MAP.MultiPath = MultiPathNode;\nNODE_MAP.Path = PathNode;\nNODE_MAP.Rect = RectNode;\nNODE_MAP.Text = TextNode;\n\nclass Surface extends BaseSurface {\n  get type() {\n    return \"canvas\";\n  }\n\n  constructor(element, options) {\n    super(element, options);\n    this.element.innerHTML = this._template(this);\n    const canvas = this.element.firstElementChild;\n    const size = elementSize(element);\n    canvas.width = size.width;\n    canvas.height = size.height;\n    this._rootElement = canvas;\n    this._root = new RootNode(canvas, size);\n    this._mouseTrackHandler = this._trackMouse.bind(this);\n    bindEvents(this.element, {\n      click: this._mouseTrackHandler,\n      mousemove: this._mouseTrackHandler\n    });\n  }\n\n  destroy() {\n    super.destroy();\n\n    if (this._root) {\n      this._root.destroy();\n\n      this._root = null;\n    }\n\n    if (this._searchTree) {\n      this._searchTree.clear();\n\n      delete this._searchTree;\n    }\n\n    if (this._cursor) {\n      this._cursor.destroy();\n\n      delete this._cursor;\n    }\n\n    unbindEvents(this.element, {\n      click: this._mouseTrackHandler,\n      mousemove: this._mouseTrackHandler\n    });\n  }\n\n  draw(element) {\n    super.draw(element);\n\n    this._root.load([element], undefined, this.options.cors);\n\n    if (this._searchTree) {\n      this._searchTree.add([element]);\n    }\n  }\n\n  clear() {\n    super.clear();\n\n    this._root.clear();\n\n    if (this._searchTree) {\n      this._searchTree.clear();\n    }\n\n    if (this._cursor) {\n      this._cursor.clear();\n    }\n  }\n\n  eventTarget(e) {\n    if (this._searchTree) {\n      const point = this._surfacePoint(e);\n\n      const shape = this._searchTree.pointShape(point);\n\n      return shape;\n    }\n  }\n\n  image() {\n    const {\n      _root: root,\n      _rootElement: rootElement\n    } = this;\n    const loadingStates = [];\n    root.traverse(childNode => {\n      if (childNode.loading) {\n        loadingStates.push(childNode.loading);\n      }\n    });\n    const promise = createPromise();\n\n    const resolveDataURL = () => {\n      root._invalidate({\n        fixedScale: true\n      });\n\n      try {\n        const data = rootElement.toDataURL();\n        promise.resolve(data);\n      } catch (e) {\n        promise.reject(e);\n      }\n    };\n\n    promiseAll(loadingStates).then(resolveDataURL, resolveDataURL);\n    return promise;\n  }\n\n  suspendTracking() {\n    super.suspendTracking();\n\n    if (this._searchTree) {\n      this._searchTree.clear();\n\n      delete this._searchTree;\n    }\n  }\n\n  resumeTracking() {\n    super.resumeTracking();\n\n    if (!this._searchTree) {\n      this._searchTree = new ShapesQuadTree();\n      const childNodes = this._root.childNodes;\n      const rootElements = [];\n\n      for (let idx = 0; idx < childNodes.length; idx++) {\n        rootElements.push(childNodes[idx].srcElement);\n      }\n\n      this._searchTree.add(rootElements);\n    }\n  }\n\n  _resize() {\n    this._rootElement.width = this._size.width;\n    this._rootElement.height = this._size.height;\n    this._root.size = this._size;\n\n    this._root.invalidate();\n  }\n\n  _template() {\n    return \"<canvas style='width: 100%; height: 100%;'></canvas>\";\n  }\n\n  _enableTracking() {\n    this._searchTree = new ShapesQuadTree();\n    this._cursor = new SurfaceCursor(this);\n\n    super._enableTracking();\n  }\n\n  _trackMouse(e) {\n    if (this._suspendedTracking) {\n      return;\n    }\n\n    const shape = this.eventTarget(e);\n\n    if (e.type !== \"click\") {\n      const currentShape = this._currentShape;\n\n      if (currentShape && currentShape !== shape) {\n        this.trigger(\"mouseleave\", {\n          element: currentShape,\n          originalEvent: e,\n          type: \"mouseleave\"\n        });\n      }\n\n      if (shape && currentShape !== shape) {\n        this.trigger(\"mouseenter\", {\n          element: shape,\n          originalEvent: e,\n          type: \"mouseenter\"\n        });\n      }\n\n      this.trigger(\"mousemove\", {\n        element: shape,\n        originalEvent: e,\n        type: \"mousemove\"\n      });\n      this._currentShape = shape;\n    } else if (shape) {\n      this.trigger(\"click\", {\n        element: shape,\n        originalEvent: e,\n        type: \"click\"\n      });\n    }\n  }\n\n}\n\nexport default Surface;","map":null,"metadata":{},"sourceType":"module"}