{"ast":null,"code":"/**-----------------------------------------------------------------------------------------\n* Copyright © 2020 Progress Software Corporation. All rights reserved.\n* Licensed under commercial license. See LICENSE.md in the project root for more information\n*-------------------------------------------------------------------------------------------*/\nimport { __decorate, __metadata, __param } from 'tslib';\nimport { EventEmitter, ɵɵdefineInjectable, ɵɵinject, LOCALE_ID, Injectable, Inject, Pipe, NgModule } from '@angular/core';\nimport { validatePackage } from '@progress/kendo-licensing';\nimport { dateFormatNames, dateFieldName, firstDay, format, formatDate, formatNumber, load, numberSymbols, parseDate, parseNumber, splitDateFormat, toString, weekendRange, setData, localeInfo } from '@telerik/kendo-intl';\n/**\n * @hidden\n */\n\nimport * as ɵngcc0 from '@angular/core';\nconst packageMetadata = {\n  name: '@progress/kendo-angular-intl',\n  productName: 'Kendo UI for Angular',\n  productCodes: ['KENDOUIANGULAR', 'KENDOUICOMPLETE'],\n  publishDate: 1620213344,\n  version: '',\n  licensingDocsUrl: 'https://www.telerik.com/kendo-angular-ui/my-license/?utm_medium=product&utm_source=kendoangular&utm_campaign=kendo-ui-angular-purchase-license-keys-warning'\n};\nconst DOCS_URL = 'http://www.telerik.com/kendo-angular-ui/components/internationalization/troubleshooting/';\n/**\n * @hidden\n */\n\nconst errorSolutions = {\n  'NoCurrency': `Solution: ${DOCS_URL}#toc-no-currency`,\n  'NoCurrencyDisplay': `Solution: ${DOCS_URL}#toc-no-currency-display`,\n  'NoCurrencyRegion': `Solution: ${DOCS_URL}#toc-no-currency-region`,\n  'NoDateFieldNames': `Solution: ${DOCS_URL}#toc-no-date-filed-names`,\n  'NoFirstDay': `Solution: ${DOCS_URL}#toc-no-first-day`,\n  'NoGMTInfo': `Solution: ${DOCS_URL}#toc-no-gmt-info`,\n  'NoLocale': `Solution: ${DOCS_URL}#toc-no-locale`,\n  'NoValidCurrency': `Solution: ${DOCS_URL}#toc-no-valid-currency`,\n  'NoWeekData': `Solution: ${DOCS_URL}#toc-no-week-data`\n};\n\nfunction formatMessage(error) {\n  const message = error.message;\n  const errorSolution = errorSolutions[Object.keys(errorSolutions).filter(key => message.indexOf(key) === 0)[0]];\n  return errorSolution ? `${message} ${errorSolution}` : message;\n}\n\nfunction intlMethod(fn) {\n  return function (...values) {\n    try {\n      return fn.apply(null, values);\n    } catch (error) {\n      error.message = formatMessage(error);\n      throw error;\n    }\n  };\n}\n/**\n * @hidden\n */\n\n\nconst dateFormatNames$1 = intlMethod(dateFormatNames);\n/**\n * @hidden\n */\n\nconst dateFieldName$1 = intlMethod(dateFieldName);\n/**\n * @hidden\n */\n\nconst firstDay$1 = intlMethod(firstDay);\n/**\n * @hidden\n */\n\nconst format$1 = intlMethod(format);\n/**\n * @hidden\n */\n\nconst formatDate$1 = intlMethod(formatDate);\n/**\n * @hidden\n */\n\nconst formatNumber$1 = intlMethod(formatNumber);\n/**\n * @hidden\n */\n\nconst load$1 = intlMethod(load);\n/**\n * @hidden\n */\n\nconst numberSymbols$1 = intlMethod(numberSymbols);\n/**\n * @hidden\n */\n\nconst parseDate$1 = intlMethod(parseDate);\n/**\n * @hidden\n */\n\nconst parseNumber$1 = intlMethod(parseNumber);\n/**\n * @hidden\n */\n\nconst splitDateFormat$1 = intlMethod(splitDateFormat);\n/**\n * @hidden\n */\n\nconst toString$1 = intlMethod(toString);\n/**\n * @hidden\n */\n\nconst weekendRange$1 = intlMethod(weekendRange);\n/**\n * Sets a pre-built locale.\n *\n * @params data - The pre-built locale data.\n */\n\nconst setData$1 = data => setData(data);\n/**\n * Retrieves the locale data for the specified locale.\n *\n * @params locale - The locale id.\n * @returns data - The locale data.\n */\n\n\nconst localeData = locale => {\n  try {\n    return localeInfo(locale);\n  } catch (error) {\n    error.message = formatMessage(error);\n    throw error;\n  }\n};\n\nconst LOCALE_REGEX = /_/g;\n/**\n * @hidden\n */\n\nfunction cldrServiceFactory(localeId) {\n  return new CldrIntlService(localeId);\n}\n/**\n * An abstract base class that implements\n * the Internationalization service methods\n * for the current locale.\n */\n\n\nlet IntlService = class IntlService {\n  /**\n   * @hidden\n   */\n  constructor() {\n    /**\n     * @hidden\n     */\n    this.changes = new EventEmitter();\n    validatePackage(packageMetadata);\n  }\n  /**\n   * Notifies that the service was changed.\n   */\n\n\n  notify() {\n    this.changes.emit();\n  }\n\n};\n\nIntlService.ɵfac = function IntlService_Factory(t) {\n  return new (t || IntlService)();\n};\n\nIntlService.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n  token: IntlService,\n  factory: function IntlService_Factory(t) {\n    let r = null;\n\n    if (t) {\n      r = new t();\n    } else {\n      r = cldrServiceFactory(ɵngcc0.ɵɵinject(LOCALE_ID));\n    }\n\n    return r;\n  },\n  providedIn: 'root'\n});\nIntlService.ngInjectableDef = ɵɵdefineInjectable({\n  factory: function IntlService_Factory() {\n    return cldrServiceFactory(ɵɵinject(LOCALE_ID));\n  },\n  token: IntlService,\n  providedIn: \"root\"\n});\nIntlService = __decorate([__metadata(\"design:paramtypes\", [])], IntlService);\n/**\n * The Internationalization service implemented by using\n * the CLDR Database via the `@telerik/kendo-intl` package.\n */\n\nlet CldrIntlService = /*#__PURE__*/(() => {\n  let CldrIntlService = class CldrIntlService extends IntlService {\n    /**\n     * Creates a new instance of the service with the ID of the specified locale.\n     *\n     * Note that the parts of the locale ID can be separated by either `_` (underscore)\n     * or `-` (dash).\n     *\n     * @param localeId - The default locale ID.\n     */\n    constructor(localeId) {\n      super();\n      this.localeId = localeId;\n    }\n    /**\n     * Gets or sets the current locale ID.\n     */\n\n\n    get localeId() {\n      return this.locale;\n    }\n\n    set localeId(value) {\n      // Angular locales use underscore, for example, en_US\n      // while IETF BCP-47 specifies a dash.\n      // https://tools.ietf.org/html/bcp47\n      const locale = value.replace(LOCALE_REGEX, '-');\n\n      if (locale !== this.locale) {\n        this.locale = locale;\n        this.notify();\n      }\n    }\n    /**\n     * Formats a string with placeholders such as\n     * `Total amount {0:c}`.\n     *\n     * @param format - The format string.\n     * @param values - One or more values to output in the format string placeholders.\n     * @return - The formatted string.\n     */\n\n\n    format(format$$1, ...values) {\n      return format$1(format$$1, values, this.localeId);\n    }\n    /**\n     * Converts an object into a string based on the specified format.\n     *\n     * @param value - The value to format.\n     * @param format - The format to use.\n     * @param localeId - The locale ID to use in place of the default one. Optional.\n     * @return The formatted object.\n     */\n\n\n    toString(value, format$$1, localeId) {\n      return toString$1(value, format$$1, localeId || this.localeId);\n    }\n    /**\n     * Converts a `Date` object into a string based on the specified format.\n     * If no format is provided, the default short date format is used.\n     *\n     * @param value - The date to format.\n     * @param format - The format string or options.\n     * @param localeId - The locale ID to use in place of the default one. Optional.\n     * @return The formatted date.\n     */\n\n\n    formatDate(value, format$$1, localeId) {\n      return formatDate$1(value, format$$1, localeId || this.localeId);\n    }\n    /**\n     * Converts a string into a `Date` object based on the specified format.\n     *\n     * @param value - The string to convert.\n     * @param format - The format strings or options.\n     * @param localeId - The locale ID to use in place of the default one. Optional.\n     * @return The parsed date.\n     */\n\n\n    parseDate(value, format$$1, localeId) {\n      return parseDate$1(value, format$$1, localeId || this.localeId);\n    }\n    /**\n     * Converts a string into a `Number`.\n     *\n     * @param value - The string to convert.\n     * @param format - The format string or options.\n     * @param localeId - The locale ID to use in place of the default one. Optional.\n     * @return The parsed number.\n     */\n\n\n    parseNumber(value, format$$1, localeId) {\n      return parseNumber$1(value, localeId || this.localeId, format$$1);\n    }\n    /**\n     * Converts a `Number` into a string based on the specified format.\n     *\n     * @param value - The number to format.\n     * @param format - The format string or options.\n     * @param localeId - The locale ID to use in place of the default one. Optional.\n     * @return The formatted number.\n     */\n\n\n    formatNumber(value, format$$1, localeId) {\n      return formatNumber$1(value, format$$1, localeId || this.localeId);\n    }\n    /**\n     * Returns the date names from the current locale based on the option.\n     *\n     * The available `type` values are:\n     * - `era`\n     * - `year`\n     * - `quarter`\n     * - `month`\n     * - `week`\n     * - `day`\n     * - `dayperiod`\n     * - `hour`\n     * - `minute`\n     * - `second`\n     * - `zone`\n     *\n     * The available `nameType` values are:\n     * - `wide`\n     * - `narrow`\n     * - `short`\n     *\n     * @param options - Detailed configuration for the desired date field name.\n     * @param localeId - The locale ID to use in place of the default one. Optional.\n     * @return - The day names from the current locale based on the option.\n     * @returns The localized date field name from the current locale based on the option.\n     *\n     * @example\n     * ```\n     * dateFieldName({ type: 'day' });                      //returns 'day';\n     * dateFieldName({ type: 'day', nameType: 'wide' });    //returns 'day';\n     * dateFieldName({ type: 'month', nameType: 'short' }); //returns 'mo.';\n     * dateFieldName({ type: 'month', nameType: 'wide' });  //returns 'month';\n     * ```\n     */\n\n\n    dateFieldName(options, localeId) {\n      return dateFieldName$1(options, localeId || this.localeId);\n    }\n    /**\n     * Returns a localized date field name based on specific dateFieldName options.\n     *\n     * The available type values are:\n     * - `day`\n     * - `dayperiod`\n     * - `months`\n     * - `quarters`\n     * - `eras`\n     *\n     * @param options - Detailed configuration for the desired date format.\n     * @param localeId - The locale ID to use in place of the default one. Optional.\n     * @return - The day names from the current locale based on the option.\n     */\n\n\n    dateFormatNames(options, localeId) {\n      return dateFormatNames$1(localeId || this.localeId, options);\n    }\n    /**\n     * Splits the date format into objects containing information about each part of the pattern.\n     *\n     * @param format The format string or options.\n     * @param localeId The optional locale id. If not specified, the `\"en\"` locale id is used.\n     * @returns The date format parts.\n     */\n\n\n    splitDateFormat(format$$1, localeId) {\n      return splitDateFormat$1(format$$1, localeId || this.localeId);\n    }\n    /**\n     * Returns the number symbols from the current locale based on the option.\n     *\n     * @param localeId - The locale ID to use in place of the default one. Optional.\n     * @return - The number symbols from the current locale.\n     */\n\n\n    numberSymbols(localeId) {\n      return numberSymbols$1(localeId || this.localeId);\n    }\n    /**\n     * Returns the first day index starting from Sunday.\n     *\n     * @param localeId - The locale ID. Defaults to the current locale ID.\n     * @return - The index of the first day of the week (0 == Sunday).\n     */\n\n\n    firstDay(localeId) {\n      return firstDay$1(localeId || this.localeId);\n    }\n    /**\n     * Returns the start and end index of the locale weekend starting from Sunday.\n     *\n     * @param localeId - The locale ID. Defaults to the current locale ID.\n     * @return - The the start and end index of the locale weekend (0 == Sunday).\n     */\n\n\n    weekendRange(localeId) {\n      return weekendRange$1(localeId || this.localeId);\n    }\n\n  };\n\n  CldrIntlService.ɵfac = function CldrIntlService_Factory(t) {\n    return new (t || CldrIntlService)(ɵngcc0.ɵɵinject(LOCALE_ID));\n  };\n\n  CldrIntlService.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: CldrIntlService,\n    factory: function (t) {\n      return CldrIntlService.ɵfac(t);\n    }\n  });\n  CldrIntlService = __decorate([__param(0, Inject(LOCALE_ID)), __metadata(\"design:paramtypes\", [String])], CldrIntlService);\n  return CldrIntlService;\n})();\n\nconst isNumeric = value => !isNaN(value - parseFloat(value));\n\nconst ɵ0 = isNumeric;\n/**\n * Formats a date value to a string based on the requested format.\n * This pipe uses the [IntlService]({% slug api_intl_intlservice %}).\n *\n * @example\n * ```ng-template-no-run\n * <ul>\n *    <li>{{date | kendoDate }}</li>\n *    <li>{{milliseconds | kendoDate: 'M/dd/yyy' }}</li>\n *    <li>{{stringDate | kendoDate: 'G' }}</li>\n * </ul>\n * ```\n */\n\nlet DatePipe = /*#__PURE__*/(() => {\n  let DatePipe = class DatePipe {\n    /**\n     * @hidden\n     */\n    constructor(intlService) {\n      this.intlService = intlService;\n    }\n    /**\n     * Converts a `Date` object into a string based on the specified format.\n     * If no format is provided, the default short date format is used.\n     *\n     * @param value - The date to format.\n     * @param format - The format string or options.\n     * @param localeId - (Optional) The ID of the locale which will be used instead of the default one.\n     * @return - The formatted date.\n     */\n\n\n    transform(value, format$$1 = \"\", localeId) {\n      value = this.normalize(value);\n\n      if (value) {\n        return this.intlService.formatDate(value, format$$1, localeId);\n      }\n\n      return value;\n    }\n\n    normalize(value) {\n      if (value && typeof value === 'string') {\n        value = this.intlService.parseDate(value);\n      } else if (value && isNumeric(value)) {\n        value = new Date(parseFloat(value));\n      }\n\n      return value;\n    }\n\n  };\n\n  DatePipe.ɵfac = function DatePipe_Factory(t) {\n    return new (t || DatePipe)(ɵngcc0.ɵɵdirectiveInject(IntlService, 16));\n  };\n\n  DatePipe.ɵpipe = /*@__PURE__*/ɵngcc0.ɵɵdefinePipe({\n    name: \"kendoDate\",\n    type: DatePipe,\n    pure: true\n  });\n  DatePipe = __decorate([__metadata(\"design:paramtypes\", [IntlService])], DatePipe);\n  /**\n   * Formats a number value to a string based on the requested format.\n   * This pipe uses the [`IntlService`]({% slug api_intl_intlservice %}).\n   *\n   * @example\n   * ```ng-template-no-run\n   *   <ul>\n   *     <li>{{decimal | kendoNumber:'c' }}</li>\n   *     <li>{{stringNumber | kendoNumber:'p' }}</li>\n   *     <li>{{int | kendoNumber:'##.00' }}</li>\n   *  </ul>\n   * ```\n   */\n\n  return DatePipe;\n})();\nlet NumberPipe = /*#__PURE__*/(() => {\n  let NumberPipe = class NumberPipe {\n    /**\n     * @hidden\n     */\n    constructor(intlService) {\n      this.intlService = intlService;\n    }\n    /**\n     * Converts a `Number` object into a string based on the specified format.\n     * If no format is provided, the value is formatted as decimal number using the\n     * [`\"n\"`](https://github.com/telerik/kendo-intl/blob/master/docs/num-formatting/index.md#standard) format.\n     *\n     * @param value - The numer that will be formatted.\n     * @param format - The format string or options.\n     * @param localeId - (Optional) The locale ID that will be used in place of the default one.\n     * @return - The formatted number.\n     */\n\n\n    transform(value, format$$1, localeId) {\n      if (typeof value === 'string') {\n        value = this.intlService.parseNumber(value);\n      }\n\n      if (value !== null && value !== undefined) {\n        return this.intlService.formatNumber(value, format$$1, localeId);\n      }\n\n      return value;\n    }\n\n  };\n\n  NumberPipe.ɵfac = function NumberPipe_Factory(t) {\n    return new (t || NumberPipe)(ɵngcc0.ɵɵdirectiveInject(IntlService, 16));\n  };\n\n  NumberPipe.ɵpipe = /*@__PURE__*/ɵngcc0.ɵɵdefinePipe({\n    name: \"kendoNumber\",\n    type: NumberPipe,\n    pure: true\n  });\n  NumberPipe = __decorate([__metadata(\"design:paramtypes\", [IntlService])], NumberPipe);\n  return NumberPipe;\n})();\nconst pipes = [DatePipe, NumberPipe];\n/**\n * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }}docs/ts/latest/guide/ngmodule.html)\n * definition for the Intl services.\n */\n\nlet IntlModule = /*#__PURE__*/(() => {\n  let IntlModule = class IntlModule {};\n\n  IntlModule.ɵfac = function IntlModule_Factory(t) {\n    return new (t || IntlModule)();\n  };\n\n  IntlModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: IntlModule\n  });\n  IntlModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({});\n  return IntlModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IntlModule, {\n    declarations: [DatePipe, NumberPipe],\n    exports: [DatePipe, NumberPipe]\n  });\n})();\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { cldrServiceFactory, IntlService, CldrIntlService, DatePipe, ɵ0, NumberPipe, IntlModule, dateFormatNames$1 as dateFormatNames, dateFieldName$1 as dateFieldName, firstDay$1 as firstDay, format$1 as format, formatDate$1 as formatDate, formatNumber$1 as formatNumber, load$1 as load, numberSymbols$1 as numberSymbols, parseDate$1 as parseDate, parseNumber$1 as parseNumber, splitDateFormat$1 as splitDateFormat, toString$1 as toString, weekendRange$1 as weekendRange, setData$1 as setData, localeData }; //# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VzIjpbImluZGV4LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozt5Q0FBRTtBQUNGO0FBQ0EsMEJBTUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7dUpBQUU7QUFDRiw4QkFFRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7c0dBQUU7QUFDRix1QkFJRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7NEdBQUU7QUFDRix5QkFJRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozt5TEFNZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXNDb250ZW50IjpbIi8qKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4qIENvcHlyaWdodCDCqSAyMDIwIFByb2dyZXNzIFNvZnR3YXJlIENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuKiBMaWNlbnNlZCB1bmRlciBjb21tZXJjaWFsIGxpY2Vuc2UuIFNlZSBMSUNFTlNFLm1kIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIG1vcmUgaW5mb3JtYXRpb25cbiotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmltcG9ydCB7IF9fZGVjb3JhdGUsIF9fbWV0YWRhdGEsIF9fcGFyYW0gfSBmcm9tICd0c2xpYic7XG5pbXBvcnQgeyBFdmVudEVtaXR0ZXIsIMm1ybVkZWZpbmVJbmplY3RhYmxlLCDJtcm1aW5qZWN0LCBMT0NBTEVfSUQsIEluamVjdGFibGUsIEluamVjdCwgUGlwZSwgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IHZhbGlkYXRlUGFja2FnZSB9IGZyb20gJ0Bwcm9ncmVzcy9rZW5kby1saWNlbnNpbmcnO1xuaW1wb3J0IHsgZGF0ZUZvcm1hdE5hbWVzLCBkYXRlRmllbGROYW1lLCBmaXJzdERheSwgZm9ybWF0LCBmb3JtYXREYXRlLCBmb3JtYXROdW1iZXIsIGxvYWQsIG51bWJlclN5bWJvbHMsIHBhcnNlRGF0ZSwgcGFyc2VOdW1iZXIsIHNwbGl0RGF0ZUZvcm1hdCwgdG9TdHJpbmcsIHdlZWtlbmRSYW5nZSwgc2V0RGF0YSwgbG9jYWxlSW5mbyB9IGZyb20gJ0B0ZWxlcmlrL2tlbmRvLWludGwnO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgcGFja2FnZU1ldGFkYXRhID0ge1xuICAgIG5hbWU6ICdAcHJvZ3Jlc3Mva2VuZG8tYW5ndWxhci1pbnRsJyxcbiAgICBwcm9kdWN0TmFtZTogJ0tlbmRvIFVJIGZvciBBbmd1bGFyJyxcbiAgICBwcm9kdWN0Q29kZXM6IFsnS0VORE9VSUFOR1VMQVInLCAnS0VORE9VSUNPTVBMRVRFJ10sXG4gICAgcHVibGlzaERhdGU6IDE2MjAyMTMzNDQsXG4gICAgdmVyc2lvbjogJycsXG4gICAgbGljZW5zaW5nRG9jc1VybDogJ2h0dHBzOi8vd3d3LnRlbGVyaWsuY29tL2tlbmRvLWFuZ3VsYXItdWkvbXktbGljZW5zZS8/dXRtX21lZGl1bT1wcm9kdWN0JnV0bV9zb3VyY2U9a2VuZG9hbmd1bGFyJnV0bV9jYW1wYWlnbj1rZW5kby11aS1hbmd1bGFyLXB1cmNoYXNlLWxpY2Vuc2Uta2V5cy13YXJuaW5nJ1xufTtcblxuY29uc3QgRE9DU19VUkwgPSAnaHR0cDovL3d3dy50ZWxlcmlrLmNvbS9rZW5kby1hbmd1bGFyLXVpL2NvbXBvbmVudHMvaW50ZXJuYXRpb25hbGl6YXRpb24vdHJvdWJsZXNob290aW5nLyc7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgZXJyb3JTb2x1dGlvbnMgPSB7XG4gICAgJ05vQ3VycmVuY3knOiBgU29sdXRpb246ICR7RE9DU19VUkx9I3RvYy1uby1jdXJyZW5jeWAsXG4gICAgJ05vQ3VycmVuY3lEaXNwbGF5JzogYFNvbHV0aW9uOiAke0RPQ1NfVVJMfSN0b2Mtbm8tY3VycmVuY3ktZGlzcGxheWAsXG4gICAgJ05vQ3VycmVuY3lSZWdpb24nOiBgU29sdXRpb246ICR7RE9DU19VUkx9I3RvYy1uby1jdXJyZW5jeS1yZWdpb25gLFxuICAgICdOb0RhdGVGaWVsZE5hbWVzJzogYFNvbHV0aW9uOiAke0RPQ1NfVVJMfSN0b2Mtbm8tZGF0ZS1maWxlZC1uYW1lc2AsXG4gICAgJ05vRmlyc3REYXknOiBgU29sdXRpb246ICR7RE9DU19VUkx9I3RvYy1uby1maXJzdC1kYXlgLFxuICAgICdOb0dNVEluZm8nOiBgU29sdXRpb246ICR7RE9DU19VUkx9I3RvYy1uby1nbXQtaW5mb2AsXG4gICAgJ05vTG9jYWxlJzogYFNvbHV0aW9uOiAke0RPQ1NfVVJMfSN0b2Mtbm8tbG9jYWxlYCxcbiAgICAnTm9WYWxpZEN1cnJlbmN5JzogYFNvbHV0aW9uOiAke0RPQ1NfVVJMfSN0b2Mtbm8tdmFsaWQtY3VycmVuY3lgLFxuICAgICdOb1dlZWtEYXRhJzogYFNvbHV0aW9uOiAke0RPQ1NfVVJMfSN0b2Mtbm8td2Vlay1kYXRhYFxufTtcblxuZnVuY3Rpb24gZm9ybWF0TWVzc2FnZShlcnJvcikge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBlcnJvci5tZXNzYWdlO1xuICAgIGNvbnN0IGVycm9yU29sdXRpb24gPSBlcnJvclNvbHV0aW9uc1tPYmplY3Qua2V5cyhlcnJvclNvbHV0aW9ucykuZmlsdGVyKGtleSA9PiBtZXNzYWdlLmluZGV4T2Yoa2V5KSA9PT0gMClbMF1dO1xuICAgIHJldHVybiBlcnJvclNvbHV0aW9uID8gYCR7bWVzc2FnZX0gJHtlcnJvclNvbHV0aW9ufWAgOiBtZXNzYWdlO1xufVxuZnVuY3Rpb24gaW50bE1ldGhvZChmbikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoLi4udmFsdWVzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkobnVsbCwgdmFsdWVzKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGVycm9yLm1lc3NhZ2UgPSBmb3JtYXRNZXNzYWdlKGVycm9yKTtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfTtcbn1cbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBkYXRlRm9ybWF0TmFtZXMkMSA9IGludGxNZXRob2QoZGF0ZUZvcm1hdE5hbWVzKTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBkYXRlRmllbGROYW1lJDEgPSBpbnRsTWV0aG9kKGRhdGVGaWVsZE5hbWUpO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGZpcnN0RGF5JDEgPSBpbnRsTWV0aG9kKGZpcnN0RGF5KTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBmb3JtYXQkMSA9IGludGxNZXRob2QoZm9ybWF0KTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBmb3JtYXREYXRlJDEgPSBpbnRsTWV0aG9kKGZvcm1hdERhdGUpO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGZvcm1hdE51bWJlciQxID0gaW50bE1ldGhvZChmb3JtYXROdW1iZXIpO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGxvYWQkMSA9IGludGxNZXRob2QobG9hZCk7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgbnVtYmVyU3ltYm9scyQxID0gaW50bE1ldGhvZChudW1iZXJTeW1ib2xzKTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBwYXJzZURhdGUkMSA9IGludGxNZXRob2QocGFyc2VEYXRlKTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBwYXJzZU51bWJlciQxID0gaW50bE1ldGhvZChwYXJzZU51bWJlcik7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3Qgc3BsaXREYXRlRm9ybWF0JDEgPSBpbnRsTWV0aG9kKHNwbGl0RGF0ZUZvcm1hdCk7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgdG9TdHJpbmckMSA9IGludGxNZXRob2QodG9TdHJpbmcpO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IHdlZWtlbmRSYW5nZSQxID0gaW50bE1ldGhvZCh3ZWVrZW5kUmFuZ2UpO1xuLyoqXG4gKiBTZXRzIGEgcHJlLWJ1aWx0IGxvY2FsZS5cbiAqXG4gKiBAcGFyYW1zIGRhdGEgLSBUaGUgcHJlLWJ1aWx0IGxvY2FsZSBkYXRhLlxuICovXG5jb25zdCBzZXREYXRhJDEgPSAoZGF0YSkgPT4gc2V0RGF0YShkYXRhKTtcbi8qKlxuICogUmV0cmlldmVzIHRoZSBsb2NhbGUgZGF0YSBmb3IgdGhlIHNwZWNpZmllZCBsb2NhbGUuXG4gKlxuICogQHBhcmFtcyBsb2NhbGUgLSBUaGUgbG9jYWxlIGlkLlxuICogQHJldHVybnMgZGF0YSAtIFRoZSBsb2NhbGUgZGF0YS5cbiAqL1xuY29uc3QgbG9jYWxlRGF0YSA9IChsb2NhbGUpID0+IHtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gbG9jYWxlSW5mbyhsb2NhbGUpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgZXJyb3IubWVzc2FnZSA9IGZvcm1hdE1lc3NhZ2UoZXJyb3IpO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG59O1xuXG5jb25zdCBMT0NBTEVfUkVHRVggPSAvXy9nO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmZ1bmN0aW9uIGNsZHJTZXJ2aWNlRmFjdG9yeShsb2NhbGVJZCkge1xuICAgIHJldHVybiBuZXcgQ2xkckludGxTZXJ2aWNlKGxvY2FsZUlkKTtcbn1cbi8qKlxuICogQW4gYWJzdHJhY3QgYmFzZSBjbGFzcyB0aGF0IGltcGxlbWVudHNcbiAqIHRoZSBJbnRlcm5hdGlvbmFsaXphdGlvbiBzZXJ2aWNlIG1ldGhvZHNcbiAqIGZvciB0aGUgY3VycmVudCBsb2NhbGUuXG4gKi9cbmxldCBJbnRsU2VydmljZSA9IGNsYXNzIEludGxTZXJ2aWNlIHtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaGlkZGVuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNoYW5nZXMgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHZhbGlkYXRlUGFja2FnZShwYWNrYWdlTWV0YWRhdGEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBOb3RpZmllcyB0aGF0IHRoZSBzZXJ2aWNlIHdhcyBjaGFuZ2VkLlxuICAgICAqL1xuICAgIG5vdGlmeSgpIHtcbiAgICAgICAgdGhpcy5jaGFuZ2VzLmVtaXQoKTtcbiAgICB9XG59O1xuSW50bFNlcnZpY2UubmdJbmplY3RhYmxlRGVmID0gybXJtWRlZmluZUluamVjdGFibGUoeyBmYWN0b3J5OiBmdW5jdGlvbiBJbnRsU2VydmljZV9GYWN0b3J5KCkgeyByZXR1cm4gY2xkclNlcnZpY2VGYWN0b3J5KMm1ybVpbmplY3QoTE9DQUxFX0lEKSk7IH0sIHRva2VuOiBJbnRsU2VydmljZSwgcHJvdmlkZWRJbjogXCJyb290XCIgfSk7XG5JbnRsU2VydmljZSA9IF9fZGVjb3JhdGUoW1xuICAgIEluamVjdGFibGUoe1xuICAgICAgICBwcm92aWRlZEluOiAncm9vdCcsXG4gICAgICAgIHVzZUZhY3Rvcnk6IGNsZHJTZXJ2aWNlRmFjdG9yeSxcbiAgICAgICAgZGVwczogW0xPQ0FMRV9JRF1cbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBJbnRsU2VydmljZSk7XG4vKipcbiAqIFRoZSBJbnRlcm5hdGlvbmFsaXphdGlvbiBzZXJ2aWNlIGltcGxlbWVudGVkIGJ5IHVzaW5nXG4gKiB0aGUgQ0xEUiBEYXRhYmFzZSB2aWEgdGhlIGBAdGVsZXJpay9rZW5kby1pbnRsYCBwYWNrYWdlLlxuICovXG5sZXQgQ2xkckludGxTZXJ2aWNlID0gY2xhc3MgQ2xkckludGxTZXJ2aWNlIGV4dGVuZHMgSW50bFNlcnZpY2Uge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgdGhlIHNlcnZpY2Ugd2l0aCB0aGUgSUQgb2YgdGhlIHNwZWNpZmllZCBsb2NhbGUuXG4gICAgICpcbiAgICAgKiBOb3RlIHRoYXQgdGhlIHBhcnRzIG9mIHRoZSBsb2NhbGUgSUQgY2FuIGJlIHNlcGFyYXRlZCBieSBlaXRoZXIgYF9gICh1bmRlcnNjb3JlKVxuICAgICAqIG9yIGAtYCAoZGFzaCkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbG9jYWxlSWQgLSBUaGUgZGVmYXVsdCBsb2NhbGUgSUQuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobG9jYWxlSWQpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5sb2NhbGVJZCA9IGxvY2FsZUlkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIG9yIHNldHMgdGhlIGN1cnJlbnQgbG9jYWxlIElELlxuICAgICAqL1xuICAgIGdldCBsb2NhbGVJZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlO1xuICAgIH1cbiAgICBzZXQgbG9jYWxlSWQodmFsdWUpIHtcbiAgICAgICAgLy8gQW5ndWxhciBsb2NhbGVzIHVzZSB1bmRlcnNjb3JlLCBmb3IgZXhhbXBsZSwgZW5fVVNcbiAgICAgICAgLy8gd2hpbGUgSUVURiBCQ1AtNDcgc3BlY2lmaWVzIGEgZGFzaC5cbiAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL2JjcDQ3XG4gICAgICAgIGNvbnN0IGxvY2FsZSA9IHZhbHVlLnJlcGxhY2UoTE9DQUxFX1JFR0VYLCAnLScpO1xuICAgICAgICBpZiAobG9jYWxlICE9PSB0aGlzLmxvY2FsZSkge1xuICAgICAgICAgICAgdGhpcy5sb2NhbGUgPSBsb2NhbGU7XG4gICAgICAgICAgICB0aGlzLm5vdGlmeSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZvcm1hdHMgYSBzdHJpbmcgd2l0aCBwbGFjZWhvbGRlcnMgc3VjaCBhc1xuICAgICAqIGBUb3RhbCBhbW91bnQgezA6Y31gLlxuICAgICAqXG4gICAgICogQHBhcmFtIGZvcm1hdCAtIFRoZSBmb3JtYXQgc3RyaW5nLlxuICAgICAqIEBwYXJhbSB2YWx1ZXMgLSBPbmUgb3IgbW9yZSB2YWx1ZXMgdG8gb3V0cHV0IGluIHRoZSBmb3JtYXQgc3RyaW5nIHBsYWNlaG9sZGVycy5cbiAgICAgKiBAcmV0dXJuIC0gVGhlIGZvcm1hdHRlZCBzdHJpbmcuXG4gICAgICovXG4gICAgZm9ybWF0KGZvcm1hdCQkMSwgLi4udmFsdWVzKSB7XG4gICAgICAgIHJldHVybiBmb3JtYXQkMShmb3JtYXQkJDEsIHZhbHVlcywgdGhpcy5sb2NhbGVJZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGFuIG9iamVjdCBpbnRvIGEgc3RyaW5nIGJhc2VkIG9uIHRoZSBzcGVjaWZpZWQgZm9ybWF0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGZvcm1hdC5cbiAgICAgKiBAcGFyYW0gZm9ybWF0IC0gVGhlIGZvcm1hdCB0byB1c2UuXG4gICAgICogQHBhcmFtIGxvY2FsZUlkIC0gVGhlIGxvY2FsZSBJRCB0byB1c2UgaW4gcGxhY2Ugb2YgdGhlIGRlZmF1bHQgb25lLiBPcHRpb25hbC5cbiAgICAgKiBAcmV0dXJuIFRoZSBmb3JtYXR0ZWQgb2JqZWN0LlxuICAgICAqL1xuICAgIHRvU3RyaW5nKHZhbHVlLCBmb3JtYXQkJDEsIGxvY2FsZUlkKSB7XG4gICAgICAgIHJldHVybiB0b1N0cmluZyQxKHZhbHVlLCBmb3JtYXQkJDEsIGxvY2FsZUlkIHx8IHRoaXMubG9jYWxlSWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhIGBEYXRlYCBvYmplY3QgaW50byBhIHN0cmluZyBiYXNlZCBvbiB0aGUgc3BlY2lmaWVkIGZvcm1hdC5cbiAgICAgKiBJZiBubyBmb3JtYXQgaXMgcHJvdmlkZWQsIHRoZSBkZWZhdWx0IHNob3J0IGRhdGUgZm9ybWF0IGlzIHVzZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgLSBUaGUgZGF0ZSB0byBmb3JtYXQuXG4gICAgICogQHBhcmFtIGZvcm1hdCAtIFRoZSBmb3JtYXQgc3RyaW5nIG9yIG9wdGlvbnMuXG4gICAgICogQHBhcmFtIGxvY2FsZUlkIC0gVGhlIGxvY2FsZSBJRCB0byB1c2UgaW4gcGxhY2Ugb2YgdGhlIGRlZmF1bHQgb25lLiBPcHRpb25hbC5cbiAgICAgKiBAcmV0dXJuIFRoZSBmb3JtYXR0ZWQgZGF0ZS5cbiAgICAgKi9cbiAgICBmb3JtYXREYXRlKHZhbHVlLCBmb3JtYXQkJDEsIGxvY2FsZUlkKSB7XG4gICAgICAgIHJldHVybiBmb3JtYXREYXRlJDEodmFsdWUsIGZvcm1hdCQkMSwgbG9jYWxlSWQgfHwgdGhpcy5sb2NhbGVJZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGEgc3RyaW5nIGludG8gYSBgRGF0ZWAgb2JqZWN0IGJhc2VkIG9uIHRoZSBzcGVjaWZpZWQgZm9ybWF0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIC0gVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgICAqIEBwYXJhbSBmb3JtYXQgLSBUaGUgZm9ybWF0IHN0cmluZ3Mgb3Igb3B0aW9ucy5cbiAgICAgKiBAcGFyYW0gbG9jYWxlSWQgLSBUaGUgbG9jYWxlIElEIHRvIHVzZSBpbiBwbGFjZSBvZiB0aGUgZGVmYXVsdCBvbmUuIE9wdGlvbmFsLlxuICAgICAqIEByZXR1cm4gVGhlIHBhcnNlZCBkYXRlLlxuICAgICAqL1xuICAgIHBhcnNlRGF0ZSh2YWx1ZSwgZm9ybWF0JCQxLCBsb2NhbGVJZCkge1xuICAgICAgICByZXR1cm4gcGFyc2VEYXRlJDEodmFsdWUsIGZvcm1hdCQkMSwgbG9jYWxlSWQgfHwgdGhpcy5sb2NhbGVJZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGEgc3RyaW5nIGludG8gYSBgTnVtYmVyYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICAgKiBAcGFyYW0gZm9ybWF0IC0gVGhlIGZvcm1hdCBzdHJpbmcgb3Igb3B0aW9ucy5cbiAgICAgKiBAcGFyYW0gbG9jYWxlSWQgLSBUaGUgbG9jYWxlIElEIHRvIHVzZSBpbiBwbGFjZSBvZiB0aGUgZGVmYXVsdCBvbmUuIE9wdGlvbmFsLlxuICAgICAqIEByZXR1cm4gVGhlIHBhcnNlZCBudW1iZXIuXG4gICAgICovXG4gICAgcGFyc2VOdW1iZXIodmFsdWUsIGZvcm1hdCQkMSwgbG9jYWxlSWQpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlTnVtYmVyJDEodmFsdWUsIGxvY2FsZUlkIHx8IHRoaXMubG9jYWxlSWQsIGZvcm1hdCQkMSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGEgYE51bWJlcmAgaW50byBhIHN0cmluZyBiYXNlZCBvbiB0aGUgc3BlY2lmaWVkIGZvcm1hdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBudW1iZXIgdG8gZm9ybWF0LlxuICAgICAqIEBwYXJhbSBmb3JtYXQgLSBUaGUgZm9ybWF0IHN0cmluZyBvciBvcHRpb25zLlxuICAgICAqIEBwYXJhbSBsb2NhbGVJZCAtIFRoZSBsb2NhbGUgSUQgdG8gdXNlIGluIHBsYWNlIG9mIHRoZSBkZWZhdWx0IG9uZS4gT3B0aW9uYWwuXG4gICAgICogQHJldHVybiBUaGUgZm9ybWF0dGVkIG51bWJlci5cbiAgICAgKi9cbiAgICBmb3JtYXROdW1iZXIodmFsdWUsIGZvcm1hdCQkMSwgbG9jYWxlSWQpIHtcbiAgICAgICAgcmV0dXJuIGZvcm1hdE51bWJlciQxKHZhbHVlLCBmb3JtYXQkJDEsIGxvY2FsZUlkIHx8IHRoaXMubG9jYWxlSWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBkYXRlIG5hbWVzIGZyb20gdGhlIGN1cnJlbnQgbG9jYWxlIGJhc2VkIG9uIHRoZSBvcHRpb24uXG4gICAgICpcbiAgICAgKiBUaGUgYXZhaWxhYmxlIGB0eXBlYCB2YWx1ZXMgYXJlOlxuICAgICAqIC0gYGVyYWBcbiAgICAgKiAtIGB5ZWFyYFxuICAgICAqIC0gYHF1YXJ0ZXJgXG4gICAgICogLSBgbW9udGhgXG4gICAgICogLSBgd2Vla2BcbiAgICAgKiAtIGBkYXlgXG4gICAgICogLSBgZGF5cGVyaW9kYFxuICAgICAqIC0gYGhvdXJgXG4gICAgICogLSBgbWludXRlYFxuICAgICAqIC0gYHNlY29uZGBcbiAgICAgKiAtIGB6b25lYFxuICAgICAqXG4gICAgICogVGhlIGF2YWlsYWJsZSBgbmFtZVR5cGVgIHZhbHVlcyBhcmU6XG4gICAgICogLSBgd2lkZWBcbiAgICAgKiAtIGBuYXJyb3dgXG4gICAgICogLSBgc2hvcnRgXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIERldGFpbGVkIGNvbmZpZ3VyYXRpb24gZm9yIHRoZSBkZXNpcmVkIGRhdGUgZmllbGQgbmFtZS5cbiAgICAgKiBAcGFyYW0gbG9jYWxlSWQgLSBUaGUgbG9jYWxlIElEIHRvIHVzZSBpbiBwbGFjZSBvZiB0aGUgZGVmYXVsdCBvbmUuIE9wdGlvbmFsLlxuICAgICAqIEByZXR1cm4gLSBUaGUgZGF5IG5hbWVzIGZyb20gdGhlIGN1cnJlbnQgbG9jYWxlIGJhc2VkIG9uIHRoZSBvcHRpb24uXG4gICAgICogQHJldHVybnMgVGhlIGxvY2FsaXplZCBkYXRlIGZpZWxkIG5hbWUgZnJvbSB0aGUgY3VycmVudCBsb2NhbGUgYmFzZWQgb24gdGhlIG9wdGlvbi5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgXG4gICAgICogZGF0ZUZpZWxkTmFtZSh7IHR5cGU6ICdkYXknIH0pOyAgICAgICAgICAgICAgICAgICAgICAvL3JldHVybnMgJ2RheSc7XG4gICAgICogZGF0ZUZpZWxkTmFtZSh7IHR5cGU6ICdkYXknLCBuYW1lVHlwZTogJ3dpZGUnIH0pOyAgICAvL3JldHVybnMgJ2RheSc7XG4gICAgICogZGF0ZUZpZWxkTmFtZSh7IHR5cGU6ICdtb250aCcsIG5hbWVUeXBlOiAnc2hvcnQnIH0pOyAvL3JldHVybnMgJ21vLic7XG4gICAgICogZGF0ZUZpZWxkTmFtZSh7IHR5cGU6ICdtb250aCcsIG5hbWVUeXBlOiAnd2lkZScgfSk7ICAvL3JldHVybnMgJ21vbnRoJztcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBkYXRlRmllbGROYW1lKG9wdGlvbnMsIGxvY2FsZUlkKSB7XG4gICAgICAgIHJldHVybiBkYXRlRmllbGROYW1lJDEob3B0aW9ucywgbG9jYWxlSWQgfHwgdGhpcy5sb2NhbGVJZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBsb2NhbGl6ZWQgZGF0ZSBmaWVsZCBuYW1lIGJhc2VkIG9uIHNwZWNpZmljIGRhdGVGaWVsZE5hbWUgb3B0aW9ucy5cbiAgICAgKlxuICAgICAqIFRoZSBhdmFpbGFibGUgdHlwZSB2YWx1ZXMgYXJlOlxuICAgICAqIC0gYGRheWBcbiAgICAgKiAtIGBkYXlwZXJpb2RgXG4gICAgICogLSBgbW9udGhzYFxuICAgICAqIC0gYHF1YXJ0ZXJzYFxuICAgICAqIC0gYGVyYXNgXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIERldGFpbGVkIGNvbmZpZ3VyYXRpb24gZm9yIHRoZSBkZXNpcmVkIGRhdGUgZm9ybWF0LlxuICAgICAqIEBwYXJhbSBsb2NhbGVJZCAtIFRoZSBsb2NhbGUgSUQgdG8gdXNlIGluIHBsYWNlIG9mIHRoZSBkZWZhdWx0IG9uZS4gT3B0aW9uYWwuXG4gICAgICogQHJldHVybiAtIFRoZSBkYXkgbmFtZXMgZnJvbSB0aGUgY3VycmVudCBsb2NhbGUgYmFzZWQgb24gdGhlIG9wdGlvbi5cbiAgICAgKi9cbiAgICBkYXRlRm9ybWF0TmFtZXMob3B0aW9ucywgbG9jYWxlSWQpIHtcbiAgICAgICAgcmV0dXJuIGRhdGVGb3JtYXROYW1lcyQxKGxvY2FsZUlkIHx8IHRoaXMubG9jYWxlSWQsIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTcGxpdHMgdGhlIGRhdGUgZm9ybWF0IGludG8gb2JqZWN0cyBjb250YWluaW5nIGluZm9ybWF0aW9uIGFib3V0IGVhY2ggcGFydCBvZiB0aGUgcGF0dGVybi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBmb3JtYXQgVGhlIGZvcm1hdCBzdHJpbmcgb3Igb3B0aW9ucy5cbiAgICAgKiBAcGFyYW0gbG9jYWxlSWQgVGhlIG9wdGlvbmFsIGxvY2FsZSBpZC4gSWYgbm90IHNwZWNpZmllZCwgdGhlIGBcImVuXCJgIGxvY2FsZSBpZCBpcyB1c2VkLlxuICAgICAqIEByZXR1cm5zIFRoZSBkYXRlIGZvcm1hdCBwYXJ0cy5cbiAgICAgKi9cbiAgICBzcGxpdERhdGVGb3JtYXQoZm9ybWF0JCQxLCBsb2NhbGVJZCkge1xuICAgICAgICByZXR1cm4gc3BsaXREYXRlRm9ybWF0JDEoZm9ybWF0JCQxLCBsb2NhbGVJZCB8fCB0aGlzLmxvY2FsZUlkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbnVtYmVyIHN5bWJvbHMgZnJvbSB0aGUgY3VycmVudCBsb2NhbGUgYmFzZWQgb24gdGhlIG9wdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBsb2NhbGVJZCAtIFRoZSBsb2NhbGUgSUQgdG8gdXNlIGluIHBsYWNlIG9mIHRoZSBkZWZhdWx0IG9uZS4gT3B0aW9uYWwuXG4gICAgICogQHJldHVybiAtIFRoZSBudW1iZXIgc3ltYm9scyBmcm9tIHRoZSBjdXJyZW50IGxvY2FsZS5cbiAgICAgKi9cbiAgICBudW1iZXJTeW1ib2xzKGxvY2FsZUlkKSB7XG4gICAgICAgIHJldHVybiBudW1iZXJTeW1ib2xzJDEobG9jYWxlSWQgfHwgdGhpcy5sb2NhbGVJZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGZpcnN0IGRheSBpbmRleCBzdGFydGluZyBmcm9tIFN1bmRheS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBsb2NhbGVJZCAtIFRoZSBsb2NhbGUgSUQuIERlZmF1bHRzIHRvIHRoZSBjdXJyZW50IGxvY2FsZSBJRC5cbiAgICAgKiBAcmV0dXJuIC0gVGhlIGluZGV4IG9mIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsgKDAgPT0gU3VuZGF5KS5cbiAgICAgKi9cbiAgICBmaXJzdERheShsb2NhbGVJZCkge1xuICAgICAgICByZXR1cm4gZmlyc3REYXkkMShsb2NhbGVJZCB8fCB0aGlzLmxvY2FsZUlkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgc3RhcnQgYW5kIGVuZCBpbmRleCBvZiB0aGUgbG9jYWxlIHdlZWtlbmQgc3RhcnRpbmcgZnJvbSBTdW5kYXkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbG9jYWxlSWQgLSBUaGUgbG9jYWxlIElELiBEZWZhdWx0cyB0byB0aGUgY3VycmVudCBsb2NhbGUgSUQuXG4gICAgICogQHJldHVybiAtIFRoZSB0aGUgc3RhcnQgYW5kIGVuZCBpbmRleCBvZiB0aGUgbG9jYWxlIHdlZWtlbmQgKDAgPT0gU3VuZGF5KS5cbiAgICAgKi9cbiAgICB3ZWVrZW5kUmFuZ2UobG9jYWxlSWQpIHtcbiAgICAgICAgcmV0dXJuIHdlZWtlbmRSYW5nZSQxKGxvY2FsZUlkIHx8IHRoaXMubG9jYWxlSWQpO1xuICAgIH1cbn07XG5DbGRySW50bFNlcnZpY2UgPSBfX2RlY29yYXRlKFtcbiAgICBJbmplY3RhYmxlKCksXG4gICAgX19wYXJhbSgwLCBJbmplY3QoTE9DQUxFX0lEKSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtTdHJpbmddKVxuXSwgQ2xkckludGxTZXJ2aWNlKTtcblxuY29uc3QgaXNOdW1lcmljID0gKHZhbHVlKSA9PiAhaXNOYU4odmFsdWUgLSBwYXJzZUZsb2F0KHZhbHVlKSk7XG5jb25zdCDJtTAgPSBpc051bWVyaWM7XG4vKipcbiAqIEZvcm1hdHMgYSBkYXRlIHZhbHVlIHRvIGEgc3RyaW5nIGJhc2VkIG9uIHRoZSByZXF1ZXN0ZWQgZm9ybWF0LlxuICogVGhpcyBwaXBlIHVzZXMgdGhlIFtJbnRsU2VydmljZV0oeyUgc2x1ZyBhcGlfaW50bF9pbnRsc2VydmljZSAlfSkuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYG5nLXRlbXBsYXRlLW5vLXJ1blxuICogPHVsPlxuICogICAgPGxpPnt7ZGF0ZSB8IGtlbmRvRGF0ZSB9fTwvbGk+XG4gKiAgICA8bGk+e3ttaWxsaXNlY29uZHMgfCBrZW5kb0RhdGU6ICdNL2RkL3l5eScgfX08L2xpPlxuICogICAgPGxpPnt7c3RyaW5nRGF0ZSB8IGtlbmRvRGF0ZTogJ0cnIH19PC9saT5cbiAqIDwvdWw+XG4gKiBgYGBcbiAqL1xubGV0IERhdGVQaXBlID0gY2xhc3MgRGF0ZVBpcGUge1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihpbnRsU2VydmljZSkge1xuICAgICAgICB0aGlzLmludGxTZXJ2aWNlID0gaW50bFNlcnZpY2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGEgYERhdGVgIG9iamVjdCBpbnRvIGEgc3RyaW5nIGJhc2VkIG9uIHRoZSBzcGVjaWZpZWQgZm9ybWF0LlxuICAgICAqIElmIG5vIGZvcm1hdCBpcyBwcm92aWRlZCwgdGhlIGRlZmF1bHQgc2hvcnQgZGF0ZSBmb3JtYXQgaXMgdXNlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBkYXRlIHRvIGZvcm1hdC5cbiAgICAgKiBAcGFyYW0gZm9ybWF0IC0gVGhlIGZvcm1hdCBzdHJpbmcgb3Igb3B0aW9ucy5cbiAgICAgKiBAcGFyYW0gbG9jYWxlSWQgLSAoT3B0aW9uYWwpIFRoZSBJRCBvZiB0aGUgbG9jYWxlIHdoaWNoIHdpbGwgYmUgdXNlZCBpbnN0ZWFkIG9mIHRoZSBkZWZhdWx0IG9uZS5cbiAgICAgKiBAcmV0dXJuIC0gVGhlIGZvcm1hdHRlZCBkYXRlLlxuICAgICAqL1xuICAgIHRyYW5zZm9ybSh2YWx1ZSwgZm9ybWF0JCQxID0gXCJcIiwgbG9jYWxlSWQpIHtcbiAgICAgICAgdmFsdWUgPSB0aGlzLm5vcm1hbGl6ZSh2YWx1ZSk7XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW50bFNlcnZpY2UuZm9ybWF0RGF0ZSh2YWx1ZSwgZm9ybWF0JCQxLCBsb2NhbGVJZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBub3JtYWxpemUodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdGhpcy5pbnRsU2VydmljZS5wYXJzZURhdGUodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZhbHVlICYmIGlzTnVtZXJpYyh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHZhbHVlID0gbmV3IERhdGUocGFyc2VGbG9hdCh2YWx1ZSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG59O1xuRGF0ZVBpcGUgPSBfX2RlY29yYXRlKFtcbiAgICBQaXBlKHtcbiAgICAgICAgbmFtZTogJ2tlbmRvRGF0ZSdcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0ludGxTZXJ2aWNlXSlcbl0sIERhdGVQaXBlKTtcblxuLyoqXG4gKiBGb3JtYXRzIGEgbnVtYmVyIHZhbHVlIHRvIGEgc3RyaW5nIGJhc2VkIG9uIHRoZSByZXF1ZXN0ZWQgZm9ybWF0LlxuICogVGhpcyBwaXBlIHVzZXMgdGhlIFtgSW50bFNlcnZpY2VgXSh7JSBzbHVnIGFwaV9pbnRsX2ludGxzZXJ2aWNlICV9KS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgbmctdGVtcGxhdGUtbm8tcnVuXG4gKiAgIDx1bD5cbiAqICAgICA8bGk+e3tkZWNpbWFsIHwga2VuZG9OdW1iZXI6J2MnIH19PC9saT5cbiAqICAgICA8bGk+e3tzdHJpbmdOdW1iZXIgfCBrZW5kb051bWJlcjoncCcgfX08L2xpPlxuICogICAgIDxsaT57e2ludCB8IGtlbmRvTnVtYmVyOicjIy4wMCcgfX08L2xpPlxuICogIDwvdWw+XG4gKiBgYGBcbiAqL1xubGV0IE51bWJlclBpcGUgPSBjbGFzcyBOdW1iZXJQaXBlIHtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoaW50bFNlcnZpY2UpIHtcbiAgICAgICAgdGhpcy5pbnRsU2VydmljZSA9IGludGxTZXJ2aWNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhIGBOdW1iZXJgIG9iamVjdCBpbnRvIGEgc3RyaW5nIGJhc2VkIG9uIHRoZSBzcGVjaWZpZWQgZm9ybWF0LlxuICAgICAqIElmIG5vIGZvcm1hdCBpcyBwcm92aWRlZCwgdGhlIHZhbHVlIGlzIGZvcm1hdHRlZCBhcyBkZWNpbWFsIG51bWJlciB1c2luZyB0aGVcbiAgICAgKiBbYFwiblwiYF0oaHR0cHM6Ly9naXRodWIuY29tL3RlbGVyaWsva2VuZG8taW50bC9ibG9iL21hc3Rlci9kb2NzL251bS1mb3JtYXR0aW5nL2luZGV4Lm1kI3N0YW5kYXJkKSBmb3JtYXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgLSBUaGUgbnVtZXIgdGhhdCB3aWxsIGJlIGZvcm1hdHRlZC5cbiAgICAgKiBAcGFyYW0gZm9ybWF0IC0gVGhlIGZvcm1hdCBzdHJpbmcgb3Igb3B0aW9ucy5cbiAgICAgKiBAcGFyYW0gbG9jYWxlSWQgLSAoT3B0aW9uYWwpIFRoZSBsb2NhbGUgSUQgdGhhdCB3aWxsIGJlIHVzZWQgaW4gcGxhY2Ugb2YgdGhlIGRlZmF1bHQgb25lLlxuICAgICAqIEByZXR1cm4gLSBUaGUgZm9ybWF0dGVkIG51bWJlci5cbiAgICAgKi9cbiAgICB0cmFuc2Zvcm0odmFsdWUsIGZvcm1hdCQkMSwgbG9jYWxlSWQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdGhpcy5pbnRsU2VydmljZS5wYXJzZU51bWJlcih2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmludGxTZXJ2aWNlLmZvcm1hdE51bWJlcih2YWx1ZSwgZm9ybWF0JCQxLCBsb2NhbGVJZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbn07XG5OdW1iZXJQaXBlID0gX19kZWNvcmF0ZShbXG4gICAgUGlwZSh7XG4gICAgICAgIG5hbWU6ICdrZW5kb051bWJlcidcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0ludGxTZXJ2aWNlXSlcbl0sIE51bWJlclBpcGUpO1xuXG5jb25zdCBwaXBlcyA9IFtcbiAgICBEYXRlUGlwZSxcbiAgICBOdW1iZXJQaXBlXG5dO1xuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBbTmdNb2R1bGVdKHt7IHNpdGUuZGF0YS51cmxzLmFuZ3VsYXJbJ25nbW9kdWxlYXBpJ10gfX1kb2NzL3RzL2xhdGVzdC9ndWlkZS9uZ21vZHVsZS5odG1sKVxuICogZGVmaW5pdGlvbiBmb3IgdGhlIEludGwgc2VydmljZXMuXG4gKi9cbmxldCBJbnRsTW9kdWxlID0gY2xhc3MgSW50bE1vZHVsZSB7XG59O1xuSW50bE1vZHVsZSA9IF9fZGVjb3JhdGUoW1xuICAgIE5nTW9kdWxlKHtcbiAgICAgICAgZGVjbGFyYXRpb25zOiBbcGlwZXNdLFxuICAgICAgICBleHBvcnRzOiBbcGlwZXNdXG4gICAgfSlcbl0sIEludGxNb2R1bGUpO1xuXG4vKipcbiAqIEdlbmVyYXRlZCBidW5kbGUgaW5kZXguIERvIG5vdCBlZGl0LlxuICovXG5cbmV4cG9ydCB7IGNsZHJTZXJ2aWNlRmFjdG9yeSwgSW50bFNlcnZpY2UsIENsZHJJbnRsU2VydmljZSwgRGF0ZVBpcGUsIMm1MCwgTnVtYmVyUGlwZSwgSW50bE1vZHVsZSwgZGF0ZUZvcm1hdE5hbWVzJDEgYXMgZGF0ZUZvcm1hdE5hbWVzLCBkYXRlRmllbGROYW1lJDEgYXMgZGF0ZUZpZWxkTmFtZSwgZmlyc3REYXkkMSBhcyBmaXJzdERheSwgZm9ybWF0JDEgYXMgZm9ybWF0LCBmb3JtYXREYXRlJDEgYXMgZm9ybWF0RGF0ZSwgZm9ybWF0TnVtYmVyJDEgYXMgZm9ybWF0TnVtYmVyLCBsb2FkJDEgYXMgbG9hZCwgbnVtYmVyU3ltYm9scyQxIGFzIG51bWJlclN5bWJvbHMsIHBhcnNlRGF0ZSQxIGFzIHBhcnNlRGF0ZSwgcGFyc2VOdW1iZXIkMSBhcyBwYXJzZU51bWJlciwgc3BsaXREYXRlRm9ybWF0JDEgYXMgc3BsaXREYXRlRm9ybWF0LCB0b1N0cmluZyQxIGFzIHRvU3RyaW5nLCB3ZWVrZW5kUmFuZ2UkMSBhcyB3ZWVrZW5kUmFuZ2UsIHNldERhdGEkMSBhcyBzZXREYXRhLCBsb2NhbGVEYXRhIH07XG4iXX0=","map":null,"metadata":{},"sourceType":"module"}