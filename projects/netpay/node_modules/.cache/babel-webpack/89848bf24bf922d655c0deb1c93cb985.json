{"ast":null,"code":"import OptionsStore from '../core/options-store';\nimport Rect from '../geometry/rect';\nimport Matrix from '../geometry/matrix';\nimport createTransform from '../geometry/transform';\nimport toMatrix from '../geometry/to-matrix';\nimport HasObservers from '../core/has-observers';\nimport { defined, definitionId, isTransparent, valueOrDefault } from '../util';\n\nclass Element extends HasObservers {\n  get nodeType() {\n    return \"Rect\";\n  }\n\n  constructor(options) {\n    super();\n\n    this._initOptions(options);\n  }\n\n  _initOptions(options = {}) {\n    const {\n      clip,\n      transform\n    } = options;\n\n    if (transform) {\n      options.transform = createTransform(transform);\n    }\n\n    if (clip && !clip.id) {\n      clip.id = definitionId();\n    }\n\n    this.options = new OptionsStore(options);\n    this.options.addObserver(this);\n  }\n\n  transform(value) {\n    if (defined(value)) {\n      this.options.set(\"transform\", createTransform(value));\n    } else {\n      return this.options.get(\"transform\");\n    }\n  }\n\n  parentTransform() {\n    let element = this;\n    let parentMatrix;\n\n    while (element.parent) {\n      element = element.parent;\n      let transformation = element.transform();\n\n      if (transformation) {\n        parentMatrix = transformation.matrix().multiplyCopy(parentMatrix || Matrix.unit());\n      }\n    }\n\n    if (parentMatrix) {\n      return createTransform(parentMatrix);\n    }\n  }\n\n  currentTransform(parentTransform = this.parentTransform()) {\n    const elementTransform = this.transform();\n    const elementMatrix = toMatrix(elementTransform);\n    let parentMatrix = toMatrix(parentTransform);\n    let combinedMatrix;\n\n    if (elementMatrix && parentMatrix) {\n      combinedMatrix = parentMatrix.multiplyCopy(elementMatrix);\n    } else {\n      combinedMatrix = elementMatrix || parentMatrix;\n    }\n\n    if (combinedMatrix) {\n      return createTransform(combinedMatrix);\n    }\n  }\n\n  visible(value) {\n    if (defined(value)) {\n      this.options.set(\"visible\", value);\n      return this;\n    }\n\n    return this.options.get(\"visible\") !== false;\n  }\n\n  clip(value) {\n    const options = this.options;\n\n    if (defined(value)) {\n      if (value && !value.id) {\n        value.id = definitionId();\n      }\n\n      options.set(\"clip\", value);\n      return this;\n    }\n\n    return options.get(\"clip\");\n  }\n\n  opacity(value) {\n    if (defined(value)) {\n      this.options.set(\"opacity\", value);\n      return this;\n    }\n\n    return valueOrDefault(this.options.get(\"opacity\"), 1);\n  }\n\n  clippedBBox(transformation) {\n    const bbox = this._clippedBBox(transformation);\n\n    if (bbox) {\n      const clip = this.clip();\n      return clip ? Rect.intersect(bbox, clip.bbox(transformation)) : bbox;\n    }\n  }\n\n  containsPoint(point, parentTransform) {\n    if (this.visible()) {\n      const transform = this.currentTransform(parentTransform);\n      let transformedPoint = point;\n\n      if (transform) {\n        transformedPoint = point.transformCopy(transform.matrix().invert());\n      }\n\n      return this._hasFill() && this._containsPoint(transformedPoint) || this._isOnPath && this._hasStroke() && this._isOnPath(transformedPoint);\n    }\n\n    return false;\n  }\n\n  _hasFill() {\n    const fill = this.options.fill;\n    return fill && !isTransparent(fill.color);\n  }\n\n  _hasStroke() {\n    const stroke = this.options.stroke;\n    return stroke && stroke.width > 0 && !isTransparent(stroke.color);\n  }\n\n  _clippedBBox(transformation) {\n    return this.bbox(transformation);\n  }\n\n}\n\nexport default Element;","map":null,"metadata":{},"sourceType":"module"}