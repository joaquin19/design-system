{"ast":null,"code":"import GeometryElementsArray from './geometry-elements-array';\nimport Element from './element';\nimport paintable from '../mixins/paintable';\nimport measurable from '../mixins/measurable';\nimport Arc from '../geometry/arc';\nimport Rect from '../geometry/rect';\nimport Segment from '../geometry/segment';\nimport Point from '../geometry/point';\nimport Size from '../geometry/size';\nimport lineIntersectionsCount from '../geometry/math/line-intersections-count';\nimport { defined, last, rad } from '../util';\nimport parsePath from '../parsing/parse-path';\nimport elementsBoundingBox from './utils/elements-bounding-box';\nimport elementsClippedBoundingBox from './utils/elements-clippend-bounding-box';\nimport limitValue from '../util/limit-value';\nexport class Path extends paintable(measurable(Element)) {\n  static parse(str, options) {\n    return MultiPath.parse(str, options);\n  }\n\n  get nodeType() {\n    return \"Path\";\n  }\n\n  constructor(options) {\n    super(options);\n    this.segments = new GeometryElementsArray();\n    this.segments.addObserver(this);\n\n    if (!defined(this.options.stroke)) {\n      this.stroke(\"#000\");\n\n      if (!defined(this.options.stroke.lineJoin)) {\n        this.options.set(\"stroke.lineJoin\", \"miter\");\n      }\n    }\n  }\n\n  moveTo(x, y) {\n    this.suspend();\n    this.segments.elements([]);\n    this.resume();\n    this.lineTo(x, y);\n    return this;\n  }\n\n  lineTo(x, y) {\n    const point = defined(y) ? new Point(x, y) : x;\n    const segment = new Segment(point);\n    this.segments.push(segment);\n    return this;\n  }\n\n  curveTo(controlOut, controlIn, point) {\n    if (this.segments.length > 0) {\n      const lastSegment = last(this.segments);\n      const segment = new Segment(point, controlIn);\n      this.suspend();\n      lastSegment.controlOut(controlOut);\n      this.resume();\n      this.segments.push(segment);\n    }\n\n    return this;\n  }\n\n  arc(startAngle, endAngle, radiusX, radiusY, anticlockwise) {\n    if (this.segments.length > 0) {\n      const lastSegment = last(this.segments);\n      const anchor = lastSegment.anchor();\n      const start = rad(startAngle);\n      const center = new Point(anchor.x - radiusX * Math.cos(start), anchor.y - radiusY * Math.sin(start));\n      const arc = new Arc(center, {\n        startAngle: startAngle,\n        endAngle: endAngle,\n        radiusX: radiusX,\n        radiusY: radiusY,\n        anticlockwise: anticlockwise\n      });\n\n      this._addArcSegments(arc);\n    }\n\n    return this;\n  }\n\n  arcTo(end, rx, ry, largeArc, swipe, rotation) {\n    if (this.segments.length > 0) {\n      const lastSegment = last(this.segments);\n      const anchor = lastSegment.anchor();\n      const arc = Arc.fromPoints(anchor, Point.create(end), rx, ry, largeArc, swipe, rotation);\n\n      this._addArcSegments(arc);\n    }\n\n    return this;\n  }\n\n  _addArcSegments(arc) {\n    this.suspend();\n    const curvePoints = arc.curvePoints();\n\n    for (let i = 1; i < curvePoints.length; i += 3) {\n      this.curveTo(curvePoints[i], curvePoints[i + 1], curvePoints[i + 2]);\n    }\n\n    this.resume();\n    this.geometryChange();\n  }\n\n  close() {\n    this.options.closed = true;\n    this.geometryChange();\n    return this;\n  }\n\n  rawBBox() {\n    return this._bbox();\n  }\n\n  _containsPoint(point) {\n    const segments = this.segments;\n    const length = segments.length;\n    let intersectionsCount = 0;\n    let previous, current;\n\n    for (let idx = 1; idx < length; idx++) {\n      previous = segments[idx - 1];\n      current = segments[idx];\n      intersectionsCount += previous._intersectionsTo(current, point);\n    }\n\n    if (this.options.closed || !segments[0].anchor().equals(segments[length - 1].anchor())) {\n      intersectionsCount += lineIntersectionsCount(segments[0].anchor(), segments[length - 1].anchor(), point);\n    }\n\n    return intersectionsCount % 2 !== 0;\n  }\n\n  _isOnPath(point, width) {\n    const segments = this.segments;\n    const length = segments.length;\n    const pathWidth = width || this.options.stroke.width;\n\n    if (length > 1) {\n      if (segments[0]._isOnPathTo(segments[1], point, pathWidth, \"start\")) {\n        return true;\n      }\n\n      for (let idx = 2; idx <= length - 2; idx++) {\n        if (segments[idx - 1]._isOnPathTo(segments[idx], point, pathWidth)) {\n          return true;\n        }\n      }\n\n      if (segments[length - 2]._isOnPathTo(segments[length - 1], point, pathWidth, \"end\")) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  _bbox(matrix) {\n    const segments = this.segments;\n    const length = segments.length;\n    let boundingBox;\n\n    if (length === 1) {\n      let anchor = segments[0].anchor().transformCopy(matrix);\n      boundingBox = new Rect(anchor, Size.ZERO);\n    } else if (length > 0) {\n      for (let i = 1; i < length; i++) {\n        let segmentBox = segments[i - 1].bboxTo(segments[i], matrix);\n\n        if (boundingBox) {\n          boundingBox = Rect.union(boundingBox, segmentBox);\n        } else {\n          boundingBox = segmentBox;\n        }\n      }\n    }\n\n    return boundingBox;\n  }\n\n  static fromRect(rect, options) {\n    const path = new Path(options);\n    let [rx, ry] = rect.cornerRadius;\n\n    if (rx === 0 && ry === 0) {\n      path.moveTo(rect.topLeft()).lineTo(rect.topRight()).lineTo(rect.bottomRight()).lineTo(rect.bottomLeft()).close();\n    } else {\n      const origin = rect.origin;\n      const {\n        x,\n        y\n      } = origin;\n      const width = rect.width();\n      const height = rect.height();\n      rx = limitValue(rx, 0, width / 2);\n      ry = limitValue(ry, 0, height / 2);\n      path.moveTo(x + rx, y).lineTo(x + width - rx, y).arcTo([x + width, y + ry], rx, ry, false).lineTo(x + width, y + height - ry).arcTo([x + width - rx, y + height], rx, ry, false).lineTo(x + rx, y + height).arcTo([x, y + height - ry], rx, ry, false).lineTo(x, y + ry).arcTo([x + rx, y], rx, ry, false);\n    }\n\n    return path;\n  }\n\n  static fromPoints(points, options) {\n    if (points) {\n      const path = new Path(options);\n\n      for (let i = 0; i < points.length; i++) {\n        let point = Point.create(points[i]);\n\n        if (point) {\n          if (i === 0) {\n            path.moveTo(point);\n          } else {\n            path.lineTo(point);\n          }\n        }\n      }\n\n      return path;\n    }\n  }\n\n  static fromArc(arc, options) {\n    const path = new Path(options);\n    const startAngle = arc.startAngle;\n    const start = arc.pointAt(startAngle);\n    path.moveTo(start.x, start.y);\n    path.arc(startAngle, arc.endAngle, arc.radiusX, arc.radiusY, arc.anticlockwise);\n    return path;\n  }\n\n}\nexport class MultiPath extends paintable(measurable(Element)) {\n  static parse(str, options) {\n    const instance = new MultiPath(options);\n    return parsePath(instance, str);\n  }\n\n  get nodeType() {\n    return \"MultiPath\";\n  }\n\n  constructor(options) {\n    super(options);\n    this.paths = new GeometryElementsArray();\n    this.paths.addObserver(this);\n\n    if (!defined(this.options.stroke)) {\n      this.stroke(\"#000\");\n    }\n  }\n\n  moveTo(x, y) {\n    const path = new Path();\n    path.moveTo(x, y);\n    this.paths.push(path);\n    return this;\n  }\n\n  lineTo(x, y) {\n    if (this.paths.length > 0) {\n      last(this.paths).lineTo(x, y);\n    }\n\n    return this;\n  }\n\n  curveTo(controlOut, controlIn, point) {\n    if (this.paths.length > 0) {\n      last(this.paths).curveTo(controlOut, controlIn, point);\n    }\n\n    return this;\n  }\n\n  arc(startAngle, endAngle, radiusX, radiusY, anticlockwise) {\n    if (this.paths.length > 0) {\n      last(this.paths).arc(startAngle, endAngle, radiusX, radiusY, anticlockwise);\n    }\n\n    return this;\n  }\n\n  arcTo(end, rx, ry, largeArc, swipe, rotation) {\n    if (this.paths.length > 0) {\n      last(this.paths).arcTo(end, rx, ry, largeArc, swipe, rotation);\n    }\n\n    return this;\n  }\n\n  close() {\n    if (this.paths.length > 0) {\n      last(this.paths).close();\n    }\n\n    return this;\n  }\n\n  _bbox(matrix) {\n    return elementsBoundingBox(this.paths, true, matrix);\n  }\n\n  rawBBox() {\n    return elementsBoundingBox(this.paths, false);\n  }\n\n  _containsPoint(point) {\n    const paths = this.paths;\n\n    for (let idx = 0; idx < paths.length; idx++) {\n      if (paths[idx]._containsPoint(point)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  _isOnPath(point) {\n    const paths = this.paths;\n    const width = this.options.stroke.width;\n\n    for (let idx = 0; idx < paths.length; idx++) {\n      if (paths[idx]._isOnPath(point, width)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  _clippedBBox(transformation) {\n    return elementsClippedBoundingBox(this.paths, this.currentTransform(transformation));\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}