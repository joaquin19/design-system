{"ast":null,"code":"/**-----------------------------------------------------------------------------------------\n* Copyright © 2021 Progress Software Corporation. All rights reserved.\n* Licensed under commercial license. See LICENSE.md in the project root for more information\n*-------------------------------------------------------------------------------------------*/\nimport { __decorate, __metadata, __param } from 'tslib';\nimport { EventEmitter, Injectable, Directive, Optional, TemplateRef, forwardRef, isDevMode, HostBinding, ViewChild, ViewContainerRef, Input, Output, ContentChild, Component, ChangeDetectionStrategy, ElementRef, ChangeDetectorRef, NgZone, Renderer2, ComponentFactoryResolver, Host, NgModule } from '@angular/core';\nimport { isDocumentAvailable, Keys, anyChanged, hasObservers, isChanged, guid } from '@progress/kendo-angular-common';\nimport { LocalizationService, L10N_PREFIX } from '@progress/kendo-angular-l10n';\nimport { Subject, of, BehaviorSubject, Subscription, EMPTY, merge } from 'rxjs';\nimport { validatePackage } from '@progress/kendo-licensing';\nimport { getter, setter } from '@progress/kendo-common';\nimport { trigger, transition, style, animate } from '@angular/animations';\nimport { filter, catchError, tap, finalize, switchMap, take, map, delay, takeUntil } from 'rxjs/operators';\nimport { CommonModule } from '@angular/common';\nimport Draggable from '@telerik/kendo-draggable';\nimport { InputsModule } from '@progress/kendo-angular-inputs';\n/**\n * @hidden\n */\n\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from '@progress/kendo-angular-l10n';\nimport * as ɵngcc2 from '@angular/common';\nimport * as ɵngcc3 from '@progress/kendo-angular-inputs';\nconst _c0 = [\"assetsContainer\"];\n\nfunction TreeViewComponent_kendo_textbox_0_ng_template_2_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelement(0, \"span\", 6);\n  }\n}\n\nfunction TreeViewComponent_kendo_textbox_0_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r5 = ɵngcc0.ɵɵgetCurrentView();\n\n    ɵngcc0.ɵɵelementStart(0, \"kendo-textbox\", 3, 4);\n    ɵngcc0.ɵɵlistener(\"valueChange\", function TreeViewComponent_kendo_textbox_0_Template_kendo_textbox_valueChange_0_listener($event) {\n      ɵngcc0.ɵɵrestoreView(_r5);\n      const ctx_r4 = ɵngcc0.ɵɵnextContext();\n      return ctx_r4.filterChange.emit($event);\n    });\n    ɵngcc0.ɵɵtemplate(2, TreeViewComponent_kendo_textbox_0_ng_template_2_Template, 1, 0, \"ng-template\", 5);\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵproperty(\"value\", ctx_r0.filter)(\"clearButton\", true)(\"placeholder\", ctx_r0.filterInputPlaceholder);\n  }\n}\n\nconst _c1 = [\"kendoTreeViewGroup\", \"\"];\n\nfunction TreeViewGroupComponent_li_0_span_2_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r11 = ɵngcc0.ɵɵgetCurrentView();\n\n    ɵngcc0.ɵɵelementStart(0, \"span\", 11);\n    ɵngcc0.ɵɵlistener(\"click\", function TreeViewGroupComponent_li_0_span_2_Template_span_click_0_listener() {\n      ɵngcc0.ɵɵrestoreView(_r11);\n      const ctx_r10 = ɵngcc0.ɵɵnextContext();\n      const index_r3 = ctx_r10.index;\n      const node_r2 = ctx_r10.$implicit;\n      const ctx_r9 = ɵngcc0.ɵɵnextContext();\n      return ctx_r9.expandNode(ctx_r9.nodeIndex(index_r3), node_r2, !ctx_r9.isExpanded(node_r2, ctx_r9.nodeIndex(index_r3)));\n    });\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r12 = ɵngcc0.ɵɵnextContext();\n    const node_r2 = ctx_r12.$implicit;\n    const index_r3 = ctx_r12.index;\n    const ctx_r4 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵclassProp(\"k-i-collapse\", ctx_r4.isExpanded(node_r2, ctx_r4.nodeIndex(index_r3)))(\"k-i-expand\", !ctx_r4.isExpanded(node_r2, ctx_r4.nodeIndex(index_r3)));\n    ɵngcc0.ɵɵproperty(\"kendoTreeViewLoading\", ctx_r4.nodeIndex(index_r3));\n  }\n}\n\nfunction TreeViewGroupComponent_li_0_kendo_checkbox_3_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r15 = ɵngcc0.ɵɵgetCurrentView();\n\n    ɵngcc0.ɵɵelementStart(0, \"kendo-checkbox\", 12);\n    ɵngcc0.ɵɵlistener(\"checkStateChange\", function TreeViewGroupComponent_li_0_kendo_checkbox_3_Template_kendo_checkbox_checkStateChange_0_listener() {\n      ɵngcc0.ɵɵrestoreView(_r15);\n      const index_r3 = ɵngcc0.ɵɵnextContext().index;\n      const ctx_r13 = ɵngcc0.ɵɵnextContext();\n      return ctx_r13.checkNode(ctx_r13.nodeIndex(index_r3));\n    });\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r16 = ɵngcc0.ɵɵnextContext();\n    const node_r2 = ctx_r16.$implicit;\n    const index_r3 = ctx_r16.index;\n    const ctx_r5 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵproperty(\"node\", node_r2)(\"index\", ctx_r5.nodeIndex(index_r3))(\"isChecked\", ctx_r5.isChecked);\n  }\n}\n\nfunction TreeViewGroupComponent_li_0_ng_container_6_ng_template_1_Template(rf, ctx) {}\n\nconst _c2 = function (a0, a1) {\n  return {\n    $implicit: a0,\n    index: a1\n  };\n};\n\nfunction TreeViewGroupComponent_li_0_ng_container_6_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementContainerStart(0);\n    ɵngcc0.ɵɵtemplate(1, TreeViewGroupComponent_li_0_ng_container_6_ng_template_1_Template, 0, 0, \"ng-template\", 13);\n    ɵngcc0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r18 = ɵngcc0.ɵɵnextContext();\n    const node_r2 = ctx_r18.$implicit;\n    const index_r3 = ctx_r18.index;\n    const ctx_r6 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r6.nodeTemplateRef)(\"ngTemplateOutletContext\", ɵngcc0.ɵɵpureFunction2(2, _c2, node_r2, ctx_r6.nodeIndex(index_r3)));\n  }\n}\n\nfunction TreeViewGroupComponent_li_0_ng_container_7_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementContainerStart(0);\n    ɵngcc0.ɵɵtext(1);\n    ɵngcc0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const node_r2 = ɵngcc0.ɵɵnextContext().$implicit;\n    const ctx_r7 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵtextInterpolate1(\" \", ctx_r7.nodeText(node_r2), \" \");\n  }\n}\n\nfunction TreeViewGroupComponent_li_0_ul_8_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelement(0, \"ul\", 14);\n  }\n\n  if (rf & 2) {\n    const ctx_r20 = ɵngcc0.ɵɵnextContext();\n    const node_r2 = ctx_r20.$implicit;\n    const index_r3 = ctx_r20.index;\n    const ctx_r8 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵproperty(\"nodes\", ctx_r8.fetchChildren)(\"loadOnDemand\", ctx_r8.loadOnDemand)(\"checkboxes\", ctx_r8.checkboxes)(\"expandIcons\", ctx_r8.expandIcons)(\"selectable\", ctx_r8.selectable)(\"touchActions\", ctx_r8.touchActions)(\"children\", ctx_r8.children)(\"hasChildren\", ctx_r8.hasChildren)(\"isChecked\", ctx_r8.isChecked)(\"isDisabled\", ctx_r8.isDisabled)(\"disabled\", ctx_r8.disabled || ctx_r8.isDisabled(node_r2, ctx_r8.nodeIndex(index_r3)))(\"isExpanded\", ctx_r8.isExpanded)(\"isSelected\", ctx_r8.isSelected)(\"isVisible\", ctx_r8.isVisible)(\"nodeTemplateRef\", ctx_r8.nodeTemplateRef)(\"loadMoreButtonTemplateRef\", ctx_r8.loadMoreButtonTemplateRef)(\"parentIndex\", ctx_r8.nodeIndex(index_r3))(\"parentDataItem\", node_r2)(\"textField\", ctx_r8.nextFields)(\"loadMoreService\", ctx_r8.loadMoreService)(\"@toggle\", true)(\"trackBy\", ctx_r8.trackBy);\n  }\n}\n\nfunction TreeViewGroupComponent_li_0_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"li\", 2);\n    ɵngcc0.ɵɵelementStart(1, \"div\", 3);\n    ɵngcc0.ɵɵtemplate(2, TreeViewGroupComponent_li_0_span_2_Template, 1, 5, \"span\", 4);\n    ɵngcc0.ɵɵtemplate(3, TreeViewGroupComponent_li_0_kendo_checkbox_3_Template, 1, 3, \"kendo-checkbox\", 5);\n    ɵngcc0.ɵɵelementStart(4, \"span\", 6);\n    ɵngcc0.ɵɵelementContainerStart(5, 7);\n    ɵngcc0.ɵɵtemplate(6, TreeViewGroupComponent_li_0_ng_container_6_Template, 2, 5, \"ng-container\", 8);\n    ɵngcc0.ɵɵtemplate(7, TreeViewGroupComponent_li_0_ng_container_7_Template, 2, 1, \"ng-container\", 9);\n    ɵngcc0.ɵɵelementContainerEnd();\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵtemplate(8, TreeViewGroupComponent_li_0_ul_8_Template, 1, 22, \"ul\", 10);\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const node_r2 = ctx.$implicit;\n    const index_r3 = ctx.index;\n    const ctx_r0 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵclassProp(\"k-display-none\", !ctx_r0.isVisible(node_r2, ctx_r0.nodeIndex(index_r3)));\n    ɵngcc0.ɵɵproperty(\"dataItem\", node_r2)(\"index\", ctx_r0.nodeIndex(index_r3))(\"parentDataItem\", ctx_r0.parentDataItem)(\"parentIndex\", ctx_r0.parentIndex)(\"loadOnDemand\", ctx_r0.loadOnDemand)(\"checkable\", ctx_r0.checkboxes)(\"isChecked\", ctx_r0.isChecked(node_r2, ctx_r0.nodeIndex(index_r3)))(\"isDisabled\", ctx_r0.disabled || ctx_r0.isDisabled(node_r2, ctx_r0.nodeIndex(index_r3)))(\"isVisible\", ctx_r0.isVisible(node_r2, ctx_r0.nodeIndex(index_r3)))(\"expandable\", ctx_r0.expandIcons && ctx_r0.hasChildren(node_r2))(\"isExpanded\", ctx_r0.isExpanded(node_r2, ctx_r0.nodeIndex(index_r3)))(\"selectable\", ctx_r0.selectable)(\"isSelected\", ctx_r0.isSelected(node_r2, ctx_r0.nodeIndex(index_r3)));\n    ɵngcc0.ɵɵattribute(\"aria-setsize\", ctx_r0.totalNodesCount)(\"data-treeindex\", ctx_r0.nodeIndex(index_r3));\n    ɵngcc0.ɵɵadvance(2);\n    ɵngcc0.ɵɵproperty(\"ngIf\", ctx_r0.expandIcons && ctx_r0.hasChildren(node_r2));\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngIf\", ctx_r0.checkboxes);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵstyleProp(\"touch-action\", ctx_r0.touchActions ? \"\" : \"none\");\n    ɵngcc0.ɵɵproperty(\"dataItem\", node_r2)(\"index\", ctx_r0.nodeIndex(index_r3))(\"initialSelection\", ctx_r0.isSelected(node_r2, ctx_r0.nodeIndex(index_r3)))(\"isSelected\", ctx_r0.isSelected);\n    ɵngcc0.ɵɵattribute(\"data-treeindex\", ctx_r0.nodeIndex(index_r3));\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngSwitch\", ctx_r0.hasTemplate);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngSwitchCase\", true);\n    ɵngcc0.ɵɵadvance(2);\n    ɵngcc0.ɵɵproperty(\"ngIf\", ctx_r0.isExpanded(node_r2, ctx_r0.nodeIndex(index_r3)) && ctx_r0.hasChildren(node_r2));\n  }\n}\n\nfunction TreeViewGroupComponent_li_1_span_2_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelement(0, \"span\", 19);\n  }\n}\n\nfunction TreeViewGroupComponent_li_1_4_ng_template_0_Template(rf, ctx) {}\n\nconst _c3 = function (a0) {\n  return {\n    index: a0\n  };\n};\n\nfunction TreeViewGroupComponent_li_1_4_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵtemplate(0, TreeViewGroupComponent_li_1_4_ng_template_0_Template, 0, 0, \"ng-template\", 13);\n  }\n\n  if (rf & 2) {\n    const ctx_r22 = ɵngcc0.ɵɵnextContext(2);\n    ɵngcc0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r22.loadMoreButtonTemplateRef)(\"ngTemplateOutletContext\", ɵngcc0.ɵɵpureFunction1(2, _c3, ctx_r22.loadMoreButtonIndex));\n  }\n}\n\nfunction TreeViewGroupComponent_li_1_ng_container_5_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementContainerStart(0);\n    ɵngcc0.ɵɵtext(1, \" Load more \");\n    ɵngcc0.ɵɵelementContainerEnd();\n  }\n}\n\nfunction TreeViewGroupComponent_li_1_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"li\", 15);\n    ɵngcc0.ɵɵelementStart(1, \"div\", 3);\n    ɵngcc0.ɵɵtemplate(2, TreeViewGroupComponent_li_1_span_2_Template, 1, 0, \"span\", 16);\n    ɵngcc0.ɵɵelementStart(3, \"span\", 17);\n    ɵngcc0.ɵɵtemplate(4, TreeViewGroupComponent_li_1_4_Template, 1, 4, undefined, 18);\n    ɵngcc0.ɵɵtemplate(5, TreeViewGroupComponent_li_1_ng_container_5_Template, 2, 0, \"ng-container\", 18);\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r1 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵclassProp(\"k-treeview-load-more-checkboxes-container\", ctx_r1.checkboxes);\n    ɵngcc0.ɵɵproperty(\"selectable\", false)(\"checkable\", false)(\"expandable\", false)(\"index\", ctx_r1.loadMoreButtonIndex)(\"parentDataItem\", ctx_r1.parentDataItem)(\"parentIndex\", ctx_r1.parentIndex);\n    ɵngcc0.ɵɵattribute(\"data-treeindex\", ctx_r1.loadMoreButtonIndex);\n    ɵngcc0.ɵɵadvance(2);\n    ɵngcc0.ɵɵproperty(\"ngIf\", ctx_r1.loadingMoreNodes);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"index\", ctx_r1.loadMoreButtonIndex);\n    ɵngcc0.ɵɵattribute(\"data-treeindex\", ctx_r1.loadMoreButtonIndex);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngIf\", ctx_r1.loadMoreButtonTemplateRef);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngIf\", !ctx_r1.loadMoreButtonTemplateRef);\n  }\n}\n\nfunction DragClueComponent_ng_container_0_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementContainerStart(0);\n    ɵngcc0.ɵɵelement(1, \"span\");\n    ɵngcc0.ɵɵelementStart(2, \"span\");\n    ɵngcc0.ɵɵtext(3);\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵclassMapInterpolate1(\"k-icon \", ctx_r0.statusIconClass, \" k-drag-status\");\n    ɵngcc0.ɵɵadvance(2);\n    ɵngcc0.ɵɵtextInterpolate(ctx_r0.text);\n  }\n}\n\nfunction DragClueComponent_1_ng_template_0_Template(rf, ctx) {}\n\nconst _c4 = function (a0, a1, a2, a3) {\n  return {\n    text: a0,\n    action: a1,\n    sourceItem: a2,\n    destinationItem: a3\n  };\n};\n\nfunction DragClueComponent_1_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵtemplate(0, DragClueComponent_1_ng_template_0_Template, 0, 0, \"ng-template\", 1);\n  }\n\n  if (rf & 2) {\n    const ctx_r1 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r1.template)(\"ngTemplateOutletContext\", ɵngcc0.ɵɵpureFunction4(2, _c4, ctx_r1.text, ctx_r1.action, ctx_r1.sourceItem, ctx_r1.destinationItem));\n  }\n}\n\nfunction DropHintComponent_div_0_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"div\", 2);\n    ɵngcc0.ɵɵelement(1, \"div\", 3);\n    ɵngcc0.ɵɵelement(2, \"div\", 4);\n    ɵngcc0.ɵɵelementEnd();\n  }\n}\n\nfunction DropHintComponent_1_ng_template_0_ng_template_0_Template(rf, ctx) {}\n\nfunction DropHintComponent_1_ng_template_0_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵtemplate(0, DropHintComponent_1_ng_template_0_ng_template_0_Template, 0, 0, \"ng-template\");\n  }\n}\n\nconst _c5 = function (a0, a1, a2) {\n  return {\n    action: a0,\n    sourceItem: a1,\n    destinationItem: a2\n  };\n};\n\nfunction DropHintComponent_1_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵtemplate(0, DropHintComponent_1_ng_template_0_Template, 1, 0, \"ng-template\", 5);\n  }\n\n  if (rf & 2) {\n    const ctx_r1 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r1.template)(\"ngTemplateOutletContext\", ɵngcc0.ɵɵpureFunction3(2, _c5, ctx_r1.action, ctx_r1.sourceItem, ctx_r1.destinationItem));\n  }\n}\n\nconst packageMetadata = {\n  name: '@progress/kendo-angular-treeview',\n  productName: 'Kendo UI for Angular',\n  productCodes: ['KENDOUIANGULAR', 'KENDOUICOMPLETE'],\n  publishDate: 1631260544,\n  version: '',\n  licensingDocsUrl: 'https://www.telerik.com/kendo-angular-ui/my-license/?utm_medium=product&utm_source=kendoangular&utm_campaign=kendo-ui-angular-purchase-license-keys-warning'\n};\n/**\n * @hidden\n */\n\nlet DataChangeNotificationService = /*#__PURE__*/(() => {\n  class DataChangeNotificationService {\n    constructor() {\n      this.changes = new EventEmitter();\n    }\n\n    notify() {\n      this.changes.emit();\n    }\n\n  }\n\n  DataChangeNotificationService.ɵfac = function DataChangeNotificationService_Factory(t) {\n    return new (t || DataChangeNotificationService)();\n  };\n\n  DataChangeNotificationService.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: DataChangeNotificationService,\n    factory: DataChangeNotificationService.ɵfac\n  });\n  /**\n   * @hidden\n   */\n\n  return DataChangeNotificationService;\n})();\n\nconst hasChildren = () => false;\n/**\n * @hidden\n */\n\n\nconst isChecked = () => 'none';\n/**\n * @hidden\n */\n\n\nconst isDisabled = () => false;\n/**\n * @hidden\n */\n\n\nconst isExpanded = () => true;\n/**\n * @hidden\n */\n\n\nconst isSelected = () => false;\n/**\n * @hidden\n */\n\n\nconst isVisible = () => true;\n/**\n * @hidden\n */\n\n\nconst trackBy = (_, item) => item;\n/**\n * @hidden\n */\n\n\nlet ExpandStateService = /*#__PURE__*/(() => {\n  let ExpandStateService = class ExpandStateService {\n    /**\n     * @hidden\n     */\n    constructor() {\n      this.changes = new Subject();\n    }\n\n    expand(index, dataItem) {\n      this.changes.next({\n        dataItem,\n        index,\n        expand: true\n      });\n    }\n\n    collapse(index, dataItem) {\n      this.changes.next({\n        dataItem,\n        index,\n        expand: false\n      });\n    }\n\n  };\n\n  ExpandStateService.ɵfac = function ExpandStateService_Factory(t) {\n    return new (t || ExpandStateService)();\n  };\n\n  ExpandStateService.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: ExpandStateService,\n    factory: function (t) {\n      return ExpandStateService.ɵfac(t);\n    }\n  });\n  /**\n   * @hidden\n   */\n\n  return ExpandStateService;\n})();\nlet IndexBuilderService = /*#__PURE__*/(() => {\n  let IndexBuilderService = class IndexBuilderService {\n    /**\n     * @hidden\n     */\n    constructor() {\n      this.INDEX_SEPARATOR = '_';\n    }\n\n    nodeIndex(index = '', parentIndex = '') {\n      return `${parentIndex}${parentIndex ? this.INDEX_SEPARATOR : ''}${index}`;\n    }\n\n    indexForLevel(index, level) {\n      return index.split(this.INDEX_SEPARATOR).slice(0, level).join(this.INDEX_SEPARATOR);\n    }\n\n    lastLevelIndex(index = '') {\n      const parts = index.split(this.INDEX_SEPARATOR);\n\n      if (!parts.length) {\n        return NaN;\n      }\n\n      return parseInt(parts[parts.length - 1], 10);\n    }\n\n    level(index) {\n      return index.split(this.INDEX_SEPARATOR).length;\n    }\n\n  };\n\n  IndexBuilderService.ɵfac = function IndexBuilderService_Factory(t) {\n    return new (t || IndexBuilderService)();\n  };\n\n  IndexBuilderService.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: IndexBuilderService,\n    factory: function (t) {\n      return IndexBuilderService.ɵfac(t);\n    }\n  });\n  /**\n   * @hidden\n   */\n\n  return IndexBuilderService;\n})();\nlet LoadingNotificationService = /*#__PURE__*/(() => {\n  let LoadingNotificationService = class LoadingNotificationService {\n    /**\n     * @hidden\n     */\n    constructor() {\n      this.changes = new Subject();\n    }\n\n    notifyLoaded(index) {\n      this.changes.next(index);\n    }\n\n  };\n\n  LoadingNotificationService.ɵfac = function LoadingNotificationService_Factory(t) {\n    return new (t || LoadingNotificationService)();\n  };\n\n  LoadingNotificationService.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: LoadingNotificationService,\n    factory: function (t) {\n      return LoadingNotificationService.ɵfac(t);\n    }\n  });\n  return LoadingNotificationService;\n})();\nconst focusableRegex = /^(?:a|input|select|option|textarea|button|object)$/i;\n/**\n * @hidden\n */\n\nconst match = (element, selector) => {\n  const matcher = element.matches || element.msMatchesSelector || element.webkitMatchesSelector;\n\n  if (!matcher) {\n    return false;\n  }\n\n  return matcher.call(element, selector);\n};\n/**\n * @hidden\n */\n\n\nconst closestWithMatch = (element, selector) => {\n  if (!document.documentElement.contains(element)) {\n    return null;\n  }\n\n  let parent = element;\n\n  while (parent !== null && parent.nodeType === 1) {\n    if (match(parent, selector)) {\n      return parent;\n    }\n\n    parent = parent.parentElement || parent.parentNode;\n  }\n\n  return null;\n};\n/**\n * @hidden\n */\n\n\nconst noop = () => {};\n/**\n * @hidden\n */\n\n\nconst isPresent = value => value !== null && value !== undefined;\n/**\n * @hidden\n */\n\n\nconst isBlank = value => value === null || value === undefined;\n/**\n * @hidden\n */\n\n\nconst isArray = value => Array.isArray(value);\n/**\n * @hidden\n */\n\n\nconst isNullOrEmptyString = value => isBlank(value) || value.trim().length === 0;\n/**\n * @hidden\n */\n\n\nconst isBoolean = value => typeof value === 'boolean';\n/**\n * @hidden\n */\n\n\nconst closestNode = element => {\n  const selector = 'li.k-treeview-item';\n\n  if (!isDocumentAvailable()) {\n    return null;\n  }\n\n  if (element.closest) {\n    return element.closest(selector);\n  } else {\n    return closestWithMatch(element, selector);\n  }\n};\n/**\n * @hidden\n */\n\n\nconst isFocusable = element => {\n  if (element.tagName) {\n    const tagName = element.tagName.toLowerCase();\n    const tabIndex = element.getAttribute('tabIndex');\n    const skipTab = tabIndex === '-1';\n    let focusable = tabIndex !== null && !skipTab;\n\n    if (focusableRegex.test(tagName)) {\n      focusable = !element.disabled && !skipTab;\n    }\n\n    return focusable;\n  }\n\n  return false;\n};\n/**\n * @hidden\n */\n\n\nconst isContent = element => {\n  const scopeSelector = '.k-in:not(.k-treeview-load-more-button),.k-treeview-item,.k-treeview';\n\n  if (!isDocumentAvailable()) {\n    return null;\n  }\n\n  let node = element;\n\n  while (node && !match(node, scopeSelector)) {\n    node = node.parentNode;\n  }\n\n  if (node) {\n    return match(node, '.k-in:not(.k-treeview-load-more-button)');\n  }\n};\n/**\n * @hidden\n *\n * Returns the nested .k-in:not(.k-treeview-load-more-button) element.\n * If the passed parent item is itself a content node, it is returned.\n */\n\n\nconst getContentElement = parent => {\n  if (!isPresent(parent)) {\n    return null;\n  }\n\n  const selector = '.k-in:not(.k-treeview-load-more-button)';\n\n  if (match(parent, selector)) {\n    return parent;\n  }\n\n  return parent.querySelector(selector);\n};\n/**\n * @hidden\n */\n\n\nconst isLoadMoreButton = element => {\n  return isPresent(closestWithMatch(element, '.k-in.k-treeview-load-more-button'));\n};\n/**\n * @hidden\n */\n\n\nconst closest = (node, predicate) => {\n  while (node && !predicate(node)) {\n    node = node.parentNode;\n  }\n\n  return node;\n};\n/**\n * @hidden\n */\n\n\nconst hasParent = (element, container) => {\n  return Boolean(closest(element, node => node === container));\n};\n/**\n * @hidden\n */\n\n\nconst focusableNode = element => element.nativeElement.querySelector('li[tabindex=\"0\"]');\n/**\n * @hidden\n */\n\n\nconst nodeId = node => node ? node.getAttribute('data-treeindex') : '';\n/**\n * @hidden\n */\n\n\nconst nodeIndex = item => (item || {}).index;\n/**\n * @hidden\n */\n\n\nconst dataItemsEqual = (first, second) => {\n  if (!isPresent(first) && !isPresent(second)) {\n    return true;\n  }\n\n  return isPresent(first) && isPresent(second) && first.item.dataItem === second.item.dataItem;\n};\n/**\n * @hidden\n */\n\n\nconst getDataItem = lookup => {\n  if (!isPresent(lookup)) {\n    return lookup;\n  }\n\n  return lookup.item.dataItem;\n};\n/**\n * @hidden\n */\n\n\nconst isArrayWithAtLeastOneItem = v => v && Array.isArray(v) && v.length !== 0;\n/**\n * @hidden\n * A recursive tree-filtering algorithm that returns:\n * - all child nodes of matching nodes\n * - a chain parent nodes from the match to the root node\n */\n\n\nconst filterTree = (items, term, {\n  operator,\n  ignoreCase,\n  mode\n}, textField, depth = 0) => {\n  const field = typeof textField === \"string\" ? textField : textField[depth];\n  items.forEach(wrapper => {\n    const matcher = typeof operator === \"string\" ? matchByFieldAndCase(field, operator, ignoreCase) : operator;\n    const isMatch = matcher(wrapper.dataItem, term);\n    wrapper.isMatch = isMatch;\n    wrapper.visible = isMatch;\n    wrapper.containsMatches = false;\n\n    if (isMatch) {\n      setParentChain(wrapper.parent);\n    }\n\n    if (wrapper.children && wrapper.children.length > 0) {\n      if (mode === \"strict\" || !isMatch) {\n        filterTree(wrapper.children, term, {\n          operator,\n          ignoreCase,\n          mode\n        }, textField, depth + 1);\n      } else {\n        makeAllVisible(wrapper.children);\n      }\n    }\n  });\n};\n\nconst setParentChain = node => {\n  if (!isPresent(node)) {\n    return;\n  }\n\n  node.containsMatches = true;\n  node.visible = true;\n\n  if (isPresent(node.parent) && !node.parent.containsMatches) {\n    setParentChain(node.parent);\n  }\n};\n\nconst makeAllVisible = nodes => {\n  nodes.forEach(node => {\n    node.visible = true;\n\n    if (node.children) {\n      makeAllVisible(node.children);\n    }\n  });\n};\n\nconst ɵ2 = (a, b) => a.indexOf(b) >= 0,\n      ɵ3 = (a, b) => a.indexOf(b) === -1,\n      ɵ4 = (a, b) => a.lastIndexOf(b, 0) === 0,\n      ɵ5 = (a, b) => a.lastIndexOf(b, 0) === -1,\n      ɵ6 = (a, b) => a.indexOf(b, a.length - b.length) >= 0,\n      ɵ7 = (a, b) => a.indexOf(b, a.length - b.length) < 0;\n\nconst operators = {\n  contains: ɵ2,\n  doesnotcontain: ɵ3,\n  startswith: ɵ4,\n  doesnotstartwith: ɵ5,\n  endswith: ɵ6,\n  doesnotendwith: ɵ7\n};\n\nconst matchByCase = (matcher, ignoreCase) => (a, b) => {\n  if (ignoreCase) {\n    return matcher(a.toLowerCase(), b.toLowerCase());\n  }\n\n  return matcher(a, b);\n};\n\nconst matchByFieldAndCase = (field, operator, ignoreCase) => (dataItem, term) => matchByCase(operators[operator], ignoreCase)(getter(field)(dataItem), term);\n/**\n * @hidden\n */\n\n\nconst buildTreeIndex = (parentIndex, itemIndex) => {\n  return [parentIndex, itemIndex].filter(part => isPresent(part)).join('_');\n};\n/**\n * @hidden\n */\n\n\nconst buildTreeItem = (dataItem, currentLevelIndex, parentIndex) => {\n  if (!isPresent(dataItem)) {\n    return null;\n  }\n\n  return {\n    dataItem,\n    index: buildTreeIndex(parentIndex, currentLevelIndex)\n  };\n};\n/**\n * @hidden\n *\n * Retrieves all descendant nodes' lookups which are currently registered in the provided lookup item as a flat array.\n */\n\n\nconst fetchLoadedDescendants = (lookup, filterExpression) => {\n  if (!isPresent(lookup) || lookup.children.length === 0) {\n    return [];\n  }\n\n  let descendants = lookup.children;\n\n  if (isPresent(filterExpression)) {\n    descendants = descendants.filter(filterExpression);\n  }\n\n  descendants.forEach(child => descendants = descendants.concat(fetchLoadedDescendants(child, filterExpression)));\n  return descendants;\n};\n/**\n * @hidden\n *\n * Compares two arrays to determine whether all unique elements in one, are present in the other.\n * Important:\n *  - it disregards the element order\n *  - it disregards element repetitions - sameValues([1, 1, 2], [1, 2, 2]) will return true\n */\n\n\nconst sameValues = (a, b) => {\n  if (a.length !== b.length) {\n    return false;\n  }\n\n  const values = new Set(b);\n  return a.every(v => values.has(v));\n};\n\nconst safe = node => node || {};\n\nconst safeChildren = node => safe(node).children || [];\n\nconst lastVisibleNode = nodes => {\n  if (!Array.isArray(nodes) || nodes.length === 0) {\n    return null;\n  }\n\n  const nodesCount = nodes.length;\n  const lastIndex = nodesCount - 1;\n\n  for (let index = lastIndex; index >= 0; index -= 1) {\n    const node = nodes[index];\n\n    if (node.visible) {\n      return node;\n    }\n  }\n\n  return null;\n};\n/**\n * @hidden\n */\n\n\nclass NavigationModel {\n  constructor() {\n    this.ib = new IndexBuilderService();\n    this.nodes = [];\n  }\n\n  firstVisibleNode() {\n    return (this.nodes || []).find(node => node.visible);\n  }\n\n  lastVisibleNode() {\n    let node = lastVisibleNode(this.nodes);\n\n    while (isPresent(node) && safeChildren(node).length > 0) {\n      const children = safeChildren(node);\n      const lastVisibleChild = lastVisibleNode(children);\n\n      if (!isPresent(lastVisibleChild)) {\n        return node;\n      }\n\n      node = lastVisibleChild;\n    }\n\n    return node;\n  }\n\n  closestNode(index) {\n    const {\n      prev\n    } = safe(this.findNode(index));\n    const sibling = prev || this.firstVisibleNode();\n    return safe(sibling).index === index ? this.visibleSibling(sibling, 1) : sibling;\n  }\n\n  firstFocusableNode() {\n    return this.nodes.find(node => {\n      return !node.disabled && node.visible;\n    });\n  }\n\n  findNode(index) {\n    return this.find(index, this.nodes);\n  }\n\n  findParent(index) {\n    const parentLevel = this.ib.level(index) - 1;\n    return this.findNode(this.ib.indexForLevel(index, parentLevel));\n  }\n\n  findVisibleChild(index) {\n    const node = this.findNode(index);\n    const children = safeChildren(node);\n    return children.find(child => child.visible);\n  }\n\n  findVisiblePrev(item) {\n    const index = item.index;\n    const parent = this.findParent(index);\n    const levelIndex = this.ib.lastLevelIndex(index);\n    const prevNodes = this.container(parent).slice(0, levelIndex);\n    const prevNodesHidden = prevNodes.every(node => !node.visible);\n\n    if (levelIndex === 0 || prevNodesHidden) {\n      return parent;\n    }\n\n    const currentNode = this.findNode(index);\n    let prev = this.visibleSibling(currentNode, -1);\n\n    if (prev) {\n      let children = this.container(prev);\n\n      while (children.length > 0 && children.some(node => node.visible)) {\n        prev = lastVisibleNode(children);\n        children = this.container(prev);\n      }\n    }\n\n    return prev;\n  }\n\n  findVisibleNext(item) {\n    const children = this.container(item);\n    const hasVisibleChildren = children.some(child => child.visible);\n\n    if (children.length === 0 || !hasVisibleChildren) {\n      return this.visibleSibling(item, 1);\n    }\n\n    return children.find(child => child.visible);\n  }\n\n  registerItem(id, index, disabled, loadMoreButton = false, visible = true) {\n    const children = [];\n    const level = this.ib.level(index);\n    const parent = this.findParent(index);\n\n    if (parent || level === 1) {\n      const node = {\n        id,\n        children,\n        index,\n        parent,\n        disabled,\n        loadMoreButton,\n        visible\n      };\n      this.insert(node, parent);\n    }\n  }\n\n  unregisterItem(id, index) {\n    const node = this.find(index, this.nodes);\n\n    if (!node || node.id !== id) {\n      return;\n    }\n\n    const children = this.container(node.parent);\n    children.splice(children.indexOf(node), 1);\n  }\n\n  childLevel(nodes) {\n    const children = nodes.filter(node => isPresent(node));\n\n    if (!children || !children.length) {\n      return 1;\n    }\n\n    return this.ib.level(children[0].index);\n  }\n\n  container(node) {\n    return node ? node.children : this.nodes;\n  }\n\n  find(index, nodes) {\n    const childLevel = this.childLevel(nodes);\n    const indexToMatch = this.ib.indexForLevel(index, childLevel);\n    const isLeaf = childLevel === this.ib.level(index);\n    const node = nodes.find(n => n && n.index === indexToMatch);\n\n    if (!node) {\n      return null;\n    }\n\n    return isLeaf ? node : this.find(index, node.children);\n  }\n\n  insert(node, parent) {\n    const nodes = this.container(parent);\n    nodes.splice(this.ib.lastLevelIndex(node.index), 0, node);\n  }\n\n  visibleSibling(node, offset) {\n    if (!node) {\n      return null;\n    }\n\n    const parent = this.findParent(node.index);\n    const container = this.container(parent);\n    let nextItemIndex = container.indexOf(node) + offset;\n    let nextItem = container[nextItemIndex];\n\n    while (isPresent(nextItem)) {\n      if (nextItem.visible) {\n        return nextItem;\n      }\n\n      nextItemIndex += offset;\n      nextItem = container[nextItemIndex];\n    }\n\n    return this.visibleSibling(parent, offset);\n  }\n\n}\n/**\n * @hidden\n */\n\n\nlet NavigationService = /*#__PURE__*/(() => {\n  let NavigationService = class NavigationService {\n    constructor(localization) {\n      this.localization = localization;\n      this.expands = new Subject();\n      this.moves = new Subject();\n      this.checks = new Subject();\n      this.selects = new Subject();\n      this.loadMore = new Subject();\n      this.navigable = true;\n      this.actions = {\n        [Keys.ArrowUp]: () => this.activate(this.model.findVisiblePrev(this.focusableItem)),\n        [Keys.ArrowDown]: () => this.activate(this.model.findVisibleNext(this.focusableItem)),\n        [Keys.ArrowLeft]: () => !this.isLoadMoreButton && this.expand({\n          expand: this.localization.rtl,\n          intercept: this.localization.rtl ? this.moveToFirstVisibleChild : this.moveToParent\n        }),\n        [Keys.ArrowRight]: () => !this.isLoadMoreButton && this.expand({\n          expand: !this.localization.rtl,\n          intercept: this.localization.rtl ? this.moveToParent : this.moveToFirstVisibleChild\n        }),\n        [Keys.Home]: () => this.activate(this.model.firstVisibleNode()),\n        [Keys.End]: () => this.activate(this.model.lastVisibleNode()),\n        [Keys.Enter]: () => this.handleEnter(),\n        [Keys.Space]: () => this.handleSpace()\n      };\n      this.isFocused = false;\n      this._model = new NavigationModel();\n      this.moveToFirstVisibleChild = this.moveToFirstVisibleChild.bind(this);\n      this.moveToParent = this.moveToParent.bind(this);\n    }\n\n    get model() {\n      return this._model;\n    }\n\n    set model(model) {\n      this._model = model;\n    }\n\n    get activeIndex() {\n      return nodeIndex(this.activeItem) || null;\n    }\n\n    get isActiveExpanded() {\n      return this.activeItem && this.activeItem.children.length > 0;\n    }\n\n    get isLoadMoreButton() {\n      return this.activeItem && this.activeItem.loadMoreButton;\n    }\n\n    get focusableItem() {\n      return this.activeItem || this.model.firstFocusableNode();\n    }\n\n    activate(item) {\n      if (!this.navigable || !item || this.isActive(nodeIndex(item))) {\n        return;\n      }\n\n      this.isFocused = true;\n      this.activeItem = item || this.activeItem;\n      this.notifyMove();\n    }\n\n    activateParent(index) {\n      this.activate(this.model.findParent(index));\n    }\n\n    activateIndex(index) {\n      if (!index) {\n        return;\n      }\n\n      this.activate(this.model.findNode(index));\n    }\n\n    activateClosest(index) {\n      if (!index || nodeIndex(this.focusableItem) !== index) {\n        return;\n      }\n\n      this.activeItem = this.model.closestNode(index);\n      this.notifyMove();\n    }\n\n    activateFocusable() {\n      if (this.activeItem) {\n        return;\n      }\n\n      this.activeItem = this.model.firstVisibleNode();\n      this.notifyMove();\n    }\n\n    deactivate() {\n      if (!this.navigable || !this.isFocused) {\n        return;\n      }\n\n      this.isFocused = false;\n      this.notifyMove();\n    }\n\n    checkIndex(index) {\n      if (!this.isDisabled(index)) {\n        this.checks.next(index);\n      }\n    }\n\n    selectIndex(index) {\n      if (!this.isDisabled(index)) {\n        this.selects.next(index);\n      }\n    }\n\n    notifyLoadMore(index) {\n      if (!isPresent(index)) {\n        return;\n      }\n\n      this.loadMore.next(index);\n    }\n\n    isActive(index) {\n      if (!index) {\n        return false;\n      }\n\n      return this.isFocused && this.activeIndex === index;\n    }\n\n    isFocusable(index) {\n      return nodeIndex(this.focusableItem) === index;\n    }\n\n    isDisabled(index) {\n      return this.model.findNode(index).disabled;\n    }\n\n    registerItem(id, index, disabled, loadMoreButton = false, visible = true) {\n      const itemAtIndex = this.model.findNode(index);\n\n      if (isPresent(itemAtIndex)) {\n        this.model.unregisterItem(itemAtIndex.id, itemAtIndex.index);\n\n        if (this.isActive(index)) {\n          this.deactivate();\n        }\n      }\n\n      this.model.registerItem(id, index, disabled, loadMoreButton, visible);\n    }\n\n    unregisterItem(id, index) {\n      if (this.isActive(index)) {\n        this.activateParent(index);\n      }\n\n      this.model.unregisterItem(id, index);\n    }\n\n    move(e) {\n      if (!this.navigable) {\n        return;\n      }\n\n      const moveAction = this.actions[e.keyCode];\n\n      if (!moveAction) {\n        return;\n      }\n\n      moveAction();\n      e.preventDefault();\n    }\n\n    expand({\n      expand,\n      intercept\n    }) {\n      const index = nodeIndex(this.activeItem);\n\n      if (!index || intercept(index)) {\n        return;\n      }\n\n      this.notifyExpand(expand);\n    }\n\n    moveToParent() {\n      if (this.isActiveExpanded) {\n        return false;\n      }\n\n      this.activate(this.model.findParent(nodeIndex(this.activeItem)));\n      return true;\n    }\n\n    moveToFirstVisibleChild() {\n      if (!this.isActiveExpanded) {\n        return false;\n      }\n\n      this.activate(this.model.findVisibleChild(nodeIndex(this.activeItem)));\n      return true;\n    }\n\n    notifyExpand(expand) {\n      this.expands.next(this.navigationState(expand));\n    }\n\n    notifyMove() {\n      this.moves.next(this.navigationState());\n    }\n\n    navigationState(expand = false) {\n      return {\n        expand,\n        index: this.activeIndex,\n        isFocused: this.isFocused\n      };\n    }\n\n    handleEnter() {\n      if (!this.navigable) {\n        return;\n      }\n\n      if (this.isLoadMoreButton) {\n        this.notifyLoadMore(this.activeIndex);\n      } else {\n        this.selectIndex(this.activeIndex);\n      }\n    }\n\n    handleSpace() {\n      if (!this.navigable) {\n        return;\n      }\n\n      if (this.isLoadMoreButton) {\n        this.notifyLoadMore(this.activeIndex);\n      } else {\n        this.checkIndex(this.activeIndex);\n      }\n    }\n\n  };\n\n  NavigationService.ɵfac = function NavigationService_Factory(t) {\n    return new (t || NavigationService)(ɵngcc0.ɵɵinject(ɵngcc1.LocalizationService));\n  };\n\n  NavigationService.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: NavigationService,\n    factory: function (t) {\n      return NavigationService.ɵfac(t);\n    }\n  });\n  NavigationService = __decorate([__metadata(\"design:paramtypes\", [LocalizationService])], NavigationService);\n  /**\n   * @hidden\n   */\n\n  return NavigationService;\n})();\nlet NodeChildrenService = /*#__PURE__*/(() => {\n  let NodeChildrenService = class NodeChildrenService {\n    /**\n     * @hidden\n     */\n    constructor() {\n      this.changes = new Subject();\n    }\n\n    childrenLoaded(item, children) {\n      this.changes.next({\n        item,\n        children\n      });\n    }\n\n  };\n\n  NodeChildrenService.ɵfac = function NodeChildrenService_Factory(t) {\n    return new (t || NodeChildrenService)();\n  };\n\n  NodeChildrenService.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: NodeChildrenService,\n    factory: function (t) {\n      return NodeChildrenService.ɵfac(t);\n    }\n  });\n  /**\n   * Represents the template for the TreeView nodes ([more information and example]({% slug nodetemplate_treeview %})).\n   * The template helps to customize the content of the nodes. To define the node template, nest an `<ng-template>`\n   * tag with the `kendoTreeViewNodeTemplate` directive inside a `<kendo-treeview>` tag.\n   *\n   *\n   * The node data item and its hierarchical index are available as context variables:\n   *\n   * - `let-dataItem` (`any`) - available as implicit context variable\n   * - `let-index=\"index\"` (`string`)\n   *\n   *\n   * @example\n   * ```ts\n   *\n   *  import { Component } from '@angular/core';\n   *  @Component({\n   *      selector: 'my-app',\n   *      template: `\n   *      <kendo-treeview\n   *          [nodes]=\"data\"\n   *          kendoTreeViewExpandable\n   *\n   *          kendoTreeViewHierarchyBinding\n   *          childrenField=\"items\">\n   *        <ng-template kendoTreeViewNodeTemplate let-dataItem let-index=\"index\">\n   *          <span [style.fontWeight]=\"dataItem.items ? 'bolder': 'normal' \">{{ index }}: {{ dataItem.text }}</span>\n   *        </ng-template>\n   *      </kendo-treeview>\n   *    `\n   *  })\n   *  export class AppComponent {\n   *      public data: any[] = [\n   *          {\n   *              text: \"Inbox\",\n   *              items: [{ text: \"Read Mail\" }]\n   *          },\n   *          {\n   *              text: \"Drafts\"\n   *          },\n   *          {\n   *              text: \"Search Folders\",\n   *              items: [\n   *                  { text: \"Categorized Mail\" },\n   *                  { text: \"Large Mail\" },\n   *                  { text: \"Unread Mail\"}\n   *              ]\n   *          },\n   *          { text: \"Settings\" }\n   *      ];\n   *  }\n   *\n   * ```\n   */\n\n  return NodeChildrenService;\n})();\nlet NodeTemplateDirective = /*#__PURE__*/(() => {\n  let NodeTemplateDirective = class NodeTemplateDirective {\n    constructor(templateRef) {\n      this.templateRef = templateRef;\n    }\n\n  };\n\n  NodeTemplateDirective.ɵfac = function NodeTemplateDirective_Factory(t) {\n    return new (t || NodeTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef, 8));\n  };\n\n  NodeTemplateDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: NodeTemplateDirective,\n    selectors: [[\"\", \"kendoTreeViewNodeTemplate\", \"\"]]\n  });\n  NodeTemplateDirective = __decorate([__param(0, Optional()), __metadata(\"design:paramtypes\", [TemplateRef])], NodeTemplateDirective);\n  /**\n   * Represents the template for the TreeView load more buttons.\n   * To define a button template, nest an `<ng-template>`\n   * tag with the `kendoTreeViewLoadMoreButtonTemplate` directive inside a `<kendo-treeview>` tag\n   * ([see example]({% slug loadmorebutton_treeview %}#toc-button-template)).\n   *\n   * The hierarchical index of the load more button node is available as a context variable:\n   *\n   * - `let-index=\"index\"` (`string`)\n   */\n\n  return NodeTemplateDirective;\n})();\nlet LoadMoreButtonTemplateDirective = /*#__PURE__*/(() => {\n  let LoadMoreButtonTemplateDirective = class LoadMoreButtonTemplateDirective {\n    constructor(templateRef) {\n      this.templateRef = templateRef;\n    }\n\n  };\n\n  LoadMoreButtonTemplateDirective.ɵfac = function LoadMoreButtonTemplateDirective_Factory(t) {\n    return new (t || LoadMoreButtonTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef, 8));\n  };\n\n  LoadMoreButtonTemplateDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: LoadMoreButtonTemplateDirective,\n    selectors: [[\"\", \"kendoTreeViewLoadMoreButtonTemplate\", \"\"]]\n  });\n  LoadMoreButtonTemplateDirective = __decorate([__param(0, Optional()), __metadata(\"design:paramtypes\", [TemplateRef])], LoadMoreButtonTemplateDirective);\n  /**\n   * @hidden\n   *\n   * An injection token used by the data binding directives to interface with\n   * the TreeView or the DropDownTree components.\n   */\n\n  return LoadMoreButtonTemplateDirective;\n})();\nlet DataBoundComponent = /*#__PURE__*/(() => {\n  let DataBoundComponent = class DataBoundComponent {};\n\n  DataBoundComponent.ɵfac = function DataBoundComponent_Factory(t) {\n    return new (t || DataBoundComponent)();\n  };\n\n  DataBoundComponent.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: DataBoundComponent,\n    factory: function (t) {\n      return DataBoundComponent.ɵfac(t);\n    }\n  });\n  /**\n   * @hidden\n   *\n   * An injection token used by the expand-directive to interface with\n   * the TreeView or the DropDownTree components.\n   */\n\n  return DataBoundComponent;\n})();\nlet ExpandableComponent = /*#__PURE__*/(() => {\n  let ExpandableComponent = class ExpandableComponent {};\n\n  ExpandableComponent.ɵfac = function ExpandableComponent_Factory(t) {\n    return new (t || ExpandableComponent)();\n  };\n\n  ExpandableComponent.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: ExpandableComponent,\n    factory: function (t) {\n      return ExpandableComponent.ɵfac(t);\n    }\n  });\n  /**\n   * @hidden\n   */\n\n  return ExpandableComponent;\n})();\nlet SelectionService = /*#__PURE__*/(() => {\n  let SelectionService = class SelectionService {\n    /**\n     * @hidden\n     */\n    constructor() {\n      this.changes = new Subject();\n    }\n\n    isFirstSelected(index) {\n      return this.firstIndex === index;\n    }\n\n    setFirstSelected(index, selected) {\n      if (this.firstIndex === index && selected === false) {\n        this.firstIndex = null;\n      } else if (!this.firstIndex && selected) {\n        this.firstIndex = index;\n      }\n    }\n\n    select(index, dataItem) {\n      this.changes.next({\n        dataItem,\n        index\n      });\n    }\n\n  };\n\n  SelectionService.ɵfac = function SelectionService_Factory(t) {\n    return new (t || SelectionService)();\n  };\n\n  SelectionService.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: SelectionService,\n    factory: function (t) {\n      return SelectionService.ɵfac(t);\n    }\n  });\n  return SelectionService;\n})();\nconst INDEX_REGEX = /\\d+$/;\n/**\n * @hidden\n */\n\nlet TreeViewLookupService = /*#__PURE__*/(() => {\n  let TreeViewLookupService = class TreeViewLookupService {\n    /**\n     * @hidden\n     */\n    constructor() {\n      this.map = new Map();\n    }\n\n    reset() {\n      this.map.clear();\n    }\n\n    registerItem(item, parent) {\n      const currentLookup = {\n        children: [],\n        item,\n        parent: this.item(nodeIndex(parent))\n      };\n      this.map.set(item.index, currentLookup);\n    }\n\n    registerChildren(index, children) {\n      const item = this.item(index);\n\n      if (!item) {\n        return;\n      }\n\n      item.children = children;\n    }\n\n    unregisterItem(index, dataItem) {\n      const current = this.item(index);\n\n      if (current && current.item.dataItem === dataItem) {\n        this.map.delete(index);\n\n        if (current.parent && current.parent.children) {\n          current.parent.children = current.parent.children.filter(item => item.dataItem !== dataItem);\n        }\n      }\n    }\n\n    replaceItem(index, item, parent) {\n      if (!item) {\n        return;\n      }\n\n      this.unregisterItem(index, item.dataItem);\n      this.registerItem(item, parent);\n      this.addToParent(item, parent);\n    }\n\n    itemLookup(index) {\n      const item = this.item(index);\n\n      if (!item) {\n        return null;\n      }\n\n      return {\n        children: this.mapChildren(item.children),\n        item: item.item,\n        parent: item.parent\n      };\n    }\n\n    hasItem(index) {\n      return this.map.has(index);\n    }\n\n    item(index) {\n      return this.map.get(index) || null;\n    }\n\n    addToParent(item, parent) {\n      if (parent) {\n        const parentItem = this.item(parent.index);\n        const index = parseInt(INDEX_REGEX.exec(item.index)[0], 10);\n        parentItem.children = parentItem.children || [];\n        parentItem.children.splice(index, 0, item);\n      }\n    }\n\n    mapChildren(children = []) {\n      return children.map(c => {\n        const {\n          item,\n          parent,\n          children\n        } = this.item(c.index);\n        return {\n          children: this.mapChildren(children),\n          item,\n          parent\n        };\n      });\n    }\n\n  };\n\n  TreeViewLookupService.ɵfac = function TreeViewLookupService_Factory(t) {\n    return new (t || TreeViewLookupService)();\n  };\n\n  TreeViewLookupService.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: TreeViewLookupService,\n    factory: function (t) {\n      return TreeViewLookupService.ɵfac(t);\n    }\n  });\n  return TreeViewLookupService;\n})();\nconst LOAD_MORE_DOC_LINK = 'http://www.telerik.com/kendo-angular-ui/components/treeview/load-more-button/';\nconst providers = [ExpandStateService, IndexBuilderService, TreeViewLookupService, LoadingNotificationService, NodeChildrenService, NavigationService, SelectionService, DataChangeNotificationService, LocalizationService, {\n  provide: L10N_PREFIX,\n  useValue: 'kendo.treeview'\n}, {\n  provide: DataBoundComponent,\n  useExisting: forwardRef(() => TreeViewComponent)\n}, {\n  provide: ExpandableComponent,\n  useExisting: forwardRef(() => TreeViewComponent)\n}];\n/* tslint:disable:member-ordering */\n\n/**\n * Represents the [Kendo UI TreeView component for Angular]({% slug overview_treeview %}).\n *\n * @example\n * {% meta height:350 %}\n * {% embed_file basic-usage/app.component.ts preview %}\n * {% embed_file basic-usage/app.module.ts %}\n * {% endmeta %}\n */\n\nlet TreeViewComponent = /*#__PURE__*/(() => {\n  let TreeViewComponent = class TreeViewComponent {\n    constructor(element, changeDetectorRef, expandService, navigationService, nodeChildrenService, selectionService, treeViewLookupService, ngZone, renderer, dataChangeNotification, localization) {\n      this.element = element;\n      this.changeDetectorRef = changeDetectorRef;\n      this.expandService = expandService;\n      this.navigationService = navigationService;\n      this.nodeChildrenService = nodeChildrenService;\n      this.selectionService = selectionService;\n      this.treeViewLookupService = treeViewLookupService;\n      this.ngZone = ngZone;\n      this.renderer = renderer;\n      this.dataChangeNotification = dataChangeNotification;\n      this.localization = localization;\n      this.classNames = true;\n      this.role = 'tree';\n      /**\n       * The hint which is displayed when the component is empty.\n       */\n\n      this.filterInputPlaceholder = \"\";\n      /** @hidden */\n\n      this.fetchNodes = () => this.data;\n      /**\n       * Fires when the children of the expanded node are loaded.\n       */\n\n\n      this.childrenLoaded = new EventEmitter();\n      /**\n       * Fires when the user blurs the component.\n       */\n\n      this.onBlur = new EventEmitter();\n      /**\n       * Fires when the user focuses the component.\n       */\n\n      this.onFocus = new EventEmitter();\n      /**\n       * Fires when the user expands a TreeView node.\n       */\n\n      this.expand = new EventEmitter();\n      /**\n       * Fires when the user collapses a TreeView node.\n       */\n\n      this.collapse = new EventEmitter();\n      /**\n       * Fires just before the dragging of the node starts ([see example]({% slug draganddrop_treeview %}#toc-setup)). This event is preventable.\n       * If you prevent the event default, no drag hint will be created and the subsequent drag-related events will not be fired.\n       */\n\n      this.nodeDragStart = new EventEmitter();\n      /**\n       * Fires when an item is being dragged ([see example]({% slug draganddrop_treeview %}#toc-setup)).\n       */\n\n      this.nodeDrag = new EventEmitter();\n      /**\n       * Emits when the built-in filtering mechanism in the data-binding directives updates the node's visibility.\n       * Used for the built-in auto-expand functionalities of the component and available for custom implementations.\n       */\n\n      this.filterStateChange = new EventEmitter();\n      /**\n       * Fires on the target TreeView when a dragged item is dropped ([see example]({% slug draganddrop_treeview %}#toc-setup)).\n       * This event is preventable. If you prevent the event default (`event.preventDefualt()`) or invalidate its state (`event.setValid(false)`),\n       * the `addItem` and `removeItem` events will not be triggered.\n       *\n       * Both operations cancel the default drop operation, but the indication to the user is different. `event.setValid(false)` indicates that the operation was\n       * unsuccessful by animating the drag clue to its original position. `event.preventDefault()` simply removes the clue, as if it has been dropped successfully.\n       * As a general rule, use `preventDefault` to manually handle the add and remove operations, and `setValid(false)` to indicate the operation was unsuccessful.\n       */\n\n      this.nodeDrop = new EventEmitter();\n      /**\n       * Fires on the source TreeView after the dragged item has been dropped ([see example]({% slug draganddrop_treeview %}#toc-setup)).\n       */\n\n      this.nodeDragEnd = new EventEmitter();\n      /**\n       * Fires after a dragged item is dropped ([see example]({% slug draganddrop_treeview %}#toc-setup)).\n       * Called on the TreeView where the item is dropped.\n       */\n\n      this.addItem = new EventEmitter();\n      /**\n       * Fires after a dragged item is dropped ([see example]({% slug draganddrop_treeview %}#toc-setup)).\n       * Called on the TreeView from where the item is dragged.\n       */\n\n      this.removeItem = new EventEmitter();\n      /**\n       * Fires when the user selects a TreeView node checkbox\n       * ([see example]({% slug checkboxes_treeview %}#toc-modifying-the-checked-state)).\n       */\n\n      this.checkedChange = new EventEmitter();\n      /**\n       * Fires when the user selects a TreeView node\n       * ([see example]({% slug selection_treeview %}#toc-modifying-the-selection)).\n       */\n\n      this.selectionChange = new EventEmitter();\n      /**\n       * Fires when the value of the built-in filter input element changes.\n       */\n\n      this.filterChange = new EventEmitter();\n      /**\n       * Fires when the user clicks a TreeView node.\n       */\n\n      this.nodeClick = new EventEmitter();\n      /**\n       * Fires when the user double clicks a TreeView node.\n       */\n\n      this.nodeDblClick = new EventEmitter();\n      /**\n       * A function that defines how to track node changes.\n       * By default, the TreeView tracks the nodes by data item object reference.\n       *\n       * @example\n       * ```ts\n       *  @Component({\n       *      selector: 'my-app',\n       *      template: `\n       *          <kendo-treeview\n       *              [nodes]=\"data\"\n       *              textField=\"text\"\n       *              [trackBy]=\"trackBy\"\n       *          >\n       *          </kendo-treeview>\n       *      `\n       *  })\n       *  export class AppComponent {\n       *      public data: any[] = [\n       *          { text: \"Furniture\" },\n       *          { text: \"Decor\" }\n       *      ];\n       *\n       *      public trackBy(index: number, item: any): any {\n       *          return item.text;\n       *      }\n       *  }\n       * ```\n       */\n\n      this.trackBy = trackBy;\n      /**\n       * A function which determines if a specific node is disabled.\n       */\n\n      this.isDisabled = isDisabled;\n      /**\n       * A callback which determines whether a TreeView node should be rendered as hidden. The utility .k-display-none class is used to hide the nodes.\n       * Useful for custom filtering implementations.\n       */\n\n      this.isVisible = isVisible;\n      /**\n       * Determines whether the TreeView keyboard navigable is enabled.\n       */\n\n      this.navigable = true;\n      /**\n       * A function which provides the child nodes for a given parent node\n       * ([see example]({% slug databinding_treeview %})).\n       */\n\n      this.children = () => of([]);\n      /**\n       * Indicates whether the child nodes will be fetched on node expand or will be initially prefetched.\n       * @default true\n       */\n\n\n      this.loadOnDemand = true;\n      /**\n       * Renders the built-in input element for filtering the TreeView.\n       * If set to `true`, the component emits the `filterChange` event, which can be used to [filter the TreeView manually]({% slug filtering_treeview %}#toc-manual-filtering).\n       * A built-in filtering implementation is available to use with the [`kendoTreeViewHierarchyBinding`]({% slug api_treeview_hierarchybindingdirective %}) and [`kendoTreeViewFlatDataBinding`]({% slug api_treeview_flatdatabindingdirective %}) directives.\n       */\n\n      this.filterable = false;\n      /**\n       * Sets an initial value of the built-in input element used for filtering.\n       */\n\n      this.filter = '';\n      this.checkboxes = false;\n      this.expandIcons = false;\n      this.selectable = false;\n      this.touchActions = true;\n      this.isActive = false;\n      this.data = new BehaviorSubject([]);\n      this._animate = true;\n      this.subscriptions = new Subscription();\n      this.domSubscriptions = [];\n      validatePackage(packageMetadata);\n    }\n    /** @hidden */\n\n\n    get direction() {\n      return this.localization.rtl ? 'rtl' : 'ltr';\n    }\n    /**\n     * Determines whether the content animation is enabled.\n     */\n\n\n    set animate(value) {\n      this._animate = value;\n    }\n\n    get animate() {\n      return !this._animate;\n    }\n    /**\n     * @hidden\n     */\n\n\n    set nodeTemplateRef(template) {\n      this.nodeTemplate = template;\n    }\n    /**\n     * @hidden\n     */\n\n\n    set loadMoreButtonTemplateRef(template) {\n      this.loadMoreButtonTemplate = template;\n    }\n    /**\n     * The nodes which will be displayed by the TreeView\n     * ([see example]({% slug databinding_treeview %})).\n     */\n\n\n    set nodes(value) {\n      this.data.next(value || []);\n      this.dataChangeNotification.notify();\n    }\n\n    get nodes() {\n      return this.data.value;\n    }\n    /**\n     * A function which determines if a specific node has child nodes\n     * ([see example]({% slug databinding_treeview %})).\n     */\n\n\n    get hasChildren() {\n      return this._hasChildren || hasChildren;\n    }\n\n    set hasChildren(callback) {\n      this._hasChildren = callback;\n      this.expandIcons = Boolean(this._isExpanded && this._hasChildren);\n    }\n    /**\n     * A function which determines if a specific node is checked\n     * ([see example]({% slug checkboxes_treeview %}#toc-modifying-the-checked-state)).\n     */\n\n\n    get isChecked() {\n      return this._isChecked || isChecked;\n    }\n\n    set isChecked(callback) {\n      this._isChecked = callback;\n      this.checkboxes = Boolean(this._isChecked);\n    }\n    /**\n     * A function which determines if a specific node is expanded.\n     */\n\n\n    get isExpanded() {\n      return this._isExpanded || isExpanded;\n    }\n\n    set isExpanded(callback) {\n      this._isExpanded = callback;\n      this.expandIcons = Boolean(this._isExpanded && this._hasChildren);\n    }\n    /**\n     * A function which determines if a specific node is selected\n     * ([see example]({% slug selection_treeview %}#toc-modifying-the-selection)).\n     */\n\n\n    get isSelected() {\n      return this._isSelected || isSelected;\n    }\n\n    set isSelected(callback) {\n      this._isSelected = callback;\n      this.selectable = Boolean(this._isSelected);\n    }\n\n    ngOnChanges(changes) {\n      this.navigationService.navigable = Boolean(this.navigable); // TODO: should react to changes.loadOnDemand as well - should preload the data or clear the already cached items\n\n      if (anyChanged(['nodes', 'children', 'hasChildren', 'loadOnDemand'], changes, false) && !this.loadOnDemand) {\n        this.preloadChildNodes();\n      }\n    }\n\n    ngOnDestroy() {\n      this.subscriptions.unsubscribe();\n      this.domSubscriptions.forEach(subscription => subscription());\n    }\n\n    ngOnInit() {\n      this.subscriptions.add(this.nodeChildrenService.changes.subscribe(x => this.childrenLoaded.emit(x)));\n      this.subscriptions.add(this.expandService.changes.subscribe(({\n        index,\n        dataItem,\n        expand\n      }) => expand ? this.expand.emit({\n        index,\n        dataItem\n      }) : this.collapse.emit({\n        index,\n        dataItem\n      })));\n      this.subscriptions.add(this.navigationService.checks.subscribe(x => this.checkedChange.emit(this.treeViewLookupService.itemLookup(x))));\n      this.subscriptions.add(this.selectionService.changes.subscribe(x => {\n        if (hasObservers(this.selectionChange)) {\n          this.ngZone.run(() => {\n            this.selectionChange.emit(x);\n          });\n        }\n      }));\n\n      if (this.element) {\n        this.ngZone.runOutsideAngular(() => {\n          this.attachDomHandlers();\n        });\n      }\n    }\n    /**\n     * Blurs the focused TreeView item.\n     */\n\n\n    blur() {\n      if (!isDocumentAvailable()) {\n        return;\n      }\n\n      const target = focusableNode(this.element);\n\n      if (document.activeElement === target) {\n        target.blur();\n      }\n    }\n    /**\n     * Focuses the first focusable item in the TreeView component if no hierarchical index is provided.\n     *\n     * @example\n     * ```ts\n     * import { Component } from '@angular/core';\n     *\n     *  @Component({\n     *      selector: 'my-app',\n     *      template: `\n     *      <button (click)=\"treeview.focus('1')\">Focuses the second node</button>\n     *      <kendo-treeview\n     *          #treeview\n     *          [nodes]=\"data\"\n     *          textField=\"text\"\n     *      >\n     *      </kendo-treeview>\n     *  `\n     *  })\n     *  export class AppComponent {\n     *      public data: any[] = [\n     *          { text: \"Furniture\" },\n     *          { text: \"Decor\" }\n     *      ];\n     *  }\n     * ```\n     */\n\n\n    focus(index) {\n      const focusIndex = index || nodeIndex(this.navigationService.focusableItem);\n      this.navigationService.activateIndex(focusIndex);\n      const target = focusableNode(this.element);\n\n      if (target) {\n        target.focus();\n      }\n    }\n    /**\n     * Based on the specified index, returns the TreeItemLookup node.\n     *\n     * @param index - The index of the node.\n     * @returns {TreeItemLookup} - The item that was searched (looked up).\n     */\n\n\n    itemLookup(index) {\n      return this.treeViewLookupService.itemLookup(index);\n    }\n    /**\n     * Triggers the [`children`]({% slug api_treeview_treeviewcomponent %}#toc-children) function for every expanded node,\n     * causing all rendered child nodes to be fetched again.\n     */\n\n\n    rebindChildren() {\n      this.dataChangeNotification.notify();\n    }\n    /**\n     * Triggers the `expand` event for the provided node and displays it's loading indicator.\n     */\n\n\n    expandNode(item, index) {\n      this.expandService.expand(index, item);\n    }\n    /**\n     * Triggers the `collapse` event for the provided node.\n     */\n\n\n    collapseNode(item, index) {\n      this.expandService.collapse(index, item);\n    }\n    /**\n     * Gets the current page size of the checked data item children collection\n     * ([see example]({% slug loadmorebutton_treeview %}#toc-managing-page-sizes)).\n     *\n     * > Since the root nodes collection is not associated with any parent data item, pass `null` as `dataItem` param to get its page size.\n     *\n     * @param dataItem {any} - The parent data item of the targeted collection.\n     * @returns {number} - The page size of the checked data item children collection.\n     */\n\n\n    getNodePageSize(dataItem) {\n      this.verifyLoadMoreService();\n      return this.loadMoreService.getGroupSize(dataItem);\n    }\n    /**\n     * Sets the page size of the targeted data item children collection\n     * ([see example]({% slug loadmorebutton_treeview %}#toc-managing-page-sizes)).\n     *\n     * > Since the root nodes collection is not associated with any parent data item, pass `null` as `dataItem` param to target its page size.\n     *\n     * @param dataItem {any} - The parent data item of the targeted collection.\n     * @param pageSize {number} - The new page size.\n     */\n\n\n    setNodePageSize(dataItem, pageSize) {\n      this.verifyLoadMoreService();\n      this.loadMoreService.setGroupSize(dataItem, pageSize);\n    }\n    /**\n     * @hidden\n     *\n     * Clears the current TreeViewLookupService node map and re-registers all nodes anew.\n     * Child nodes are acquired through the provided `children` callback.\n     */\n\n\n    preloadChildNodes() {\n      this.treeViewLookupService.reset();\n      this.registerLookupItems(this.nodes);\n    }\n\n    attachDomHandlers() {\n      const element = this.element.nativeElement;\n      this.clickHandler = this.clickHandler.bind(this);\n      this.domSubscriptions.push(this.renderer.listen(element, 'contextmenu', this.clickHandler), this.renderer.listen(element, 'click', this.clickHandler), this.renderer.listen(element, 'dblclick', this.clickHandler), this.renderer.listen(element, 'focusin', this.focusHandler.bind(this)), this.renderer.listen(element, 'focusout', this.blurHandler.bind(this)), this.renderer.listen(element, 'keydown', this.keydownHandler.bind(this)));\n    }\n\n    focusHandler(e) {\n      let focusItem;\n\n      if (match(e.target, '.k-treeview-item')) {\n        focusItem = e.target;\n      } else if (!isFocusable(e.target)) {\n        // with compliments to IE\n        focusItem = closestNode(e.target);\n      }\n\n      if (focusItem) {\n        this.navigationService.activateIndex(nodeId(e.target));\n\n        if (!this.isActive && hasObservers(this.onFocus)) {\n          this.ngZone.run(() => {\n            this.onFocus.emit();\n          });\n        }\n\n        this.isActive = true;\n      }\n    }\n\n    blurHandler(e) {\n      if (this.isActive && match(e.target, '.k-treeview-item') && (!e.relatedTarget || !match(e.relatedTarget, '.k-treeview-item') || !hasParent(e.relatedTarget, this.element.nativeElement))) {\n        this.navigationService.deactivate();\n        this.isActive = false;\n\n        if (hasObservers(this.onBlur)) {\n          this.ngZone.run(() => {\n            this.onBlur.emit();\n          });\n        }\n      }\n    }\n\n    clickHandler(e) {\n      const target = e.target;\n\n      if (e.type === 'contextmenu' && !hasObservers(this.nodeClick) || e.type === 'click' && !hasObservers(this.nodeClick) && !hasObservers(this.selectionChange) && !isLoadMoreButton(target) || e.type === 'dblclick' && !hasObservers(this.nodeDblClick) || isFocusable(target) || !isContent(target) && !isLoadMoreButton(target) || !hasParent(target, this.element.nativeElement)) {\n        return;\n      }\n\n      const index = nodeId(closestNode(target)); // the disabled check is probably not needed due to the k-state-disabled styles\n\n      if (!index || this.navigationService.isDisabled(index)) {\n        return;\n      }\n\n      this.ngZone.run(() => {\n        // record this value before emitting selectionChange (`this.navigationService.selectIndex`), as the treeview state may be changed on its emission\n        const lookup = this.treeViewLookupService.itemLookup(index);\n\n        if (e.type === 'click') {\n          const loadMoreButton = this.navigationService.model.findNode(index).loadMoreButton;\n\n          if (loadMoreButton) {\n            this.navigationService.notifyLoadMore(index);\n            return;\n          } else {\n            this.navigationService.selectIndex(index);\n          }\n        }\n\n        const emitter = e.type === 'dblclick' ? this.nodeDblClick : this.nodeClick;\n        emitter.emit({\n          item: lookup.item,\n          originalEvent: e,\n          type: e.type\n        });\n      });\n    }\n\n    keydownHandler(e) {\n      if (this.isActive && this.navigable) {\n        this.ngZone.run(() => {\n          this.navigationService.move(e);\n        });\n      }\n    }\n\n    verifyLoadMoreService() {\n      if (isDevMode() && !isPresent(this.loadMoreService)) {\n        throw new Error(`To use the TreeView paging functionality, you need to assign the \\`kendoTreeViewLoadMore\\` directive. See ${LOAD_MORE_DOC_LINK}.`);\n      }\n    }\n\n    registerLookupItems(data, parentItem = null) {\n      if (!isPresent(data) || data.length === 0) {\n        return;\n      }\n\n      const parentIndex = nodeIndex(parentItem);\n      const treeItems = data.map((node, index) => buildTreeItem(node, index, parentIndex));\n\n      if (isPresent(parentItem)) {\n        this.treeViewLookupService.registerChildren(parentIndex, treeItems);\n      }\n\n      treeItems.forEach(item => {\n        this.treeViewLookupService.registerItem(item, parentItem);\n\n        if (this.hasChildren(item.dataItem)) {\n          this.children(item.dataItem).subscribe(children => this.registerLookupItems(children, item));\n        }\n      });\n    }\n\n  };\n\n  TreeViewComponent.ɵfac = function TreeViewComponent_Factory(t) {\n    return new (t || TreeViewComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ExpandStateService), ɵngcc0.ɵɵdirectiveInject(NavigationService), ɵngcc0.ɵɵdirectiveInject(NodeChildrenService), ɵngcc0.ɵɵdirectiveInject(SelectionService), ɵngcc0.ɵɵdirectiveInject(TreeViewLookupService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(DataChangeNotificationService), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocalizationService));\n  };\n\n  TreeViewComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: TreeViewComponent,\n    selectors: [[\"kendo-treeview\"]],\n    contentQueries: function TreeViewComponent_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵcontentQuery(dirIndex, NodeTemplateDirective, 7);\n        ɵngcc0.ɵɵcontentQuery(dirIndex, LoadMoreButtonTemplateDirective, 7);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.nodeTemplate = _t.first);\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.loadMoreButtonTemplate = _t.first);\n      }\n    },\n    viewQuery: function TreeViewComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵviewQuery(_c0, 7, ViewContainerRef);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.assetsContainer = _t.first);\n      }\n    },\n    hostVars: 7,\n    hostBindings: function TreeViewComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        ɵngcc0.ɵɵattribute(\"role\", ctx.role)(\"dir\", ctx.direction);\n        ɵngcc0.ɵɵsyntheticHostProperty(\"@.disabled\", ctx.animate);\n        ɵngcc0.ɵɵclassProp(\"k-widget\", ctx.classNames)(\"k-treeview\", ctx.classNames);\n      }\n    },\n    inputs: {\n      filterInputPlaceholder: \"filterInputPlaceholder\",\n      trackBy: \"trackBy\",\n      isDisabled: \"isDisabled\",\n      isVisible: \"isVisible\",\n      navigable: \"navigable\",\n      children: \"children\",\n      loadOnDemand: \"loadOnDemand\",\n      filterable: \"filterable\",\n      filter: \"filter\",\n      animate: \"animate\",\n      nodeTemplateRef: [\"nodeTemplate\", \"nodeTemplateRef\"],\n      loadMoreButtonTemplateRef: [\"loadMoreButtonTemplate\", \"loadMoreButtonTemplateRef\"],\n      nodes: \"nodes\",\n      hasChildren: \"hasChildren\",\n      isChecked: \"isChecked\",\n      isExpanded: \"isExpanded\",\n      isSelected: \"isSelected\",\n      textField: \"textField\"\n    },\n    outputs: {\n      childrenLoaded: \"childrenLoaded\",\n      onBlur: \"blur\",\n      onFocus: \"focus\",\n      expand: \"expand\",\n      collapse: \"collapse\",\n      nodeDragStart: \"nodeDragStart\",\n      nodeDrag: \"nodeDrag\",\n      filterStateChange: \"filterStateChange\",\n      nodeDrop: \"nodeDrop\",\n      nodeDragEnd: \"nodeDragEnd\",\n      addItem: \"addItem\",\n      removeItem: \"removeItem\",\n      checkedChange: \"checkedChange\",\n      selectionChange: \"selectionChange\",\n      filterChange: \"filterChange\",\n      nodeClick: \"nodeClick\",\n      nodeDblClick: \"nodeDblClick\"\n    },\n    exportAs: [\"kendoTreeView\"],\n    features: [ɵngcc0.ɵɵProvidersFeature(providers), ɵngcc0.ɵɵNgOnChangesFeature],\n    decls: 4,\n    vars: 19,\n    consts: [[3, \"value\", \"clearButton\", \"placeholder\", \"valueChange\", 4, \"ngIf\"], [\"kendoTreeViewGroup\", \"\", \"role\", \"group\", 1, \"k-treeview-lines\", 3, \"loadOnDemand\", \"checkboxes\", \"expandIcons\", \"selectable\", \"touchActions\", \"children\", \"hasChildren\", \"isChecked\", \"isDisabled\", \"isExpanded\", \"isSelected\", \"isVisible\", \"nodeTemplateRef\", \"loadMoreButtonTemplateRef\", \"textField\", \"nodes\", \"loadMoreService\", \"trackBy\"], [\"assetsContainer\", \"\"], [3, \"value\", \"clearButton\", \"placeholder\", \"valueChange\"], [\"filterInput\", \"\"], [\"kendoTextBoxPrefixTemplate\", \"\"], [1, \"k-icon\", \"k-i-search\"]],\n    template: function TreeViewComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵtemplate(0, TreeViewComponent_kendo_textbox_0_Template, 3, 3, \"kendo-textbox\", 0);\n        ɵngcc0.ɵɵelement(1, \"ul\", 1);\n        ɵngcc0.ɵɵelementContainer(2, null, 2);\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵproperty(\"ngIf\", ctx.filterable);\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"loadOnDemand\", ctx.loadOnDemand)(\"checkboxes\", ctx.checkboxes)(\"expandIcons\", ctx.expandIcons)(\"selectable\", ctx.selectable)(\"touchActions\", ctx.touchActions)(\"children\", ctx.children)(\"hasChildren\", ctx.hasChildren)(\"isChecked\", ctx.isChecked)(\"isDisabled\", ctx.isDisabled)(\"isExpanded\", ctx.isExpanded)(\"isSelected\", ctx.isSelected)(\"isVisible\", ctx.isVisible)(\"nodeTemplateRef\", ctx.nodeTemplate == null ? null : ctx.nodeTemplate.templateRef)(\"loadMoreButtonTemplateRef\", ctx.loadMoreButtonTemplate == null ? null : ctx.loadMoreButtonTemplate.templateRef)(\"textField\", ctx.textField)(\"nodes\", ctx.fetchNodes)(\"loadMoreService\", ctx.loadMoreService)(\"trackBy\", ctx.trackBy);\n      }\n    },\n    directives: function () {\n      return [ɵngcc2.NgIf, TreeViewGroupComponent, ɵngcc3.TextBoxComponent, ɵngcc3.TextBoxPrefixTemplateDirective];\n    },\n    encapsulation: 2\n  });\n\n  __decorate([HostBinding(\"class.k-widget\"), HostBinding(\"class.k-treeview\"), __metadata(\"design:type\", Boolean)], TreeViewComponent.prototype, \"classNames\", void 0);\n\n  __decorate([HostBinding(\"attr.role\"), __metadata(\"design:type\", String)], TreeViewComponent.prototype, \"role\", void 0);\n\n  __decorate([HostBinding(\"attr.dir\"), __metadata(\"design:type\", String), __metadata(\"design:paramtypes\", [])], TreeViewComponent.prototype, \"direction\", null);\n\n  __decorate([ViewChild('assetsContainer', {\n    read: ViewContainerRef,\n    static: true\n  }), __metadata(\"design:type\", ViewContainerRef)], TreeViewComponent.prototype, \"assetsContainer\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", String)], TreeViewComponent.prototype, \"filterInputPlaceholder\", void 0);\n\n  __decorate([Input(), HostBinding('@.disabled'), __metadata(\"design:type\", Boolean), __metadata(\"design:paramtypes\", [Boolean])], TreeViewComponent.prototype, \"animate\", null);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], TreeViewComponent.prototype, \"childrenLoaded\", void 0);\n\n  __decorate([Output('blur'), __metadata(\"design:type\", EventEmitter)], TreeViewComponent.prototype, \"onBlur\", void 0);\n\n  __decorate([Output('focus'), __metadata(\"design:type\", EventEmitter)], TreeViewComponent.prototype, \"onFocus\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], TreeViewComponent.prototype, \"expand\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], TreeViewComponent.prototype, \"collapse\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], TreeViewComponent.prototype, \"nodeDragStart\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], TreeViewComponent.prototype, \"nodeDrag\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], TreeViewComponent.prototype, \"filterStateChange\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], TreeViewComponent.prototype, \"nodeDrop\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], TreeViewComponent.prototype, \"nodeDragEnd\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], TreeViewComponent.prototype, \"addItem\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], TreeViewComponent.prototype, \"removeItem\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], TreeViewComponent.prototype, \"checkedChange\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], TreeViewComponent.prototype, \"selectionChange\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], TreeViewComponent.prototype, \"filterChange\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], TreeViewComponent.prototype, \"nodeClick\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], TreeViewComponent.prototype, \"nodeDblClick\", void 0);\n\n  __decorate([ContentChild(NodeTemplateDirective, {\n    static: true\n  }), __metadata(\"design:type\", NodeTemplateDirective)], TreeViewComponent.prototype, \"nodeTemplate\", void 0);\n\n  __decorate([Input('nodeTemplate'), __metadata(\"design:type\", NodeTemplateDirective), __metadata(\"design:paramtypes\", [NodeTemplateDirective])], TreeViewComponent.prototype, \"nodeTemplateRef\", null);\n\n  __decorate([ContentChild(LoadMoreButtonTemplateDirective, {\n    static: true\n  }), __metadata(\"design:type\", LoadMoreButtonTemplateDirective)], TreeViewComponent.prototype, \"loadMoreButtonTemplate\", void 0);\n\n  __decorate([Input('loadMoreButtonTemplate'), __metadata(\"design:type\", LoadMoreButtonTemplateDirective), __metadata(\"design:paramtypes\", [LoadMoreButtonTemplateDirective])], TreeViewComponent.prototype, \"loadMoreButtonTemplateRef\", null);\n\n  __decorate([Input(), __metadata(\"design:type\", Function)], TreeViewComponent.prototype, \"trackBy\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", Array), __metadata(\"design:paramtypes\", [Array])], TreeViewComponent.prototype, \"nodes\", null);\n\n  __decorate([Input(), __metadata(\"design:type\", Object)], TreeViewComponent.prototype, \"textField\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [Function])], TreeViewComponent.prototype, \"hasChildren\", null);\n\n  __decorate([Input(), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [Function])], TreeViewComponent.prototype, \"isChecked\", null);\n\n  __decorate([Input(), __metadata(\"design:type\", Function)], TreeViewComponent.prototype, \"isDisabled\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [Function])], TreeViewComponent.prototype, \"isExpanded\", null);\n\n  __decorate([Input(), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [Function])], TreeViewComponent.prototype, \"isSelected\", null);\n\n  __decorate([Input(), __metadata(\"design:type\", Function)], TreeViewComponent.prototype, \"isVisible\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", Boolean)], TreeViewComponent.prototype, \"navigable\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", Function)], TreeViewComponent.prototype, \"children\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", Boolean)], TreeViewComponent.prototype, \"loadOnDemand\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", Boolean)], TreeViewComponent.prototype, \"filterable\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", String)], TreeViewComponent.prototype, \"filter\", void 0);\n\n  TreeViewComponent = __decorate([__metadata(\"design:paramtypes\", [ElementRef, ChangeDetectorRef, ExpandStateService, NavigationService, NodeChildrenService, SelectionService, TreeViewLookupService, NgZone, Renderer2, DataChangeNotificationService, LocalizationService])], TreeViewComponent);\n  /**\n   * @hidden\n   */\n\n  return TreeViewComponent;\n})();\nlet TreeViewGroupComponent = /*#__PURE__*/(() => {\n  let TreeViewGroupComponent = class TreeViewGroupComponent {\n    constructor(expandService, loadingService, indexBuilder, treeViewLookupService, navigationService, nodeChildrenService, dataChangeNotification, changeDetectorRef) {\n      this.expandService = expandService;\n      this.loadingService = loadingService;\n      this.indexBuilder = indexBuilder;\n      this.treeViewLookupService = treeViewLookupService;\n      this.navigationService = navigationService;\n      this.nodeChildrenService = nodeChildrenService;\n      this.dataChangeNotification = dataChangeNotification;\n      this.changeDetectorRef = changeDetectorRef;\n      this.kGroupClass = true;\n      this.role = 'group';\n      this.loadOnDemand = true;\n      this.textField = \"\";\n      this.initialNodesLoaded = false;\n      this.loadingMoreNodes = false;\n      this._data = [];\n      this.singleRecordSubscriptions = new Subscription();\n\n      this.isChecked = () => 'none';\n\n      this.isDisabled = () => false;\n\n      this.isExpanded = () => false;\n\n      this.isVisible = () => true;\n\n      this.isSelected = () => false;\n\n      this.children = () => of([]);\n\n      this.hasChildren = () => false;\n    }\n\n    get moreNodesAvailable() {\n      if (!isPresent(this.loadMoreService) || this.data.length === 0) {\n        return false;\n      }\n\n      return this.pageSize < this.totalNodesCount;\n    }\n\n    get pageSize() {\n      if (!isPresent(this.loadMoreService)) {\n        return null;\n      }\n\n      return this.loadMoreService.getGroupSize(this.parentDataItem);\n    }\n\n    set pageSize(pageSize) {\n      this.loadMoreService.setGroupSize(this.parentDataItem, pageSize);\n    }\n\n    get data() {\n      if (isPresent(this.pageSize)) {\n        const normalizedSizeValue = this.pageSize > 0 ? this.pageSize : 0;\n        return this._data.slice(0, normalizedSizeValue);\n      }\n\n      return this._data;\n    }\n\n    set data(data) {\n      this._data = data;\n      this.registerLoadedNodes(this.data);\n    }\n\n    get loadMoreButtonIndex() {\n      if (!this.loadMoreService) {\n        return null;\n      }\n\n      return this.nodeIndex(this.data.length);\n    }\n    /**\n     * Represents the total number of nodes for the current level.\n     */\n\n\n    get totalNodesCount() {\n      if (!this.loadMoreService) {\n        return this.data.length;\n      }\n\n      return this.loadMoreService.getTotalNodesCount(this.parentDataItem, this._data.length);\n    }\n\n    get hasTemplate() {\n      return isPresent(this.nodeTemplateRef);\n    }\n\n    expandNode(index, dataItem, expand) {\n      if (expand) {\n        this.expandService.expand(index, dataItem);\n      } else {\n        this.expandService.collapse(index, dataItem);\n      }\n    }\n\n    checkNode(index) {\n      this.navigationService.checkIndex(index);\n      this.navigationService.activateIndex(index);\n    }\n\n    nodeIndex(index) {\n      return this.indexBuilder.nodeIndex(index.toString(), this.parentIndex);\n    }\n\n    nodeText(dataItem) {\n      const textField = isArray(this.textField) ? this.textField[0] : this.textField;\n      return getter(textField)(dataItem);\n    }\n\n    ngOnDestroy() {\n      if (isPresent(this.nodesSubscription)) {\n        this.nodesSubscription.unsubscribe();\n      }\n\n      if (isPresent(this.loadMoreNodesSubscription)) {\n        this.loadMoreNodesSubscription.unsubscribe();\n      }\n\n      this.singleRecordSubscriptions.unsubscribe();\n    }\n\n    ngOnInit() {\n      this.subscribeToNodesChange();\n      this.singleRecordSubscriptions.add(this.dataChangeNotification.changes.subscribe(this.subscribeToNodesChange.bind(this)));\n      this.singleRecordSubscriptions.add(this.navigationService.loadMore.pipe(filter(index => index === this.loadMoreButtonIndex)).subscribe(this.loadMoreNodes.bind(this)));\n    }\n\n    ngOnChanges(changes) {\n      if (changes.parentIndex && this.loadOnDemand) {\n        this.setNodeChildren(this.mapToTreeItem(this.data));\n      }\n    }\n\n    fetchChildren(node, index) {\n      return this.children(node).pipe(catchError(() => {\n        this.loadingService.notifyLoaded(index);\n        return EMPTY;\n      }), tap(() => this.loadingService.notifyLoaded(index)));\n    }\n\n    get nextFields() {\n      if (isArray(this.textField)) {\n        return this.textField.length > 1 ? this.textField.slice(1) : this.textField;\n      }\n\n      return [this.textField];\n    }\n\n    loadMoreNodes() {\n      if (isPresent(this.loadMoreService.loadMoreNodes)) {\n        this.fetchMoreNodes();\n      } else {\n        this.loadMoreLocalNodes();\n      }\n    }\n\n    loadMoreLocalNodes() {\n      const initialLoadMoreButtonIndex = this.loadMoreButtonIndex;\n      this.pageSize += this.loadMoreService.getInitialPageSize(this.parentDataItem);\n      this.registerLoadedNodes(this.data); // forces the new items to be registered before the focus is changed\n\n      this.changeDetectorRef.detectChanges();\n      this.reselectItemAt(initialLoadMoreButtonIndex);\n    }\n\n    fetchMoreNodes() {\n      if (this.loadingMoreNodes) {\n        return;\n      }\n\n      this.loadingMoreNodes = true;\n\n      if (isPresent(this.loadMoreNodesSubscription)) {\n        this.loadMoreNodesSubscription.unsubscribe();\n      }\n\n      this.loadMoreNodesSubscription = this.loadMoreService.loadMoreNodes({\n        dataItem: this.parentDataItem,\n        skip: this.data.length,\n        take: this.loadMoreService.getInitialPageSize(this.parentDataItem)\n      }).pipe(finalize(() => this.loadingMoreNodes = false)).subscribe(items => {\n        if (!(Array.isArray(items) && items.length > 0)) {\n          return;\n        }\n\n        const initialLoadMoreButtonIndex = this.loadMoreButtonIndex;\n        this.pageSize += items.length;\n        this.data = this.data.concat(items);\n\n        if (this.navigationService.isActive(initialLoadMoreButtonIndex)) {\n          // forces the new items to be registered before the focus is changed\n          this.changeDetectorRef.detectChanges();\n          this.reselectItemAt(initialLoadMoreButtonIndex);\n        }\n      });\n    }\n\n    setNodeChildren(children) {\n      this.treeViewLookupService.registerChildren(this.parentIndex, children);\n    }\n\n    mapToTreeItem(data) {\n      if (!this.parentIndex) {\n        return [];\n      }\n\n      return data.map((dataItem, idx) => ({\n        dataItem,\n        index: this.nodeIndex(idx)\n      }));\n    }\n\n    emitChildrenLoaded(children) {\n      if (!this.parentIndex) {\n        return;\n      } // ignores the registered load-more button\n\n\n      const contentChildren = children.filter(item => item.dataItem);\n      this.nodeChildrenService.childrenLoaded({\n        dataItem: this.parentDataItem,\n        index: this.parentIndex\n      }, contentChildren);\n    }\n\n    subscribeToNodesChange() {\n      if (this.nodesSubscription) {\n        this.nodesSubscription.unsubscribe();\n      }\n\n      this.nodesSubscription = this.nodes(this.parentDataItem, this.parentIndex).subscribe(data => {\n        this.data = data;\n        this.initialNodesLoaded = true;\n      });\n    }\n\n    reselectItemAt(index) {\n      if (!isPresent(index)) {\n        return;\n      } // make sure the old index is cleared first\n\n\n      this.navigationService.deactivate();\n      this.navigationService.activateIndex(index);\n    }\n\n    registerLoadedNodes(nodes = []) {\n      const mappedChildren = this.mapToTreeItem(nodes);\n\n      if (this.loadOnDemand) {\n        this.setNodeChildren(mappedChildren);\n      }\n\n      this.emitChildrenLoaded(mappedChildren);\n    }\n\n  };\n\n  TreeViewGroupComponent.ɵfac = function TreeViewGroupComponent_Factory(t) {\n    return new (t || TreeViewGroupComponent)(ɵngcc0.ɵɵdirectiveInject(ExpandStateService), ɵngcc0.ɵɵdirectiveInject(LoadingNotificationService), ɵngcc0.ɵɵdirectiveInject(IndexBuilderService), ɵngcc0.ɵɵdirectiveInject(TreeViewLookupService), ɵngcc0.ɵɵdirectiveInject(NavigationService), ɵngcc0.ɵɵdirectiveInject(NodeChildrenService), ɵngcc0.ɵɵdirectiveInject(DataChangeNotificationService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef));\n  };\n\n  TreeViewGroupComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: TreeViewGroupComponent,\n    selectors: [[\"\", \"kendoTreeViewGroup\", \"\"]],\n    hostVars: 3,\n    hostBindings: function TreeViewGroupComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        ɵngcc0.ɵɵattribute(\"role\", ctx.role);\n        ɵngcc0.ɵɵclassProp(\"k-group\", ctx.kGroupClass);\n      }\n    },\n    inputs: {\n      loadOnDemand: \"loadOnDemand\",\n      textField: \"textField\",\n      isChecked: \"isChecked\",\n      isDisabled: \"isDisabled\",\n      isExpanded: \"isExpanded\",\n      isVisible: \"isVisible\",\n      isSelected: \"isSelected\",\n      children: \"children\",\n      hasChildren: \"hasChildren\",\n      checkboxes: \"checkboxes\",\n      expandIcons: \"expandIcons\",\n      disabled: \"disabled\",\n      selectable: \"selectable\",\n      touchActions: \"touchActions\",\n      trackBy: \"trackBy\",\n      nodes: \"nodes\",\n      parentDataItem: \"parentDataItem\",\n      parentIndex: \"parentIndex\",\n      nodeTemplateRef: \"nodeTemplateRef\",\n      loadMoreButtonTemplateRef: \"loadMoreButtonTemplateRef\",\n      loadMoreService: \"loadMoreService\"\n    },\n    features: [ɵngcc0.ɵɵNgOnChangesFeature],\n    attrs: _c1,\n    decls: 2,\n    vars: 3,\n    consts: [[\"class\", \"k-item k-treeview-item\", \"kendoTreeViewItem\", \"\", 3, \"k-display-none\", \"dataItem\", \"index\", \"parentDataItem\", \"parentIndex\", \"loadOnDemand\", \"checkable\", \"isChecked\", \"isDisabled\", \"isVisible\", \"expandable\", \"isExpanded\", \"selectable\", \"isSelected\", 4, \"ngFor\", \"ngForOf\", \"ngForTrackBy\"], [\"class\", \"k-item k-treeview-item\", \"kendoTreeViewItem\", \"\", \"role\", \"button\", 3, \"k-treeview-load-more-checkboxes-container\", \"selectable\", \"checkable\", \"expandable\", \"index\", \"parentDataItem\", \"parentIndex\", 4, \"ngIf\"], [\"kendoTreeViewItem\", \"\", 1, \"k-item\", \"k-treeview-item\", 3, \"dataItem\", \"index\", \"parentDataItem\", \"parentIndex\", \"loadOnDemand\", \"checkable\", \"isChecked\", \"isDisabled\", \"isVisible\", \"expandable\", \"isExpanded\", \"selectable\", \"isSelected\"], [1, \"k-mid\"], [\"class\", \"k-icon\", 3, \"k-i-collapse\", \"k-i-expand\", \"kendoTreeViewLoading\", \"click\", 4, \"ngIf\"], [\"tabindex\", \"-1\", 3, \"node\", \"index\", \"isChecked\", \"checkStateChange\", 4, \"ngIf\"], [\"kendoTreeViewItemContent\", \"\", 1, \"k-in\", 3, \"dataItem\", \"index\", \"initialSelection\", \"isSelected\"], [3, \"ngSwitch\"], [4, \"ngSwitchCase\"], [4, \"ngSwitchDefault\"], [\"kendoTreeViewGroup\", \"\", \"role\", \"group\", 3, \"nodes\", \"loadOnDemand\", \"checkboxes\", \"expandIcons\", \"selectable\", \"touchActions\", \"children\", \"hasChildren\", \"isChecked\", \"isDisabled\", \"disabled\", \"isExpanded\", \"isSelected\", \"isVisible\", \"nodeTemplateRef\", \"loadMoreButtonTemplateRef\", \"parentIndex\", \"parentDataItem\", \"textField\", \"loadMoreService\", \"trackBy\", 4, \"ngIf\"], [1, \"k-icon\", 3, \"kendoTreeViewLoading\", \"click\"], [\"tabindex\", \"-1\", 3, \"node\", \"index\", \"isChecked\", \"checkStateChange\"], [3, \"ngTemplateOutlet\", \"ngTemplateOutletContext\"], [\"kendoTreeViewGroup\", \"\", \"role\", \"group\", 3, \"nodes\", \"loadOnDemand\", \"checkboxes\", \"expandIcons\", \"selectable\", \"touchActions\", \"children\", \"hasChildren\", \"isChecked\", \"isDisabled\", \"disabled\", \"isExpanded\", \"isSelected\", \"isVisible\", \"nodeTemplateRef\", \"loadMoreButtonTemplateRef\", \"parentIndex\", \"parentDataItem\", \"textField\", \"loadMoreService\", \"trackBy\"], [\"kendoTreeViewItem\", \"\", \"role\", \"button\", 1, \"k-item\", \"k-treeview-item\", 3, \"selectable\", \"checkable\", \"expandable\", \"index\", \"parentDataItem\", \"parentIndex\"], [\"class\", \"k-icon k-i-loading k-i-expand\", 4, \"ngIf\"], [\"kendoTreeViewItemContent\", \"\", 1, \"k-in\", \"k-treeview-load-more-button\", 3, \"index\"], [4, \"ngIf\"], [1, \"k-icon\", \"k-i-loading\", \"k-i-expand\"]],\n    template: function TreeViewGroupComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵtemplate(0, TreeViewGroupComponent_li_0_Template, 9, 29, \"li\", 0);\n        ɵngcc0.ɵɵtemplate(1, TreeViewGroupComponent_li_1_Template, 6, 14, \"li\", 1);\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵproperty(\"ngForOf\", ctx.data)(\"ngForTrackBy\", ctx.trackBy);\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngIf\", ctx.initialNodesLoaded && ctx.moreNodesAvailable);\n      }\n    },\n    directives: function () {\n      return [ɵngcc2.NgForOf, ɵngcc2.NgIf, TreeViewItemDirective, TreeViewItemContentDirective, ɵngcc2.NgSwitch, ɵngcc2.NgSwitchCase, ɵngcc2.NgSwitchDefault, LoadingIndicatorDirective, CheckBoxComponent, ɵngcc2.NgTemplateOutlet, TreeViewGroupComponent];\n    },\n    encapsulation: 2,\n    data: {\n      animation: [trigger('toggle', [transition('void => *', [style({\n        height: 0\n      }), animate('0.1s ease-in', style({\n        height: \"*\"\n      }))]), transition('* => void', [style({\n        height: \"*\"\n      }), animate('0.1s ease-in', style({\n        height: 0\n      }))])])]\n    }\n  });\n\n  __decorate([HostBinding(\"class.k-group\"), __metadata(\"design:type\", Boolean)], TreeViewGroupComponent.prototype, \"kGroupClass\", void 0);\n\n  __decorate([HostBinding(\"attr.role\"), __metadata(\"design:type\", String)], TreeViewGroupComponent.prototype, \"role\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", Boolean)], TreeViewGroupComponent.prototype, \"checkboxes\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", Boolean)], TreeViewGroupComponent.prototype, \"expandIcons\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", Boolean)], TreeViewGroupComponent.prototype, \"disabled\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", Boolean)], TreeViewGroupComponent.prototype, \"selectable\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", Boolean)], TreeViewGroupComponent.prototype, \"touchActions\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", Boolean)], TreeViewGroupComponent.prototype, \"loadOnDemand\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", Function)], TreeViewGroupComponent.prototype, \"trackBy\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", Function)], TreeViewGroupComponent.prototype, \"nodes\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", Object)], TreeViewGroupComponent.prototype, \"textField\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", Object)], TreeViewGroupComponent.prototype, \"parentDataItem\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", String)], TreeViewGroupComponent.prototype, \"parentIndex\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", TemplateRef)], TreeViewGroupComponent.prototype, \"nodeTemplateRef\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", TemplateRef)], TreeViewGroupComponent.prototype, \"loadMoreButtonTemplateRef\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", Object)], TreeViewGroupComponent.prototype, \"loadMoreService\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", Function)], TreeViewGroupComponent.prototype, \"isChecked\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", Function)], TreeViewGroupComponent.prototype, \"isDisabled\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", Function)], TreeViewGroupComponent.prototype, \"isExpanded\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", Function)], TreeViewGroupComponent.prototype, \"isVisible\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", Function)], TreeViewGroupComponent.prototype, \"isSelected\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", Function)], TreeViewGroupComponent.prototype, \"children\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", Function)], TreeViewGroupComponent.prototype, \"hasChildren\", void 0);\n\n  TreeViewGroupComponent = __decorate([__metadata(\"design:paramtypes\", [ExpandStateService, LoadingNotificationService, IndexBuilderService, TreeViewLookupService, NavigationService, NodeChildrenService, DataChangeNotificationService, ChangeDetectorRef])], TreeViewGroupComponent);\n  return TreeViewGroupComponent;\n})();\n\nconst indexChecked = (keys, index) => keys.filter(k => k === index).length > 0;\n\nconst matchKey = index => k => {\n  if (index === k) {\n    return true;\n  }\n\n  if (!k.split) {\n    return false;\n  }\n\n  return k.split('_').reduce(({\n    key,\n    result\n  }, part) => {\n    key += part;\n\n    if (index === key || result) {\n      return {\n        result: true\n      };\n    }\n\n    key += \"_\";\n    return {\n      key,\n      result: false\n    };\n  }, {\n    key: \"\",\n    result: false\n  }).result;\n};\n/**\n * A directive which manages the in-memory checked state of the TreeView node\n * ([see example]({% slug checkboxes_treeview %})).\n */\n\n\nlet CheckDirective = /*#__PURE__*/(() => {\n  let CheckDirective = class CheckDirective {\n    constructor(treeView, zone) {\n      this.treeView = treeView;\n      this.zone = zone;\n      /**\n       * Fires when the `checkedKeys` collection was updated.\n       */\n\n      this.checkedKeysChange = new EventEmitter();\n      this.subscriptions = new Subscription();\n      this.checkActions = {\n        'multiple': e => this.checkMultiple(e),\n        'single': e => this.checkSingle(e)\n      };\n      this._checkedKeys = [];\n      this.subscriptions.add(this.treeView.checkedChange.subscribe(e => this.check(e)));\n      let expandedItems = [];\n      this.subscriptions.add(this.treeView.childrenLoaded.pipe(filter(() => this.options.checkChildren && this.treeView.loadOnDemand), tap(item => expandedItems.push(item)), switchMap(() => this.zone.onStable.pipe(take(1)))).subscribe(() => this.addCheckedItemsChildren(expandedItems)));\n      this.treeView.isChecked = this.isItemChecked.bind(this);\n    }\n    /**\n     * @hidden\n     */\n\n\n    set isChecked(value) {\n      this.treeView.isChecked = value;\n    }\n    /**\n     * Defines the collection that will store the checked keys\n     * ([see example]({% slug checkboxes_treeview %})).\n     */\n\n\n    get checkedKeys() {\n      return this._checkedKeys;\n    }\n\n    set checkedKeys(keys) {\n      this._checkedKeys = keys;\n    }\n\n    get options() {\n      const defaultOptions = {\n        checkChildren: true,\n        checkParents: true,\n        enabled: true,\n        mode: \"multiple\"\n      };\n\n      if (!isPresent(this.checkable) || typeof this.checkable === 'string') {\n        return defaultOptions;\n      }\n\n      const checkSettings = isBoolean(this.checkable) ? {\n        enabled: this.checkable\n      } : this.checkable;\n      return Object.assign(defaultOptions, checkSettings);\n    }\n\n    ngOnChanges(changes) {\n      if (changes.checkable) {\n        this.treeView.checkboxes = this.options.enabled;\n        this.toggleCheckOnClick();\n      }\n    }\n\n    ngOnDestroy() {\n      this.subscriptions.unsubscribe();\n      this.unsubscribeClick();\n    }\n\n    isItemChecked(dataItem, index) {\n      if (!this.checkKey) {\n        return this.isIndexChecked(index);\n      }\n\n      const keyIndex = this.checkedKeys.indexOf(this.itemKey({\n        dataItem,\n        index\n      }));\n      return keyIndex > -1 ? 'checked' : 'none';\n    }\n\n    isIndexChecked(index) {\n      const checkedKeys = this.checkedKeys.filter(matchKey(index));\n\n      if (indexChecked(checkedKeys, index)) {\n        return 'checked';\n      }\n\n      const {\n        mode,\n        checkParents\n      } = this.options;\n\n      if (mode === 'multiple' && checkParents && checkedKeys.length) {\n        return 'indeterminate';\n      }\n\n      return 'none';\n    }\n\n    itemKey(item) {\n      if (!isPresent(this.checkKey)) {\n        return item.index;\n      }\n\n      if (typeof this.checkKey === \"string\" && isPresent(item.dataItem)) {\n        return item.dataItem[this.checkKey];\n      }\n\n      if (typeof this.checkKey === \"function\") {\n        return this.checkKey(item);\n      }\n    }\n\n    check(e) {\n      const {\n        enabled,\n        mode\n      } = this.options;\n      const performSelection = this.checkActions[mode] || noop;\n\n      if (!enabled) {\n        return;\n      }\n\n      performSelection(e);\n    }\n\n    checkSingle(node) {\n      const key = this.itemKey(node.item);\n      this.checkedKeys = this.checkedKeys[0] !== key ? [key] : [];\n      this.notify();\n    }\n\n    checkMultiple(node) {\n      this.checkNode(node);\n\n      if (this.options.checkParents) {\n        this.checkParents(node.parent);\n      }\n\n      this.notify();\n    }\n\n    toggleCheckOnClick() {\n      this.unsubscribeClick();\n\n      if (this.options.checkOnClick) {\n        this.clickSubscription = this.treeView.nodeClick.subscribe(args => {\n          if (args.type === 'click') {\n            const lookup = this.treeView.itemLookup(args.item.index);\n            this.check(lookup);\n          }\n        });\n      }\n    }\n\n    unsubscribeClick() {\n      if (this.clickSubscription) {\n        this.clickSubscription.unsubscribe();\n        this.clickSubscription = null;\n      }\n    }\n\n    checkNode(node) {\n      if (!isPresent(node.item.dataItem) || this.treeView.isDisabled(node.item.dataItem, node.item.index)) {\n        return;\n      }\n\n      const currentKey = this.itemKey(node.item);\n\n      if (!isPresent(currentKey)) {\n        return;\n      }\n\n      const checkedKeys = new Set(this.checkedKeys);\n      const pendingCheck = [currentKey];\n\n      if (this.options.checkChildren) {\n        const descendants = fetchLoadedDescendants(node, ({\n          item\n        }) => this.treeView.isVisible(item.dataItem, item.index) && !this.treeView.isDisabled(item.dataItem, item.index)).map(({\n          item\n        }) => this.itemKey(item));\n        pendingCheck.push(...descendants);\n      }\n\n      const shouldCheck = !checkedKeys.has(currentKey);\n      pendingCheck.forEach(key => {\n        if (shouldCheck) {\n          checkedKeys.add(key);\n        } else {\n          checkedKeys.delete(key);\n        }\n      });\n      this.checkedKeys = Array.from(checkedKeys);\n    }\n\n    checkParents(parent) {\n      if (!isPresent(parent)) {\n        return;\n      }\n\n      const checkedKeys = new Set(this.checkedKeys);\n      let currentParent = parent;\n\n      while (currentParent) {\n        const parentKey = this.itemKey(currentParent.item);\n        const allChildrenSelected = currentParent.children.every(item => checkedKeys.has(this.itemKey(item)));\n\n        if (allChildrenSelected) {\n          checkedKeys.add(parentKey);\n        } else {\n          checkedKeys.delete(parentKey);\n        }\n\n        currentParent = currentParent.parent;\n      }\n\n      this.checkedKeys = Array.from(checkedKeys);\n    }\n\n    notify() {\n      this.checkedKeysChange.emit(this.checkedKeys.slice());\n    }\n\n    addCheckedItemsChildren(lookups) {\n      if (!isPresent(lookups) || lookups.length === 0) {\n        return;\n      }\n\n      const initiallyCheckedItemsCount = this.checkedKeys.length;\n      const checkedKeys = new Set(this.checkedKeys);\n      lookups.forEach(lookup => {\n        const itemKey = this.itemKey(lookup.item);\n\n        if (!checkedKeys.has(itemKey)) {\n          return;\n        }\n\n        lookup.children.forEach(item => {\n          // ensure both the parent item and each child node is enabled\n          if (!this.treeView.isDisabled(lookup.item.dataItem, lookup.item.index) && !this.treeView.isDisabled(item.dataItem, item.index)) {\n            checkedKeys.add(this.itemKey(item));\n          }\n        });\n      });\n      const hasNewlyCheckedItems = initiallyCheckedItemsCount !== checkedKeys.size;\n\n      if (hasNewlyCheckedItems) {\n        this.checkedKeys = Array.from(checkedKeys);\n        this.zone.run(() => this.notify());\n      }\n    }\n\n  };\n\n  CheckDirective.ɵfac = function CheckDirective_Factory(t) {\n    return new (t || CheckDirective)(ɵngcc0.ɵɵdirectiveInject(TreeViewComponent), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone));\n  };\n\n  CheckDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: CheckDirective,\n    selectors: [[\"\", \"kendoTreeViewCheckable\", \"\"]],\n    inputs: {\n      isChecked: \"isChecked\",\n      checkedKeys: \"checkedKeys\",\n      checkKey: [\"checkBy\", \"checkKey\"],\n      checkable: [\"kendoTreeViewCheckable\", \"checkable\"]\n    },\n    outputs: {\n      checkedKeysChange: \"checkedKeysChange\"\n    },\n    features: [ɵngcc0.ɵɵNgOnChangesFeature]\n  });\n\n  __decorate([Input(), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [Function])], CheckDirective.prototype, \"isChecked\", null);\n\n  __decorate([Input(\"checkBy\"), __metadata(\"design:type\", Object)], CheckDirective.prototype, \"checkKey\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", Array), __metadata(\"design:paramtypes\", [Array])], CheckDirective.prototype, \"checkedKeys\", null);\n\n  __decorate([Input('kendoTreeViewCheckable'), __metadata(\"design:type\", Object)], CheckDirective.prototype, \"checkable\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], CheckDirective.prototype, \"checkedKeysChange\", void 0);\n\n  CheckDirective = __decorate([__metadata(\"design:paramtypes\", [TreeViewComponent, NgZone])], CheckDirective);\n  /**\n   * A directive which manages the disabled in-memory state of the TreeView node\n   * ([see example]({% slug disabledstate_treeview %})).\n   */\n\n  return CheckDirective;\n})();\nlet DisableDirective = /*#__PURE__*/(() => {\n  let DisableDirective = class DisableDirective {\n    constructor(treeView, cdr) {\n      this.treeView = treeView;\n      this.cdr = cdr;\n      /**\n       * Defines the collection that will store the disabled keys.\n       */\n\n      this.disabledKeys = [];\n\n      this.treeView.isDisabled = (dataItem, index) => this.disabledKeys.indexOf(this.itemKey({\n        dataItem,\n        index\n      })) > -1;\n    }\n    /**\n     * @hidden\n     */\n\n\n    set isDisabled(value) {\n      this.treeView.isDisabled = value;\n    }\n\n    ngOnChanges(changes = {}) {\n      const {\n        disabledKeys\n      } = changes;\n\n      if (disabledKeys && !disabledKeys.firstChange) {\n        this.cdr.markForCheck();\n      }\n    }\n\n    itemKey(e) {\n      if (!this.disableKey) {\n        return e.index;\n      }\n\n      if (typeof this.disableKey === \"string\") {\n        return e.dataItem[this.disableKey];\n      }\n\n      if (typeof this.disableKey === \"function\") {\n        return this.disableKey(e);\n      }\n    }\n\n  };\n\n  DisableDirective.ɵfac = function DisableDirective_Factory(t) {\n    return new (t || DisableDirective)(ɵngcc0.ɵɵdirectiveInject(TreeViewComponent), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef));\n  };\n\n  DisableDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: DisableDirective,\n    selectors: [[\"\", \"kendoTreeViewDisable\", \"\"]],\n    inputs: {\n      disabledKeys: \"disabledKeys\",\n      isDisabled: \"isDisabled\",\n      disableKey: [\"kendoTreeViewDisable\", \"disableKey\"]\n    },\n    features: [ɵngcc0.ɵɵNgOnChangesFeature]\n  });\n\n  __decorate([Input(), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [Function])], DisableDirective.prototype, \"isDisabled\", null);\n\n  __decorate([Input(\"kendoTreeViewDisable\"), __metadata(\"design:type\", Object)], DisableDirective.prototype, \"disableKey\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", Array)], DisableDirective.prototype, \"disabledKeys\", void 0);\n\n  DisableDirective = __decorate([__metadata(\"design:paramtypes\", [TreeViewComponent, ChangeDetectorRef])], DisableDirective);\n  return DisableDirective;\n})();\nconst DEFAULT_FILTER_EXPAND_SETTINGS = {\n  maxAutoExpandResults: -1,\n  expandMatches: false,\n  expandedOnClear: \"none\"\n};\n/**\n * A directive which manages the expanded state of the TreeView.\n * ([see example]({% slug expandedstate_treeview %})).\n */\n\nlet ExpandDirective = /*#__PURE__*/(() => {\n  let ExpandDirective = class ExpandDirective {\n    constructor(component) {\n      this.component = component;\n      /**\n       * Whether or not to auto-expand the nodes leading from the root node to each filter result.\n       * To fine-tune this behavior, pass a [`FilterExpandSettings`]({% slug api_treeview_filterexpandsettings %}) object to this input.\n       * @default false\n       */\n\n      this.expandOnFilter = false;\n      /**\n       * Fires when the `expandedKeys` collection was updated.\n       */\n\n      this.expandedKeysChange = new EventEmitter();\n      this.subscriptions = new Subscription();\n      this._expandedKeys = [];\n      this.originalExpandedKeys = [];\n      this.isFiltered = false;\n      /**\n       * Fills array with the correct expand keys according to wrapper metadata.\n       */\n\n      this.updateExpandedNodes = (collection, node, autoExpandMatches) => {\n        if (node.containsMatches || node.isMatch && autoExpandMatches && isArrayWithAtLeastOneItem(node.children)) {\n          collection.push(this.itemKey({\n            dataItem: node.dataItem,\n            index: node.index\n          }));\n        }\n\n        if (isArrayWithAtLeastOneItem(node.children)) {\n          node.children.forEach(child => {\n            this.updateExpandedNodes(collection, child, autoExpandMatches);\n          });\n        }\n      };\n      /**\n       * Fills array with the expand key of every node.\n       */\n\n\n      this.getEveryExpandKey = (collection, node) => {\n        if (isArrayWithAtLeastOneItem(node.children)) {\n          collection.push(this.itemKey({\n            dataItem: node.dataItem,\n            index: node.index\n          }));\n        }\n\n        if (isArrayWithAtLeastOneItem(node.children)) {\n          node.children.forEach(child => {\n            this.getEveryExpandKey(collection, child);\n          });\n        }\n      };\n\n      this.subscriptions.add(merge(this.component.expand.pipe(map(e => Object.assign({\n        expand: true\n      }, e))), this.component.collapse.pipe(map(e => Object.assign({\n        expand: false\n      }, e)))).subscribe(this.toggleExpand.bind(this)));\n\n      if (this.component.filterStateChange) {\n        this.subscriptions.add(this.component.filterStateChange.subscribe(this.handleAutoExpand.bind(this)));\n      }\n\n      this.component.isExpanded = (dataItem, index) => this.expandedKeys.indexOf(this.itemKey({\n        dataItem,\n        index\n      })) > -1;\n    }\n    /**\n     * @hidden\n     */\n\n\n    set isExpanded(value) {\n      this.component.isExpanded = value;\n    }\n\n    get filterExpandSettings() {\n      const settings = isBoolean(this.expandOnFilter) ? {\n        enabled: this.expandOnFilter\n      } : Object.assign({}, this.expandOnFilter, {\n        enabled: true\n      });\n      return Object.assign({}, DEFAULT_FILTER_EXPAND_SETTINGS, settings);\n    }\n    /**\n     * Defines the collection that will store the expanded keys.\n     */\n\n\n    get expandedKeys() {\n      return this._expandedKeys;\n    }\n\n    set expandedKeys(keys) {\n      this._expandedKeys = Array.from(new Set(keys));\n    }\n\n    ngOnDestroy() {\n      this.subscriptions.unsubscribe();\n    }\n    /**\n     * @hidden\n     */\n\n\n    itemKey(e) {\n      if (this.expandKey) {\n        if (typeof this.expandKey === \"string\") {\n          return e.dataItem[this.expandKey];\n        }\n\n        if (typeof this.expandKey === \"function\") {\n          return this.expandKey(e);\n        }\n      }\n\n      return e.index;\n    }\n\n    toggleExpand({\n      index,\n      dataItem,\n      expand\n    }) {\n      const item = this.itemKey({\n        index,\n        dataItem\n      });\n      const idx = this.expandedKeys.indexOf(item);\n      let notify = false;\n\n      if (idx > -1 && !expand) {\n        this.expandedKeys.splice(idx, 1);\n        notify = true;\n      } else if (idx === -1 && expand) {\n        this.expandedKeys.push(item);\n        notify = true;\n      }\n\n      if (notify) {\n        this.expandedKeysChange.emit(this.expandedKeys);\n      }\n    }\n\n    handleAutoExpand({\n      nodes,\n      matchCount,\n      term\n    }) {\n      if (!this.filterExpandSettings.enabled) {\n        return;\n      }\n\n      const {\n        maxAutoExpandResults,\n        expandMatches: autoExpandMatches,\n        expandedOnClear\n      } = this.filterExpandSettings;\n\n      if (!this.isFiltered) {\n        this.originalExpandedKeys = this.expandedKeys.slice();\n      }\n\n      const exitingFilteredState = this.isFiltered && !term;\n      const maxExceeded = maxAutoExpandResults !== -1 && matchCount > maxAutoExpandResults;\n      const exitAutoExpandedState = exitingFilteredState || maxExceeded;\n\n      if (exitAutoExpandedState) {\n        switch (expandedOnClear) {\n          case \"initial\":\n            {\n              if (!sameValues(this.expandedKeys, this.originalExpandedKeys)) {\n                this.expandedKeys = this.originalExpandedKeys;\n                this.expandedKeysChange.emit(this.expandedKeys);\n              }\n\n              break;\n            }\n\n          case \"all\":\n            {\n              this.expandedKeys = nodes.reduce((acc, rootNode) => {\n                this.getEveryExpandKey(acc, rootNode);\n                return acc;\n              }, []);\n              this.expandedKeysChange.emit(this.expandedKeys);\n              break;\n            }\n\n          case \"unchanged\":\n            {\n              break;\n            }\n\n          case \"none\":\n          default:\n            {\n              if (this.expandedKeys.length !== 0) {\n                this.expandedKeys = [];\n                this.expandedKeysChange.emit(this.expandedKeys);\n              }\n\n              break;\n            }\n        }\n\n        this.isFiltered = false;\n        return;\n      }\n\n      const indicesToExpand = nodes.reduce((acc, rootNode) => {\n        this.updateExpandedNodes(acc, rootNode, autoExpandMatches);\n        return acc;\n      }, []);\n\n      if (!sameValues(this.expandedKeys, indicesToExpand)) {\n        this.expandedKeys = indicesToExpand;\n        this.expandedKeysChange.emit(this.expandedKeys);\n      }\n\n      this.isFiltered = true;\n    }\n\n  };\n\n  ExpandDirective.ɵfac = function ExpandDirective_Factory(t) {\n    return new (t || ExpandDirective)(ɵngcc0.ɵɵdirectiveInject(ExpandableComponent));\n  };\n\n  ExpandDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: ExpandDirective,\n    selectors: [[\"\", \"kendoTreeViewExpandable\", \"\"]],\n    inputs: {\n      expandOnFilter: \"expandOnFilter\",\n      isExpanded: \"isExpanded\",\n      expandedKeys: \"expandedKeys\",\n      expandKey: [\"expandBy\", \"expandKey\"]\n    },\n    outputs: {\n      expandedKeysChange: \"expandedKeysChange\"\n    }\n  });\n\n  __decorate([Input(), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [Function])], ExpandDirective.prototype, \"isExpanded\", null);\n\n  __decorate([Input(\"expandBy\"), __metadata(\"design:type\", Object)], ExpandDirective.prototype, \"expandKey\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", Object)], ExpandDirective.prototype, \"expandOnFilter\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], ExpandDirective.prototype, \"expandedKeysChange\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", Array), __metadata(\"design:paramtypes\", [Array])], ExpandDirective.prototype, \"expandedKeys\", null);\n\n  ExpandDirective = __decorate([__metadata(\"design:paramtypes\", [ExpandableComponent])], ExpandDirective);\n  /**\n   * A directive which manages the in-memory selection state of the TreeView node\n   * ([see example]({% slug selection_treeview %})).\n   */\n\n  return ExpandDirective;\n})();\nlet SelectDirective = /*#__PURE__*/(() => {\n  let SelectDirective = class SelectDirective {\n    constructor(treeView) {\n      this.treeView = treeView;\n      /**\n       * Fires when the `selectedKeys` collection was updated.\n       */\n\n      this.selectedKeysChange = new EventEmitter();\n      this.subscriptions = new Subscription();\n      this.selectActions = {\n        'multiple': e => this.selectMultiple(e),\n        'single': e => this.selectSingle(e)\n      };\n      this._selectedKeys = [];\n      this.subscriptions.add(this.treeView.selectionChange.subscribe(this.select.bind(this)));\n\n      this.treeView.isSelected = (dataItem, index) => this.selectedKeys.indexOf(this.itemKey({\n        dataItem,\n        index\n      })) > -1;\n    }\n    /**\n     * @hidden\n     */\n\n\n    set isSelected(value) {\n      this.treeView.isSelected = value;\n    }\n    /**\n     * Defines the collection that will store the selected keys\n     * ([see example]({% slug selection_treeview %}#toc-selection-modes)).\n     */\n\n\n    get selectedKeys() {\n      return this._selectedKeys;\n    }\n\n    set selectedKeys(keys) {\n      this._selectedKeys = keys;\n    }\n\n    get getAriaMultiselectable() {\n      return this.options.mode === 'multiple';\n    }\n\n    get options() {\n      const defaultOptions = {\n        enabled: true,\n        mode: 'single'\n      };\n\n      if (!isPresent(this.selection) || typeof this.selection === 'string') {\n        return defaultOptions;\n      }\n\n      const selectionSettings = isBoolean(this.selection) ? {\n        enabled: this.selection\n      } : this.selection;\n      return Object.assign(defaultOptions, selectionSettings);\n    }\n\n    ngOnDestroy() {\n      this.subscriptions.unsubscribe();\n    }\n\n    itemKey(e) {\n      if (!this.selectKey) {\n        return e.index;\n      }\n\n      if (typeof this.selectKey === 'string') {\n        return e.dataItem[this.selectKey];\n      }\n\n      if (typeof this.selectKey === 'function') {\n        return this.selectKey(e);\n      }\n    }\n\n    select(e) {\n      const {\n        enabled,\n        mode\n      } = this.options;\n      const performSelection = this.selectActions[mode] || noop;\n\n      if (!enabled) {\n        return;\n      }\n\n      performSelection(e);\n    }\n\n    selectSingle(node) {\n      const key = this.itemKey(node);\n\n      if (this.selectedKeys[0] === key) {\n        return;\n      }\n\n      this.selectedKeys = [key];\n      this.notify();\n    }\n\n    selectMultiple(node) {\n      const key = this.itemKey(node);\n      const idx = this.selectedKeys.indexOf(key);\n      const isSelected = idx > -1;\n\n      if (!isPresent(key)) {\n        return;\n      }\n\n      if (isSelected) {\n        this.selectedKeys.splice(idx, 1);\n      } else {\n        this.selectedKeys.push(key);\n      }\n\n      this.notify();\n    }\n\n    notify() {\n      this.selectedKeysChange.emit(this.selectedKeys.slice());\n    }\n\n  };\n\n  SelectDirective.ɵfac = function SelectDirective_Factory(t) {\n    return new (t || SelectDirective)(ɵngcc0.ɵɵdirectiveInject(TreeViewComponent));\n  };\n\n  SelectDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: SelectDirective,\n    selectors: [[\"\", \"kendoTreeViewSelectable\", \"\"]],\n    hostVars: 1,\n    hostBindings: function SelectDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        ɵngcc0.ɵɵattribute(\"aria-multiselectable\", ctx.getAriaMultiselectable);\n      }\n    },\n    inputs: {\n      isSelected: \"isSelected\",\n      selectedKeys: \"selectedKeys\",\n      selectKey: [\"selectBy\", \"selectKey\"],\n      selection: [\"kendoTreeViewSelectable\", \"selection\"]\n    },\n    outputs: {\n      selectedKeysChange: \"selectedKeysChange\"\n    }\n  });\n\n  __decorate([Input(), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [Function])], SelectDirective.prototype, \"isSelected\", null);\n\n  __decorate([Input('selectBy'), __metadata(\"design:type\", Object)], SelectDirective.prototype, \"selectKey\", void 0);\n\n  __decorate([Input('kendoTreeViewSelectable'), __metadata(\"design:type\", Object)], SelectDirective.prototype, \"selection\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", Array), __metadata(\"design:paramtypes\", [Array])], SelectDirective.prototype, \"selectedKeys\", null);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], SelectDirective.prototype, \"selectedKeysChange\", void 0);\n\n  __decorate([HostBinding('attr.aria-multiselectable'), __metadata(\"design:type\", Boolean), __metadata(\"design:paramtypes\", [])], SelectDirective.prototype, \"getAriaMultiselectable\", null);\n\n  SelectDirective = __decorate([__metadata(\"design:paramtypes\", [TreeViewComponent])], SelectDirective);\n  /**\n   * Describes the attempted drop action during dragging.\n   * Passed as `action` value to the [`kendoTreeViewDragClueTemplate`]({% slug api_treeview_dragcluetemplatedirective %}) directive.\n   * By default, this value defines the rendered icon in the drag clue.\n   */\n\n  return SelectDirective;\n})();\nvar DropAction = /*#__PURE__*/(() => {\n  (function (DropAction) {\n    DropAction[DropAction[\"Add\"] = 0] = \"Add\";\n    DropAction[DropAction[\"InsertTop\"] = 1] = \"InsertTop\";\n    DropAction[DropAction[\"InsertBottom\"] = 2] = \"InsertBottom\";\n    DropAction[DropAction[\"InsertMiddle\"] = 3] = \"InsertMiddle\";\n    DropAction[DropAction[\"Invalid\"] = 4] = \"Invalid\";\n  })(DropAction || (DropAction = {}));\n\n  return DropAction;\n})();\n\n/**\n * Describes where the dragged item is dropped relative to the drop target item.\n */\nvar DropPosition = /*#__PURE__*/(() => {\n  (function (DropPosition) {\n    DropPosition[DropPosition[\"Over\"] = 0] = \"Over\";\n    DropPosition[DropPosition[\"Before\"] = 1] = \"Before\";\n    DropPosition[DropPosition[\"After\"] = 2] = \"After\";\n  })(DropPosition || (DropPosition = {}));\n\n  return DropPosition;\n})();\n\n/**\n * @hidden\n */\nvar ScrollDirection = /*#__PURE__*/(() => {\n  (function (ScrollDirection) {\n    ScrollDirection[ScrollDirection[\"Up\"] = -1] = \"Up\";\n    ScrollDirection[ScrollDirection[\"Down\"] = 1] = \"Down\";\n  })(ScrollDirection || (ScrollDirection = {}));\n\n  return ScrollDirection;\n})();\n\n/**\n * @hidden\n */\nclass PreventableEvent {\n  constructor() {\n    this.prevented = false;\n  }\n  /**\n   * Prevents the default action for a specified event.\n   * In this way, the source component suppresses the built-in behavior that follows the event.\n   */\n\n\n  preventDefault() {\n    this.prevented = true;\n  }\n  /**\n   * If the event is prevented by any of its subscribers, returns `true`.\n   *\n   * @returns `true` if the default action was prevented. Otherwise, returns `false`.\n   */\n\n\n  isDefaultPrevented() {\n    return this.prevented;\n  }\n\n}\n/**\n * Arguments for the TreeView [`nodeDrop`]({% slug api_treeview_treeviewcomponent %}#toc-nodedrop) event.\n */\n\n\nclass TreeItemDropEvent extends PreventableEvent {\n  /**\n   * @hidden\n   */\n  constructor(initializer, originalEvent) {\n    super();\n    /**\n     * @hidden\n     */\n\n    this.isValid = true;\n    Object.assign(this, initializer);\n    this.originalEvent = originalEvent;\n  }\n  /**\n   * Specifies if the drop action should be marked as valid.\n   * If set to `false`, the [`addItem`]({% slug api_treeview_treeviewcomponent %}#toc-additem) and\n   * [`removeItem`]({% slug api_treeview_treeviewcomponent %}#toc-removeitem) events will not be fired and the drag clue\n   * will be animated back to the source item to indicate the action is marked as invalid.\n   */\n\n\n  setValid(isValid) {\n    this.isValid = isValid;\n  }\n\n}\n/**\n * Arguments for the TreeView [`nodeDragStart`]({% slug api_treeview_treeviewcomponent %}#toc-nodedragstart) event.\n */\n\n\nclass TreeItemDragStartEvent extends PreventableEvent {\n  /**\n   * @hidden\n   */\n  constructor(initializer) {\n    super();\n    Object.assign(this, initializer);\n  }\n\n}\n/**\n * Arguments for the TreeView [`nodeDrag`]({% slug api_treeview_treeviewcomponent %}#toc-nodedrag) and\n * [`nodeDragEnd`]({% slug api_treeview_treeviewcomponent %}#toc-nodedragend) events.\n */\n\n\nclass TreeItemDragEvent {}\n\nconst ɵ0$3 = () => {\n  if (!(isDocumentAvailable() && isPresent(document.body))) {\n    return false;\n  }\n\n  const top = 10;\n  const parent = document.createElement(\"div\");\n  parent.style.transform = \"matrix(10, 0, 0, 10, 0, 0)\";\n  parent.innerHTML = `<div style=\"position: fixed; top: ${top}px;\">child</div>`;\n  document.body.appendChild(parent);\n  const isDifferent = parent.children[0].getBoundingClientRect().top !== top;\n  document.body.removeChild(parent);\n  return isDifferent;\n};\n/**\n * Checks if the browser supports relative stacking context.\n * https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Positioning/Understanding_z_index/The_stacking_context\n */\n\n\nconst hasRelativeStackingContext = memoize(ɵ0$3);\n/**\n * Stores the result of the passed function's first invokation and returns it instead of invoking it again afterwards.\n */\n\nfunction memoize(fn) {\n  let result;\n  let called = false;\n  return (...args) => {\n    if (called) {\n      return result;\n    }\n\n    result = fn(...args);\n    called = true;\n    return result;\n  };\n}\n/**\n * @hidden\n *\n * Gets the offset of the parent element if the latter has the `transform` CSS prop applied.\n * Transformed parents create new stacking context and the `fixed` children must be position based on the transformed parent.\n * https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Positioning/Understanding_z_index/The_stacking_context\n *\n * If no parent container is `transform`-ed the function will return `{ left: 0, top: 0 }`;\n */\n\n\nconst getContainerOffset = element => {\n  if (!(element && hasRelativeStackingContext())) {\n    return {\n      left: 0,\n      top: 0\n    };\n  }\n\n  let offsetParent = element.parentElement;\n\n  while (offsetParent) {\n    if (window.getComputedStyle(offsetParent).transform !== 'none') {\n      break;\n    }\n\n    offsetParent = offsetParent.parentElement;\n  }\n\n  if (offsetParent) {\n    const rect = offsetParent.getBoundingClientRect();\n    return {\n      left: rect.left - offsetParent.scrollLeft,\n      top: rect.top - offsetParent.scrollTop\n    };\n  }\n\n  return {\n    left: 0,\n    top: 0\n  };\n};\n/**\n * @hidden\n */\n\n\nconst getDropAction = (dropPosition, dropTarget) => {\n  if (!(isPresent(dropPosition) && isPresent(dropTarget))) {\n    return DropAction.Invalid;\n  }\n\n  switch (dropPosition) {\n    case DropPosition.Over:\n      return DropAction.Add;\n\n    case DropPosition.Before:\n      return isPresent(closestNode(dropTarget).previousElementSibling) ? DropAction.InsertMiddle : DropAction.InsertTop;\n\n    case DropPosition.After:\n      return isPresent(closestNode(dropTarget).nextElementSibling) ? DropAction.InsertMiddle : DropAction.InsertBottom;\n\n    default:\n      return DropAction.Invalid;\n  }\n};\n/**\n * @hidden\n */\n\n\nconst getDropPosition = (draggedItem, target, clientY, targetTreeView, containerOffset) => {\n  if (!(isPresent(draggedItem) && isPresent(target) && isPresent(targetTreeView) && isPresent(containerOffset))) {\n    return;\n  } // the .k-mid element starts just after the checkbox/expand arrow and stretches till the end of the treeview on the right\n\n\n  const item = closestWithMatch(target, '.k-mid');\n\n  if (!isPresent(item)) {\n    return;\n  } // the content element (.k-in:not(.k-treeview-load-more-button)) holds just the treeview item text\n\n\n  const content = getContentElement(item);\n  const targetChildOfDraggedItem = hasParent(item, closestNode(draggedItem));\n\n  if (!isPresent(content) || content === draggedItem || targetChildOfDraggedItem) {\n    return;\n  }\n\n  const itemViewPortCoords = content.getBoundingClientRect();\n  /*\n      if the user is hovering a treeview item, split the item height into four parts:\n          - dropping into the top quarter should insert the dragged item before the drop target\n          - dropping into the bottom quarter should insert the dragged item after the drop target\n          - dropping into the second or third quarter should add the item as child node of the drop target\n       if the user is NOT hovering a treeview item (he's dragging somewhere on the right), split the item height to just two parts:\n          - dropping should insert before or after\n  */\n\n  const itemDivisionHeight = itemViewPortCoords.height / (isContent(target) ? 4 : 2); // clear any possible container offset created by parent elements with `transform` css property set\n\n  const pointerPosition = clientY - containerOffset.top;\n  const itemTop = itemViewPortCoords.top - containerOffset.top;\n\n  if (pointerPosition < itemTop + itemDivisionHeight) {\n    return DropPosition.Before;\n  }\n\n  if (pointerPosition >= itemTop + itemViewPortCoords.height - itemDivisionHeight) {\n    return DropPosition.After;\n  }\n\n  return DropPosition.Over;\n};\n/**\n * @hidden\n */\n\n\nconst treeItemFromEventTarget = (treeView, dropTarget) => {\n  if (!(isPresent(treeView) && isPresent(dropTarget))) {\n    return null;\n  }\n\n  const node = closestNode(dropTarget);\n  const index = nodeId(node);\n  const lookup = treeView.itemLookup(index);\n\n  if (!(isPresent(lookup) && isPresent(lookup.item.dataItem))) {\n    return null;\n  }\n\n  return lookup;\n};\n/**\n * @hidden\n *\n * Emits `collapse` on the specified TreeView node if the latter is left empty after its last child node was dragged out.\n */\n\n\nconst collapseEmptyParent = (parent, parentNodes, treeview) => {\n  if (isPresent(parent) && parentNodes.length === 0 && treeview.isExpanded(parent.item.dataItem, parent.item.index)) {\n    treeview.collapseNode(parent.item.dataItem, parent.item.index);\n  }\n};\n/**\n * @hidden\n *\n * Expands the node if it's dropped into and it's not yet expanded.\n */\n\n\nconst expandDropTarget = (dropTarget, treeView) => {\n  if (!treeView.isExpanded(dropTarget.item.dataItem, dropTarget.item.index)) {\n    treeView.expandNode(dropTarget.item.dataItem, dropTarget.item.index);\n  }\n};\n/**\n * @hidden\n *\n * Extracts the event target from the viewport coords. Required for touch devices\n * where the `event.target` of a `pointermove` event is always the initially dragged item.\n */\n\n\nconst getDropTarget = event => {\n  if (!(isDocumentAvailable() && isPresent(document.elementFromPoint))) {\n    return event.target;\n  }\n\n  return document.elementFromPoint(event.clientX, event.clientY);\n};\n/**\n * @hidden\n *\n * Checks if the original index is before the new one and corrects the new one by decrementing the index for the level, where the original item stood.\n */\n\n\nconst updateMovedItemIndex = (newIndex, originalIndex) => {\n  const movedItemNewIndexParts = newIndex.split('_');\n  const originalItemIndexParts = originalIndex.split('_'); // if the original item was moved from a deeper level, there's no need for index correction\n  // e.g. 4_0_1 is moved to 5_0 => removing 4_0_1 will not cause 5_0 to be moved\n\n  if (movedItemNewIndexParts.length < originalItemIndexParts.length) {\n    return newIndex;\n  } // check if the parent item paths are the same - index correction is not required when the original item path differs from the path of the moved item - they belong to different hierarchies\n  // e.g. 4_1 is moved to 5_1 - the parent item paths are differen (4 compared to 5) => removing 4_1 will not cause 5_1 to be moved\n  // e.g 4_1 is moved to 4_3 - the parent paths are the same (both 4) => removing 4_1 will cause 4_3 to be moved\n\n\n  const originalItemParentPathLength = originalItemIndexParts.length - 1;\n  const originalItemParentPath = originalItemIndexParts.slice(0, originalItemParentPathLength).join('_');\n  const movedItemParentPath = movedItemNewIndexParts.slice(0, originalItemParentPathLength).join('_'); // check if the the index of the level where the original item is taken from is greater than the one of the moved item\n  // e.g. 4_5 is moved to 4_1 (comapre 5 and 1) => removing 4_5 will not cause 4_1 to be moved\n  // e.g. 4_1 is moved to 4_5 (comapre 1 and 5) => removing 4_1 will cause 4_5 to be moved\n\n  const originalItemIndexLevel = originalItemIndexParts.length - 1;\n  const originalItemLevelIndex = Number(originalItemIndexParts[originalItemIndexLevel]);\n  const movedItemLevelIndex = Number(movedItemNewIndexParts[originalItemIndexLevel]);\n\n  if (originalItemParentPath === movedItemParentPath && movedItemLevelIndex > originalItemLevelIndex) {\n    // if the removed item causes the dropped item to be moved a position up - decrement the index at that level\n    movedItemNewIndexParts[originalItemIndexLevel] = String(movedItemLevelIndex - 1);\n    return movedItemNewIndexParts.join('_');\n  }\n\n  return newIndex;\n};\n/**\n * @hidden\n */\n\n\nconst SCROLLBAR_REG_EXP = new RegExp('(auto|scroll)');\n/**\n * @hidden\n *\n * Retrives the first scrollable element starting the search from the provided one, traversing to the top of the DOM tree.\n */\n\nconst getScrollableContainer = node => {\n  while (isPresent(node) && node.nodeName !== 'HTML') {\n    const hasOverflow = node.scrollHeight > node.clientHeight;\n    const hasScrollbar = SCROLLBAR_REG_EXP.test(getComputedStyle(node).overflowY);\n\n    if (hasOverflow && hasScrollbar) {\n      return node;\n    }\n\n    node = node.parentNode;\n  }\n\n  return node;\n};\n/**\n * @hidden\n *\n * Checks if the top of the scrollable element is reached.\n * Floors the scrollTop value.\n */\n\n\nconst isTopReached = element => Math.floor(element.scrollTop) <= 0;\n/**\n * @hidden\n *\n * Checks if the bottom of the scrollable element is reached.\n * Ceils the scrollTop value.\n */\n\n\nconst isBottomReached = element => Math.ceil(element.scrollTop) >= element.scrollHeight - element.clientHeight;\n/**\n * @hidden\n *\n * Scrolls the element in the given direction by the provided step.\n *\n * If the targeted scroll incrementation doesn't yield any result due to device pixel ratio issues (https://github.com/dimitar-pechev/RenderingIndependentScrollOffsets#readme),\n * increments the step with 1px and again attempts to change the scrollTop of the element, until the content is actually scrolled.\n *\n * Cuts the operation short after 20 unsuccessful attempts to prevent infinite loops in possible corner-case scenarios.\n */\n\n\nconst scrollElementBy = (element, step, direction) => {\n  if (!(isPresent(element) && isDocumentAvailable())) {\n    return;\n  }\n\n  const initialScrollTop = element.scrollTop;\n  let currentStep = step;\n  let iterations = 0;\n\n  while (initialScrollTop === element.scrollTop && !(direction === ScrollDirection.Up && isTopReached(element)) && !(direction === ScrollDirection.Down && isBottomReached(element)) && iterations < 20 // as the bulgarian saying goes - to ties our underpants\n  ) {\n    element.scrollTop += currentStep * direction;\n    currentStep += 1;\n    iterations += 1;\n  }\n};\n/**\n * @hidden\n */\n\n\nconst copyPageSize = (treeview, source, target) => {\n  if (!isPresent(treeview.loadMoreService)) {\n    return;\n  }\n\n  const sourceGroupSize = treeview.getNodePageSize(source);\n  treeview.setNodePageSize(target, sourceGroupSize);\n};\n/**\n * @hidden\n */\n\n\nconst incrementPageSize = (treeview, dataItem) => {\n  if (!isPresent(treeview.loadMoreService)) {\n    return;\n  }\n\n  const currentPageSize = treeview.getNodePageSize(dataItem);\n  treeview.setNodePageSize(dataItem, currentPageSize + 1);\n};\n/**\n * @hidden\n */\n\n\nconst decrementPageSize = (treeview, dataItem) => {\n  if (!isPresent(treeview.loadMoreService)) {\n    return;\n  }\n\n  const currentPageSize = treeview.getNodePageSize(dataItem);\n  treeview.setNodePageSize(dataItem, currentPageSize - 1);\n};\n/**\n * @hidden\n */\n\n\nclass HierarchyEditingService {\n  constructor(hierarchyBinding) {\n    this.hierarchyBinding = hierarchyBinding;\n  }\n\n  add({\n    sourceItem,\n    destinationItem,\n    dropPosition,\n    sourceTree,\n    destinationTree\n  }) {\n    // shallow clone the item as not to mistake it for its 'older' version when the remove handler kicks in to splice the item at its old position\n    const clonedSourceDataItem = Object.assign({}, getDataItem(sourceItem));\n\n    if (dropPosition === DropPosition.Over) {\n      // expand the item that was dropped into\n      expandDropTarget(destinationItem, destinationTree);\n      const destinationChildren = this.childrenFor(getDataItem(destinationItem)); // add the moved node just before the load more button if load more is enabled\n\n      const targetIndex = isPresent(destinationTree.loadMoreService) ? Math.min(destinationTree.loadMoreService.getGroupSize(getDataItem(destinationItem)), destinationChildren.length) : // the page size might be greater than the actual children array length\n      destinationChildren.length;\n      destinationChildren.splice(targetIndex, 0, clonedSourceDataItem);\n      setter(this.hierarchyBinding.childrenField)(getDataItem(destinationItem), destinationChildren);\n      this.movedItemNewIndex = buildTreeIndex(destinationItem.item.index, targetIndex);\n    } else {\n      const destinationParentNodes = this.getParentNodes(destinationItem, destinationTree);\n      const shiftIndex = dropPosition === DropPosition.After ? 1 : 0;\n      const targetIndex = destinationParentNodes.indexOf(getDataItem(destinationItem)) + shiftIndex;\n      destinationParentNodes.splice(targetIndex, 0, clonedSourceDataItem);\n      const parentIndex = destinationItem.parent ? destinationItem.parent.item.index : null;\n      this.movedItemNewIndex = buildTreeIndex(parentIndex, targetIndex);\n    } // increment the parent page size => an item is moved into it\n\n\n    const updatedParent = dropPosition === DropPosition.Over ? getDataItem(destinationItem) : getDataItem(destinationItem.parent);\n    incrementPageSize(destinationTree, updatedParent); // the page sizes are stored by data-item reference => copy the old item ref page size to the new item reference\n\n    copyPageSize(destinationTree, getDataItem(sourceItem), clonedSourceDataItem); // the source tree nodes are reloaded on `removeItem` - reload the destination tree nodes if the soruce and the destination tree are different\n\n    if (sourceTree !== destinationTree && !destinationTree.loadOnDemand) {\n      destinationTree.preloadChildNodes();\n    } // if the source and destination trees are the same, focusing the moved item here will not have the desired effect\n    // as the `remove` handler has not yet kicked-in to remove the item from its old position\n\n\n    if (sourceTree !== destinationTree) {\n      // ensure the focus target is rendered and registered\n      destinationTree.changeDetectorRef.detectChanges();\n      destinationTree.focus(this.movedItemNewIndex);\n    }\n  }\n\n  remove({\n    sourceItem,\n    sourceTree,\n    destinationTree\n  }) {\n    const sourceParentNodes = this.getParentNodes(sourceItem, sourceTree);\n    const sourceItemIndex = sourceParentNodes.indexOf(getDataItem(sourceItem));\n    sourceParentNodes.splice(sourceItemIndex, 1); // emit collapse for the parent node if its last child node was spliced\n\n    collapseEmptyParent(sourceItem.parent, sourceParentNodes, sourceTree); // decrement source item parent page size => an item has been removed from it\n\n    decrementPageSize(sourceTree, getDataItem(sourceItem.parent)); // reload the treeview nodes\n\n    if (!sourceTree.loadOnDemand) {\n      sourceTree.preloadChildNodes();\n    } // if the source and destination trees are different we want to focus only the moved item in the destination tree\n\n\n    if (sourceTree === destinationTree) {\n      // ensure the focus target is rendered and registered\n      destinationTree.changeDetectorRef.detectChanges(); // after the source item is removed from its original position, the candidate index might have to be corrected\n\n      const index = updateMovedItemIndex(this.movedItemNewIndex, sourceItem.item.index);\n      destinationTree.focus(index);\n    }\n  }\n\n  getParentNodes(node, treeView) {\n    return isPresent(node.parent) ? this.childrenFor(getDataItem(node.parent)) : treeView.nodes;\n  }\n\n  childrenFor(dataItem) {\n    return getter(this.hierarchyBinding.childrenField)(dataItem) || [];\n  }\n\n}\n/**\n * @hidden\n */\n\n\nlet DragClueComponent = /*#__PURE__*/(() => {\n  let DragClueComponent = class DragClueComponent {\n    constructor(cdr) {\n      this.cdr = cdr;\n      this.hostClasses = true;\n      this.posistionStyle = 'fixed';\n    }\n\n    get statusIconClass() {\n      switch (this.action) {\n        case DropAction.Add:\n          return 'k-i-plus';\n\n        case DropAction.InsertTop:\n          return 'k-i-insert-up';\n\n        case DropAction.InsertBottom:\n          return 'k-i-insert-down';\n\n        case DropAction.InsertMiddle:\n          return 'k-i-insert-middle';\n\n        case DropAction.Invalid:\n        default:\n          return 'k-i-cancel';\n      }\n    } // exposed as a public method that can be called from outside as the component uses `OnPush` strategy\n\n\n    detectChanges() {\n      this.cdr.detectChanges();\n    }\n\n  };\n\n  DragClueComponent.ɵfac = function DragClueComponent_Factory(t) {\n    return new (t || DragClueComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef));\n  };\n\n  DragClueComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: DragClueComponent,\n    selectors: [[\"kendo-treeview-drag-clue\"]],\n    hostVars: 6,\n    hostBindings: function DragClueComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        ɵngcc0.ɵɵstyleProp(\"position\", ctx.posistionStyle);\n        ɵngcc0.ɵɵclassProp(\"k-header\", ctx.hostClasses)(\"k-drag-clue\", ctx.hostClasses);\n      }\n    },\n    decls: 2,\n    vars: 2,\n    consts: [[4, \"ngIf\"], [3, \"ngTemplateOutlet\", \"ngTemplateOutletContext\"]],\n    template: function DragClueComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵtemplate(0, DragClueComponent_ng_container_0_Template, 4, 4, \"ng-container\", 0);\n        ɵngcc0.ɵɵtemplate(1, DragClueComponent_1_Template, 1, 7, undefined, 0);\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵproperty(\"ngIf\", !ctx.template);\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngIf\", ctx.template);\n      }\n    },\n    directives: [ɵngcc2.NgIf, ɵngcc2.NgTemplateOutlet],\n    encapsulation: 2,\n    changeDetection: 0\n  });\n\n  __decorate([HostBinding('class.k-header'), HostBinding('class.k-drag-clue'), __metadata(\"design:type\", Boolean)], DragClueComponent.prototype, \"hostClasses\", void 0);\n\n  __decorate([HostBinding('style.position'), __metadata(\"design:type\", String)], DragClueComponent.prototype, \"posistionStyle\", void 0);\n\n  DragClueComponent = __decorate([__metadata(\"design:paramtypes\", [ChangeDetectorRef])], DragClueComponent);\n  /**\n   * @hidden\n   */\n\n  return DragClueComponent;\n})();\nlet DragAndDropAssetService = /*#__PURE__*/(() => {\n  class DragAndDropAssetService {\n    get componentRef() {\n      if (!isPresent(this._componentRef)) {\n        throw new Error('The `initalize` method must be called before calling other service methods.');\n      }\n\n      return this._componentRef;\n    }\n\n    set componentRef(componentRef) {\n      this._componentRef = componentRef;\n    }\n\n    get element() {\n      return this.componentRef.location.nativeElement;\n    }\n\n    ngOnDestroy() {\n      if (!isPresent(this._componentRef)) {\n        return;\n      }\n\n      this.element.parentElement.removeChild(this.element);\n      this.componentRef.destroy();\n      this.componentRef = null;\n    }\n\n    show() {\n      this.element.style.display = '';\n    }\n\n    hide() {\n      this.element.style.display = 'none';\n    }\n\n    move(left, top, offset = 0) {\n      this.element.style.left = `${left + offset}px`;\n      this.element.style.top = `${top + offset}px`;\n    }\n\n  }\n\n  DragAndDropAssetService.ɵfac = function DragAndDropAssetService_Factory(t) {\n    return new (t || DragAndDropAssetService)();\n  };\n\n  DragAndDropAssetService.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: DragAndDropAssetService\n  });\n  /**\n   * @hidden\n   */\n\n  return DragAndDropAssetService;\n})();\nconst CLUE_OFFSET = 10;\n/**\n * @hidden\n */\n\nconst RETURN_ANIMATION_DURATION = 200;\n/**\n * @hidden\n */\n\nlet DragClueService = /*#__PURE__*/(() => {\n  let DragClueService = class DragClueService extends DragAndDropAssetService {\n    constructor(componentFactoryResolver) {\n      super();\n      this.componentFactoryResolver = componentFactoryResolver;\n    }\n\n    initialize(container, template) {\n      if (isPresent(this._componentRef)) {\n        this.ngOnDestroy();\n      }\n\n      const clueComponentFactory = this.componentFactoryResolver.resolveComponentFactory(DragClueComponent);\n      this.componentRef = container.createComponent(clueComponentFactory);\n      this.hide();\n      this.componentRef.instance.template = template;\n      this.componentRef.changeDetectorRef.detectChanges();\n    }\n\n    ngOnDestroy() {\n      this.cancelReturnAnimation();\n      this.cancelScroll();\n      super.ngOnDestroy();\n    }\n\n    move(left, top) {\n      super.move(left, top, CLUE_OFFSET);\n    }\n\n    animateDragClueToElementPosition(target) {\n      if (!(isPresent(target) && isPresent(this.element.animate))) {\n        this.hide();\n        return;\n      }\n\n      const targetElementViewPortCoords = target.getBoundingClientRect();\n      const clueElementViewPortCoords = this.element.getBoundingClientRect();\n      this.returnAnimation = this.element.animate([{\n        transform: 'translate(0, 0)'\n      }, {\n        transform: `translate(${targetElementViewPortCoords.left - clueElementViewPortCoords.left}px, ${targetElementViewPortCoords.top - clueElementViewPortCoords.top}px)`\n      }], RETURN_ANIMATION_DURATION);\n\n      this.returnAnimation.onfinish = () => this.hide();\n    }\n\n    cancelReturnAnimation() {\n      if (!isPresent(this.returnAnimation)) {\n        return;\n      }\n\n      this.returnAnimation.cancel();\n      this.returnAnimation = null;\n    }\n\n    updateDragClueData(action, sourceItem, destinationItem) {\n      const dragClue = this.componentRef.instance;\n\n      if (action === dragClue.action && dataItemsEqual(sourceItem, dragClue.sourceItem) && dataItemsEqual(destinationItem, dragClue.destinationItem)) {\n        return;\n      }\n\n      dragClue.action = action;\n      dragClue.sourceItem = sourceItem;\n      dragClue.destinationItem = destinationItem;\n      dragClue.detectChanges();\n    }\n\n    updateText(text) {\n      if (text === this.componentRef.instance.text) {\n        return;\n      }\n\n      this.componentRef.instance.text = text;\n      this.componentRef.instance.detectChanges();\n    }\n    /**\n     * Triggers the first scrollable parent to scroll upwards or downwards.\n     * Uses setInterval, so should be called outside the angular zone.\n     */\n\n\n    scrollIntoView({\n      step,\n      interval\n    }) {\n      this.cancelScroll();\n      const scrollableContainer = getScrollableContainer(this.element);\n\n      if (!isPresent(scrollableContainer)) {\n        return;\n      }\n\n      const containerRect = scrollableContainer.getBoundingClientRect();\n      const clueRect = this.element.getBoundingClientRect(); // if the beginning of the scrollable container is above the current viewport, fall-back to 0\n\n      const firstVisibleClientTopPart = Math.max(containerRect.top, 0); // start scrolling up when the first visible item is dragged over\n\n      const topLimit = firstVisibleClientTopPart + clueRect.height; // if the end of the scrollable container is beneath the current viewport, fall-back to its client height\n      // add the distance from the start of the viewport to the beginning of the container to ensure scrolling bottom begins when the actual end of the container is reached\n\n      const bottomLimit = firstVisibleClientTopPart + Math.min(containerRect.bottom, scrollableContainer.clientHeight);\n\n      if (clueRect.top < topLimit) {\n        this.scrollInterval = setInterval(() => scrollElementBy(scrollableContainer, step, ScrollDirection.Up), interval);\n      } else if (clueRect.bottom > bottomLimit) {\n        this.scrollInterval = setInterval(() => scrollElementBy(scrollableContainer, step, ScrollDirection.Down), interval);\n      }\n    }\n    /**\n     * Cancels out the on-going scroll animation, if present.\n     */\n\n\n    cancelScroll() {\n      if (isPresent(this.scrollInterval)) {\n        clearInterval(this.scrollInterval);\n        this.scrollInterval = null;\n      }\n    }\n\n  };\n\n  DragClueService.ɵfac = function DragClueService_Factory(t) {\n    return new (t || DragClueService)(ɵngcc0.ɵɵinject(ɵngcc0.ComponentFactoryResolver));\n  };\n\n  DragClueService.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: DragClueService,\n    factory: function (t) {\n      return DragClueService.ɵfac(t);\n    }\n  });\n  DragClueService = __decorate([__metadata(\"design:paramtypes\", [ComponentFactoryResolver])], DragClueService);\n  /**\n   * @hidden\n   */\n\n  return DragClueService;\n})();\nlet DropHintComponent = /*#__PURE__*/(() => {\n  let DropHintComponent = class DropHintComponent {\n    constructor(changeDetectorRef) {\n      this.changeDetectorRef = changeDetectorRef;\n      this.hostClass = true;\n      this.position = 'fixed';\n      this.pointerEvents = 'none';\n    } // exposed as a public method that can be called from outside as the component uses `OnPush` strategy\n\n\n    detectChanges() {\n      this.changeDetectorRef.detectChanges();\n    }\n\n  };\n\n  DropHintComponent.ɵfac = function DropHintComponent_Factory(t) {\n    return new (t || DropHintComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef));\n  };\n\n  DropHintComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: DropHintComponent,\n    selectors: [[\"kendo-treeview-drop-hint\"]],\n    hostVars: 6,\n    hostBindings: function DropHintComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        ɵngcc0.ɵɵstyleProp(\"position\", ctx.position)(\"pointer-events\", ctx.pointerEvents);\n        ɵngcc0.ɵɵclassProp(\"k-drop-hint-container\", ctx.hostClass);\n      }\n    },\n    decls: 2,\n    vars: 2,\n    consts: [[\"class\", \"k-drop-hint k-drop-hint-h\", 4, \"ngIf\"], [4, \"ngIf\"], [1, \"k-drop-hint\", \"k-drop-hint-h\"], [1, \"k-drop-hint-start\"], [1, \"k-drop-hint-line\"], [3, \"ngTemplateOutlet\", \"ngTemplateOutletContext\"]],\n    template: function DropHintComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵtemplate(0, DropHintComponent_div_0_Template, 3, 0, \"div\", 0);\n        ɵngcc0.ɵɵtemplate(1, DropHintComponent_1_Template, 1, 6, undefined, 1);\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵproperty(\"ngIf\", !ctx.template);\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngIf\", ctx.template);\n      }\n    },\n    directives: [ɵngcc2.NgIf, ɵngcc2.NgTemplateOutlet],\n    encapsulation: 2,\n    changeDetection: 0\n  });\n\n  __decorate([HostBinding('class.k-drop-hint-container'), __metadata(\"design:type\", Boolean)], DropHintComponent.prototype, \"hostClass\", void 0);\n\n  __decorate([HostBinding('style.position'), __metadata(\"design:type\", String)], DropHintComponent.prototype, \"position\", void 0);\n\n  __decorate([HostBinding('style.pointer-events'), __metadata(\"design:type\", String)], DropHintComponent.prototype, \"pointerEvents\", void 0);\n\n  DropHintComponent = __decorate([__metadata(\"design:paramtypes\", [ChangeDetectorRef])], DropHintComponent);\n  /**\n   * @hidden\n   */\n\n  return DropHintComponent;\n})();\nlet DropHintService = /*#__PURE__*/(() => {\n  let DropHintService = class DropHintService extends DragAndDropAssetService {\n    constructor(componentFactoryResolver) {\n      super();\n      this.componentFactoryResolver = componentFactoryResolver;\n    }\n\n    initialize(container, template) {\n      if (isPresent(this._componentRef)) {\n        this.ngOnDestroy();\n      }\n\n      const hintComponentFactory = this.componentFactoryResolver.resolveComponentFactory(DropHintComponent);\n      this.componentRef = container.createComponent(hintComponentFactory);\n      this.hide();\n      this.componentRef.instance.template = template;\n      this.componentRef.changeDetectorRef.detectChanges();\n    }\n\n    updateDropHintData(action, sourceItem, destinationItem) {\n      const dropHint = this.componentRef.instance;\n\n      if (action === dropHint.action && dataItemsEqual(sourceItem, dropHint.sourceItem) && dataItemsEqual(destinationItem, dropHint.destinationItem)) {\n        return;\n      }\n\n      dropHint.action = action;\n      dropHint.sourceItem = sourceItem;\n      dropHint.destinationItem = destinationItem;\n      dropHint.detectChanges();\n    }\n\n  };\n\n  DropHintService.ɵfac = function DropHintService_Factory(t) {\n    return new (t || DropHintService)(ɵngcc0.ɵɵinject(ɵngcc0.ComponentFactoryResolver));\n  };\n\n  DropHintService.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: DropHintService,\n    factory: function (t) {\n      return DropHintService.ɵfac(t);\n    }\n  });\n  DropHintService = __decorate([__metadata(\"design:paramtypes\", [ComponentFactoryResolver])], DropHintService);\n  /**\n   * Represents the template for the TreeView drag clue when an item is dragged. To define the clue template,\n   * nest an `<ng-template>` tag with the `kendoTreeViewDragClueTemplate` directive inside a `<kendo-treeview>` tag\n   * ([see example]({% slug draganddrop_treeview %}#toc-templates)).\n   *\n   *\n   * The text, attempted drop action, source item and destination item are available as context variables in the template:\n   *\n   *\n   * - `let-text=\"text\"` (`string`)\n   * - `let-action=\"action\"` ([`DropAction`]({% slug api_treeview_dropaction %}))\n   * - `let-sourceItem=\"sourceItem\"` ([`TreeItemLookup`]({% slug api_treeview_treeitemlookup %}))\n   * - `let-destinationItem=\"destinationItem\"` ([`TreeItemLookup`]({% slug api_treeview_treeitemlookup %}))\n   */\n\n  return DropHintService;\n})();\nlet DragClueTemplateDirective = /*#__PURE__*/(() => {\n  let DragClueTemplateDirective = class DragClueTemplateDirective {\n    constructor(templateRef) {\n      this.templateRef = templateRef;\n    }\n\n  };\n\n  DragClueTemplateDirective.ɵfac = function DragClueTemplateDirective_Factory(t) {\n    return new (t || DragClueTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef, 8));\n  };\n\n  DragClueTemplateDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: DragClueTemplateDirective,\n    selectors: [[\"\", \"kendoTreeViewDragClueTemplate\", \"\"]]\n  });\n  DragClueTemplateDirective = __decorate([__param(0, Optional()), __metadata(\"design:paramtypes\", [TemplateRef])], DragClueTemplateDirective);\n  /**\n   * Represents the template for the TreeView drop hint when an item is dragged. To define the hint template,\n   * nest an `<ng-template>` tag with the `kendoTreeViewDropHintTemplate` directive inside a `<kendo-treeview>` tag\n   * ([see example]({% slug draganddrop_treeview %}#toc-templates)).\n   *\n   * The attempted drop action, source item and destination item are available as context variables in the template:\n   *\n   * - `let-action=\"action\"` ([`DropAction`]({% slug api_treeview_dropaction %}))\n   * - `let-sourceItem=\"sourceItem\"` ([`TreeItemLookup`]({% slug api_treeview_treeitemlookup %}))\n   * - `let-destinationItem=\"destinationItem\"` ([`TreeItemLookup`]({% slug api_treeview_treeitemlookup %}))\n   */\n\n  return DragClueTemplateDirective;\n})();\nlet DropHintTemplateDirective = /*#__PURE__*/(() => {\n  let DropHintTemplateDirective = class DropHintTemplateDirective {\n    constructor(templateRef) {\n      this.templateRef = templateRef;\n    }\n\n  };\n\n  DropHintTemplateDirective.ɵfac = function DropHintTemplateDirective_Factory(t) {\n    return new (t || DropHintTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef, 8));\n  };\n\n  DropHintTemplateDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: DropHintTemplateDirective,\n    selectors: [[\"\", \"kendoTreeViewDropHintTemplate\", \"\"]]\n  });\n  DropHintTemplateDirective = __decorate([__param(0, Optional()), __metadata(\"design:paramtypes\", [TemplateRef])], DropHintTemplateDirective);\n  return DropHintTemplateDirective;\n})();\nconst DEFAULT_SCROLL_SETTINGS = {\n  enabled: true,\n  step: 1,\n  interval: 1\n};\n/**\n * A directive which enables the dragging and dropping items inside the current TreeView or between multiple linked TreeView component instances\n * ([see example]({% slug draganddrop_treeview %})).\n *\n * Triggers the [`nodeDragStart`]({% slug api_treeview_treeviewcomponent %}#toc-nodedragstart),\n * [`nodeDrag`]({% slug api_treeview_treeviewcomponent %}#toc-nodedrag),\n * [`nodeDrop`]({% slug api_treeview_treeviewcomponent %}#toc-nodedrop),\n * [`nodeDragEnd`]({% slug api_treeview_treeviewcomponent %}#toc-nodedragend),\n * [`addItem`]({% slug api_treeview_treeviewcomponent %}#toc-additem) and\n * [`removeItem`]({% slug api_treeview_treeviewcomponent %}#toc-removeitem)\n * events when the corresponding actions occur on the respective TreeView instance.\n */\n\nlet DragAndDropDirective = /*#__PURE__*/(() => {\n  let DragAndDropDirective = class DragAndDropDirective {\n    constructor(element, zone, treeview, dragClueService, dropHintService) {\n      this.element = element;\n      this.zone = zone;\n      this.treeview = treeview;\n      this.dragClueService = dragClueService;\n      this.dropHintService = dropHintService;\n      /**\n       * Specifies whether the `removeItem` event will be fired after an item is dropped when the `ctrl` key is pressed.\n       * If enabled, the `removeItem` event will not be fired on the source TreeView\n       * ([see example]({% slug draganddrop_treeview %}#toc-multiple-treeviews)).\n       *\n       * @default false\n       */\n\n      this.allowCopy = false;\n      /**\n       * Specifes the TreeViewComponent instances into which dragged items from the current TreeViewComponent can be dropped\n       * ([see example]({% slug draganddrop_treeview %}#toc-multiple-treeviews)).\n       */\n\n      this.dropZoneTreeViews = [];\n      /**\n       * Specifies the distance in pixels from the initial item pointerdown event, before the dragging is initiated.\n       * The `nodeDragStart` and all consequent TreeView drag events will not be fired until the actual dragging begins.\n       *\n       * @default 5\n       */\n\n      this.startDragAfter = 5;\n      /**\n       * Controlls the auto-scrolling behavior during drag-and-drop ([see example]({% slug draganddrop_treeview %}#toc-auto-scrolling)).\n       * Enbaled by default. To turn the auto-scrolling off, set this prop to `false`.\n       *\n       * By default, the scrolling will be performed by 1 pixel at every 1 millisecond, when the dragged item reaches the top or the bottom of the scrollable container.\n       * The `step` and `interval` can be overridden by providing a `DragAndDropScrollSettings` object to this prop.\n       *\n       * @default true\n       */\n\n      this.autoScroll = true;\n      /**\n       * @hidden\n       */\n\n      this.userSelectStyle = 'none';\n      /**\n       * Describes the offset of the parent element if the latter has the `transform` CSS prop applied.\n       * Transformed parents create new stacking context and the fixed children must be position based on the transformed parent.\n       * https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Positioning/Understanding_z_index/The_stacking_context\n       */\n\n      this.containerOffset = {\n        top: 0,\n        left: 0\n      };\n      this.treeview.touchActions = false;\n    }\n\n    get scrollSettings() {\n      const userProvidedSettings = typeof this.autoScroll === 'boolean' ? {\n        enabled: this.autoScroll\n      } : this.autoScroll;\n      return Object.assign({}, DEFAULT_SCROLL_SETTINGS, userProvidedSettings);\n    }\n\n    ngAfterContentInit() {\n      this.initalizeDraggable();\n      this.dragClueService.initialize(this.treeview.assetsContainer, this.dragClueTemplate && this.dragClueTemplate.templateRef);\n      this.dropHintService.initialize(this.treeview.assetsContainer, this.dropHintTemplate && this.dropHintTemplate.templateRef);\n    }\n\n    ngOnDestroy() {\n      this.draggable.destroy();\n    }\n    /**\n     * @hidden\n     */\n\n\n    handlePress({\n      originalEvent\n    }) {\n      if (!isContent(originalEvent.target)) {\n        return;\n      } // store the drag target on press, show it only when it's actually dragged\n\n\n      this.draggedItem = closestWithMatch(originalEvent.target, '.k-in'); // record the current pointer down coords - copared to the `startDragAfter` value to calculate whether to initiate dragging\n\n      this.pendingDragStartEvent = originalEvent;\n    }\n    /**\n     * @hidden\n     */\n\n\n    handleDrag({\n      originalEvent,\n      clientX,\n      clientY\n    }) {\n      if (this.shouldInitiateDragStart({\n        clientX,\n        clientY\n      })) {\n        this.initiateDragStart();\n      }\n\n      if (!isPresent(this.draggedItem) || isPresent(this.pendingDragStartEvent)) {\n        return;\n      }\n\n      const dropTarget = getDropTarget(originalEvent);\n\n      if (hasObservers(this.treeview.nodeDrag)) {\n        this.zone.run(() => this.notifyDrag(originalEvent, dropTarget));\n      }\n\n      const targetTreeView = this.getTargetTreeView(dropTarget);\n      const dropPosition = getDropPosition(this.draggedItem, dropTarget, clientY, targetTreeView, this.containerOffset);\n      const dropHintAnchor = closestWithMatch(dropTarget, '.k-mid');\n      const dropAction = getDropAction(dropPosition, dropTarget);\n      const sourceItem = treeItemFromEventTarget(this.treeview, this.draggedItem);\n      const destinationItem = treeItemFromEventTarget(targetTreeView, dropTarget);\n      this.updateDropHintState(dropPosition, dropHintAnchor, dropAction, sourceItem, destinationItem);\n      this.updateDragClueState(dropAction, clientX, clientY, sourceItem, destinationItem);\n\n      if (this.scrollSettings.enabled) {\n        this.dragClueService.scrollIntoView(this.scrollSettings);\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    handleRelease({\n      originalEvent,\n      clientY\n    }) {\n      if (this.scrollSettings.enabled) {\n        this.dragClueService.cancelScroll();\n      }\n\n      if (!isPresent(this.draggedItem) || isPresent(this.pendingDragStartEvent)) {\n        this.pendingDragStartEvent = null;\n        this.draggedItem = null;\n        return;\n      }\n\n      const dropTarget = getDropTarget(originalEvent);\n      const sourceTree = this.treeview;\n      const destinationTree = this.getTargetTreeView(dropTarget);\n      const dropPosition = getDropPosition(this.draggedItem, dropTarget, clientY, this.getTargetTreeView(dropTarget), this.containerOffset);\n      const sourceItem = treeItemFromEventTarget(sourceTree, this.draggedItem);\n      const destinationItem = treeItemFromEventTarget(destinationTree, dropTarget);\n\n      if (isPresent(destinationItem) && isPresent(dropPosition)) {\n        this.zone.run(() => this.notifyDrop({\n          sourceItem,\n          destinationItem,\n          dropPosition,\n          sourceTree,\n          destinationTree\n        }, originalEvent));\n      } else {\n        this.dragClueService.animateDragClueToElementPosition(this.draggedItem);\n      }\n\n      if (hasObservers(this.treeview.nodeDragEnd)) {\n        this.zone.run(() => this.notifyDragEnd({\n          sourceItem,\n          destinationItem,\n          originalEvent\n        }));\n      }\n\n      this.dropHintService.hide();\n      this.draggedItem = null;\n    }\n\n    updateDropHintState(dropPosition, dropHintAnchor, dropAction, sourceItem, destinationItem) {\n      if (!isPresent(dropHintAnchor) || dropPosition === DropPosition.Over || !isPresent(dropPosition)) {\n        this.dropHintService.hide();\n        return;\n      }\n\n      const anchorViewPortCoords = dropHintAnchor.getBoundingClientRect();\n      const insertBefore = dropPosition === DropPosition.Before;\n      const top = insertBefore ? anchorViewPortCoords.top : anchorViewPortCoords.top + anchorViewPortCoords.height;\n      this.dropHintService.updateDropHintData(dropAction, sourceItem, destinationItem); // clear any possible container offset created by parent elements with `transform` css property set\n\n      this.dropHintService.move(anchorViewPortCoords.left - this.containerOffset.left, top - this.containerOffset.top);\n      this.dropHintService.show();\n    }\n\n    updateDragClueState(dropAction, clientX, clientY, sourceItem, destinationItem) {\n      // clear any possible container offset created by parent elements with `transform` css property set\n      this.dragClueService.move(clientX - this.containerOffset.left, clientY - this.containerOffset.top);\n      this.dragClueService.updateDragClueData(dropAction, sourceItem, destinationItem);\n      this.dragClueService.show();\n    }\n\n    initalizeDraggable() {\n      this.draggable = new Draggable({\n        press: this.handlePress.bind(this),\n        drag: this.handleDrag.bind(this),\n        release: this.handleRelease.bind(this)\n      });\n      this.zone.runOutsideAngular(() => this.draggable.bindTo(this.element.nativeElement));\n    }\n\n    notifyDragStart(originalEvent, dropTarget) {\n      const sourceItem = treeItemFromEventTarget(this.treeview, dropTarget);\n      const event = new TreeItemDragStartEvent({\n        sourceItem,\n        originalEvent\n      });\n      this.treeview.nodeDragStart.emit(event);\n      return event;\n    }\n\n    notifyDrag(originalEvent, dropTarget) {\n      const dragEvent = {\n        sourceItem: treeItemFromEventTarget(this.treeview, this.draggedItem),\n        destinationItem: treeItemFromEventTarget(this.getTargetTreeView(dropTarget), dropTarget),\n        originalEvent\n      };\n      this.treeview.nodeDrag.emit(dragEvent);\n    }\n\n    notifyDrop(args, originalEvent) {\n      const event = new TreeItemDropEvent(args, originalEvent);\n      args.destinationTree.nodeDrop.emit(event); // disable the animations on drop and restore them afterwards (if they were initially turned on)\n\n      this.disableAnimationsForNextTick(args.destinationTree);\n\n      if (args.sourceTree !== args.destinationTree) {\n        this.disableAnimationsForNextTick(args.sourceTree);\n      }\n\n      if (!event.isDefaultPrevented() && event.isValid) {\n        this.dragClueService.hide(); // order matters in a flat data binding scenario (first add, then remove)\n\n        args.destinationTree.addItem.emit(args);\n\n        if (!(originalEvent.ctrlKey && this.allowCopy)) {\n          args.sourceTree.removeItem.emit(args);\n        }\n      } else if (event.isDefaultPrevented()) {\n        // directly hide the clue if the default is prevented\n        this.dragClueService.hide();\n      } else if (!event.isValid) {\n        // animate the clue back to the source item position if marked as invalid\n        this.dragClueService.animateDragClueToElementPosition(this.draggedItem);\n      }\n    }\n\n    notifyDragEnd(dragEndEvent) {\n      this.treeview.nodeDragEnd.emit(dragEndEvent);\n    }\n\n    getTargetTreeView(dropTarget) {\n      const treeViewTagName = this.treeview.element.nativeElement.tagName;\n      const targetTreeView = closestWithMatch(dropTarget, treeViewTagName);\n      return [this.treeview, ...this.dropZoneTreeViews].find(treeView => isPresent(treeView) && treeView.element.nativeElement === targetTreeView);\n    }\n\n    disableAnimationsForNextTick(treeView) {\n      // the treeView.animate getter returns `true` when the animations are turned off\n      // confusing, but seems on purpose (the `animate` prop sets the value of the @.disabled host-bound attribute)\n      if (treeView.animate) {\n        return;\n      }\n\n      treeView.animate = false;\n      this.zone.runOutsideAngular(() => setTimeout(() => treeView.animate = true));\n    }\n\n    shouldInitiateDragStart(currentPointerCoords) {\n      if (!isPresent(this.pendingDragStartEvent)) {\n        return false;\n      }\n\n      const distanceFromPointerDown = Math.sqrt(Math.pow(this.pendingDragStartEvent.clientX - currentPointerCoords.clientX, 2) + Math.pow(this.pendingDragStartEvent.clientY - currentPointerCoords.clientY, 2));\n      return distanceFromPointerDown >= this.startDragAfter;\n    }\n\n    initiateDragStart() {\n      if (hasObservers(this.treeview.nodeDragStart)) {\n        const dragStartEvent = this.zone.run(() => this.notifyDragStart(this.pendingDragStartEvent, getDropTarget(this.pendingDragStartEvent)));\n\n        if (dragStartEvent.isDefaultPrevented()) {\n          this.pendingDragStartEvent = null;\n          this.draggedItem = null;\n          return;\n        }\n      }\n\n      this.dragClueService.cancelReturnAnimation();\n      this.dragClueService.updateText(this.draggedItem.innerText);\n      this.containerOffset = getContainerOffset(this.draggedItem);\n      this.pendingDragStartEvent = null;\n    }\n\n  };\n\n  DragAndDropDirective.ɵfac = function DragAndDropDirective_Factory(t) {\n    return new (t || DragAndDropDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(TreeViewComponent), ɵngcc0.ɵɵdirectiveInject(DragClueService), ɵngcc0.ɵɵdirectiveInject(DropHintService));\n  };\n\n  DragAndDropDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: DragAndDropDirective,\n    selectors: [[\"\", \"kendoTreeViewDragAndDrop\", \"\"]],\n    contentQueries: function DragAndDropDirective_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵcontentQuery(dirIndex, DragClueTemplateDirective, 5);\n        ɵngcc0.ɵɵcontentQuery(dirIndex, DropHintTemplateDirective, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.dragClueTemplate = _t.first);\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.dropHintTemplate = _t.first);\n      }\n    },\n    hostVars: 8,\n    hostBindings: function DragAndDropDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        ɵngcc0.ɵɵstyleProp(\"user-select\", ctx.userSelectStyle)(\"-ms-user-select\", ctx.userSelectStyle)(\"-moz-user-select\", ctx.userSelectStyle)(\"-webkit-user-select\", ctx.userSelectStyle);\n      }\n    },\n    inputs: {\n      allowCopy: \"allowCopy\",\n      dropZoneTreeViews: \"dropZoneTreeViews\",\n      startDragAfter: \"startDragAfter\",\n      autoScroll: \"autoScroll\"\n    },\n    features: [ɵngcc0.ɵɵProvidersFeature([DragClueService, DropHintService])]\n  });\n\n  __decorate([Input(), __metadata(\"design:type\", Boolean)], DragAndDropDirective.prototype, \"allowCopy\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", Array)], DragAndDropDirective.prototype, \"dropZoneTreeViews\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", Number)], DragAndDropDirective.prototype, \"startDragAfter\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", Object)], DragAndDropDirective.prototype, \"autoScroll\", void 0);\n\n  __decorate([ContentChild(DragClueTemplateDirective, {\n    static: false\n  }), __metadata(\"design:type\", DragClueTemplateDirective)], DragAndDropDirective.prototype, \"dragClueTemplate\", void 0);\n\n  __decorate([ContentChild(DropHintTemplateDirective, {\n    static: false\n  }), __metadata(\"design:type\", DropHintTemplateDirective)], DragAndDropDirective.prototype, \"dropHintTemplate\", void 0);\n\n  __decorate([HostBinding('style.user-select'), HostBinding('style.-ms-user-select'), HostBinding('style.-moz-user-select'), HostBinding('style.-webkit-user-select'), __metadata(\"design:type\", String)], DragAndDropDirective.prototype, \"userSelectStyle\", void 0);\n\n  DragAndDropDirective = __decorate([__metadata(\"design:paramtypes\", [ElementRef, NgZone, TreeViewComponent, DragClueService, DropHintService])], DragAndDropDirective);\n  /**\n   * @hidden\n   */\n\n  return DragAndDropDirective;\n})();\nconst DEFAULT_FILTER_SETTINGS = {\n  operator: 'contains',\n  ignoreCase: true,\n  mode: \"lenient\"\n};\n/**\n * @hidden\n */\n\nlet FilteringBase = /*#__PURE__*/(() => {\n  class FilteringBase {\n    constructor(component) {\n      this.component = component;\n      this.visibleNodes = new Set();\n      this._filterSettings = DEFAULT_FILTER_SETTINGS;\n    }\n    /**\n     * The settings which are applied when performing a filter on the component's data.\n     */\n\n\n    set filterSettings(settings) {\n      this._filterSettings = Object.assign({}, DEFAULT_FILTER_SETTINGS, settings);\n    }\n\n    get filterSettings() {\n      return this._filterSettings;\n    }\n    /**\n     * Applies a filter and changes the visibility of the component's nodes accordingly.\n     */\n\n\n    set filter(term) {\n      this.handleFilterChange(term);\n    }\n    /**\n     * @hidden\n     */\n\n\n    handleFilterChange(term) {\n      if (!this.filterData) {\n        return;\n      }\n\n      this.resetNodesVisibility(this.filterData);\n\n      if (term) {\n        filterTree(this.filterData, term, this.filterSettings, this.component.textField);\n      }\n\n      this.updateVisibleNodes(this.filterData);\n\n      if (isPresent(this.component.filterStateChange)) {\n        this.component.filterStateChange.emit({\n          nodes: this.filterData,\n          matchCount: this.visibleNodes.size,\n          term,\n          filterSettings: this.filterSettings\n        });\n      }\n    }\n\n    updateVisibleNodes(items) {\n      items.forEach(wrapper => {\n        if (wrapper.visible) {\n          this.visibleNodes.add(wrapper.dataItem);\n        }\n\n        if (wrapper.children) {\n          this.updateVisibleNodes(wrapper.children);\n        }\n      });\n    }\n\n    resetNodesVisibility(items) {\n      this.visibleNodes.clear();\n      items.forEach(wrapper => {\n        wrapper.visible = true;\n\n        if (wrapper.children) {\n          this.resetNodesVisibility(wrapper.children);\n        }\n      });\n    }\n\n  }\n\n  FilteringBase.ɵfac = function FilteringBase_Factory(t) {\n    ɵngcc0.ɵɵinvalidFactory();\n  };\n\n  FilteringBase.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: FilteringBase,\n    inputs: {\n      filterSettings: \"filterSettings\",\n      filter: \"filter\"\n    }\n  });\n\n  __decorate([Input(), __metadata(\"design:type\", Object), __metadata(\"design:paramtypes\", [Object])], FilteringBase.prototype, \"filterSettings\", null);\n\n  __decorate([Input(), __metadata(\"design:type\", String), __metadata(\"design:paramtypes\", [String])], FilteringBase.prototype, \"filter\", null);\n\n  return FilteringBase;\n})();\nconst indexBuilder = new IndexBuilderService();\n\nconst mapToWrappers = (currentLevelNodes, childrenField, parent = null, parentIndex = '') => {\n  if (!isArrayWithAtLeastOneItem(currentLevelNodes)) {\n    return [];\n  }\n\n  return currentLevelNodes.map((node, idx) => {\n    const index = indexBuilder.nodeIndex(idx.toString(), parentIndex);\n    const wrapper = {\n      dataItem: node,\n      index,\n      parent,\n      visible: true\n    };\n    wrapper.children = mapToWrappers(getter(childrenField)(node), childrenField, wrapper, index);\n    return wrapper;\n  });\n};\n/**\n * A directive which encapsulates the retrieval of child nodes.\n */\n\n\nlet HierarchyBindingDirective = /*#__PURE__*/(() => {\n  let HierarchyBindingDirective = class HierarchyBindingDirective extends FilteringBase {\n    constructor(component, dragAndDropDirective) {\n      super(component);\n      this.component = component;\n      this.dragAndDropDirective = dragAndDropDirective;\n      /**\n       * @hidden\n       */\n\n      this.loadOnDemand = true;\n      this.originalData = [];\n      const shouldFilter = !isPresent(this.dragAndDropDirective);\n      this.component.isVisible = shouldFilter ? node => this.visibleNodes.has(node) : isVisible;\n    }\n    /**\n     * The field name which holds the data items of the child component.\n     */\n\n\n    set childrenField(value) {\n      if (!value) {\n        throw new Error(\"'childrenField' cannot be empty\");\n      }\n\n      this._childrenField = value;\n    }\n    /**\n     * The nodes which will be displayed by the TreeView.\n     */\n\n\n    set nodes(values) {\n      this.originalData = values || [];\n      this.filterData = mapToWrappers(values, this.childrenField) || [];\n      this.updateVisibleNodes(this.filterData);\n    }\n    /**\n     * @hidden\n     * A callback which determines whether a TreeView node should be rendered as hidden.\n     */\n\n\n    set isVisible(fn) {\n      this.component.isVisible = fn;\n    }\n    /**\n     * The field name which holds the data items of the child component.\n     */\n\n\n    get childrenField() {\n      return this._childrenField;\n    }\n\n    ngOnInit() {\n      if (isPresent(this.childrenField)) {\n        this.component.children = item => of(getter(this.childrenField)(item));\n\n        this.component.hasChildren = item => {\n          const children = getter(this.childrenField)(item);\n          return Boolean(children && children.length);\n        };\n\n        this.component.editService = new HierarchyEditingService(this);\n        this.component.filterChange.subscribe(this.handleFilterChange.bind(this));\n\n        if (this.component.filter) {\n          this.handleFilterChange(this.component.filter);\n        }\n\n        if (!this.loadOnDemand && isPresent(this.component.preloadChildNodes)) {\n          this.component.preloadChildNodes();\n        }\n      }\n    }\n\n    ngOnChanges(changes) {\n      if (isChanged('childrenField', changes, false)) {\n        this.nodes = this.originalData;\n      } // should react to changes.loadOnDemand as well - should preload the data or clear the already cached items\n\n\n      if (anyChanged(['nodes', 'loadOnDemand'], changes) && !this.loadOnDemand && isPresent(this.component.preloadChildNodes)) {\n        this.component.preloadChildNodes();\n      }\n    }\n\n  };\n\n  HierarchyBindingDirective.ɵfac = function HierarchyBindingDirective_Factory(t) {\n    return new (t || HierarchyBindingDirective)(ɵngcc0.ɵɵdirectiveInject(DataBoundComponent), ɵngcc0.ɵɵdirectiveInject(DragAndDropDirective, 9));\n  };\n\n  HierarchyBindingDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: HierarchyBindingDirective,\n    selectors: [[\"\", \"kendoTreeViewHierarchyBinding\", \"\"]],\n    inputs: {\n      loadOnDemand: \"loadOnDemand\",\n      childrenField: \"childrenField\",\n      nodes: \"nodes\",\n      isVisible: \"isVisible\"\n    },\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature, ɵngcc0.ɵɵNgOnChangesFeature]\n  });\n\n  __decorate([Input(), __metadata(\"design:type\", String), __metadata(\"design:paramtypes\", [String])], HierarchyBindingDirective.prototype, \"childrenField\", null);\n\n  __decorate([Input(), __metadata(\"design:type\", Array), __metadata(\"design:paramtypes\", [Array])], HierarchyBindingDirective.prototype, \"nodes\", null);\n\n  __decorate([Input(), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [Function])], HierarchyBindingDirective.prototype, \"isVisible\", null);\n\n  __decorate([Input(), __metadata(\"design:type\", Boolean)], HierarchyBindingDirective.prototype, \"loadOnDemand\", void 0);\n\n  HierarchyBindingDirective = __decorate([__param(1, Optional()), __param(1, Host()), __metadata(\"design:paramtypes\", [DataBoundComponent, DragAndDropDirective])], HierarchyBindingDirective);\n  /**\n   * @hidden\n   */\n\n  return HierarchyBindingDirective;\n})();\nlet LoadingIndicatorDirective = /*#__PURE__*/(() => {\n  let LoadingIndicatorDirective = class LoadingIndicatorDirective {\n    constructor(expandService, loadingService, cd) {\n      this.expandService = expandService;\n      this.loadingService = loadingService;\n      this.cd = cd;\n      this._loading = false;\n    }\n\n    get loading() {\n      return this._loading;\n    }\n\n    set loading(value) {\n      this._loading = value;\n      this.cd.markForCheck();\n    }\n\n    ngOnInit() {\n      const loadingNotifications = this.loadingService.changes.pipe(filter(index => index === this.index));\n      this.subscription = this.expandService.changes.pipe(filter(({\n        index\n      }) => index === this.index), tap(({\n        expand\n      }) => {\n        if (!expand && this.loading) {\n          this.loading = false;\n        }\n      }), filter(({\n        expand\n      }) => expand), switchMap(x => of(x).pipe(delay(100), takeUntil(loadingNotifications)))).subscribe(() => this.loading = true);\n      this.subscription.add(loadingNotifications.subscribe(() => this.loading = false));\n    }\n\n    ngOnDestroy() {\n      if (this.subscription) {\n        this.subscription.unsubscribe();\n      }\n    }\n\n  };\n\n  LoadingIndicatorDirective.ɵfac = function LoadingIndicatorDirective_Factory(t) {\n    return new (t || LoadingIndicatorDirective)(ɵngcc0.ɵɵdirectiveInject(ExpandStateService), ɵngcc0.ɵɵdirectiveInject(LoadingNotificationService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef));\n  };\n\n  LoadingIndicatorDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: LoadingIndicatorDirective,\n    selectors: [[\"\", \"kendoTreeViewLoading\", \"\"]],\n    hostVars: 2,\n    hostBindings: function LoadingIndicatorDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        ɵngcc0.ɵɵclassProp(\"k-i-loading\", ctx.loading);\n      }\n    },\n    inputs: {\n      index: [\"kendoTreeViewLoading\", \"index\"]\n    }\n  });\n\n  __decorate([HostBinding(\"class.k-i-loading\"), __metadata(\"design:type\", Boolean), __metadata(\"design:paramtypes\", [Boolean])], LoadingIndicatorDirective.prototype, \"loading\", null);\n\n  __decorate([Input(\"kendoTreeViewLoading\"), __metadata(\"design:type\", String)], LoadingIndicatorDirective.prototype, \"index\", void 0);\n\n  LoadingIndicatorDirective = __decorate([__metadata(\"design:paramtypes\", [ExpandStateService, LoadingNotificationService, ChangeDetectorRef])], LoadingIndicatorDirective);\n  /**\n   * @hidden\n   * Performs the right-to-left function composition. Functions must have a unary.\n   */\n\n  return LoadingIndicatorDirective;\n})();\n\nconst compose = (...args) => data => args.reduceRight((acc, curr) => curr(acc), data);\n/**\n * @hidden\n */\n\n\nclass FlatEditingService {\n  constructor(flatBinding) {\n    this.flatBinding = flatBinding;\n  }\n\n  add({\n    sourceItem,\n    destinationItem,\n    dropPosition,\n    sourceTree,\n    destinationTree\n  }) {\n    // shallow clone the item as not to mistake it for its 'older' version when the remove handler kicks in to splice the item at its old position\n    const clonedSourceDataItem = Object.assign({}, getDataItem(sourceItem));\n\n    if (dropPosition === DropPosition.Over) {\n      // expand the item that was dropped into\n      expandDropTarget(destinationItem, destinationTree);\n      const destinationItemId = getter(this.flatBinding.idField)(getDataItem(destinationItem));\n      setter(this.flatBinding.parentIdField)(clonedSourceDataItem, destinationItemId);\n      const lastChildNodeIndex = this.getLastVisibleChildNodeIndex(destinationTree, this.flatBinding.originalData, getDataItem(destinationItem)); // insert after the last visible child\n\n      const targetIndex = lastChildNodeIndex + 1;\n      this.flatBinding.originalData.splice(targetIndex, 0, clonedSourceDataItem); // rebind the treeview data before searching for the focus target index\n\n      this.rebindData();\n      const focusTarget = this.fetchChildNodes(getDataItem(destinationItem), destinationTree).indexOf(clonedSourceDataItem);\n      this.movedItemNewIndex = buildTreeIndex(destinationItem.item.index, focusTarget);\n    } else {\n      const shiftIndex = dropPosition === DropPosition.After ? 1 : 0;\n      const targetIndex = this.flatBinding.originalData.indexOf(getDataItem(destinationItem)) + shiftIndex;\n      this.flatBinding.originalData.splice(targetIndex, 0, clonedSourceDataItem);\n      const destinationItemParentId = getter(this.flatBinding.parentIdField)(getDataItem(destinationItem));\n      setter(this.flatBinding.parentIdField)(clonedSourceDataItem, destinationItemParentId); // rebind the treeview data before searching for the focus target index\n\n      this.rebindData();\n      const parentIndex = destinationItem.parent ? destinationItem.parent.item.index : null;\n      const parentContainer = destinationItem.parent ? this.fetchChildNodes(getDataItem(destinationItem.parent), destinationTree) : destinationTree.nodes;\n      const focusTarget = parentContainer.indexOf(clonedSourceDataItem);\n      this.movedItemNewIndex = buildTreeIndex(parentIndex, focusTarget);\n    }\n\n    if (sourceTree !== destinationTree) {\n      this.addChildNodes(clonedSourceDataItem, sourceTree);\n    } // increment the parent page size => an item is moved into it\n\n\n    const updatedParent = dropPosition === DropPosition.Over ? getDataItem(destinationItem) : getDataItem(destinationItem.parent);\n    incrementPageSize(destinationTree, updatedParent); // the page sizes are stored by data-item reference => copy the old item ref page size to the new item reference\n\n    copyPageSize(destinationTree, getDataItem(sourceItem), clonedSourceDataItem); // the source tree nodes are reloaded on `removeItem` - reload the destination tree nodes if the soruce and the destination tree are different\n\n    if (sourceTree !== destinationTree && !destinationTree.loadOnDemand) {\n      destinationTree.preloadChildNodes();\n    } // if the source and destination trees are the same, focusing the moved item here will not have the desired effect\n    // as the `remove` handler has not yet kicked-in to remove the item from its old position\n\n\n    if (sourceTree !== destinationTree) {\n      // ensure the focus target is rendered and registered\n      destinationTree.changeDetectorRef.detectChanges();\n      destinationTree.focus(this.movedItemNewIndex);\n    }\n  }\n\n  remove({\n    sourceItem,\n    sourceTree,\n    destinationTree\n  }) {\n    const sourceDataItem = getDataItem(sourceItem);\n    const sourceItemIndex = this.flatBinding.originalData.indexOf(sourceDataItem);\n    this.flatBinding.originalData.splice(sourceItemIndex, 1);\n\n    if (sourceTree !== destinationTree) {\n      this.removeChildNodes(sourceDataItem, sourceTree);\n    }\n\n    this.rebindData(); // emit collapse for the parent node if its last child node was spliced\n\n    const parentChildren = sourceItem.parent ? sourceItem.parent.children : [];\n    collapseEmptyParent(sourceItem.parent, parentChildren, sourceTree); // decrement source item parent page size => an item has been removed from it\n\n    decrementPageSize(sourceTree, getDataItem(sourceItem.parent)); // reload the treeview nodes\n\n    if (!sourceTree.loadOnDemand) {\n      sourceTree.preloadChildNodes();\n    } // if the source and destination trees are different we want to focus only the moved item in the destination tree\n\n\n    if (sourceTree === destinationTree) {\n      // ensure the focus target is rendered and registered\n      destinationTree.changeDetectorRef.detectChanges(); // after the source item is removed from its original position, the candidate index might have to be corrected\n\n      const index = updateMovedItemIndex(this.movedItemNewIndex, sourceItem.item.index);\n      destinationTree.focus(index);\n    }\n  }\n\n  addChildNodes(dataItem, source) {\n    const itemChildren = this.fetchAllDescendantNodes(dataItem, source);\n    this.flatBinding.originalData.push(...itemChildren);\n  }\n\n  removeChildNodes(dataItem, source) {\n    const sourceChildren = this.fetchAllDescendantNodes(dataItem, source);\n    sourceChildren.forEach(item => {\n      const index = this.flatBinding.originalData.indexOf(item);\n      this.flatBinding.originalData.splice(index, 1);\n    });\n  }\n\n  fetchAllDescendantNodes(node, treeview) {\n    let nodes = this.fetchChildNodes(node, treeview);\n    nodes.forEach(node => nodes = nodes.concat(this.fetchAllDescendantNodes(node, treeview) || []));\n    return nodes;\n  }\n\n  fetchChildNodes(node, treeview) {\n    if (!node) {\n      return [];\n    }\n\n    let nodes = [];\n    treeview.children(node).pipe(take(1)).subscribe(children => nodes = nodes.concat(children || []));\n    return nodes;\n  }\n\n  getLastVisibleChildNodeIndex(treeview, data, node) {\n    if (!isPresent(treeview.loadMoreService) || !treeview.hasChildren(node)) {\n      return data.length;\n    }\n\n    const visibleNodesCount = treeview.loadMoreService.getGroupSize(node);\n    const visibleChildren = this.fetchChildNodes(node, treeview).slice(0, visibleNodesCount);\n    const lastNode = visibleChildren[visibleChildren.length - 1];\n    const lastNodeIndex = data.indexOf(lastNode);\n    return lastNodeIndex;\n  }\n\n  rebindData() {\n    this.flatBinding.nodes = this.flatBinding.originalData;\n  }\n\n}\n\nconst findChildren = (prop, nodes, value) => nodes.filter(x => prop(x) === value);\n\nconst indexBuilder$1 = new IndexBuilderService();\n\nconst mapToTree = (currentLevelNodes, allNodes, parentIdField, idField, parent = null, parentIndex = '') => {\n  if (!isArrayWithAtLeastOneItem(currentLevelNodes)) {\n    return [];\n  }\n\n  return currentLevelNodes.map((node, idx) => {\n    const index = indexBuilder$1.nodeIndex(idx.toString(), parentIndex);\n    const wrapper = {\n      dataItem: node,\n      index,\n      parent,\n      visible: true\n    };\n    wrapper.children = mapToTree(findChildren(getter(parentIdField), allNodes || [], getter(idField)(node)), allNodes, parentIdField, idField, wrapper, index);\n    return wrapper;\n  });\n};\n/**\n * A directive which encapsulates the retrieval of the child nodes.\n */\n\n\nlet FlatDataBindingDirective = /*#__PURE__*/(() => {\n  let FlatDataBindingDirective = class FlatDataBindingDirective extends FilteringBase {\n    constructor(component) {\n      super(component);\n      this.component = component;\n      /**\n       * @hidden\n       */\n\n      this.loadOnDemand = true;\n      /**\n       * @hidden\n       */\n\n      this.originalData = [];\n\n      this.component.isVisible = node => this.visibleNodes.has(node);\n    }\n    /**\n     * The nodes which will be displayed by the TreeView.\n     */\n\n\n    set nodes(values) {\n      this.originalData = values || [];\n\n      if (!isNullOrEmptyString(this.parentIdField)) {\n        const prop = getter(this.parentIdField);\n        this.component.nodes = this.originalData.filter(compose(isBlank, prop));\n        this.filterData = mapToTree(this.component.nodes, this.originalData, this.parentIdField, this.idField);\n        this.updateVisibleNodes(this.filterData);\n      } else {\n        this.component.nodes = this.originalData.slice(0);\n      }\n    }\n    /**\n     * @hidden\n     * A callback which determines whether a TreeView node should be rendered as hidden.\n     */\n\n\n    set isVisible(fn) {\n      this.component.isVisible = fn;\n    }\n    /**\n     * @hidden\n     */\n\n\n    ngOnInit() {\n      if (isPresent(this.parentIdField) && isPresent(this.idField)) {\n        const fetchChildren = node => findChildren(getter(this.parentIdField), this.originalData || [], getter(this.idField)(node));\n\n        this.component.hasChildren = node => fetchChildren(node).length > 0;\n\n        this.component.children = node => of(fetchChildren(node));\n\n        this.component.editService = new FlatEditingService(this);\n        this.component.filterChange.subscribe(this.handleFilterChange.bind(this));\n\n        if (this.component.filter) {\n          this.handleFilterChange(this.component.filter);\n        }\n\n        if (!this.loadOnDemand && isPresent(this.component.preloadChildNodes)) {\n          this.component.preloadChildNodes();\n        }\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    ngOnChanges(changes) {\n      if (isChanged('parentIdField', changes, false)) {\n        this.nodes = this.originalData;\n      } // should react to changes.loadOnDemand as well - should preload the data or clear the already cached items\n\n\n      if (anyChanged(['nodes', 'loadOnDemand'], changes) && !this.loadOnDemand && isPresent(this.component.preloadChildNodes)) {\n        this.component.preloadChildNodes();\n      }\n    }\n\n  };\n\n  FlatDataBindingDirective.ɵfac = function FlatDataBindingDirective_Factory(t) {\n    return new (t || FlatDataBindingDirective)(ɵngcc0.ɵɵdirectiveInject(DataBoundComponent));\n  };\n\n  FlatDataBindingDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: FlatDataBindingDirective,\n    selectors: [[\"\", \"kendoTreeViewFlatDataBinding\", \"\"]],\n    inputs: {\n      loadOnDemand: \"loadOnDemand\",\n      nodes: \"nodes\",\n      isVisible: \"isVisible\",\n      parentIdField: \"parentIdField\",\n      idField: \"idField\"\n    },\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature, ɵngcc0.ɵɵNgOnChangesFeature]\n  });\n\n  __decorate([Input(), __metadata(\"design:type\", Array), __metadata(\"design:paramtypes\", [Array])], FlatDataBindingDirective.prototype, \"nodes\", null);\n\n  __decorate([Input(), __metadata(\"design:type\", String)], FlatDataBindingDirective.prototype, \"parentIdField\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", String)], FlatDataBindingDirective.prototype, \"idField\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", Boolean)], FlatDataBindingDirective.prototype, \"loadOnDemand\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [Function])], FlatDataBindingDirective.prototype, \"isVisible\", null);\n\n  FlatDataBindingDirective = __decorate([__metadata(\"design:paramtypes\", [DataBoundComponent])], FlatDataBindingDirective);\n  return FlatDataBindingDirective;\n})();\n\nconst buildItem = (index, dataItem) => ({\n  dataItem,\n  index\n});\n\nlet id = 0;\nconst TREE_ITEM_ROLE = 'treeitem';\nconst BUTTON_ROLE = 'button';\n/**\n * @hidden\n *\n * A directive which manages the expanded state of the TreeView.\n */\n\nlet TreeViewItemDirective = /*#__PURE__*/(() => {\n  let TreeViewItemDirective = class TreeViewItemDirective {\n    constructor(element, expandService, navigationService, selectionService, lookupService, renderer, ib) {\n      this.element = element;\n      this.expandService = expandService;\n      this.navigationService = navigationService;\n      this.selectionService = selectionService;\n      this.lookupService = lookupService;\n      this.renderer = renderer;\n      this.ib = ib;\n      this.role = TREE_ITEM_ROLE;\n      this.loadOnDemand = true;\n      this.isDisabled = false;\n      this.isVisible = true;\n      this.ariaChecked = 'false';\n      this.id = id++;\n      this.isInitialized = false;\n      this.subscriptions = [];\n      this.subscribe();\n    }\n\n    set isChecked(checked) {\n      if (checked === 'checked') {\n        this.ariaChecked = 'true';\n      } else if (checked === 'indeterminate') {\n        this.ariaChecked = 'mixed';\n      } else {\n        this.ariaChecked = 'false';\n      }\n    }\n\n    get isExpanded() {\n      return this._isExpanded || false;\n    }\n\n    set isExpanded(isExpanded) {\n      this._isExpanded = isExpanded;\n    }\n\n    get isSelected() {\n      return this._isSelected || false;\n    }\n\n    set isSelected(isSelected) {\n      this._isSelected = isSelected;\n    }\n\n    get isButton() {\n      return this.role === BUTTON_ROLE;\n    }\n\n    get treeItem() {\n      return buildItem(this.index, this.dataItem);\n    }\n\n    get parentTreeItem() {\n      return this.parentDataItem ? buildItem(this.parentIndex, this.parentDataItem) : null;\n    }\n\n    ngOnInit() {\n      if (this.loadOnDemand && !this.isButton) {\n        this.lookupService.registerItem(this.treeItem, this.parentTreeItem);\n      }\n\n      this.registerNavigationItem();\n      this.isInitialized = true;\n      this.setAttribute('role', this.role);\n      this.setAriaAttributes();\n      this.setDisabledClass();\n      this.updateTabIndex();\n    }\n\n    ngOnChanges(changes) {\n      const {\n        index,\n        isDisabled\n      } = changes;\n\n      if (anyChanged(['index', 'checkable', 'isChecked', 'expandable', 'isExpanded', 'selectable', 'isSelected'], changes)) {\n        this.setAriaAttributes();\n      }\n\n      if (isDisabled) {\n        this.setDisabledClass();\n      }\n\n      if (this.loadOnDemand && !this.isButton) {\n        this.moveLookupItem(changes);\n      }\n\n      this.moveNavigationItem(index);\n\n      if (anyChanged(['isDisabled', 'isVisible'], changes)) {\n        this.updateNodeAvailability();\n      }\n    }\n\n    ngOnDestroy() {\n      this.navigationService.unregisterItem(this.id, this.index);\n\n      if (this.loadOnDemand && !this.isButton) {\n        this.lookupService.unregisterItem(this.index, this.dataItem);\n      }\n\n      this.subscriptions = this.subscriptions.reduce((list, callback) => (callback.unsubscribe(), list), []);\n    }\n\n    subscribe() {\n      this.subscriptions = [this.navigationService.moves.subscribe(() => {\n        this.updateTabIndex();\n        this.focusItem();\n      }), this.navigationService.expands.pipe(filter(({\n        index\n      }) => index === this.index && !this.isDisabled)).subscribe(({\n        expand\n      }) => this.expand(expand))];\n    }\n\n    registerNavigationItem() {\n      this.navigationService.registerItem(this.id, this.index, this.isDisabled, this.isButton, this.isVisible);\n      this.activateItem();\n    }\n\n    activateItem() {\n      if (this.isDisabled) {\n        return;\n      }\n\n      const navigationService = this.navigationService;\n      const selectionService = this.selectionService;\n      const index = this.index;\n      selectionService.setFirstSelected(index, this.isSelected);\n\n      if (!navigationService.isActive(index) && selectionService.isFirstSelected(index)) {\n        navigationService.activateIndex(index);\n      }\n    }\n\n    expand(shouldExpand) {\n      this.expandService[shouldExpand ? 'expand' : 'collapse'](this.index, this.dataItem);\n    }\n\n    isFocusable() {\n      return !this.isDisabled && this.navigationService.isFocusable(this.index);\n    }\n\n    focusItem() {\n      if (this.isInitialized && this.navigationService.isActive(this.index)) {\n        this.element.nativeElement.focus();\n      }\n    }\n\n    moveLookupItem(changes = {}) {\n      const {\n        dataItem,\n        index,\n        parentDataItem,\n        parentIndex\n      } = changes;\n\n      if (index && index.firstChange || !dataItem && !index && !parentDataItem && !parentIndex) {\n        return;\n      }\n\n      const oldIndex = (index || {}).previousValue || this.index;\n      this.lookupService.replaceItem(oldIndex, this.treeItem, this.parentTreeItem);\n    }\n\n    moveNavigationItem(indexChange = {}) {\n      const {\n        currentValue,\n        firstChange,\n        previousValue\n      } = indexChange;\n\n      if (!firstChange && isPresent(currentValue) && isPresent(previousValue)) {\n        this.navigationService.unregisterItem(this.id, previousValue);\n        this.navigationService.registerItem(this.id, currentValue, this.isDisabled, this.isButton);\n      }\n    }\n\n    updateNodeAvailability() {\n      const service = this.navigationService;\n\n      if (this.isDisabled || !this.isVisible) {\n        service.activateClosest(this.index); // activate before unregister the item\n      } else {\n        service.activateFocusable();\n      }\n\n      service.unregisterItem(this.id, this.index);\n      service.registerItem(this.id, this.index, this.isDisabled, this.isButton, this.isVisible);\n    }\n\n    setAriaAttributes() {\n      this.setAttribute('aria-level', this.ib.level(this.index).toString()); // don't render attributes when the component configuration doesn't allow the specified state\n\n      this.setAttribute('aria-expanded', this.expandable ? this.isExpanded.toString() : null);\n      this.setAttribute('aria-selected', this.selectable ? this.isSelected.toString() : null);\n      this.setAttribute('aria-checked', this.checkable ? this.ariaChecked : null);\n    }\n\n    setDisabledClass() {\n      this.setClass('k-state-disabled', this.isDisabled);\n    }\n\n    setClass(className, toggle) {\n      const action = toggle ? 'addClass' : 'removeClass';\n      this.renderer[action](this.element.nativeElement, className);\n    }\n\n    updateTabIndex() {\n      this.setAttribute('tabIndex', this.isFocusable() ? '0' : '-1');\n    }\n\n    setAttribute(attr, value) {\n      if (!isPresent(value)) {\n        this.renderer.removeAttribute(this.element.nativeElement, attr);\n        return;\n      }\n\n      this.renderer.setAttribute(this.element.nativeElement, attr, value);\n    }\n\n  };\n\n  TreeViewItemDirective.ɵfac = function TreeViewItemDirective_Factory(t) {\n    return new (t || TreeViewItemDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ExpandStateService), ɵngcc0.ɵɵdirectiveInject(NavigationService), ɵngcc0.ɵɵdirectiveInject(SelectionService), ɵngcc0.ɵɵdirectiveInject(TreeViewLookupService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(IndexBuilderService));\n  };\n\n  TreeViewItemDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: TreeViewItemDirective,\n    selectors: [[\"\", \"kendoTreeViewItem\", \"\"]],\n    inputs: {\n      role: \"role\",\n      loadOnDemand: \"loadOnDemand\",\n      isDisabled: \"isDisabled\",\n      isVisible: \"isVisible\",\n      isChecked: \"isChecked\",\n      isExpanded: \"isExpanded\",\n      isSelected: \"isSelected\",\n      dataItem: \"dataItem\",\n      index: \"index\",\n      parentDataItem: \"parentDataItem\",\n      parentIndex: \"parentIndex\",\n      checkable: \"checkable\",\n      selectable: \"selectable\",\n      expandable: \"expandable\"\n    },\n    features: [ɵngcc0.ɵɵNgOnChangesFeature]\n  });\n\n  __decorate([Input(), __metadata(\"design:type\", Object)], TreeViewItemDirective.prototype, \"dataItem\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", String)], TreeViewItemDirective.prototype, \"index\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", Object)], TreeViewItemDirective.prototype, \"parentDataItem\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", String)], TreeViewItemDirective.prototype, \"parentIndex\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", String)], TreeViewItemDirective.prototype, \"role\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", Boolean)], TreeViewItemDirective.prototype, \"loadOnDemand\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", Boolean)], TreeViewItemDirective.prototype, \"checkable\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", Boolean)], TreeViewItemDirective.prototype, \"selectable\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", Boolean)], TreeViewItemDirective.prototype, \"expandable\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", String), __metadata(\"design:paramtypes\", [String])], TreeViewItemDirective.prototype, \"isChecked\", null);\n\n  __decorate([Input(), __metadata(\"design:type\", Boolean)], TreeViewItemDirective.prototype, \"isDisabled\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", Boolean)], TreeViewItemDirective.prototype, \"isVisible\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", Boolean), __metadata(\"design:paramtypes\", [Boolean])], TreeViewItemDirective.prototype, \"isExpanded\", null);\n\n  __decorate([Input(), __metadata(\"design:type\", Boolean), __metadata(\"design:paramtypes\", [Boolean])], TreeViewItemDirective.prototype, \"isSelected\", null);\n\n  TreeViewItemDirective = __decorate([__metadata(\"design:paramtypes\", [ElementRef, ExpandStateService, NavigationService, SelectionService, TreeViewLookupService, Renderer2, IndexBuilderService])], TreeViewItemDirective);\n  /**\n   * @hidden\n   *\n   * A directive which manages the expanded state of the TreeView.\n   */\n\n  return TreeViewItemDirective;\n})();\nlet TreeViewItemContentDirective = /*#__PURE__*/(() => {\n  let TreeViewItemContentDirective = class TreeViewItemContentDirective {\n    constructor(element, navigationService, selectionService, renderer) {\n      this.element = element;\n      this.navigationService = navigationService;\n      this.selectionService = selectionService;\n      this.renderer = renderer;\n      this.initialSelection = false;\n      this.isSelected = isSelected;\n      this.subscriptions = new Subscription();\n      this.subscriptions.add(this.navigationService.moves.subscribe(this.updateFocusClass.bind(this)));\n      this.subscriptions.add(this.navigationService.selects.pipe(filter(index => index === this.index)).subscribe(index => this.selectionService.select(index, this.dataItem)));\n      this.subscriptions.add(this.selectionService.changes.subscribe(() => {\n        this.updateSelectionClass(this.isSelected(this.dataItem, this.index));\n      }));\n    }\n\n    ngOnChanges(changes) {\n      if (changes.initialSelection) {\n        this.updateSelectionClass(this.initialSelection);\n      }\n\n      if (changes.index) {\n        this.updateFocusClass();\n      }\n    }\n\n    ngOnDestroy() {\n      this.subscriptions.unsubscribe();\n    }\n\n    updateFocusClass() {\n      this.render(this.navigationService.isActive(this.index), 'k-state-focused');\n    }\n\n    updateSelectionClass(selected) {\n      this.render(selected, 'k-state-selected');\n    }\n\n    render(addClass, className) {\n      const action = addClass ? 'addClass' : 'removeClass';\n      this.renderer[action](this.element.nativeElement, className);\n    }\n\n  };\n\n  TreeViewItemContentDirective.ɵfac = function TreeViewItemContentDirective_Factory(t) {\n    return new (t || TreeViewItemContentDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(NavigationService), ɵngcc0.ɵɵdirectiveInject(SelectionService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2));\n  };\n\n  TreeViewItemContentDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: TreeViewItemContentDirective,\n    selectors: [[\"\", \"kendoTreeViewItemContent\", \"\"]],\n    inputs: {\n      initialSelection: \"initialSelection\",\n      isSelected: \"isSelected\",\n      dataItem: \"dataItem\",\n      index: \"index\"\n    },\n    features: [ɵngcc0.ɵɵNgOnChangesFeature]\n  });\n\n  __decorate([Input(), __metadata(\"design:type\", Object)], TreeViewItemContentDirective.prototype, \"dataItem\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", String)], TreeViewItemContentDirective.prototype, \"index\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", Boolean)], TreeViewItemContentDirective.prototype, \"initialSelection\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", Function)], TreeViewItemContentDirective.prototype, \"isSelected\", void 0);\n\n  TreeViewItemContentDirective = __decorate([__metadata(\"design:paramtypes\", [ElementRef, NavigationService, SelectionService, Renderer2])], TreeViewItemContentDirective);\n  /**\n   * @hidden\n   *\n   * Represents the CheckBox component of the Kendo UI TreeView for Angular.\n   *\n   */\n\n  return TreeViewItemContentDirective;\n})();\nlet CheckBoxComponent = /*#__PURE__*/(() => {\n  let CheckBoxComponent = class CheckBoxComponent {\n    constructor(element, renderer, changeDetector) {\n      this.element = element;\n      this.renderer = renderer;\n      this.changeDetector = changeDetector;\n      /**\n       * Specifies the [`id`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/id) of the component.\n       */\n\n      this.id = `_${guid()}`;\n      /**\n       * Specifies the [`tabindex`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the component.\n       */\n\n      this.tabindex = 0;\n      /**\n       * Fires when the user changes the check state of the component.\n       */\n\n      this.checkStateChange = new EventEmitter();\n      this.checkState = 'none';\n    } //XXX: implement ComponentValueAccessor\n    //XXX: focus/blur methods\n\n\n    get classWrapper() {\n      return true;\n    }\n\n    get indeterminate() {\n      return this.checkState === 'indeterminate';\n    }\n\n    get checked() {\n      return this.checkState === 'checked';\n    }\n\n    ngOnInit() {\n      this.renderer.removeAttribute(this.element.nativeElement, \"tabindex\");\n    }\n\n    ngDoCheck() {\n      this.checkState = this.isChecked(this.node, this.index);\n    }\n\n    handleChange(e) {\n      const state = e.target.checked ? 'checked' : 'none'; // update the View State so that Angular updates the input if the isChecked value is the same\n\n      this.checkState = state;\n      this.changeDetector.detectChanges();\n      this.checkStateChange.emit(state);\n    }\n\n  };\n\n  CheckBoxComponent.ɵfac = function CheckBoxComponent_Factory(t) {\n    return new (t || CheckBoxComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef));\n  };\n\n  CheckBoxComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: CheckBoxComponent,\n    selectors: [[\"kendo-checkbox\"]],\n    hostVars: 2,\n    hostBindings: function CheckBoxComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        ɵngcc0.ɵɵclassProp(\"k-checkbox-wrapper\", ctx.classWrapper);\n      }\n    },\n    inputs: {\n      id: \"id\",\n      tabindex: \"tabindex\",\n      isChecked: \"isChecked\",\n      node: \"node\",\n      index: \"index\",\n      labelText: \"labelText\"\n    },\n    outputs: {\n      checkStateChange: \"checkStateChange\"\n    },\n    decls: 3,\n    vars: 6,\n    consts: [[\"type\", \"checkbox\", 1, \"k-checkbox\", 3, \"id\", \"checked\", \"indeterminate\", \"tabindex\", \"change\"], [\"tabindex\", \"-1\", 1, \"k-checkbox-label\", 3, \"for\"]],\n    template: function CheckBoxComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵelementStart(0, \"input\", 0);\n        ɵngcc0.ɵɵlistener(\"change\", function CheckBoxComponent_Template_input_change_0_listener($event) {\n          return ctx.handleChange($event);\n        });\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵelementStart(1, \"label\", 1);\n        ɵngcc0.ɵɵtext(2);\n        ɵngcc0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵproperty(\"id\", ctx.id)(\"checked\", ctx.checked)(\"indeterminate\", ctx.indeterminate)(\"tabindex\", ctx.tabindex);\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"for\", ctx.id);\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵtextInterpolate(ctx.labelText);\n      }\n    },\n    encapsulation: 2\n  });\n\n  __decorate([HostBinding('class.k-checkbox-wrapper'), __metadata(\"design:type\", Boolean), __metadata(\"design:paramtypes\", [])], CheckBoxComponent.prototype, \"classWrapper\", null);\n\n  __decorate([Input(), __metadata(\"design:type\", String)], CheckBoxComponent.prototype, \"id\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", Object)], CheckBoxComponent.prototype, \"isChecked\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", Object)], CheckBoxComponent.prototype, \"node\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", String)], CheckBoxComponent.prototype, \"index\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", String)], CheckBoxComponent.prototype, \"labelText\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", Number)], CheckBoxComponent.prototype, \"tabindex\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], CheckBoxComponent.prototype, \"checkStateChange\", void 0);\n\n  CheckBoxComponent = __decorate([__metadata(\"design:paramtypes\", [ElementRef, Renderer2, ChangeDetectorRef])], CheckBoxComponent);\n  return CheckBoxComponent;\n})();\nconst COMPONENT_DIRECTIVES = [CheckBoxComponent];\n/**\n * @hidden\n *\n * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }}) definition for the CheckBox component.\n */\n\nlet CheckBoxModule = /*#__PURE__*/(() => {\n  let CheckBoxModule = class CheckBoxModule {};\n\n  CheckBoxModule.ɵfac = function CheckBoxModule_Factory(t) {\n    return new (t || CheckBoxModule)();\n  };\n\n  CheckBoxModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: CheckBoxModule\n  });\n  CheckBoxModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({});\n  /**\n   * A directive which enables the update of the initially provided data array during drag-and-drop.\n   *\n   * Either use this directive in combination with one of the data binding directives ([`kendoTreeViewHierarchyBinding`]({% slug api_treeview_hierarchybindingdirective %})\n   * or [`kendoTreeViewFlatDataBinding`]({% slug api_treeview_flatdatabindingdirective %})) which set their own edit handlers, or provide\n   * your own [`editService`]({% slug api_treeview_editservice %}) to this directive. The latter subscribes to and calls the\n   * [`addItem`]({% slug api_treeview_treeviewcomponent %}#toc-additem) and [`removeItem`]({% slug api_treeview_treeviewcomponent %}#toc-removeitem)\n   * handlers when the corresponding events are triggered by the TreeView component.\n   */\n\n  return CheckBoxModule;\n})();\nlet DragAndDropEditingDirective = /*#__PURE__*/(() => {\n  let DragAndDropEditingDirective = class DragAndDropEditingDirective {\n    constructor(treeview) {\n      this.treeview = treeview;\n      this.subscriptions = new Subscription();\n      this.subscriptions.add(this.treeview.addItem.subscribe(this.handleAdd.bind(this)));\n      this.subscriptions.add(this.treeview.removeItem.subscribe(this.handleRemove.bind(this)));\n    }\n    /**\n     * Specifies the handlers called on drag-and-drop [`addItem`]({% slug api_treeview_treeviewcomponent %}#toc-additem)\n     * and [`removeItem`]({% slug api_treeview_treeviewcomponent %}#toc-removeitem) events.\n     */\n\n\n    set editService(service) {\n      this.treeview.editService = service;\n    }\n\n    ngOnDestroy() {\n      this.subscriptions.unsubscribe();\n    }\n\n    handleAdd(args) {\n      if (!isPresent(this.treeview.editService)) {\n        throw new Error('No `editService` provided. Either provide your own implementation or use this directive in combination with one of the data binding directives (`kendoTreeViewHierarchyBinding` or `kendoTreeViewFlatDataBinding`).');\n      }\n\n      this.treeview.editService.add(args);\n    }\n\n    handleRemove(args) {\n      if (!isPresent(this.treeview.editService)) {\n        throw new Error('No `editService` provided. Either provide your own implementation or use this directive in combination with one of the data binding directives (`kendoTreeViewHierarchyBinding` or `kendoTreeViewFlatDataBinding`).');\n      }\n\n      this.treeview.editService.remove(args);\n    }\n\n  };\n\n  DragAndDropEditingDirective.ɵfac = function DragAndDropEditingDirective_Factory(t) {\n    return new (t || DragAndDropEditingDirective)(ɵngcc0.ɵɵdirectiveInject(TreeViewComponent));\n  };\n\n  DragAndDropEditingDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: DragAndDropEditingDirective,\n    selectors: [[\"\", \"kendoTreeViewDragAndDropEditing\", \"\"]],\n    inputs: {\n      editService: \"editService\"\n    }\n  });\n\n  __decorate([Input(), __metadata(\"design:type\", Object), __metadata(\"design:paramtypes\", [Object])], DragAndDropEditingDirective.prototype, \"editService\", null);\n\n  DragAndDropEditingDirective = __decorate([__metadata(\"design:paramtypes\", [TreeViewComponent])], DragAndDropEditingDirective);\n  return DragAndDropEditingDirective;\n})();\nconst LOAD_MORE_DOC_LINK$1 = 'http://www.telerik.com/kendo-angular-ui/components/treeview/load-more-button/';\n/**\n * A directive that enables the display of only a limited amount of nodes per level\n * ([see example]({% slug loadmorebutton_treeview %})).\n */\n\nlet LoadMoreDirective = /*#__PURE__*/(() => {\n  let LoadMoreDirective = class LoadMoreDirective {\n    constructor(treeview) {\n      this.treeview = treeview;\n      /**\n       * Keeps track of the current page size of each node over expand/collapse cycles.\n       */\n\n      this.pageSizes = new Map();\n      /**\n       * Used as an identifier for the root page size as the root collection of nodes is not associated with a data item.\n       */\n\n      this.rootLevelId = guid();\n      this.treeview.loadMoreService = {\n        getInitialPageSize: this.getInitalPageSize.bind(this),\n        getGroupSize: this.getGroupSize.bind(this),\n        setGroupSize: this.setGroupSize.bind(this),\n        getTotalNodesCount: this.getTotalNodesCount.bind(this)\n      };\n    }\n    /**\n     * Specifies the callback that will be called when the load more button is clicked.\n     * Providing a function is only required when additional nodes are fetched on demand\n     * ([see example]({% slug loadmorebutton_treeview %}#toc-remote-data)).\n     */\n\n\n    set loadMoreNodes(loadMoreNodes) {\n      if (typeof loadMoreNodes === 'string') {\n        return;\n      }\n\n      this.treeview.loadMoreService.loadMoreNodes = loadMoreNodes;\n    }\n\n    ngOnChanges() {\n      this.verifySettings();\n    }\n\n    verifySettings() {\n      if (!isDevMode()) {\n        return;\n      }\n\n      if (!isPresent(this.pageSize)) {\n        throw new Error(`To use the TreeView \\`kendoTreeViewLoadMore\\` directive, you need to assign a \\`pageSize\\` value. See ${LOAD_MORE_DOC_LINK$1}.`);\n      }\n\n      const loadMoreNodes = this.treeview.loadMoreService.loadMoreNodes;\n\n      if (isPresent(loadMoreNodes) && typeof loadMoreNodes !== 'function') {\n        throw new Error(`The passed value to the \\`kendoTreeViewLoadMore\\` directive must be a function that retrieves additional nodes. See ${LOAD_MORE_DOC_LINK$1}.`);\n      }\n\n      if (isPresent(loadMoreNodes) && !isPresent(this.totalField)) {\n        throw new Error(`When a function to fetch additional nodes is provided to the \\`kendoTreeViewLoadMore\\` directive, the \\`totalField\\` and \\`totalRootNodes\\` values must also be provided. See ${LOAD_MORE_DOC_LINK$1}.`);\n      }\n    }\n\n    getGroupSize(dataItem) {\n      const itemKey = dataItem || this.rootLevelId;\n      return this.pageSizes.has(itemKey) ? this.pageSizes.get(itemKey) : this.pageSize;\n    }\n\n    setGroupSize(dataItem, pageSize) {\n      const itemKey = dataItem || this.rootLevelId;\n      const normalizedSizeValue = pageSize > 0 ? pageSize : 0;\n      this.pageSizes.set(itemKey, normalizedSizeValue);\n    }\n\n    getTotalNodesCount(dataItem, loadedNodesCount) {\n      if (isPresent(dataItem) && isPresent(this.totalField)) {\n        return dataItem[this.totalField];\n      } else if (!isPresent(dataItem) && isPresent(this.totalRootNodes)) {\n        return this.totalRootNodes;\n      } else {\n        return loadedNodesCount;\n      }\n    }\n\n    getInitalPageSize() {\n      return this.pageSize;\n    }\n\n  };\n\n  LoadMoreDirective.ɵfac = function LoadMoreDirective_Factory(t) {\n    return new (t || LoadMoreDirective)(ɵngcc0.ɵɵdirectiveInject(TreeViewComponent));\n  };\n\n  LoadMoreDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: LoadMoreDirective,\n    selectors: [[\"\", \"kendoTreeViewLoadMore\", \"\"]],\n    inputs: {\n      loadMoreNodes: [\"kendoTreeViewLoadMore\", \"loadMoreNodes\"],\n      pageSize: \"pageSize\",\n      totalRootNodes: \"totalRootNodes\",\n      totalField: \"totalField\"\n    },\n    features: [ɵngcc0.ɵɵNgOnChangesFeature]\n  });\n\n  __decorate([Input('kendoTreeViewLoadMore'), __metadata(\"design:type\", Object), __metadata(\"design:paramtypes\", [Object])], LoadMoreDirective.prototype, \"loadMoreNodes\", null);\n\n  __decorate([Input(), __metadata(\"design:type\", Number)], LoadMoreDirective.prototype, \"pageSize\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", Number)], LoadMoreDirective.prototype, \"totalRootNodes\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", String)], LoadMoreDirective.prototype, \"totalField\", void 0);\n\n  LoadMoreDirective = __decorate([__metadata(\"design:paramtypes\", [TreeViewComponent])], LoadMoreDirective);\n  return LoadMoreDirective;\n})();\nconst COMPONENT_DIRECTIVES$1 = [TreeViewComponent, TreeViewGroupComponent, TreeViewItemDirective, TreeViewItemContentDirective, NodeTemplateDirective, CheckDirective, DisableDirective, ExpandDirective, SelectDirective, HierarchyBindingDirective, LoadingIndicatorDirective, FlatDataBindingDirective, DragAndDropDirective, DragClueTemplateDirective, DragClueComponent, DropHintTemplateDirective, DropHintComponent, DragAndDropEditingDirective, LoadMoreDirective, LoadMoreButtonTemplateDirective];\n/**\n * @hidden\n */\n\nlet SharedModule = /*#__PURE__*/(() => {\n  let SharedModule = class SharedModule {};\n\n  SharedModule.ɵfac = function SharedModule_Factory(t) {\n    return new (t || SharedModule)();\n  };\n\n  SharedModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: SharedModule\n  });\n  SharedModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    imports: [[CommonModule, CheckBoxModule, InputsModule]]\n  });\n  return SharedModule;\n})();\nconst EXPORTS = [TreeViewComponent, NodeTemplateDirective, CheckDirective, DisableDirective, ExpandDirective, SelectDirective, HierarchyBindingDirective, FlatDataBindingDirective, DragAndDropDirective, DragClueTemplateDirective, DropHintTemplateDirective, DragAndDropEditingDirective, LoadMoreDirective, LoadMoreButtonTemplateDirective];\n/**\n * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }}) definition for the TreeView component.\n */\n\nlet TreeViewModule = /*#__PURE__*/(() => {\n  let TreeViewModule = class TreeViewModule {};\n\n  TreeViewModule.ɵfac = function TreeViewModule_Factory(t) {\n    return new (t || TreeViewModule)();\n  };\n\n  TreeViewModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: TreeViewModule\n  });\n  TreeViewModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    imports: [[SharedModule]]\n  });\n  return TreeViewModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(CheckBoxModule, {\n    declarations: [CheckBoxComponent],\n    exports: [CheckBoxComponent]\n  });\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(SharedModule, {\n    declarations: function () {\n      return [TreeViewComponent, TreeViewGroupComponent, TreeViewItemDirective, TreeViewItemContentDirective, NodeTemplateDirective, CheckDirective, DisableDirective, ExpandDirective, SelectDirective, HierarchyBindingDirective, LoadingIndicatorDirective, FlatDataBindingDirective, DragAndDropDirective, DragClueTemplateDirective, DragClueComponent, DropHintTemplateDirective, DropHintComponent, DragAndDropEditingDirective, LoadMoreDirective, LoadMoreButtonTemplateDirective];\n    },\n    imports: function () {\n      return [CommonModule, CheckBoxModule, InputsModule];\n    },\n    exports: function () {\n      return [TreeViewComponent, TreeViewGroupComponent, TreeViewItemDirective, TreeViewItemContentDirective, NodeTemplateDirective, CheckDirective, DisableDirective, ExpandDirective, SelectDirective, HierarchyBindingDirective, LoadingIndicatorDirective, FlatDataBindingDirective, DragAndDropDirective, DragClueTemplateDirective, DragClueComponent, DropHintTemplateDirective, DropHintComponent, DragAndDropEditingDirective, LoadMoreDirective, LoadMoreButtonTemplateDirective];\n    }\n  });\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(TreeViewModule, {\n    imports: [SharedModule],\n    exports: [TreeViewComponent, NodeTemplateDirective, CheckDirective, DisableDirective, ExpandDirective, SelectDirective, HierarchyBindingDirective, FlatDataBindingDirective, DragAndDropDirective, DragClueTemplateDirective, DropHintTemplateDirective, DragAndDropEditingDirective, LoadMoreDirective, LoadMoreButtonTemplateDirective]\n  });\n})();\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { CheckBoxComponent, CheckBoxModule, DataChangeNotificationService, DragClueComponent, DragClueService, DropHintComponent, DropHintService, DragAndDropAssetService, PreventableEvent, ExpandStateService, FilteringBase, IndexBuilderService, LoadingIndicatorDirective, LoadingNotificationService, NavigationService, NodeChildrenService, SelectionService, SharedModule, TreeViewGroupComponent, TreeViewItemContentDirective, TreeViewItemDirective, TreeViewLookupService, TreeViewComponent, TreeViewModule, NodeTemplateDirective, CheckDirective, DisableDirective, ExpandDirective, SelectDirective, DataBoundComponent, ExpandableComponent, HierarchyBindingDirective, FlatDataBindingDirective, DragAndDropDirective, DragAndDropEditingDirective, DropHintTemplateDirective, DragClueTemplateDirective, DropAction, DropPosition, TreeItemDropEvent, TreeItemDragStartEvent, TreeItemDragEvent, LoadMoreDirective, LoadMoreButtonTemplateDirective }; //# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VzIjpbImluZGV4LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O3FLQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Z0tBR3VCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzttS0FHd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzt3TEFHK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs2SkFBRTtBQUNGLGdDQUVHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O21LQUd3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O3lKQUFFO0FBQ0Ysb0NBSUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O3VMQUFFO0FBQ0YsOENBSUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztnS0FHdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzttS0FHd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7MEpBR3FCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O3lLQUcwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O3dLQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0E2Q0c7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2VBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBd0pHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs2WEFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBRUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzsyU0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBRUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs4VUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBRUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O2lPQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBRUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7cUdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0F1Qkc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7eUdBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O3VKQUFFO0FBQ0YsOEJBRUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7cUdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0F5Qkc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7dUpBQUU7QUFDRiw4QkFFRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7cUtBQUU7QUFDRix3Q0FJRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztxS0FBRTtBQUNGLHdDQUlHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7ZUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBUUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztxSkFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O21XQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FFRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7aUVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FFRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O29YQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FFRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztnaUJBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBRUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O2lVQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FFRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7OzZCQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBb0JHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O2dFQU1tQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7bU5BQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBSUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OytVQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUlHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztjQWVpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFNbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlc0NvbnRlbnQiOlsiLyoqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiogQ29weXJpZ2h0IMKpIDIwMjEgUHJvZ3Jlc3MgU29mdHdhcmUgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4qIExpY2Vuc2VkIHVuZGVyIGNvbW1lcmNpYWwgbGljZW5zZS4gU2VlIExJQ0VOU0UubWQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbW9yZSBpbmZvcm1hdGlvblxuKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuaW1wb3J0IHsgX19kZWNvcmF0ZSwgX19tZXRhZGF0YSwgX19wYXJhbSB9IGZyb20gJ3RzbGliJztcbmltcG9ydCB7IEV2ZW50RW1pdHRlciwgSW5qZWN0YWJsZSwgRGlyZWN0aXZlLCBPcHRpb25hbCwgVGVtcGxhdGVSZWYsIGZvcndhcmRSZWYsIGlzRGV2TW9kZSwgSG9zdEJpbmRpbmcsIFZpZXdDaGlsZCwgVmlld0NvbnRhaW5lclJlZiwgSW5wdXQsIE91dHB1dCwgQ29udGVudENoaWxkLCBDb21wb25lbnQsIENoYW5nZURldGVjdGlvblN0cmF0ZWd5LCBFbGVtZW50UmVmLCBDaGFuZ2VEZXRlY3RvclJlZiwgTmdab25lLCBSZW5kZXJlcjIsIENvbXBvbmVudEZhY3RvcnlSZXNvbHZlciwgSG9zdCwgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IGlzRG9jdW1lbnRBdmFpbGFibGUsIEtleXMsIGFueUNoYW5nZWQsIGhhc09ic2VydmVycywgaXNDaGFuZ2VkLCBndWlkIH0gZnJvbSAnQHByb2dyZXNzL2tlbmRvLWFuZ3VsYXItY29tbW9uJztcbmltcG9ydCB7IExvY2FsaXphdGlvblNlcnZpY2UsIEwxME5fUFJFRklYIH0gZnJvbSAnQHByb2dyZXNzL2tlbmRvLWFuZ3VsYXItbDEwbic7XG5pbXBvcnQgeyBTdWJqZWN0LCBvZiwgQmVoYXZpb3JTdWJqZWN0LCBTdWJzY3JpcHRpb24sIEVNUFRZLCBtZXJnZSB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgdmFsaWRhdGVQYWNrYWdlIH0gZnJvbSAnQHByb2dyZXNzL2tlbmRvLWxpY2Vuc2luZyc7XG5pbXBvcnQgeyBnZXR0ZXIsIHNldHRlciB9IGZyb20gJ0Bwcm9ncmVzcy9rZW5kby1jb21tb24nO1xuaW1wb3J0IHsgdHJpZ2dlciwgdHJhbnNpdGlvbiwgc3R5bGUsIGFuaW1hdGUgfSBmcm9tICdAYW5ndWxhci9hbmltYXRpb25zJztcbmltcG9ydCB7IGZpbHRlciwgY2F0Y2hFcnJvciwgdGFwLCBmaW5hbGl6ZSwgc3dpdGNoTWFwLCB0YWtlLCBtYXAsIGRlbGF5LCB0YWtlVW50aWwgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IERyYWdnYWJsZSBmcm9tICdAdGVsZXJpay9rZW5kby1kcmFnZ2FibGUnO1xuaW1wb3J0IHsgSW5wdXRzTW9kdWxlIH0gZnJvbSAnQHByb2dyZXNzL2tlbmRvLWFuZ3VsYXItaW5wdXRzJztcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IHBhY2thZ2VNZXRhZGF0YSA9IHtcbiAgICBuYW1lOiAnQHByb2dyZXNzL2tlbmRvLWFuZ3VsYXItdHJlZXZpZXcnLFxuICAgIHByb2R1Y3ROYW1lOiAnS2VuZG8gVUkgZm9yIEFuZ3VsYXInLFxuICAgIHByb2R1Y3RDb2RlczogWydLRU5ET1VJQU5HVUxBUicsICdLRU5ET1VJQ09NUExFVEUnXSxcbiAgICBwdWJsaXNoRGF0ZTogMTYzMTI2MDU0NCxcbiAgICB2ZXJzaW9uOiAnJyxcbiAgICBsaWNlbnNpbmdEb2NzVXJsOiAnaHR0cHM6Ly93d3cudGVsZXJpay5jb20va2VuZG8tYW5ndWxhci11aS9teS1saWNlbnNlLz91dG1fbWVkaXVtPXByb2R1Y3QmdXRtX3NvdXJjZT1rZW5kb2FuZ3VsYXImdXRtX2NhbXBhaWduPWtlbmRvLXVpLWFuZ3VsYXItcHVyY2hhc2UtbGljZW5zZS1rZXlzLXdhcm5pbmcnXG59O1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgRGF0YUNoYW5nZU5vdGlmaWNhdGlvblNlcnZpY2Uge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmNoYW5nZXMgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgfVxuICAgIG5vdGlmeSgpIHtcbiAgICAgICAgdGhpcy5jaGFuZ2VzLmVtaXQoKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBoYXNDaGlsZHJlbiA9ICgpID0+IGZhbHNlO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGlzQ2hlY2tlZCA9ICgpID0+ICdub25lJztcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBpc0Rpc2FibGVkID0gKCkgPT4gZmFsc2U7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgaXNFeHBhbmRlZCA9ICgpID0+IHRydWU7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgaXNTZWxlY3RlZCA9ICgpID0+IGZhbHNlO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGlzVmlzaWJsZSA9ICgpID0+IHRydWU7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgdHJhY2tCeSA9IChfLCBpdGVtKSA9PiBpdGVtO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xubGV0IEV4cGFuZFN0YXRlU2VydmljZSA9IGNsYXNzIEV4cGFuZFN0YXRlU2VydmljZSB7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmNoYW5nZXMgPSBuZXcgU3ViamVjdCgpO1xuICAgIH1cbiAgICBleHBhbmQoaW5kZXgsIGRhdGFJdGVtKSB7XG4gICAgICAgIHRoaXMuY2hhbmdlcy5uZXh0KHsgZGF0YUl0ZW0sIGluZGV4LCBleHBhbmQ6IHRydWUgfSk7XG4gICAgfVxuICAgIGNvbGxhcHNlKGluZGV4LCBkYXRhSXRlbSkge1xuICAgICAgICB0aGlzLmNoYW5nZXMubmV4dCh7IGRhdGFJdGVtLCBpbmRleCwgZXhwYW5kOiBmYWxzZSB9KTtcbiAgICB9XG59O1xuRXhwYW5kU3RhdGVTZXJ2aWNlID0gX19kZWNvcmF0ZShbXG4gICAgSW5qZWN0YWJsZSgpXG5dLCBFeHBhbmRTdGF0ZVNlcnZpY2UpO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xubGV0IEluZGV4QnVpbGRlclNlcnZpY2UgPSBjbGFzcyBJbmRleEJ1aWxkZXJTZXJ2aWNlIHtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuSU5ERVhfU0VQQVJBVE9SID0gJ18nO1xuICAgIH1cbiAgICBub2RlSW5kZXgoaW5kZXggPSAnJywgcGFyZW50SW5kZXggPSAnJykge1xuICAgICAgICByZXR1cm4gYCR7cGFyZW50SW5kZXh9JHtwYXJlbnRJbmRleCA/IHRoaXMuSU5ERVhfU0VQQVJBVE9SIDogJyd9JHtpbmRleH1gO1xuICAgIH1cbiAgICBpbmRleEZvckxldmVsKGluZGV4LCBsZXZlbCkge1xuICAgICAgICByZXR1cm4gaW5kZXguc3BsaXQodGhpcy5JTkRFWF9TRVBBUkFUT1IpLnNsaWNlKDAsIGxldmVsKS5qb2luKHRoaXMuSU5ERVhfU0VQQVJBVE9SKTtcbiAgICB9XG4gICAgbGFzdExldmVsSW5kZXgoaW5kZXggPSAnJykge1xuICAgICAgICBjb25zdCBwYXJ0cyA9IGluZGV4LnNwbGl0KHRoaXMuSU5ERVhfU0VQQVJBVE9SKTtcbiAgICAgICAgaWYgKCFwYXJ0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBOYU47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KHBhcnRzW3BhcnRzLmxlbmd0aCAtIDFdLCAxMCk7XG4gICAgfVxuICAgIGxldmVsKGluZGV4KSB7XG4gICAgICAgIHJldHVybiBpbmRleC5zcGxpdCh0aGlzLklOREVYX1NFUEFSQVRPUikubGVuZ3RoO1xuICAgIH1cbn07XG5JbmRleEJ1aWxkZXJTZXJ2aWNlID0gX19kZWNvcmF0ZShbXG4gICAgSW5qZWN0YWJsZSgpXG5dLCBJbmRleEJ1aWxkZXJTZXJ2aWNlKTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmxldCBMb2FkaW5nTm90aWZpY2F0aW9uU2VydmljZSA9IGNsYXNzIExvYWRpbmdOb3RpZmljYXRpb25TZXJ2aWNlIHtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuY2hhbmdlcyA9IG5ldyBTdWJqZWN0KCk7XG4gICAgfVxuICAgIG5vdGlmeUxvYWRlZChpbmRleCkge1xuICAgICAgICB0aGlzLmNoYW5nZXMubmV4dChpbmRleCk7XG4gICAgfVxufTtcbkxvYWRpbmdOb3RpZmljYXRpb25TZXJ2aWNlID0gX19kZWNvcmF0ZShbXG4gICAgSW5qZWN0YWJsZSgpXG5dLCBMb2FkaW5nTm90aWZpY2F0aW9uU2VydmljZSk7XG5cbmNvbnN0IGZvY3VzYWJsZVJlZ2V4ID0gL14oPzphfGlucHV0fHNlbGVjdHxvcHRpb258dGV4dGFyZWF8YnV0dG9ufG9iamVjdCkkL2k7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgbWF0Y2ggPSAoZWxlbWVudCwgc2VsZWN0b3IpID0+IHtcbiAgICBjb25zdCBtYXRjaGVyID0gZWxlbWVudC5tYXRjaGVzIHx8IGVsZW1lbnQubXNNYXRjaGVzU2VsZWN0b3IgfHwgZWxlbWVudC53ZWJraXRNYXRjaGVzU2VsZWN0b3I7XG4gICAgaWYgKCFtYXRjaGVyKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIG1hdGNoZXIuY2FsbChlbGVtZW50LCBzZWxlY3Rvcik7XG59O1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGNsb3Nlc3RXaXRoTWF0Y2ggPSAoZWxlbWVudCwgc2VsZWN0b3IpID0+IHtcbiAgICBpZiAoIWRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jb250YWlucyhlbGVtZW50KSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgbGV0IHBhcmVudCA9IGVsZW1lbnQ7XG4gICAgd2hpbGUgKHBhcmVudCAhPT0gbnVsbCAmJiBwYXJlbnQubm9kZVR5cGUgPT09IDEpIHtcbiAgICAgICAgaWYgKG1hdGNoKHBhcmVudCwgc2VsZWN0b3IpKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyZW50O1xuICAgICAgICB9XG4gICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnRFbGVtZW50IHx8IHBhcmVudC5wYXJlbnROb2RlO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn07XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3Qgbm9vcCA9ICgpID0+IHsgfTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBpc1ByZXNlbnQgPSAodmFsdWUpID0+IHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB1bmRlZmluZWQ7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgaXNCbGFuayA9ICh2YWx1ZSkgPT4gdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZDtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBpc0FycmF5ID0gKHZhbHVlKSA9PiBBcnJheS5pc0FycmF5KHZhbHVlKTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBpc051bGxPckVtcHR5U3RyaW5nID0gKHZhbHVlKSA9PiBpc0JsYW5rKHZhbHVlKSB8fCB2YWx1ZS50cmltKCkubGVuZ3RoID09PSAwO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGlzQm9vbGVhbiA9ICh2YWx1ZSkgPT4gdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbic7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgY2xvc2VzdE5vZGUgPSAoZWxlbWVudCkgPT4ge1xuICAgIGNvbnN0IHNlbGVjdG9yID0gJ2xpLmstdHJlZXZpZXctaXRlbSc7XG4gICAgaWYgKCFpc0RvY3VtZW50QXZhaWxhYmxlKCkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChlbGVtZW50LmNsb3Nlc3QpIHtcbiAgICAgICAgcmV0dXJuIGVsZW1lbnQuY2xvc2VzdChzZWxlY3Rvcik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gY2xvc2VzdFdpdGhNYXRjaChlbGVtZW50LCBzZWxlY3Rvcik7XG4gICAgfVxufTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBpc0ZvY3VzYWJsZSA9IChlbGVtZW50KSA9PiB7XG4gICAgaWYgKGVsZW1lbnQudGFnTmFtZSkge1xuICAgICAgICBjb25zdCB0YWdOYW1lID0gZWxlbWVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGNvbnN0IHRhYkluZGV4ID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3RhYkluZGV4Jyk7XG4gICAgICAgIGNvbnN0IHNraXBUYWIgPSB0YWJJbmRleCA9PT0gJy0xJztcbiAgICAgICAgbGV0IGZvY3VzYWJsZSA9IHRhYkluZGV4ICE9PSBudWxsICYmICFza2lwVGFiO1xuICAgICAgICBpZiAoZm9jdXNhYmxlUmVnZXgudGVzdCh0YWdOYW1lKSkge1xuICAgICAgICAgICAgZm9jdXNhYmxlID0gIWVsZW1lbnQuZGlzYWJsZWQgJiYgIXNraXBUYWI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZvY3VzYWJsZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBpc0NvbnRlbnQgPSAoZWxlbWVudCkgPT4ge1xuICAgIGNvbnN0IHNjb3BlU2VsZWN0b3IgPSAnLmstaW46bm90KC5rLXRyZWV2aWV3LWxvYWQtbW9yZS1idXR0b24pLC5rLXRyZWV2aWV3LWl0ZW0sLmstdHJlZXZpZXcnO1xuICAgIGlmICghaXNEb2N1bWVudEF2YWlsYWJsZSgpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBsZXQgbm9kZSA9IGVsZW1lbnQ7XG4gICAgd2hpbGUgKG5vZGUgJiYgIW1hdGNoKG5vZGUsIHNjb3BlU2VsZWN0b3IpKSB7XG4gICAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgfVxuICAgIGlmIChub2RlKSB7XG4gICAgICAgIHJldHVybiBtYXRjaChub2RlLCAnLmstaW46bm90KC5rLXRyZWV2aWV3LWxvYWQtbW9yZS1idXR0b24pJyk7XG4gICAgfVxufTtcbi8qKlxuICogQGhpZGRlblxuICpcbiAqIFJldHVybnMgdGhlIG5lc3RlZCAuay1pbjpub3QoLmstdHJlZXZpZXctbG9hZC1tb3JlLWJ1dHRvbikgZWxlbWVudC5cbiAqIElmIHRoZSBwYXNzZWQgcGFyZW50IGl0ZW0gaXMgaXRzZWxmIGEgY29udGVudCBub2RlLCBpdCBpcyByZXR1cm5lZC5cbiAqL1xuY29uc3QgZ2V0Q29udGVudEVsZW1lbnQgPSAocGFyZW50KSA9PiB7XG4gICAgaWYgKCFpc1ByZXNlbnQocGFyZW50KSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3Qgc2VsZWN0b3IgPSAnLmstaW46bm90KC5rLXRyZWV2aWV3LWxvYWQtbW9yZS1idXR0b24pJztcbiAgICBpZiAobWF0Y2gocGFyZW50LCBzZWxlY3RvcikpIHtcbiAgICAgICAgcmV0dXJuIHBhcmVudDtcbiAgICB9XG4gICAgcmV0dXJuIHBhcmVudC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKTtcbn07XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgaXNMb2FkTW9yZUJ1dHRvbiA9IChlbGVtZW50KSA9PiB7XG4gICAgcmV0dXJuIGlzUHJlc2VudChjbG9zZXN0V2l0aE1hdGNoKGVsZW1lbnQsICcuay1pbi5rLXRyZWV2aWV3LWxvYWQtbW9yZS1idXR0b24nKSk7XG59O1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGNsb3Nlc3QgPSAobm9kZSwgcHJlZGljYXRlKSA9PiB7XG4gICAgd2hpbGUgKG5vZGUgJiYgIXByZWRpY2F0ZShub2RlKSkge1xuICAgICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbn07XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgaGFzUGFyZW50ID0gKGVsZW1lbnQsIGNvbnRhaW5lcikgPT4ge1xuICAgIHJldHVybiBCb29sZWFuKGNsb3Nlc3QoZWxlbWVudCwgKG5vZGUpID0+IG5vZGUgPT09IGNvbnRhaW5lcikpO1xufTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBmb2N1c2FibGVOb2RlID0gKGVsZW1lbnQpID0+IGVsZW1lbnQubmF0aXZlRWxlbWVudC5xdWVyeVNlbGVjdG9yKCdsaVt0YWJpbmRleD1cIjBcIl0nKTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBub2RlSWQgPSAobm9kZSkgPT4gbm9kZSA/IG5vZGUuZ2V0QXR0cmlidXRlKCdkYXRhLXRyZWVpbmRleCcpIDogJyc7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3Qgbm9kZUluZGV4ID0gKGl0ZW0pID0+IChpdGVtIHx8IHt9KS5pbmRleDtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBkYXRhSXRlbXNFcXVhbCA9IChmaXJzdCwgc2Vjb25kKSA9PiB7XG4gICAgaWYgKCFpc1ByZXNlbnQoZmlyc3QpICYmICFpc1ByZXNlbnQoc2Vjb25kKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGlzUHJlc2VudChmaXJzdCkgJiYgaXNQcmVzZW50KHNlY29uZCkgJiYgZmlyc3QuaXRlbS5kYXRhSXRlbSA9PT0gc2Vjb25kLml0ZW0uZGF0YUl0ZW07XG59O1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGdldERhdGFJdGVtID0gKGxvb2t1cCkgPT4ge1xuICAgIGlmICghaXNQcmVzZW50KGxvb2t1cCkpIHtcbiAgICAgICAgcmV0dXJuIGxvb2t1cDtcbiAgICB9XG4gICAgcmV0dXJuIGxvb2t1cC5pdGVtLmRhdGFJdGVtO1xufTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBpc0FycmF5V2l0aEF0TGVhc3RPbmVJdGVtID0gdiA9PiB2ICYmIEFycmF5LmlzQXJyYXkodikgJiYgdi5sZW5ndGggIT09IDA7XG4vKipcbiAqIEBoaWRkZW5cbiAqIEEgcmVjdXJzaXZlIHRyZWUtZmlsdGVyaW5nIGFsZ29yaXRobSB0aGF0IHJldHVybnM6XG4gKiAtIGFsbCBjaGlsZCBub2RlcyBvZiBtYXRjaGluZyBub2Rlc1xuICogLSBhIGNoYWluIHBhcmVudCBub2RlcyBmcm9tIHRoZSBtYXRjaCB0byB0aGUgcm9vdCBub2RlXG4gKi9cbmNvbnN0IGZpbHRlclRyZWUgPSAoaXRlbXMsIHRlcm0sIHsgb3BlcmF0b3IsIGlnbm9yZUNhc2UsIG1vZGUgfSwgdGV4dEZpZWxkLCBkZXB0aCA9IDApID0+IHtcbiAgICBjb25zdCBmaWVsZCA9IHR5cGVvZiB0ZXh0RmllbGQgPT09IFwic3RyaW5nXCIgPyB0ZXh0RmllbGQgOiB0ZXh0RmllbGRbZGVwdGhdO1xuICAgIGl0ZW1zLmZvckVhY2goKHdyYXBwZXIpID0+IHtcbiAgICAgICAgY29uc3QgbWF0Y2hlciA9IHR5cGVvZiBvcGVyYXRvciA9PT0gXCJzdHJpbmdcIiA/IG1hdGNoQnlGaWVsZEFuZENhc2UoZmllbGQsIG9wZXJhdG9yLCBpZ25vcmVDYXNlKSA6IG9wZXJhdG9yO1xuICAgICAgICBjb25zdCBpc01hdGNoID0gbWF0Y2hlcih3cmFwcGVyLmRhdGFJdGVtLCB0ZXJtKTtcbiAgICAgICAgd3JhcHBlci5pc01hdGNoID0gaXNNYXRjaDtcbiAgICAgICAgd3JhcHBlci52aXNpYmxlID0gaXNNYXRjaDtcbiAgICAgICAgd3JhcHBlci5jb250YWluc01hdGNoZXMgPSBmYWxzZTtcbiAgICAgICAgaWYgKGlzTWF0Y2gpIHtcbiAgICAgICAgICAgIHNldFBhcmVudENoYWluKHdyYXBwZXIucGFyZW50KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAod3JhcHBlci5jaGlsZHJlbiAmJiB3cmFwcGVyLmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGlmIChtb2RlID09PSBcInN0cmljdFwiIHx8ICFpc01hdGNoKSB7XG4gICAgICAgICAgICAgICAgZmlsdGVyVHJlZSh3cmFwcGVyLmNoaWxkcmVuLCB0ZXJtLCB7IG9wZXJhdG9yLCBpZ25vcmVDYXNlLCBtb2RlIH0sIHRleHRGaWVsZCwgZGVwdGggKyAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG1ha2VBbGxWaXNpYmxlKHdyYXBwZXIuY2hpbGRyZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG59O1xuY29uc3Qgc2V0UGFyZW50Q2hhaW4gPSAobm9kZSkgPT4ge1xuICAgIGlmICghaXNQcmVzZW50KG5vZGUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbm9kZS5jb250YWluc01hdGNoZXMgPSB0cnVlO1xuICAgIG5vZGUudmlzaWJsZSA9IHRydWU7XG4gICAgaWYgKGlzUHJlc2VudChub2RlLnBhcmVudCkgJiYgIW5vZGUucGFyZW50LmNvbnRhaW5zTWF0Y2hlcykge1xuICAgICAgICBzZXRQYXJlbnRDaGFpbihub2RlLnBhcmVudCk7XG4gICAgfVxufTtcbmNvbnN0IG1ha2VBbGxWaXNpYmxlID0gKG5vZGVzKSA9PiB7XG4gICAgbm9kZXMuZm9yRWFjaChub2RlID0+IHtcbiAgICAgICAgbm9kZS52aXNpYmxlID0gdHJ1ZTtcbiAgICAgICAgaWYgKG5vZGUuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIG1ha2VBbGxWaXNpYmxlKG5vZGUuY2hpbGRyZW4pO1xuICAgICAgICB9XG4gICAgfSk7XG59O1xuY29uc3QgybUyID0gKGEsIGIpID0+IGEuaW5kZXhPZihiKSA+PSAwLCDJtTMgPSAoYSwgYikgPT4gYS5pbmRleE9mKGIpID09PSAtMSwgybU0ID0gKGEsIGIpID0+IGEubGFzdEluZGV4T2YoYiwgMCkgPT09IDAsIMm1NSA9IChhLCBiKSA9PiBhLmxhc3RJbmRleE9mKGIsIDApID09PSAtMSwgybU2ID0gKGEsIGIpID0+IGEuaW5kZXhPZihiLCBhLmxlbmd0aCAtIGIubGVuZ3RoKSA+PSAwLCDJtTcgPSAoYSwgYikgPT4gYS5pbmRleE9mKGIsIGEubGVuZ3RoIC0gYi5sZW5ndGgpIDwgMDtcbmNvbnN0IG9wZXJhdG9ycyA9IHtcbiAgICBjb250YWluczogybUyLFxuICAgIGRvZXNub3Rjb250YWluOiDJtTMsXG4gICAgc3RhcnRzd2l0aDogybU0LFxuICAgIGRvZXNub3RzdGFydHdpdGg6IMm1NSxcbiAgICBlbmRzd2l0aDogybU2LFxuICAgIGRvZXNub3RlbmR3aXRoOiDJtTdcbn07XG5jb25zdCBtYXRjaEJ5Q2FzZSA9IChtYXRjaGVyLCBpZ25vcmVDYXNlKSA9PiAoYSwgYikgPT4ge1xuICAgIGlmIChpZ25vcmVDYXNlKSB7XG4gICAgICAgIHJldHVybiBtYXRjaGVyKGEudG9Mb3dlckNhc2UoKSwgYi50b0xvd2VyQ2FzZSgpKTtcbiAgICB9XG4gICAgcmV0dXJuIG1hdGNoZXIoYSwgYik7XG59O1xuY29uc3QgbWF0Y2hCeUZpZWxkQW5kQ2FzZSA9IChmaWVsZCwgb3BlcmF0b3IsIGlnbm9yZUNhc2UpID0+IChkYXRhSXRlbSwgdGVybSkgPT4gbWF0Y2hCeUNhc2Uob3BlcmF0b3JzW29wZXJhdG9yXSwgaWdub3JlQ2FzZSkoZ2V0dGVyKGZpZWxkKShkYXRhSXRlbSksIHRlcm0pO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGJ1aWxkVHJlZUluZGV4ID0gKHBhcmVudEluZGV4LCBpdGVtSW5kZXgpID0+IHtcbiAgICByZXR1cm4gW3BhcmVudEluZGV4LCBpdGVtSW5kZXhdLmZpbHRlcihwYXJ0ID0+IGlzUHJlc2VudChwYXJ0KSkuam9pbignXycpO1xufTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBidWlsZFRyZWVJdGVtID0gKGRhdGFJdGVtLCBjdXJyZW50TGV2ZWxJbmRleCwgcGFyZW50SW5kZXgpID0+IHtcbiAgICBpZiAoIWlzUHJlc2VudChkYXRhSXRlbSkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGRhdGFJdGVtLFxuICAgICAgICBpbmRleDogYnVpbGRUcmVlSW5kZXgocGFyZW50SW5kZXgsIGN1cnJlbnRMZXZlbEluZGV4KVxuICAgIH07XG59O1xuLyoqXG4gKiBAaGlkZGVuXG4gKlxuICogUmV0cmlldmVzIGFsbCBkZXNjZW5kYW50IG5vZGVzJyBsb29rdXBzIHdoaWNoIGFyZSBjdXJyZW50bHkgcmVnaXN0ZXJlZCBpbiB0aGUgcHJvdmlkZWQgbG9va3VwIGl0ZW0gYXMgYSBmbGF0IGFycmF5LlxuICovXG5jb25zdCBmZXRjaExvYWRlZERlc2NlbmRhbnRzID0gKGxvb2t1cCwgZmlsdGVyRXhwcmVzc2lvbikgPT4ge1xuICAgIGlmICghaXNQcmVzZW50KGxvb2t1cCkgfHwgbG9va3VwLmNoaWxkcmVuLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGxldCBkZXNjZW5kYW50cyA9IGxvb2t1cC5jaGlsZHJlbjtcbiAgICBpZiAoaXNQcmVzZW50KGZpbHRlckV4cHJlc3Npb24pKSB7XG4gICAgICAgIGRlc2NlbmRhbnRzID0gZGVzY2VuZGFudHMuZmlsdGVyKGZpbHRlckV4cHJlc3Npb24pO1xuICAgIH1cbiAgICBkZXNjZW5kYW50cy5mb3JFYWNoKGNoaWxkID0+IGRlc2NlbmRhbnRzID0gZGVzY2VuZGFudHMuY29uY2F0KGZldGNoTG9hZGVkRGVzY2VuZGFudHMoY2hpbGQsIGZpbHRlckV4cHJlc3Npb24pKSk7XG4gICAgcmV0dXJuIGRlc2NlbmRhbnRzO1xufTtcbi8qKlxuICogQGhpZGRlblxuICpcbiAqIENvbXBhcmVzIHR3byBhcnJheXMgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgYWxsIHVuaXF1ZSBlbGVtZW50cyBpbiBvbmUsIGFyZSBwcmVzZW50IGluIHRoZSBvdGhlci5cbiAqIEltcG9ydGFudDpcbiAqICAtIGl0IGRpc3JlZ2FyZHMgdGhlIGVsZW1lbnQgb3JkZXJcbiAqICAtIGl0IGRpc3JlZ2FyZHMgZWxlbWVudCByZXBldGl0aW9ucyAtIHNhbWVWYWx1ZXMoWzEsIDEsIDJdLCBbMSwgMiwgMl0pIHdpbGwgcmV0dXJuIHRydWVcbiAqL1xuY29uc3Qgc2FtZVZhbHVlcyA9IChhLCBiKSA9PiB7XG4gICAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHZhbHVlcyA9IG5ldyBTZXQoYik7XG4gICAgcmV0dXJuIGEuZXZlcnkodiA9PiB2YWx1ZXMuaGFzKHYpKTtcbn07XG5cbmNvbnN0IHNhZmUgPSBub2RlID0+IChub2RlIHx8IHt9KTtcbmNvbnN0IHNhZmVDaGlsZHJlbiA9IG5vZGUgPT4gKHNhZmUobm9kZSkuY2hpbGRyZW4gfHwgW10pO1xuY29uc3QgbGFzdFZpc2libGVOb2RlID0gKG5vZGVzKSA9PiB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KG5vZGVzKSB8fCBub2Rlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IG5vZGVzQ291bnQgPSBub2Rlcy5sZW5ndGg7XG4gICAgY29uc3QgbGFzdEluZGV4ID0gbm9kZXNDb3VudCAtIDE7XG4gICAgZm9yIChsZXQgaW5kZXggPSBsYXN0SW5kZXg7IGluZGV4ID49IDA7IGluZGV4IC09IDEpIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IG5vZGVzW2luZGV4XTtcbiAgICAgICAgaWYgKG5vZGUudmlzaWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59O1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIE5hdmlnYXRpb25Nb2RlbCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuaWIgPSBuZXcgSW5kZXhCdWlsZGVyU2VydmljZSgpO1xuICAgICAgICB0aGlzLm5vZGVzID0gW107XG4gICAgfVxuICAgIGZpcnN0VmlzaWJsZU5vZGUoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5ub2RlcyB8fCBbXSkuZmluZChub2RlID0+IG5vZGUudmlzaWJsZSk7XG4gICAgfVxuICAgIGxhc3RWaXNpYmxlTm9kZSgpIHtcbiAgICAgICAgbGV0IG5vZGUgPSBsYXN0VmlzaWJsZU5vZGUodGhpcy5ub2Rlcyk7XG4gICAgICAgIHdoaWxlIChpc1ByZXNlbnQobm9kZSkgJiYgc2FmZUNoaWxkcmVuKG5vZGUpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkcmVuID0gc2FmZUNoaWxkcmVuKG5vZGUpO1xuICAgICAgICAgICAgY29uc3QgbGFzdFZpc2libGVDaGlsZCA9IGxhc3RWaXNpYmxlTm9kZShjaGlsZHJlbik7XG4gICAgICAgICAgICBpZiAoIWlzUHJlc2VudChsYXN0VmlzaWJsZUNoaWxkKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9kZSA9IGxhc3RWaXNpYmxlQ2hpbGQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICAgIGNsb3Nlc3ROb2RlKGluZGV4KSB7XG4gICAgICAgIGNvbnN0IHsgcHJldiB9ID0gc2FmZSh0aGlzLmZpbmROb2RlKGluZGV4KSk7XG4gICAgICAgIGNvbnN0IHNpYmxpbmcgPSBwcmV2IHx8IHRoaXMuZmlyc3RWaXNpYmxlTm9kZSgpO1xuICAgICAgICByZXR1cm4gc2FmZShzaWJsaW5nKS5pbmRleCA9PT0gaW5kZXggPyB0aGlzLnZpc2libGVTaWJsaW5nKHNpYmxpbmcsIDEpIDogc2libGluZztcbiAgICB9XG4gICAgZmlyc3RGb2N1c2FibGVOb2RlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ub2Rlcy5maW5kKChub2RlKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gIW5vZGUuZGlzYWJsZWQgJiYgbm9kZS52aXNpYmxlO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZmluZE5vZGUoaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluZChpbmRleCwgdGhpcy5ub2Rlcyk7XG4gICAgfVxuICAgIGZpbmRQYXJlbnQoaW5kZXgpIHtcbiAgICAgICAgY29uc3QgcGFyZW50TGV2ZWwgPSB0aGlzLmliLmxldmVsKGluZGV4KSAtIDE7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmROb2RlKHRoaXMuaWIuaW5kZXhGb3JMZXZlbChpbmRleCwgcGFyZW50TGV2ZWwpKTtcbiAgICB9XG4gICAgZmluZFZpc2libGVDaGlsZChpbmRleCkge1xuICAgICAgICBjb25zdCBub2RlID0gdGhpcy5maW5kTm9kZShpbmRleCk7XG4gICAgICAgIGNvbnN0IGNoaWxkcmVuID0gc2FmZUNoaWxkcmVuKG5vZGUpO1xuICAgICAgICByZXR1cm4gY2hpbGRyZW4uZmluZCgoY2hpbGQpID0+IGNoaWxkLnZpc2libGUpO1xuICAgIH1cbiAgICBmaW5kVmlzaWJsZVByZXYoaXRlbSkge1xuICAgICAgICBjb25zdCBpbmRleCA9IGl0ZW0uaW5kZXg7XG4gICAgICAgIGNvbnN0IHBhcmVudCA9IHRoaXMuZmluZFBhcmVudChpbmRleCk7XG4gICAgICAgIGNvbnN0IGxldmVsSW5kZXggPSB0aGlzLmliLmxhc3RMZXZlbEluZGV4KGluZGV4KTtcbiAgICAgICAgY29uc3QgcHJldk5vZGVzID0gdGhpcy5jb250YWluZXIocGFyZW50KS5zbGljZSgwLCBsZXZlbEluZGV4KTtcbiAgICAgICAgY29uc3QgcHJldk5vZGVzSGlkZGVuID0gcHJldk5vZGVzLmV2ZXJ5KG5vZGUgPT4gIW5vZGUudmlzaWJsZSk7XG4gICAgICAgIGlmIChsZXZlbEluZGV4ID09PSAwIHx8IHByZXZOb2Rlc0hpZGRlbikge1xuICAgICAgICAgICAgcmV0dXJuIHBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjdXJyZW50Tm9kZSA9IHRoaXMuZmluZE5vZGUoaW5kZXgpO1xuICAgICAgICBsZXQgcHJldiA9IHRoaXMudmlzaWJsZVNpYmxpbmcoY3VycmVudE5vZGUsIC0xKTtcbiAgICAgICAgaWYgKHByZXYpIHtcbiAgICAgICAgICAgIGxldCBjaGlsZHJlbiA9IHRoaXMuY29udGFpbmVyKHByZXYpO1xuICAgICAgICAgICAgd2hpbGUgKGNoaWxkcmVuLmxlbmd0aCA+IDAgJiYgY2hpbGRyZW4uc29tZShub2RlID0+IG5vZGUudmlzaWJsZSkpIHtcbiAgICAgICAgICAgICAgICBwcmV2ID0gbGFzdFZpc2libGVOb2RlKGNoaWxkcmVuKTtcbiAgICAgICAgICAgICAgICBjaGlsZHJlbiA9IHRoaXMuY29udGFpbmVyKHByZXYpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcmV2O1xuICAgIH1cbiAgICBmaW5kVmlzaWJsZU5leHQoaXRlbSkge1xuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IHRoaXMuY29udGFpbmVyKGl0ZW0pO1xuICAgICAgICBjb25zdCBoYXNWaXNpYmxlQ2hpbGRyZW4gPSBjaGlsZHJlbi5zb21lKGNoaWxkID0+IGNoaWxkLnZpc2libGUpO1xuICAgICAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID09PSAwIHx8ICFoYXNWaXNpYmxlQ2hpbGRyZW4pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZpc2libGVTaWJsaW5nKGl0ZW0sIDEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaGlsZHJlbi5maW5kKGNoaWxkID0+IGNoaWxkLnZpc2libGUpO1xuICAgIH1cbiAgICByZWdpc3Rlckl0ZW0oaWQsIGluZGV4LCBkaXNhYmxlZCwgbG9hZE1vcmVCdXR0b24gPSBmYWxzZSwgdmlzaWJsZSA9IHRydWUpIHtcbiAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBbXTtcbiAgICAgICAgY29uc3QgbGV2ZWwgPSB0aGlzLmliLmxldmVsKGluZGV4KTtcbiAgICAgICAgY29uc3QgcGFyZW50ID0gdGhpcy5maW5kUGFyZW50KGluZGV4KTtcbiAgICAgICAgaWYgKHBhcmVudCB8fCBsZXZlbCA9PT0gMSkge1xuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IHsgaWQsIGNoaWxkcmVuLCBpbmRleCwgcGFyZW50LCBkaXNhYmxlZCwgbG9hZE1vcmVCdXR0b24sIHZpc2libGUgfTtcbiAgICAgICAgICAgIHRoaXMuaW5zZXJ0KG5vZGUsIHBhcmVudCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdW5yZWdpc3Rlckl0ZW0oaWQsIGluZGV4KSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLmZpbmQoaW5kZXgsIHRoaXMubm9kZXMpO1xuICAgICAgICBpZiAoIW5vZGUgfHwgbm9kZS5pZCAhPT0gaWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IHRoaXMuY29udGFpbmVyKG5vZGUucGFyZW50KTtcbiAgICAgICAgY2hpbGRyZW4uc3BsaWNlKGNoaWxkcmVuLmluZGV4T2Yobm9kZSksIDEpO1xuICAgIH1cbiAgICBjaGlsZExldmVsKG5vZGVzKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkcmVuID0gbm9kZXMuZmlsdGVyKG5vZGUgPT4gaXNQcmVzZW50KG5vZGUpKTtcbiAgICAgICAgaWYgKCFjaGlsZHJlbiB8fCAhY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5pYi5sZXZlbChjaGlsZHJlblswXS5pbmRleCk7XG4gICAgfVxuICAgIGNvbnRhaW5lcihub2RlKSB7XG4gICAgICAgIHJldHVybiBub2RlID8gbm9kZS5jaGlsZHJlbiA6IHRoaXMubm9kZXM7XG4gICAgfVxuICAgIGZpbmQoaW5kZXgsIG5vZGVzKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkTGV2ZWwgPSB0aGlzLmNoaWxkTGV2ZWwobm9kZXMpO1xuICAgICAgICBjb25zdCBpbmRleFRvTWF0Y2ggPSB0aGlzLmliLmluZGV4Rm9yTGV2ZWwoaW5kZXgsIGNoaWxkTGV2ZWwpO1xuICAgICAgICBjb25zdCBpc0xlYWYgPSBjaGlsZExldmVsID09PSB0aGlzLmliLmxldmVsKGluZGV4KTtcbiAgICAgICAgY29uc3Qgbm9kZSA9IG5vZGVzLmZpbmQobiA9PiBuICYmIG4uaW5kZXggPT09IGluZGV4VG9NYXRjaCk7XG4gICAgICAgIGlmICghbm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlzTGVhZiA/IG5vZGUgOiB0aGlzLmZpbmQoaW5kZXgsIG5vZGUuY2hpbGRyZW4pO1xuICAgIH1cbiAgICBpbnNlcnQobm9kZSwgcGFyZW50KSB7XG4gICAgICAgIGNvbnN0IG5vZGVzID0gdGhpcy5jb250YWluZXIocGFyZW50KTtcbiAgICAgICAgbm9kZXMuc3BsaWNlKHRoaXMuaWIubGFzdExldmVsSW5kZXgobm9kZS5pbmRleCksIDAsIG5vZGUpO1xuICAgIH1cbiAgICB2aXNpYmxlU2libGluZyhub2RlLCBvZmZzZXQpIHtcbiAgICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJlbnQgPSB0aGlzLmZpbmRQYXJlbnQobm9kZS5pbmRleCk7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyKHBhcmVudCk7XG4gICAgICAgIGxldCBuZXh0SXRlbUluZGV4ID0gY29udGFpbmVyLmluZGV4T2Yobm9kZSkgKyBvZmZzZXQ7XG4gICAgICAgIGxldCBuZXh0SXRlbSA9IGNvbnRhaW5lcltuZXh0SXRlbUluZGV4XTtcbiAgICAgICAgd2hpbGUgKGlzUHJlc2VudChuZXh0SXRlbSkpIHtcbiAgICAgICAgICAgIGlmIChuZXh0SXRlbS52aXNpYmxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5leHRJdGVtO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV4dEl0ZW1JbmRleCArPSBvZmZzZXQ7XG4gICAgICAgICAgICBuZXh0SXRlbSA9IGNvbnRhaW5lcltuZXh0SXRlbUluZGV4XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy52aXNpYmxlU2libGluZyhwYXJlbnQsIG9mZnNldCk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xubGV0IE5hdmlnYXRpb25TZXJ2aWNlID0gY2xhc3MgTmF2aWdhdGlvblNlcnZpY2Uge1xuICAgIGNvbnN0cnVjdG9yKGxvY2FsaXphdGlvbikge1xuICAgICAgICB0aGlzLmxvY2FsaXphdGlvbiA9IGxvY2FsaXphdGlvbjtcbiAgICAgICAgdGhpcy5leHBhbmRzID0gbmV3IFN1YmplY3QoKTtcbiAgICAgICAgdGhpcy5tb3ZlcyA9IG5ldyBTdWJqZWN0KCk7XG4gICAgICAgIHRoaXMuY2hlY2tzID0gbmV3IFN1YmplY3QoKTtcbiAgICAgICAgdGhpcy5zZWxlY3RzID0gbmV3IFN1YmplY3QoKTtcbiAgICAgICAgdGhpcy5sb2FkTW9yZSA9IG5ldyBTdWJqZWN0KCk7XG4gICAgICAgIHRoaXMubmF2aWdhYmxlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5hY3Rpb25zID0ge1xuICAgICAgICAgICAgW0tleXMuQXJyb3dVcF06ICgpID0+IHRoaXMuYWN0aXZhdGUodGhpcy5tb2RlbC5maW5kVmlzaWJsZVByZXYodGhpcy5mb2N1c2FibGVJdGVtKSksXG4gICAgICAgICAgICBbS2V5cy5BcnJvd0Rvd25dOiAoKSA9PiB0aGlzLmFjdGl2YXRlKHRoaXMubW9kZWwuZmluZFZpc2libGVOZXh0KHRoaXMuZm9jdXNhYmxlSXRlbSkpLFxuICAgICAgICAgICAgW0tleXMuQXJyb3dMZWZ0XTogKCkgPT4gIXRoaXMuaXNMb2FkTW9yZUJ1dHRvbiAmJiAodGhpcy5leHBhbmQoe1xuICAgICAgICAgICAgICAgIGV4cGFuZDogdGhpcy5sb2NhbGl6YXRpb24ucnRsLFxuICAgICAgICAgICAgICAgIGludGVyY2VwdDogdGhpcy5sb2NhbGl6YXRpb24ucnRsID8gdGhpcy5tb3ZlVG9GaXJzdFZpc2libGVDaGlsZCA6IHRoaXMubW92ZVRvUGFyZW50XG4gICAgICAgICAgICB9KSksXG4gICAgICAgICAgICBbS2V5cy5BcnJvd1JpZ2h0XTogKCkgPT4gIXRoaXMuaXNMb2FkTW9yZUJ1dHRvbiAmJiAodGhpcy5leHBhbmQoe1xuICAgICAgICAgICAgICAgIGV4cGFuZDogIXRoaXMubG9jYWxpemF0aW9uLnJ0bCxcbiAgICAgICAgICAgICAgICBpbnRlcmNlcHQ6IHRoaXMubG9jYWxpemF0aW9uLnJ0bCA/IHRoaXMubW92ZVRvUGFyZW50IDogdGhpcy5tb3ZlVG9GaXJzdFZpc2libGVDaGlsZFxuICAgICAgICAgICAgfSkpLFxuICAgICAgICAgICAgW0tleXMuSG9tZV06ICgpID0+IHRoaXMuYWN0aXZhdGUodGhpcy5tb2RlbC5maXJzdFZpc2libGVOb2RlKCkpLFxuICAgICAgICAgICAgW0tleXMuRW5kXTogKCkgPT4gdGhpcy5hY3RpdmF0ZSh0aGlzLm1vZGVsLmxhc3RWaXNpYmxlTm9kZSgpKSxcbiAgICAgICAgICAgIFtLZXlzLkVudGVyXTogKCkgPT4gdGhpcy5oYW5kbGVFbnRlcigpLFxuICAgICAgICAgICAgW0tleXMuU3BhY2VdOiAoKSA9PiB0aGlzLmhhbmRsZVNwYWNlKClcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5pc0ZvY3VzZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fbW9kZWwgPSBuZXcgTmF2aWdhdGlvbk1vZGVsKCk7XG4gICAgICAgIHRoaXMubW92ZVRvRmlyc3RWaXNpYmxlQ2hpbGQgPSB0aGlzLm1vdmVUb0ZpcnN0VmlzaWJsZUNoaWxkLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMubW92ZVRvUGFyZW50ID0gdGhpcy5tb3ZlVG9QYXJlbnQuYmluZCh0aGlzKTtcbiAgICB9XG4gICAgZ2V0IG1vZGVsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbW9kZWw7XG4gICAgfVxuICAgIHNldCBtb2RlbChtb2RlbCkge1xuICAgICAgICB0aGlzLl9tb2RlbCA9IG1vZGVsO1xuICAgIH1cbiAgICBnZXQgYWN0aXZlSW5kZXgoKSB7XG4gICAgICAgIHJldHVybiBub2RlSW5kZXgodGhpcy5hY3RpdmVJdGVtKSB8fCBudWxsO1xuICAgIH1cbiAgICBnZXQgaXNBY3RpdmVFeHBhbmRlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWN0aXZlSXRlbSAmJiB0aGlzLmFjdGl2ZUl0ZW0uY2hpbGRyZW4ubGVuZ3RoID4gMDtcbiAgICB9XG4gICAgZ2V0IGlzTG9hZE1vcmVCdXR0b24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFjdGl2ZUl0ZW0gJiYgdGhpcy5hY3RpdmVJdGVtLmxvYWRNb3JlQnV0dG9uO1xuICAgIH1cbiAgICBnZXQgZm9jdXNhYmxlSXRlbSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWN0aXZlSXRlbSB8fCB0aGlzLm1vZGVsLmZpcnN0Rm9jdXNhYmxlTm9kZSgpO1xuICAgIH1cbiAgICBhY3RpdmF0ZShpdGVtKSB7XG4gICAgICAgIGlmICghdGhpcy5uYXZpZ2FibGUgfHwgIWl0ZW0gfHwgdGhpcy5pc0FjdGl2ZShub2RlSW5kZXgoaXRlbSkpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pc0ZvY3VzZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmFjdGl2ZUl0ZW0gPSBpdGVtIHx8IHRoaXMuYWN0aXZlSXRlbTtcbiAgICAgICAgdGhpcy5ub3RpZnlNb3ZlKCk7XG4gICAgfVxuICAgIGFjdGl2YXRlUGFyZW50KGluZGV4KSB7XG4gICAgICAgIHRoaXMuYWN0aXZhdGUodGhpcy5tb2RlbC5maW5kUGFyZW50KGluZGV4KSk7XG4gICAgfVxuICAgIGFjdGl2YXRlSW5kZXgoaW5kZXgpIHtcbiAgICAgICAgaWYgKCFpbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWN0aXZhdGUodGhpcy5tb2RlbC5maW5kTm9kZShpbmRleCkpO1xuICAgIH1cbiAgICBhY3RpdmF0ZUNsb3Nlc3QoaW5kZXgpIHtcbiAgICAgICAgaWYgKCFpbmRleCB8fCBub2RlSW5kZXgodGhpcy5mb2N1c2FibGVJdGVtKSAhPT0gaW5kZXgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFjdGl2ZUl0ZW0gPSB0aGlzLm1vZGVsLmNsb3Nlc3ROb2RlKGluZGV4KTtcbiAgICAgICAgdGhpcy5ub3RpZnlNb3ZlKCk7XG4gICAgfVxuICAgIGFjdGl2YXRlRm9jdXNhYmxlKCkge1xuICAgICAgICBpZiAodGhpcy5hY3RpdmVJdGVtKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hY3RpdmVJdGVtID0gdGhpcy5tb2RlbC5maXJzdFZpc2libGVOb2RlKCk7XG4gICAgICAgIHRoaXMubm90aWZ5TW92ZSgpO1xuICAgIH1cbiAgICBkZWFjdGl2YXRlKCkge1xuICAgICAgICBpZiAoIXRoaXMubmF2aWdhYmxlIHx8ICF0aGlzLmlzRm9jdXNlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXNGb2N1c2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMubm90aWZ5TW92ZSgpO1xuICAgIH1cbiAgICBjaGVja0luZGV4KGluZGV4KSB7XG4gICAgICAgIGlmICghdGhpcy5pc0Rpc2FibGVkKGluZGV4KSkge1xuICAgICAgICAgICAgdGhpcy5jaGVja3MubmV4dChpbmRleCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2VsZWN0SW5kZXgoaW5kZXgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzRGlzYWJsZWQoaW5kZXgpKSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdHMubmV4dChpbmRleCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbm90aWZ5TG9hZE1vcmUoaW5kZXgpIHtcbiAgICAgICAgaWYgKCFpc1ByZXNlbnQoaW5kZXgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sb2FkTW9yZS5uZXh0KGluZGV4KTtcbiAgICB9XG4gICAgaXNBY3RpdmUoaW5kZXgpIHtcbiAgICAgICAgaWYgKCFpbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmlzRm9jdXNlZCAmJiB0aGlzLmFjdGl2ZUluZGV4ID09PSBpbmRleDtcbiAgICB9XG4gICAgaXNGb2N1c2FibGUoaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIG5vZGVJbmRleCh0aGlzLmZvY3VzYWJsZUl0ZW0pID09PSBpbmRleDtcbiAgICB9XG4gICAgaXNEaXNhYmxlZChpbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RlbC5maW5kTm9kZShpbmRleCkuZGlzYWJsZWQ7XG4gICAgfVxuICAgIHJlZ2lzdGVySXRlbShpZCwgaW5kZXgsIGRpc2FibGVkLCBsb2FkTW9yZUJ1dHRvbiA9IGZhbHNlLCB2aXNpYmxlID0gdHJ1ZSkge1xuICAgICAgICBjb25zdCBpdGVtQXRJbmRleCA9IHRoaXMubW9kZWwuZmluZE5vZGUoaW5kZXgpO1xuICAgICAgICBpZiAoaXNQcmVzZW50KGl0ZW1BdEluZGV4KSkge1xuICAgICAgICAgICAgdGhpcy5tb2RlbC51bnJlZ2lzdGVySXRlbShpdGVtQXRJbmRleC5pZCwgaXRlbUF0SW5kZXguaW5kZXgpO1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNBY3RpdmUoaW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWFjdGl2YXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tb2RlbC5yZWdpc3Rlckl0ZW0oaWQsIGluZGV4LCBkaXNhYmxlZCwgbG9hZE1vcmVCdXR0b24sIHZpc2libGUpO1xuICAgIH1cbiAgICB1bnJlZ2lzdGVySXRlbShpZCwgaW5kZXgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNBY3RpdmUoaW5kZXgpKSB7XG4gICAgICAgICAgICB0aGlzLmFjdGl2YXRlUGFyZW50KGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1vZGVsLnVucmVnaXN0ZXJJdGVtKGlkLCBpbmRleCk7XG4gICAgfVxuICAgIG1vdmUoZSkge1xuICAgICAgICBpZiAoIXRoaXMubmF2aWdhYmxlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbW92ZUFjdGlvbiA9IHRoaXMuYWN0aW9uc1tlLmtleUNvZGVdO1xuICAgICAgICBpZiAoIW1vdmVBY3Rpb24pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBtb3ZlQWN0aW9uKCk7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gICAgZXhwYW5kKHsgZXhwYW5kLCBpbnRlcmNlcHQgfSkge1xuICAgICAgICBjb25zdCBpbmRleCA9IG5vZGVJbmRleCh0aGlzLmFjdGl2ZUl0ZW0pO1xuICAgICAgICBpZiAoIWluZGV4IHx8IGludGVyY2VwdChpbmRleCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5vdGlmeUV4cGFuZChleHBhbmQpO1xuICAgIH1cbiAgICBtb3ZlVG9QYXJlbnQoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzQWN0aXZlRXhwYW5kZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFjdGl2YXRlKHRoaXMubW9kZWwuZmluZFBhcmVudChub2RlSW5kZXgodGhpcy5hY3RpdmVJdGVtKSkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgbW92ZVRvRmlyc3RWaXNpYmxlQ2hpbGQoKSB7XG4gICAgICAgIGlmICghdGhpcy5pc0FjdGl2ZUV4cGFuZGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hY3RpdmF0ZSh0aGlzLm1vZGVsLmZpbmRWaXNpYmxlQ2hpbGQobm9kZUluZGV4KHRoaXMuYWN0aXZlSXRlbSkpKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIG5vdGlmeUV4cGFuZChleHBhbmQpIHtcbiAgICAgICAgdGhpcy5leHBhbmRzLm5leHQodGhpcy5uYXZpZ2F0aW9uU3RhdGUoZXhwYW5kKSk7XG4gICAgfVxuICAgIG5vdGlmeU1vdmUoKSB7XG4gICAgICAgIHRoaXMubW92ZXMubmV4dCh0aGlzLm5hdmlnYXRpb25TdGF0ZSgpKTtcbiAgICB9XG4gICAgbmF2aWdhdGlvblN0YXRlKGV4cGFuZCA9IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiAoeyBleHBhbmQsIGluZGV4OiB0aGlzLmFjdGl2ZUluZGV4LCBpc0ZvY3VzZWQ6IHRoaXMuaXNGb2N1c2VkIH0pO1xuICAgIH1cbiAgICBoYW5kbGVFbnRlcigpIHtcbiAgICAgICAgaWYgKCF0aGlzLm5hdmlnYWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmlzTG9hZE1vcmVCdXR0b24pIHtcbiAgICAgICAgICAgIHRoaXMubm90aWZ5TG9hZE1vcmUodGhpcy5hY3RpdmVJbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdEluZGV4KHRoaXMuYWN0aXZlSW5kZXgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhbmRsZVNwYWNlKCkge1xuICAgICAgICBpZiAoIXRoaXMubmF2aWdhYmxlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaXNMb2FkTW9yZUJ1dHRvbikge1xuICAgICAgICAgICAgdGhpcy5ub3RpZnlMb2FkTW9yZSh0aGlzLmFjdGl2ZUluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tJbmRleCh0aGlzLmFjdGl2ZUluZGV4KTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5OYXZpZ2F0aW9uU2VydmljZSA9IF9fZGVjb3JhdGUoW1xuICAgIEluamVjdGFibGUoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0xvY2FsaXphdGlvblNlcnZpY2VdKVxuXSwgTmF2aWdhdGlvblNlcnZpY2UpO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xubGV0IE5vZGVDaGlsZHJlblNlcnZpY2UgPSBjbGFzcyBOb2RlQ2hpbGRyZW5TZXJ2aWNlIHtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuY2hhbmdlcyA9IG5ldyBTdWJqZWN0KCk7XG4gICAgfVxuICAgIGNoaWxkcmVuTG9hZGVkKGl0ZW0sIGNoaWxkcmVuKSB7XG4gICAgICAgIHRoaXMuY2hhbmdlcy5uZXh0KHsgaXRlbSwgY2hpbGRyZW4gfSk7XG4gICAgfVxufTtcbk5vZGVDaGlsZHJlblNlcnZpY2UgPSBfX2RlY29yYXRlKFtcbiAgICBJbmplY3RhYmxlKClcbl0sIE5vZGVDaGlsZHJlblNlcnZpY2UpO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIHRlbXBsYXRlIGZvciB0aGUgVHJlZVZpZXcgbm9kZXMgKFttb3JlIGluZm9ybWF0aW9uIGFuZCBleGFtcGxlXSh7JSBzbHVnIG5vZGV0ZW1wbGF0ZV90cmVldmlldyAlfSkpLlxuICogVGhlIHRlbXBsYXRlIGhlbHBzIHRvIGN1c3RvbWl6ZSB0aGUgY29udGVudCBvZiB0aGUgbm9kZXMuIFRvIGRlZmluZSB0aGUgbm9kZSB0ZW1wbGF0ZSwgbmVzdCBhbiBgPG5nLXRlbXBsYXRlPmBcbiAqIHRhZyB3aXRoIHRoZSBga2VuZG9UcmVlVmlld05vZGVUZW1wbGF0ZWAgZGlyZWN0aXZlIGluc2lkZSBhIGA8a2VuZG8tdHJlZXZpZXc+YCB0YWcuXG4gKlxuICpcbiAqIFRoZSBub2RlIGRhdGEgaXRlbSBhbmQgaXRzIGhpZXJhcmNoaWNhbCBpbmRleCBhcmUgYXZhaWxhYmxlIGFzIGNvbnRleHQgdmFyaWFibGVzOlxuICpcbiAqIC0gYGxldC1kYXRhSXRlbWAgKGBhbnlgKSAtIGF2YWlsYWJsZSBhcyBpbXBsaWNpdCBjb250ZXh0IHZhcmlhYmxlXG4gKiAtIGBsZXQtaW5kZXg9XCJpbmRleFwiYCAoYHN0cmluZ2ApXG4gKlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICpcbiAqICBpbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbiAqICBAQ29tcG9uZW50KHtcbiAqICAgICAgc2VsZWN0b3I6ICdteS1hcHAnLFxuICogICAgICB0ZW1wbGF0ZTogYFxuICogICAgICA8a2VuZG8tdHJlZXZpZXdcbiAqICAgICAgICAgIFtub2Rlc109XCJkYXRhXCJcbiAqICAgICAgICAgIGtlbmRvVHJlZVZpZXdFeHBhbmRhYmxlXG4gKlxuICogICAgICAgICAga2VuZG9UcmVlVmlld0hpZXJhcmNoeUJpbmRpbmdcbiAqICAgICAgICAgIGNoaWxkcmVuRmllbGQ9XCJpdGVtc1wiPlxuICogICAgICAgIDxuZy10ZW1wbGF0ZSBrZW5kb1RyZWVWaWV3Tm9kZVRlbXBsYXRlIGxldC1kYXRhSXRlbSBsZXQtaW5kZXg9XCJpbmRleFwiPlxuICogICAgICAgICAgPHNwYW4gW3N0eWxlLmZvbnRXZWlnaHRdPVwiZGF0YUl0ZW0uaXRlbXMgPyAnYm9sZGVyJzogJ25vcm1hbCcgXCI+e3sgaW5kZXggfX06IHt7IGRhdGFJdGVtLnRleHQgfX08L3NwYW4+XG4gKiAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAqICAgICAgPC9rZW5kby10cmVldmlldz5cbiAqICAgIGBcbiAqICB9KVxuICogIGV4cG9ydCBjbGFzcyBBcHBDb21wb25lbnQge1xuICogICAgICBwdWJsaWMgZGF0YTogYW55W10gPSBbXG4gKiAgICAgICAgICB7XG4gKiAgICAgICAgICAgICAgdGV4dDogXCJJbmJveFwiLFxuICogICAgICAgICAgICAgIGl0ZW1zOiBbeyB0ZXh0OiBcIlJlYWQgTWFpbFwiIH1dXG4gKiAgICAgICAgICB9LFxuICogICAgICAgICAge1xuICogICAgICAgICAgICAgIHRleHQ6IFwiRHJhZnRzXCJcbiAqICAgICAgICAgIH0sXG4gKiAgICAgICAgICB7XG4gKiAgICAgICAgICAgICAgdGV4dDogXCJTZWFyY2ggRm9sZGVyc1wiLFxuICogICAgICAgICAgICAgIGl0ZW1zOiBbXG4gKiAgICAgICAgICAgICAgICAgIHsgdGV4dDogXCJDYXRlZ29yaXplZCBNYWlsXCIgfSxcbiAqICAgICAgICAgICAgICAgICAgeyB0ZXh0OiBcIkxhcmdlIE1haWxcIiB9LFxuICogICAgICAgICAgICAgICAgICB7IHRleHQ6IFwiVW5yZWFkIE1haWxcIn1cbiAqICAgICAgICAgICAgICBdXG4gKiAgICAgICAgICB9LFxuICogICAgICAgICAgeyB0ZXh0OiBcIlNldHRpbmdzXCIgfVxuICogICAgICBdO1xuICogIH1cbiAqXG4gKiBgYGBcbiAqL1xubGV0IE5vZGVUZW1wbGF0ZURpcmVjdGl2ZSA9IGNsYXNzIE5vZGVUZW1wbGF0ZURpcmVjdGl2ZSB7XG4gICAgY29uc3RydWN0b3IodGVtcGxhdGVSZWYpIHtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZVJlZiA9IHRlbXBsYXRlUmVmO1xuICAgIH1cbn07XG5Ob2RlVGVtcGxhdGVEaXJlY3RpdmUgPSBfX2RlY29yYXRlKFtcbiAgICBEaXJlY3RpdmUoe1xuICAgICAgICBzZWxlY3RvcjogJ1trZW5kb1RyZWVWaWV3Tm9kZVRlbXBsYXRlXSdcbiAgICB9KSxcbiAgICBfX3BhcmFtKDAsIE9wdGlvbmFsKCkpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbVGVtcGxhdGVSZWZdKVxuXSwgTm9kZVRlbXBsYXRlRGlyZWN0aXZlKTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSB0ZW1wbGF0ZSBmb3IgdGhlIFRyZWVWaWV3IGxvYWQgbW9yZSBidXR0b25zLlxuICogVG8gZGVmaW5lIGEgYnV0dG9uIHRlbXBsYXRlLCBuZXN0IGFuIGA8bmctdGVtcGxhdGU+YFxuICogdGFnIHdpdGggdGhlIGBrZW5kb1RyZWVWaWV3TG9hZE1vcmVCdXR0b25UZW1wbGF0ZWAgZGlyZWN0aXZlIGluc2lkZSBhIGA8a2VuZG8tdHJlZXZpZXc+YCB0YWdcbiAqIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgbG9hZG1vcmVidXR0b25fdHJlZXZpZXcgJX0jdG9jLWJ1dHRvbi10ZW1wbGF0ZSkpLlxuICpcbiAqIFRoZSBoaWVyYXJjaGljYWwgaW5kZXggb2YgdGhlIGxvYWQgbW9yZSBidXR0b24gbm9kZSBpcyBhdmFpbGFibGUgYXMgYSBjb250ZXh0IHZhcmlhYmxlOlxuICpcbiAqIC0gYGxldC1pbmRleD1cImluZGV4XCJgIChgc3RyaW5nYClcbiAqL1xubGV0IExvYWRNb3JlQnV0dG9uVGVtcGxhdGVEaXJlY3RpdmUgPSBjbGFzcyBMb2FkTW9yZUJ1dHRvblRlbXBsYXRlRGlyZWN0aXZlIHtcbiAgICBjb25zdHJ1Y3Rvcih0ZW1wbGF0ZVJlZikge1xuICAgICAgICB0aGlzLnRlbXBsYXRlUmVmID0gdGVtcGxhdGVSZWY7XG4gICAgfVxufTtcbkxvYWRNb3JlQnV0dG9uVGVtcGxhdGVEaXJlY3RpdmUgPSBfX2RlY29yYXRlKFtcbiAgICBEaXJlY3RpdmUoe1xuICAgICAgICBzZWxlY3RvcjogJ1trZW5kb1RyZWVWaWV3TG9hZE1vcmVCdXR0b25UZW1wbGF0ZV0nXG4gICAgfSksXG4gICAgX19wYXJhbSgwLCBPcHRpb25hbCgpKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW1RlbXBsYXRlUmVmXSlcbl0sIExvYWRNb3JlQnV0dG9uVGVtcGxhdGVEaXJlY3RpdmUpO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqXG4gKiBBbiBpbmplY3Rpb24gdG9rZW4gdXNlZCBieSB0aGUgZGF0YSBiaW5kaW5nIGRpcmVjdGl2ZXMgdG8gaW50ZXJmYWNlIHdpdGhcbiAqIHRoZSBUcmVlVmlldyBvciB0aGUgRHJvcERvd25UcmVlIGNvbXBvbmVudHMuXG4gKi9cbmxldCBEYXRhQm91bmRDb21wb25lbnQgPSBjbGFzcyBEYXRhQm91bmRDb21wb25lbnQge1xufTtcbkRhdGFCb3VuZENvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIEluamVjdGFibGUoKVxuXSwgRGF0YUJvdW5kQ29tcG9uZW50KTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKlxuICogQW4gaW5qZWN0aW9uIHRva2VuIHVzZWQgYnkgdGhlIGV4cGFuZC1kaXJlY3RpdmUgdG8gaW50ZXJmYWNlIHdpdGhcbiAqIHRoZSBUcmVlVmlldyBvciB0aGUgRHJvcERvd25UcmVlIGNvbXBvbmVudHMuXG4gKi9cbmxldCBFeHBhbmRhYmxlQ29tcG9uZW50ID0gY2xhc3MgRXhwYW5kYWJsZUNvbXBvbmVudCB7XG59O1xuRXhwYW5kYWJsZUNvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIEluamVjdGFibGUoKVxuXSwgRXhwYW5kYWJsZUNvbXBvbmVudCk7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5sZXQgU2VsZWN0aW9uU2VydmljZSA9IGNsYXNzIFNlbGVjdGlvblNlcnZpY2Uge1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5jaGFuZ2VzID0gbmV3IFN1YmplY3QoKTtcbiAgICB9XG4gICAgaXNGaXJzdFNlbGVjdGVkKGluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpcnN0SW5kZXggPT09IGluZGV4O1xuICAgIH1cbiAgICBzZXRGaXJzdFNlbGVjdGVkKGluZGV4LCBzZWxlY3RlZCkge1xuICAgICAgICBpZiAodGhpcy5maXJzdEluZGV4ID09PSBpbmRleCAmJiBzZWxlY3RlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHRoaXMuZmlyc3RJbmRleCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXRoaXMuZmlyc3RJbmRleCAmJiBzZWxlY3RlZCkge1xuICAgICAgICAgICAgdGhpcy5maXJzdEluZGV4ID0gaW5kZXg7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2VsZWN0KGluZGV4LCBkYXRhSXRlbSkge1xuICAgICAgICB0aGlzLmNoYW5nZXMubmV4dCh7IGRhdGFJdGVtLCBpbmRleCB9KTtcbiAgICB9XG59O1xuU2VsZWN0aW9uU2VydmljZSA9IF9fZGVjb3JhdGUoW1xuICAgIEluamVjdGFibGUoKVxuXSwgU2VsZWN0aW9uU2VydmljZSk7XG5cbmNvbnN0IElOREVYX1JFR0VYID0gL1xcZCskLztcbi8qKlxuICogQGhpZGRlblxuICovXG5sZXQgVHJlZVZpZXdMb29rdXBTZXJ2aWNlID0gY2xhc3MgVHJlZVZpZXdMb29rdXBTZXJ2aWNlIHtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMubWFwID0gbmV3IE1hcCgpO1xuICAgIH1cbiAgICByZXNldCgpIHtcbiAgICAgICAgdGhpcy5tYXAuY2xlYXIoKTtcbiAgICB9XG4gICAgcmVnaXN0ZXJJdGVtKGl0ZW0sIHBhcmVudCkge1xuICAgICAgICBjb25zdCBjdXJyZW50TG9va3VwID0ge1xuICAgICAgICAgICAgY2hpbGRyZW46IFtdLFxuICAgICAgICAgICAgaXRlbSxcbiAgICAgICAgICAgIHBhcmVudDogdGhpcy5pdGVtKG5vZGVJbmRleChwYXJlbnQpKVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLm1hcC5zZXQoaXRlbS5pbmRleCwgY3VycmVudExvb2t1cCk7XG4gICAgfVxuICAgIHJlZ2lzdGVyQ2hpbGRyZW4oaW5kZXgsIGNoaWxkcmVuKSB7XG4gICAgICAgIGNvbnN0IGl0ZW0gPSB0aGlzLml0ZW0oaW5kZXgpO1xuICAgICAgICBpZiAoIWl0ZW0pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpdGVtLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgfVxuICAgIHVucmVnaXN0ZXJJdGVtKGluZGV4LCBkYXRhSXRlbSkge1xuICAgICAgICBjb25zdCBjdXJyZW50ID0gdGhpcy5pdGVtKGluZGV4KTtcbiAgICAgICAgaWYgKGN1cnJlbnQgJiYgY3VycmVudC5pdGVtLmRhdGFJdGVtID09PSBkYXRhSXRlbSkge1xuICAgICAgICAgICAgdGhpcy5tYXAuZGVsZXRlKGluZGV4KTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50LnBhcmVudCAmJiBjdXJyZW50LnBhcmVudC5jaGlsZHJlbikge1xuICAgICAgICAgICAgICAgIGN1cnJlbnQucGFyZW50LmNoaWxkcmVuID0gY3VycmVudC5wYXJlbnQuY2hpbGRyZW4uZmlsdGVyKGl0ZW0gPT4gaXRlbS5kYXRhSXRlbSAhPT0gZGF0YUl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJlcGxhY2VJdGVtKGluZGV4LCBpdGVtLCBwYXJlbnQpIHtcbiAgICAgICAgaWYgKCFpdGVtKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51bnJlZ2lzdGVySXRlbShpbmRleCwgaXRlbS5kYXRhSXRlbSk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJJdGVtKGl0ZW0sIHBhcmVudCk7XG4gICAgICAgIHRoaXMuYWRkVG9QYXJlbnQoaXRlbSwgcGFyZW50KTtcbiAgICB9XG4gICAgaXRlbUxvb2t1cChpbmRleCkge1xuICAgICAgICBjb25zdCBpdGVtID0gdGhpcy5pdGVtKGluZGV4KTtcbiAgICAgICAgaWYgKCFpdGVtKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY2hpbGRyZW46IHRoaXMubWFwQ2hpbGRyZW4oaXRlbS5jaGlsZHJlbiksXG4gICAgICAgICAgICBpdGVtOiBpdGVtLml0ZW0sXG4gICAgICAgICAgICBwYXJlbnQ6IGl0ZW0ucGFyZW50XG4gICAgICAgIH07XG4gICAgfVxuICAgIGhhc0l0ZW0oaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWFwLmhhcyhpbmRleCk7XG4gICAgfVxuICAgIGl0ZW0oaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWFwLmdldChpbmRleCkgfHwgbnVsbDtcbiAgICB9XG4gICAgYWRkVG9QYXJlbnQoaXRlbSwgcGFyZW50KSB7XG4gICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudEl0ZW0gPSB0aGlzLml0ZW0ocGFyZW50LmluZGV4KTtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gcGFyc2VJbnQoSU5ERVhfUkVHRVguZXhlYyhpdGVtLmluZGV4KVswXSwgMTApO1xuICAgICAgICAgICAgcGFyZW50SXRlbS5jaGlsZHJlbiA9IHBhcmVudEl0ZW0uY2hpbGRyZW4gfHwgW107XG4gICAgICAgICAgICBwYXJlbnRJdGVtLmNoaWxkcmVuLnNwbGljZShpbmRleCwgMCwgaXRlbSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbWFwQ2hpbGRyZW4oY2hpbGRyZW4gPSBbXSkge1xuICAgICAgICByZXR1cm4gY2hpbGRyZW4ubWFwKGMgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBpdGVtLCBwYXJlbnQsIGNoaWxkcmVuIH0gPSB0aGlzLml0ZW0oYy5pbmRleCk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuOiB0aGlzLm1hcENoaWxkcmVuKGNoaWxkcmVuKSxcbiAgICAgICAgICAgICAgICBpdGVtLFxuICAgICAgICAgICAgICAgIHBhcmVudFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfVxufTtcblRyZWVWaWV3TG9va3VwU2VydmljZSA9IF9fZGVjb3JhdGUoW1xuICAgIEluamVjdGFibGUoKVxuXSwgVHJlZVZpZXdMb29rdXBTZXJ2aWNlKTtcblxuY29uc3QgTE9BRF9NT1JFX0RPQ19MSU5LID0gJ2h0dHA6Ly93d3cudGVsZXJpay5jb20va2VuZG8tYW5ndWxhci11aS9jb21wb25lbnRzL3RyZWV2aWV3L2xvYWQtbW9yZS1idXR0b24vJztcbmNvbnN0IHByb3ZpZGVycyA9IFtcbiAgICBFeHBhbmRTdGF0ZVNlcnZpY2UsXG4gICAgSW5kZXhCdWlsZGVyU2VydmljZSxcbiAgICBUcmVlVmlld0xvb2t1cFNlcnZpY2UsXG4gICAgTG9hZGluZ05vdGlmaWNhdGlvblNlcnZpY2UsXG4gICAgTm9kZUNoaWxkcmVuU2VydmljZSxcbiAgICBOYXZpZ2F0aW9uU2VydmljZSxcbiAgICBTZWxlY3Rpb25TZXJ2aWNlLFxuICAgIERhdGFDaGFuZ2VOb3RpZmljYXRpb25TZXJ2aWNlLFxuICAgIExvY2FsaXphdGlvblNlcnZpY2UsXG4gICAge1xuICAgICAgICBwcm92aWRlOiBMMTBOX1BSRUZJWCxcbiAgICAgICAgdXNlVmFsdWU6ICdrZW5kby50cmVldmlldydcbiAgICB9LFxuICAgIHtcbiAgICAgICAgcHJvdmlkZTogRGF0YUJvdW5kQ29tcG9uZW50LFxuICAgICAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBUcmVlVmlld0NvbXBvbmVudClcbiAgICB9LFxuICAgIHtcbiAgICAgICAgcHJvdmlkZTogRXhwYW5kYWJsZUNvbXBvbmVudCxcbiAgICAgICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gVHJlZVZpZXdDb21wb25lbnQpXG4gICAgfVxuXTtcbi8qIHRzbGludDpkaXNhYmxlOm1lbWJlci1vcmRlcmluZyAqL1xuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBbS2VuZG8gVUkgVHJlZVZpZXcgY29tcG9uZW50IGZvciBBbmd1bGFyXSh7JSBzbHVnIG92ZXJ2aWV3X3RyZWV2aWV3ICV9KS5cbiAqXG4gKiBAZXhhbXBsZVxuICogeyUgbWV0YSBoZWlnaHQ6MzUwICV9XG4gKiB7JSBlbWJlZF9maWxlIGJhc2ljLXVzYWdlL2FwcC5jb21wb25lbnQudHMgcHJldmlldyAlfVxuICogeyUgZW1iZWRfZmlsZSBiYXNpYy11c2FnZS9hcHAubW9kdWxlLnRzICV9XG4gKiB7JSBlbmRtZXRhICV9XG4gKi9cbmxldCBUcmVlVmlld0NvbXBvbmVudCA9IGNsYXNzIFRyZWVWaWV3Q29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50LCBjaGFuZ2VEZXRlY3RvclJlZiwgZXhwYW5kU2VydmljZSwgbmF2aWdhdGlvblNlcnZpY2UsIG5vZGVDaGlsZHJlblNlcnZpY2UsIHNlbGVjdGlvblNlcnZpY2UsIHRyZWVWaWV3TG9va3VwU2VydmljZSwgbmdab25lLCByZW5kZXJlciwgZGF0YUNoYW5nZU5vdGlmaWNhdGlvbiwgbG9jYWxpemF0aW9uKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICAgIHRoaXMuY2hhbmdlRGV0ZWN0b3JSZWYgPSBjaGFuZ2VEZXRlY3RvclJlZjtcbiAgICAgICAgdGhpcy5leHBhbmRTZXJ2aWNlID0gZXhwYW5kU2VydmljZTtcbiAgICAgICAgdGhpcy5uYXZpZ2F0aW9uU2VydmljZSA9IG5hdmlnYXRpb25TZXJ2aWNlO1xuICAgICAgICB0aGlzLm5vZGVDaGlsZHJlblNlcnZpY2UgPSBub2RlQ2hpbGRyZW5TZXJ2aWNlO1xuICAgICAgICB0aGlzLnNlbGVjdGlvblNlcnZpY2UgPSBzZWxlY3Rpb25TZXJ2aWNlO1xuICAgICAgICB0aGlzLnRyZWVWaWV3TG9va3VwU2VydmljZSA9IHRyZWVWaWV3TG9va3VwU2VydmljZTtcbiAgICAgICAgdGhpcy5uZ1pvbmUgPSBuZ1pvbmU7XG4gICAgICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgICAgICAgdGhpcy5kYXRhQ2hhbmdlTm90aWZpY2F0aW9uID0gZGF0YUNoYW5nZU5vdGlmaWNhdGlvbjtcbiAgICAgICAgdGhpcy5sb2NhbGl6YXRpb24gPSBsb2NhbGl6YXRpb247XG4gICAgICAgIHRoaXMuY2xhc3NOYW1lcyA9IHRydWU7XG4gICAgICAgIHRoaXMucm9sZSA9ICd0cmVlJztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBoaW50IHdoaWNoIGlzIGRpc3BsYXllZCB3aGVuIHRoZSBjb21wb25lbnQgaXMgZW1wdHkuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmZpbHRlcklucHV0UGxhY2Vob2xkZXIgPSBcIlwiO1xuICAgICAgICAvKiogQGhpZGRlbiAqL1xuICAgICAgICB0aGlzLmZldGNoTm9kZXMgPSAoKSA9PiB0aGlzLmRhdGE7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyB3aGVuIHRoZSBjaGlsZHJlbiBvZiB0aGUgZXhwYW5kZWQgbm9kZSBhcmUgbG9hZGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jaGlsZHJlbkxvYWRlZCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIHdoZW4gdGhlIHVzZXIgYmx1cnMgdGhlIGNvbXBvbmVudC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub25CbHVyID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgd2hlbiB0aGUgdXNlciBmb2N1c2VzIHRoZSBjb21wb25lbnQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9uRm9jdXMgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyB3aGVuIHRoZSB1c2VyIGV4cGFuZHMgYSBUcmVlVmlldyBub2RlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5leHBhbmQgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyB3aGVuIHRoZSB1c2VyIGNvbGxhcHNlcyBhIFRyZWVWaWV3IG5vZGUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNvbGxhcHNlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMganVzdCBiZWZvcmUgdGhlIGRyYWdnaW5nIG9mIHRoZSBub2RlIHN0YXJ0cyAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGRyYWdhbmRkcm9wX3RyZWV2aWV3ICV9I3RvYy1zZXR1cCkpLiBUaGlzIGV2ZW50IGlzIHByZXZlbnRhYmxlLlxuICAgICAgICAgKiBJZiB5b3UgcHJldmVudCB0aGUgZXZlbnQgZGVmYXVsdCwgbm8gZHJhZyBoaW50IHdpbGwgYmUgY3JlYXRlZCBhbmQgdGhlIHN1YnNlcXVlbnQgZHJhZy1yZWxhdGVkIGV2ZW50cyB3aWxsIG5vdCBiZSBmaXJlZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubm9kZURyYWdTdGFydCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIHdoZW4gYW4gaXRlbSBpcyBiZWluZyBkcmFnZ2VkIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgZHJhZ2FuZGRyb3BfdHJlZXZpZXcgJX0jdG9jLXNldHVwKSkuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm5vZGVEcmFnID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogRW1pdHMgd2hlbiB0aGUgYnVpbHQtaW4gZmlsdGVyaW5nIG1lY2hhbmlzbSBpbiB0aGUgZGF0YS1iaW5kaW5nIGRpcmVjdGl2ZXMgdXBkYXRlcyB0aGUgbm9kZSdzIHZpc2liaWxpdHkuXG4gICAgICAgICAqIFVzZWQgZm9yIHRoZSBidWlsdC1pbiBhdXRvLWV4cGFuZCBmdW5jdGlvbmFsaXRpZXMgb2YgdGhlIGNvbXBvbmVudCBhbmQgYXZhaWxhYmxlIGZvciBjdXN0b20gaW1wbGVtZW50YXRpb25zLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5maWx0ZXJTdGF0ZUNoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIG9uIHRoZSB0YXJnZXQgVHJlZVZpZXcgd2hlbiBhIGRyYWdnZWQgaXRlbSBpcyBkcm9wcGVkIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgZHJhZ2FuZGRyb3BfdHJlZXZpZXcgJX0jdG9jLXNldHVwKSkuXG4gICAgICAgICAqIFRoaXMgZXZlbnQgaXMgcHJldmVudGFibGUuIElmIHlvdSBwcmV2ZW50IHRoZSBldmVudCBkZWZhdWx0IChgZXZlbnQucHJldmVudERlZnVhbHQoKWApIG9yIGludmFsaWRhdGUgaXRzIHN0YXRlIChgZXZlbnQuc2V0VmFsaWQoZmFsc2UpYCksXG4gICAgICAgICAqIHRoZSBgYWRkSXRlbWAgYW5kIGByZW1vdmVJdGVtYCBldmVudHMgd2lsbCBub3QgYmUgdHJpZ2dlcmVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBCb3RoIG9wZXJhdGlvbnMgY2FuY2VsIHRoZSBkZWZhdWx0IGRyb3Agb3BlcmF0aW9uLCBidXQgdGhlIGluZGljYXRpb24gdG8gdGhlIHVzZXIgaXMgZGlmZmVyZW50LiBgZXZlbnQuc2V0VmFsaWQoZmFsc2UpYCBpbmRpY2F0ZXMgdGhhdCB0aGUgb3BlcmF0aW9uIHdhc1xuICAgICAgICAgKiB1bnN1Y2Nlc3NmdWwgYnkgYW5pbWF0aW5nIHRoZSBkcmFnIGNsdWUgdG8gaXRzIG9yaWdpbmFsIHBvc2l0aW9uLiBgZXZlbnQucHJldmVudERlZmF1bHQoKWAgc2ltcGx5IHJlbW92ZXMgdGhlIGNsdWUsIGFzIGlmIGl0IGhhcyBiZWVuIGRyb3BwZWQgc3VjY2Vzc2Z1bGx5LlxuICAgICAgICAgKiBBcyBhIGdlbmVyYWwgcnVsZSwgdXNlIGBwcmV2ZW50RGVmYXVsdGAgdG8gbWFudWFsbHkgaGFuZGxlIHRoZSBhZGQgYW5kIHJlbW92ZSBvcGVyYXRpb25zLCBhbmQgYHNldFZhbGlkKGZhbHNlKWAgdG8gaW5kaWNhdGUgdGhlIG9wZXJhdGlvbiB3YXMgdW5zdWNjZXNzZnVsLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5ub2RlRHJvcCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIG9uIHRoZSBzb3VyY2UgVHJlZVZpZXcgYWZ0ZXIgdGhlIGRyYWdnZWQgaXRlbSBoYXMgYmVlbiBkcm9wcGVkIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgZHJhZ2FuZGRyb3BfdHJlZXZpZXcgJX0jdG9jLXNldHVwKSkuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm5vZGVEcmFnRW5kID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgYWZ0ZXIgYSBkcmFnZ2VkIGl0ZW0gaXMgZHJvcHBlZCAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGRyYWdhbmRkcm9wX3RyZWV2aWV3ICV9I3RvYy1zZXR1cCkpLlxuICAgICAgICAgKiBDYWxsZWQgb24gdGhlIFRyZWVWaWV3IHdoZXJlIHRoZSBpdGVtIGlzIGRyb3BwZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmFkZEl0ZW0gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyBhZnRlciBhIGRyYWdnZWQgaXRlbSBpcyBkcm9wcGVkIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgZHJhZ2FuZGRyb3BfdHJlZXZpZXcgJX0jdG9jLXNldHVwKSkuXG4gICAgICAgICAqIENhbGxlZCBvbiB0aGUgVHJlZVZpZXcgZnJvbSB3aGVyZSB0aGUgaXRlbSBpcyBkcmFnZ2VkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZW1vdmVJdGVtID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgd2hlbiB0aGUgdXNlciBzZWxlY3RzIGEgVHJlZVZpZXcgbm9kZSBjaGVja2JveFxuICAgICAgICAgKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGNoZWNrYm94ZXNfdHJlZXZpZXcgJX0jdG9jLW1vZGlmeWluZy10aGUtY2hlY2tlZC1zdGF0ZSkpLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jaGVja2VkQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgd2hlbiB0aGUgdXNlciBzZWxlY3RzIGEgVHJlZVZpZXcgbm9kZVxuICAgICAgICAgKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIHNlbGVjdGlvbl90cmVldmlldyAlfSN0b2MtbW9kaWZ5aW5nLXRoZS1zZWxlY3Rpb24pKS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2VsZWN0aW9uQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgd2hlbiB0aGUgdmFsdWUgb2YgdGhlIGJ1aWx0LWluIGZpbHRlciBpbnB1dCBlbGVtZW50IGNoYW5nZXMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmZpbHRlckNoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIHdoZW4gdGhlIHVzZXIgY2xpY2tzIGEgVHJlZVZpZXcgbm9kZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubm9kZUNsaWNrID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgd2hlbiB0aGUgdXNlciBkb3VibGUgY2xpY2tzIGEgVHJlZVZpZXcgbm9kZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubm9kZURibENsaWNrID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBmdW5jdGlvbiB0aGF0IGRlZmluZXMgaG93IHRvIHRyYWNrIG5vZGUgY2hhbmdlcy5cbiAgICAgICAgICogQnkgZGVmYXVsdCwgdGhlIFRyZWVWaWV3IHRyYWNrcyB0aGUgbm9kZXMgYnkgZGF0YSBpdGVtIG9iamVjdCByZWZlcmVuY2UuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIGBgYHRzXG4gICAgICAgICAqICBAQ29tcG9uZW50KHtcbiAgICAgICAgICogICAgICBzZWxlY3RvcjogJ215LWFwcCcsXG4gICAgICAgICAqICAgICAgdGVtcGxhdGU6IGBcbiAgICAgICAgICogICAgICAgICAgPGtlbmRvLXRyZWV2aWV3XG4gICAgICAgICAqICAgICAgICAgICAgICBbbm9kZXNdPVwiZGF0YVwiXG4gICAgICAgICAqICAgICAgICAgICAgICB0ZXh0RmllbGQ9XCJ0ZXh0XCJcbiAgICAgICAgICogICAgICAgICAgICAgIFt0cmFja0J5XT1cInRyYWNrQnlcIlxuICAgICAgICAgKiAgICAgICAgICA+XG4gICAgICAgICAqICAgICAgICAgIDwva2VuZG8tdHJlZXZpZXc+XG4gICAgICAgICAqICAgICAgYFxuICAgICAgICAgKiAgfSlcbiAgICAgICAgICogIGV4cG9ydCBjbGFzcyBBcHBDb21wb25lbnQge1xuICAgICAgICAgKiAgICAgIHB1YmxpYyBkYXRhOiBhbnlbXSA9IFtcbiAgICAgICAgICogICAgICAgICAgeyB0ZXh0OiBcIkZ1cm5pdHVyZVwiIH0sXG4gICAgICAgICAqICAgICAgICAgIHsgdGV4dDogXCJEZWNvclwiIH1cbiAgICAgICAgICogICAgICBdO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIHB1YmxpYyB0cmFja0J5KGluZGV4OiBudW1iZXIsIGl0ZW06IGFueSk6IGFueSB7XG4gICAgICAgICAqICAgICAgICAgIHJldHVybiBpdGVtLnRleHQ7XG4gICAgICAgICAqICAgICAgfVxuICAgICAgICAgKiAgfVxuICAgICAgICAgKiBgYGBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudHJhY2tCeSA9IHRyYWNrQnk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGZ1bmN0aW9uIHdoaWNoIGRldGVybWluZXMgaWYgYSBzcGVjaWZpYyBub2RlIGlzIGRpc2FibGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pc0Rpc2FibGVkID0gaXNEaXNhYmxlZDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgY2FsbGJhY2sgd2hpY2ggZGV0ZXJtaW5lcyB3aGV0aGVyIGEgVHJlZVZpZXcgbm9kZSBzaG91bGQgYmUgcmVuZGVyZWQgYXMgaGlkZGVuLiBUaGUgdXRpbGl0eSAuay1kaXNwbGF5LW5vbmUgY2xhc3MgaXMgdXNlZCB0byBoaWRlIHRoZSBub2Rlcy5cbiAgICAgICAgICogVXNlZnVsIGZvciBjdXN0b20gZmlsdGVyaW5nIGltcGxlbWVudGF0aW9ucy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaXNWaXNpYmxlID0gaXNWaXNpYmxlO1xuICAgICAgICAvKipcbiAgICAgICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBUcmVlVmlldyBrZXlib2FyZCBuYXZpZ2FibGUgaXMgZW5hYmxlZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubmF2aWdhYmxlID0gdHJ1ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgZnVuY3Rpb24gd2hpY2ggcHJvdmlkZXMgdGhlIGNoaWxkIG5vZGVzIGZvciBhIGdpdmVuIHBhcmVudCBub2RlXG4gICAgICAgICAqIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgZGF0YWJpbmRpbmdfdHJlZXZpZXcgJX0pKS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSAoKSA9PiBvZihbXSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgY2hpbGQgbm9kZXMgd2lsbCBiZSBmZXRjaGVkIG9uIG5vZGUgZXhwYW5kIG9yIHdpbGwgYmUgaW5pdGlhbGx5IHByZWZldGNoZWQuXG4gICAgICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubG9hZE9uRGVtYW5kID0gdHJ1ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbmRlcnMgdGhlIGJ1aWx0LWluIGlucHV0IGVsZW1lbnQgZm9yIGZpbHRlcmluZyB0aGUgVHJlZVZpZXcuXG4gICAgICAgICAqIElmIHNldCB0byBgdHJ1ZWAsIHRoZSBjb21wb25lbnQgZW1pdHMgdGhlIGBmaWx0ZXJDaGFuZ2VgIGV2ZW50LCB3aGljaCBjYW4gYmUgdXNlZCB0byBbZmlsdGVyIHRoZSBUcmVlVmlldyBtYW51YWxseV0oeyUgc2x1ZyBmaWx0ZXJpbmdfdHJlZXZpZXcgJX0jdG9jLW1hbnVhbC1maWx0ZXJpbmcpLlxuICAgICAgICAgKiBBIGJ1aWx0LWluIGZpbHRlcmluZyBpbXBsZW1lbnRhdGlvbiBpcyBhdmFpbGFibGUgdG8gdXNlIHdpdGggdGhlIFtga2VuZG9UcmVlVmlld0hpZXJhcmNoeUJpbmRpbmdgXSh7JSBzbHVnIGFwaV90cmVldmlld19oaWVyYXJjaHliaW5kaW5nZGlyZWN0aXZlICV9KSBhbmQgW2BrZW5kb1RyZWVWaWV3RmxhdERhdGFCaW5kaW5nYF0oeyUgc2x1ZyBhcGlfdHJlZXZpZXdfZmxhdGRhdGFiaW5kaW5nZGlyZWN0aXZlICV9KSBkaXJlY3RpdmVzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5maWx0ZXJhYmxlID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXRzIGFuIGluaXRpYWwgdmFsdWUgb2YgdGhlIGJ1aWx0LWluIGlucHV0IGVsZW1lbnQgdXNlZCBmb3IgZmlsdGVyaW5nLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5maWx0ZXIgPSAnJztcbiAgICAgICAgdGhpcy5jaGVja2JveGVzID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZXhwYW5kSWNvbnMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zZWxlY3RhYmxlID0gZmFsc2U7XG4gICAgICAgIHRoaXMudG91Y2hBY3Rpb25zID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5pc0FjdGl2ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRhdGEgPSBuZXcgQmVoYXZpb3JTdWJqZWN0KFtdKTtcbiAgICAgICAgdGhpcy5fYW5pbWF0ZSA9IHRydWU7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucyA9IG5ldyBTdWJzY3JpcHRpb24oKTtcbiAgICAgICAgdGhpcy5kb21TdWJzY3JpcHRpb25zID0gW107XG4gICAgICAgIHZhbGlkYXRlUGFja2FnZShwYWNrYWdlTWV0YWRhdGEpO1xuICAgIH1cbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIGdldCBkaXJlY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsaXphdGlvbi5ydGwgPyAncnRsJyA6ICdsdHInO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGNvbnRlbnQgYW5pbWF0aW9uIGlzIGVuYWJsZWQuXG4gICAgICovXG4gICAgc2V0IGFuaW1hdGUodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fYW5pbWF0ZSA9IHZhbHVlO1xuICAgIH1cbiAgICBnZXQgYW5pbWF0ZSgpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLl9hbmltYXRlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgc2V0IG5vZGVUZW1wbGF0ZVJlZih0ZW1wbGF0ZSkge1xuICAgICAgICB0aGlzLm5vZGVUZW1wbGF0ZSA9IHRlbXBsYXRlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgc2V0IGxvYWRNb3JlQnV0dG9uVGVtcGxhdGVSZWYodGVtcGxhdGUpIHtcbiAgICAgICAgdGhpcy5sb2FkTW9yZUJ1dHRvblRlbXBsYXRlID0gdGVtcGxhdGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBub2RlcyB3aGljaCB3aWxsIGJlIGRpc3BsYXllZCBieSB0aGUgVHJlZVZpZXdcbiAgICAgKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGRhdGFiaW5kaW5nX3RyZWV2aWV3ICV9KSkuXG4gICAgICovXG4gICAgc2V0IG5vZGVzKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuZGF0YS5uZXh0KHZhbHVlIHx8IFtdKTtcbiAgICAgICAgdGhpcy5kYXRhQ2hhbmdlTm90aWZpY2F0aW9uLm5vdGlmeSgpO1xuICAgIH1cbiAgICBnZXQgbm9kZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGEudmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgZnVuY3Rpb24gd2hpY2ggZGV0ZXJtaW5lcyBpZiBhIHNwZWNpZmljIG5vZGUgaGFzIGNoaWxkIG5vZGVzXG4gICAgICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBkYXRhYmluZGluZ190cmVldmlldyAlfSkpLlxuICAgICAqL1xuICAgIGdldCBoYXNDaGlsZHJlbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hhc0NoaWxkcmVuIHx8IGhhc0NoaWxkcmVuO1xuICAgIH1cbiAgICBzZXQgaGFzQ2hpbGRyZW4oY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5faGFzQ2hpbGRyZW4gPSBjYWxsYmFjaztcbiAgICAgICAgdGhpcy5leHBhbmRJY29ucyA9IEJvb2xlYW4odGhpcy5faXNFeHBhbmRlZCAmJiB0aGlzLl9oYXNDaGlsZHJlbik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgZnVuY3Rpb24gd2hpY2ggZGV0ZXJtaW5lcyBpZiBhIHNwZWNpZmljIG5vZGUgaXMgY2hlY2tlZFxuICAgICAqIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgY2hlY2tib3hlc190cmVldmlldyAlfSN0b2MtbW9kaWZ5aW5nLXRoZS1jaGVja2VkLXN0YXRlKSkuXG4gICAgICovXG4gICAgZ2V0IGlzQ2hlY2tlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzQ2hlY2tlZCB8fCBpc0NoZWNrZWQ7XG4gICAgfVxuICAgIHNldCBpc0NoZWNrZWQoY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5faXNDaGVja2VkID0gY2FsbGJhY2s7XG4gICAgICAgIHRoaXMuY2hlY2tib3hlcyA9IEJvb2xlYW4odGhpcy5faXNDaGVja2VkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBmdW5jdGlvbiB3aGljaCBkZXRlcm1pbmVzIGlmIGEgc3BlY2lmaWMgbm9kZSBpcyBleHBhbmRlZC5cbiAgICAgKi9cbiAgICBnZXQgaXNFeHBhbmRlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzRXhwYW5kZWQgfHwgaXNFeHBhbmRlZDtcbiAgICB9XG4gICAgc2V0IGlzRXhwYW5kZWQoY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5faXNFeHBhbmRlZCA9IGNhbGxiYWNrO1xuICAgICAgICB0aGlzLmV4cGFuZEljb25zID0gQm9vbGVhbih0aGlzLl9pc0V4cGFuZGVkICYmIHRoaXMuX2hhc0NoaWxkcmVuKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBmdW5jdGlvbiB3aGljaCBkZXRlcm1pbmVzIGlmIGEgc3BlY2lmaWMgbm9kZSBpcyBzZWxlY3RlZFxuICAgICAqIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgc2VsZWN0aW9uX3RyZWV2aWV3ICV9I3RvYy1tb2RpZnlpbmctdGhlLXNlbGVjdGlvbikpLlxuICAgICAqL1xuICAgIGdldCBpc1NlbGVjdGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNTZWxlY3RlZCB8fCBpc1NlbGVjdGVkO1xuICAgIH1cbiAgICBzZXQgaXNTZWxlY3RlZChjYWxsYmFjaykge1xuICAgICAgICB0aGlzLl9pc1NlbGVjdGVkID0gY2FsbGJhY2s7XG4gICAgICAgIHRoaXMuc2VsZWN0YWJsZSA9IEJvb2xlYW4odGhpcy5faXNTZWxlY3RlZCk7XG4gICAgfVxuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXMpIHtcbiAgICAgICAgdGhpcy5uYXZpZ2F0aW9uU2VydmljZS5uYXZpZ2FibGUgPSBCb29sZWFuKHRoaXMubmF2aWdhYmxlKTtcbiAgICAgICAgLy8gVE9ETzogc2hvdWxkIHJlYWN0IHRvIGNoYW5nZXMubG9hZE9uRGVtYW5kIGFzIHdlbGwgLSBzaG91bGQgcHJlbG9hZCB0aGUgZGF0YSBvciBjbGVhciB0aGUgYWxyZWFkeSBjYWNoZWQgaXRlbXNcbiAgICAgICAgaWYgKGFueUNoYW5nZWQoWydub2RlcycsICdjaGlsZHJlbicsICdoYXNDaGlsZHJlbicsICdsb2FkT25EZW1hbmQnXSwgY2hhbmdlcywgZmFsc2UpICYmICF0aGlzLmxvYWRPbkRlbWFuZCkge1xuICAgICAgICAgICAgdGhpcy5wcmVsb2FkQ2hpbGROb2RlcygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgdGhpcy5kb21TdWJzY3JpcHRpb25zLmZvckVhY2goc3Vic2NyaXB0aW9uID0+IHN1YnNjcmlwdGlvbigpKTtcbiAgICB9XG4gICAgbmdPbkluaXQoKSB7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5hZGQodGhpcy5ub2RlQ2hpbGRyZW5TZXJ2aWNlXG4gICAgICAgICAgICAuY2hhbmdlc1xuICAgICAgICAgICAgLnN1YnNjcmliZSgoeCkgPT4gdGhpcy5jaGlsZHJlbkxvYWRlZC5lbWl0KHgpKSk7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5hZGQodGhpcy5leHBhbmRTZXJ2aWNlLmNoYW5nZXNcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoKHsgaW5kZXgsIGRhdGFJdGVtLCBleHBhbmQgfSkgPT4gZXhwYW5kXG4gICAgICAgICAgICA/IHRoaXMuZXhwYW5kLmVtaXQoeyBpbmRleCwgZGF0YUl0ZW0gfSlcbiAgICAgICAgICAgIDogdGhpcy5jb2xsYXBzZS5lbWl0KHsgaW5kZXgsIGRhdGFJdGVtIH0pKSk7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5hZGQodGhpcy5uYXZpZ2F0aW9uU2VydmljZS5jaGVja3NcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoKHgpID0+IHRoaXMuY2hlY2tlZENoYW5nZS5lbWl0KHRoaXMudHJlZVZpZXdMb29rdXBTZXJ2aWNlLml0ZW1Mb29rdXAoeCkpKSk7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5hZGQodGhpcy5zZWxlY3Rpb25TZXJ2aWNlLmNoYW5nZXNcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoKHgpID0+IHtcbiAgICAgICAgICAgIGlmIChoYXNPYnNlcnZlcnModGhpcy5zZWxlY3Rpb25DaGFuZ2UpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5uZ1pvbmUucnVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25DaGFuZ2UuZW1pdCh4KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgICAgICBpZiAodGhpcy5lbGVtZW50KSB7XG4gICAgICAgICAgICB0aGlzLm5nWm9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5hdHRhY2hEb21IYW5kbGVycygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQmx1cnMgdGhlIGZvY3VzZWQgVHJlZVZpZXcgaXRlbS5cbiAgICAgKi9cbiAgICBibHVyKCkge1xuICAgICAgICBpZiAoIWlzRG9jdW1lbnRBdmFpbGFibGUoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IGZvY3VzYWJsZU5vZGUodGhpcy5lbGVtZW50KTtcbiAgICAgICAgaWYgKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IHRhcmdldCkge1xuICAgICAgICAgICAgdGFyZ2V0LmJsdXIoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBGb2N1c2VzIHRoZSBmaXJzdCBmb2N1c2FibGUgaXRlbSBpbiB0aGUgVHJlZVZpZXcgY29tcG9uZW50IGlmIG5vIGhpZXJhcmNoaWNhbCBpbmRleCBpcyBwcm92aWRlZC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiBpbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbiAgICAgKlxuICAgICAqICBAQ29tcG9uZW50KHtcbiAgICAgKiAgICAgIHNlbGVjdG9yOiAnbXktYXBwJyxcbiAgICAgKiAgICAgIHRlbXBsYXRlOiBgXG4gICAgICogICAgICA8YnV0dG9uIChjbGljayk9XCJ0cmVldmlldy5mb2N1cygnMScpXCI+Rm9jdXNlcyB0aGUgc2Vjb25kIG5vZGU8L2J1dHRvbj5cbiAgICAgKiAgICAgIDxrZW5kby10cmVldmlld1xuICAgICAqICAgICAgICAgICN0cmVldmlld1xuICAgICAqICAgICAgICAgIFtub2Rlc109XCJkYXRhXCJcbiAgICAgKiAgICAgICAgICB0ZXh0RmllbGQ9XCJ0ZXh0XCJcbiAgICAgKiAgICAgID5cbiAgICAgKiAgICAgIDwva2VuZG8tdHJlZXZpZXc+XG4gICAgICogIGBcbiAgICAgKiAgfSlcbiAgICAgKiAgZXhwb3J0IGNsYXNzIEFwcENvbXBvbmVudCB7XG4gICAgICogICAgICBwdWJsaWMgZGF0YTogYW55W10gPSBbXG4gICAgICogICAgICAgICAgeyB0ZXh0OiBcIkZ1cm5pdHVyZVwiIH0sXG4gICAgICogICAgICAgICAgeyB0ZXh0OiBcIkRlY29yXCIgfVxuICAgICAqICAgICAgXTtcbiAgICAgKiAgfVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGZvY3VzKGluZGV4KSB7XG4gICAgICAgIGNvbnN0IGZvY3VzSW5kZXggPSBpbmRleCB8fCBub2RlSW5kZXgodGhpcy5uYXZpZ2F0aW9uU2VydmljZS5mb2N1c2FibGVJdGVtKTtcbiAgICAgICAgdGhpcy5uYXZpZ2F0aW9uU2VydmljZS5hY3RpdmF0ZUluZGV4KGZvY3VzSW5kZXgpO1xuICAgICAgICBjb25zdCB0YXJnZXQgPSBmb2N1c2FibGVOb2RlKHRoaXMuZWxlbWVudCk7XG4gICAgICAgIGlmICh0YXJnZXQpIHtcbiAgICAgICAgICAgIHRhcmdldC5mb2N1cygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJhc2VkIG9uIHRoZSBzcGVjaWZpZWQgaW5kZXgsIHJldHVybnMgdGhlIFRyZWVJdGVtTG9va3VwIG5vZGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaW5kZXggLSBUaGUgaW5kZXggb2YgdGhlIG5vZGUuXG4gICAgICogQHJldHVybnMge1RyZWVJdGVtTG9va3VwfSAtIFRoZSBpdGVtIHRoYXQgd2FzIHNlYXJjaGVkIChsb29rZWQgdXApLlxuICAgICAqL1xuICAgIGl0ZW1Mb29rdXAoaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZVZpZXdMb29rdXBTZXJ2aWNlLml0ZW1Mb29rdXAoaW5kZXgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VycyB0aGUgW2BjaGlsZHJlbmBdKHslIHNsdWcgYXBpX3RyZWV2aWV3X3RyZWV2aWV3Y29tcG9uZW50ICV9I3RvYy1jaGlsZHJlbikgZnVuY3Rpb24gZm9yIGV2ZXJ5IGV4cGFuZGVkIG5vZGUsXG4gICAgICogY2F1c2luZyBhbGwgcmVuZGVyZWQgY2hpbGQgbm9kZXMgdG8gYmUgZmV0Y2hlZCBhZ2Fpbi5cbiAgICAgKi9cbiAgICByZWJpbmRDaGlsZHJlbigpIHtcbiAgICAgICAgdGhpcy5kYXRhQ2hhbmdlTm90aWZpY2F0aW9uLm5vdGlmeSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VycyB0aGUgYGV4cGFuZGAgZXZlbnQgZm9yIHRoZSBwcm92aWRlZCBub2RlIGFuZCBkaXNwbGF5cyBpdCdzIGxvYWRpbmcgaW5kaWNhdG9yLlxuICAgICAqL1xuICAgIGV4cGFuZE5vZGUoaXRlbSwgaW5kZXgpIHtcbiAgICAgICAgdGhpcy5leHBhbmRTZXJ2aWNlLmV4cGFuZChpbmRleCwgaXRlbSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJzIHRoZSBgY29sbGFwc2VgIGV2ZW50IGZvciB0aGUgcHJvdmlkZWQgbm9kZS5cbiAgICAgKi9cbiAgICBjb2xsYXBzZU5vZGUoaXRlbSwgaW5kZXgpIHtcbiAgICAgICAgdGhpcy5leHBhbmRTZXJ2aWNlLmNvbGxhcHNlKGluZGV4LCBpdGVtKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgY3VycmVudCBwYWdlIHNpemUgb2YgdGhlIGNoZWNrZWQgZGF0YSBpdGVtIGNoaWxkcmVuIGNvbGxlY3Rpb25cbiAgICAgKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGxvYWRtb3JlYnV0dG9uX3RyZWV2aWV3ICV9I3RvYy1tYW5hZ2luZy1wYWdlLXNpemVzKSkuXG4gICAgICpcbiAgICAgKiA+IFNpbmNlIHRoZSByb290IG5vZGVzIGNvbGxlY3Rpb24gaXMgbm90IGFzc29jaWF0ZWQgd2l0aCBhbnkgcGFyZW50IGRhdGEgaXRlbSwgcGFzcyBgbnVsbGAgYXMgYGRhdGFJdGVtYCBwYXJhbSB0byBnZXQgaXRzIHBhZ2Ugc2l6ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBkYXRhSXRlbSB7YW55fSAtIFRoZSBwYXJlbnQgZGF0YSBpdGVtIG9mIHRoZSB0YXJnZXRlZCBjb2xsZWN0aW9uLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IC0gVGhlIHBhZ2Ugc2l6ZSBvZiB0aGUgY2hlY2tlZCBkYXRhIGl0ZW0gY2hpbGRyZW4gY29sbGVjdGlvbi5cbiAgICAgKi9cbiAgICBnZXROb2RlUGFnZVNpemUoZGF0YUl0ZW0pIHtcbiAgICAgICAgdGhpcy52ZXJpZnlMb2FkTW9yZVNlcnZpY2UoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9hZE1vcmVTZXJ2aWNlLmdldEdyb3VwU2l6ZShkYXRhSXRlbSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHBhZ2Ugc2l6ZSBvZiB0aGUgdGFyZ2V0ZWQgZGF0YSBpdGVtIGNoaWxkcmVuIGNvbGxlY3Rpb25cbiAgICAgKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGxvYWRtb3JlYnV0dG9uX3RyZWV2aWV3ICV9I3RvYy1tYW5hZ2luZy1wYWdlLXNpemVzKSkuXG4gICAgICpcbiAgICAgKiA+IFNpbmNlIHRoZSByb290IG5vZGVzIGNvbGxlY3Rpb24gaXMgbm90IGFzc29jaWF0ZWQgd2l0aCBhbnkgcGFyZW50IGRhdGEgaXRlbSwgcGFzcyBgbnVsbGAgYXMgYGRhdGFJdGVtYCBwYXJhbSB0byB0YXJnZXQgaXRzIHBhZ2Ugc2l6ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBkYXRhSXRlbSB7YW55fSAtIFRoZSBwYXJlbnQgZGF0YSBpdGVtIG9mIHRoZSB0YXJnZXRlZCBjb2xsZWN0aW9uLlxuICAgICAqIEBwYXJhbSBwYWdlU2l6ZSB7bnVtYmVyfSAtIFRoZSBuZXcgcGFnZSBzaXplLlxuICAgICAqL1xuICAgIHNldE5vZGVQYWdlU2l6ZShkYXRhSXRlbSwgcGFnZVNpemUpIHtcbiAgICAgICAgdGhpcy52ZXJpZnlMb2FkTW9yZVNlcnZpY2UoKTtcbiAgICAgICAgdGhpcy5sb2FkTW9yZVNlcnZpY2Uuc2V0R3JvdXBTaXplKGRhdGFJdGVtLCBwYWdlU2l6ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKlxuICAgICAqIENsZWFycyB0aGUgY3VycmVudCBUcmVlVmlld0xvb2t1cFNlcnZpY2Ugbm9kZSBtYXAgYW5kIHJlLXJlZ2lzdGVycyBhbGwgbm9kZXMgYW5ldy5cbiAgICAgKiBDaGlsZCBub2RlcyBhcmUgYWNxdWlyZWQgdGhyb3VnaCB0aGUgcHJvdmlkZWQgYGNoaWxkcmVuYCBjYWxsYmFjay5cbiAgICAgKi9cbiAgICBwcmVsb2FkQ2hpbGROb2RlcygpIHtcbiAgICAgICAgdGhpcy50cmVlVmlld0xvb2t1cFNlcnZpY2UucmVzZXQoKTtcbiAgICAgICAgdGhpcy5yZWdpc3Rlckxvb2t1cEl0ZW1zKHRoaXMubm9kZXMpO1xuICAgIH1cbiAgICBhdHRhY2hEb21IYW5kbGVycygpIHtcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50O1xuICAgICAgICB0aGlzLmNsaWNrSGFuZGxlciA9IHRoaXMuY2xpY2tIYW5kbGVyLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuZG9tU3Vic2NyaXB0aW9ucy5wdXNoKHRoaXMucmVuZGVyZXIubGlzdGVuKGVsZW1lbnQsICdjb250ZXh0bWVudScsIHRoaXMuY2xpY2tIYW5kbGVyKSwgdGhpcy5yZW5kZXJlci5saXN0ZW4oZWxlbWVudCwgJ2NsaWNrJywgdGhpcy5jbGlja0hhbmRsZXIpLCB0aGlzLnJlbmRlcmVyLmxpc3RlbihlbGVtZW50LCAnZGJsY2xpY2snLCB0aGlzLmNsaWNrSGFuZGxlciksIHRoaXMucmVuZGVyZXIubGlzdGVuKGVsZW1lbnQsICdmb2N1c2luJywgdGhpcy5mb2N1c0hhbmRsZXIuYmluZCh0aGlzKSksIHRoaXMucmVuZGVyZXIubGlzdGVuKGVsZW1lbnQsICdmb2N1c291dCcsIHRoaXMuYmx1ckhhbmRsZXIuYmluZCh0aGlzKSksIHRoaXMucmVuZGVyZXIubGlzdGVuKGVsZW1lbnQsICdrZXlkb3duJywgdGhpcy5rZXlkb3duSGFuZGxlci5iaW5kKHRoaXMpKSk7XG4gICAgfVxuICAgIGZvY3VzSGFuZGxlcihlKSB7XG4gICAgICAgIGxldCBmb2N1c0l0ZW07XG4gICAgICAgIGlmIChtYXRjaChlLnRhcmdldCwgJy5rLXRyZWV2aWV3LWl0ZW0nKSkge1xuICAgICAgICAgICAgZm9jdXNJdGVtID0gZS50YXJnZXQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWlzRm9jdXNhYmxlKGUudGFyZ2V0KSkgeyAvLyB3aXRoIGNvbXBsaW1lbnRzIHRvIElFXG4gICAgICAgICAgICBmb2N1c0l0ZW0gPSBjbG9zZXN0Tm9kZShlLnRhcmdldCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZvY3VzSXRlbSkge1xuICAgICAgICAgICAgdGhpcy5uYXZpZ2F0aW9uU2VydmljZS5hY3RpdmF0ZUluZGV4KG5vZGVJZChlLnRhcmdldCkpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmlzQWN0aXZlICYmIGhhc09ic2VydmVycyh0aGlzLm9uRm9jdXMpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5uZ1pvbmUucnVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbkZvY3VzLmVtaXQoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaXNBY3RpdmUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGJsdXJIYW5kbGVyKGUpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNBY3RpdmUgJiYgbWF0Y2goZS50YXJnZXQsICcuay10cmVldmlldy1pdGVtJykgJiZcbiAgICAgICAgICAgICghZS5yZWxhdGVkVGFyZ2V0IHx8ICFtYXRjaChlLnJlbGF0ZWRUYXJnZXQsICcuay10cmVldmlldy1pdGVtJykgfHwgIWhhc1BhcmVudChlLnJlbGF0ZWRUYXJnZXQsIHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50KSkpIHtcbiAgICAgICAgICAgIHRoaXMubmF2aWdhdGlvblNlcnZpY2UuZGVhY3RpdmF0ZSgpO1xuICAgICAgICAgICAgdGhpcy5pc0FjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKGhhc09ic2VydmVycyh0aGlzLm9uQmx1cikpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5nWm9uZS5ydW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uQmx1ci5lbWl0KCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2xpY2tIYW5kbGVyKGUpIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gZS50YXJnZXQ7XG4gICAgICAgIGlmICgoZS50eXBlID09PSAnY29udGV4dG1lbnUnICYmICFoYXNPYnNlcnZlcnModGhpcy5ub2RlQ2xpY2spKSB8fFxuICAgICAgICAgICAgKGUudHlwZSA9PT0gJ2NsaWNrJyAmJiAhaGFzT2JzZXJ2ZXJzKHRoaXMubm9kZUNsaWNrKSAmJiAhaGFzT2JzZXJ2ZXJzKHRoaXMuc2VsZWN0aW9uQ2hhbmdlKSAmJiAhaXNMb2FkTW9yZUJ1dHRvbih0YXJnZXQpKSB8fFxuICAgICAgICAgICAgKGUudHlwZSA9PT0gJ2RibGNsaWNrJyAmJiAhaGFzT2JzZXJ2ZXJzKHRoaXMubm9kZURibENsaWNrKSkgfHwgaXNGb2N1c2FibGUodGFyZ2V0KSB8fFxuICAgICAgICAgICAgKCFpc0NvbnRlbnQodGFyZ2V0KSAmJiAhaXNMb2FkTW9yZUJ1dHRvbih0YXJnZXQpKSB8fCAhaGFzUGFyZW50KHRhcmdldCwgdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaW5kZXggPSBub2RlSWQoY2xvc2VzdE5vZGUodGFyZ2V0KSk7XG4gICAgICAgIC8vIHRoZSBkaXNhYmxlZCBjaGVjayBpcyBwcm9iYWJseSBub3QgbmVlZGVkIGR1ZSB0byB0aGUgay1zdGF0ZS1kaXNhYmxlZCBzdHlsZXNcbiAgICAgICAgaWYgKCFpbmRleCB8fCB0aGlzLm5hdmlnYXRpb25TZXJ2aWNlLmlzRGlzYWJsZWQoaW5kZXgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5uZ1pvbmUucnVuKCgpID0+IHtcbiAgICAgICAgICAgIC8vIHJlY29yZCB0aGlzIHZhbHVlIGJlZm9yZSBlbWl0dGluZyBzZWxlY3Rpb25DaGFuZ2UgKGB0aGlzLm5hdmlnYXRpb25TZXJ2aWNlLnNlbGVjdEluZGV4YCksIGFzIHRoZSB0cmVldmlldyBzdGF0ZSBtYXkgYmUgY2hhbmdlZCBvbiBpdHMgZW1pc3Npb25cbiAgICAgICAgICAgIGNvbnN0IGxvb2t1cCA9IHRoaXMudHJlZVZpZXdMb29rdXBTZXJ2aWNlLml0ZW1Mb29rdXAoaW5kZXgpO1xuICAgICAgICAgICAgaWYgKGUudHlwZSA9PT0gJ2NsaWNrJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvYWRNb3JlQnV0dG9uID0gdGhpcy5uYXZpZ2F0aW9uU2VydmljZS5tb2RlbC5maW5kTm9kZShpbmRleCkubG9hZE1vcmVCdXR0b247XG4gICAgICAgICAgICAgICAgaWYgKGxvYWRNb3JlQnV0dG9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubmF2aWdhdGlvblNlcnZpY2Uubm90aWZ5TG9hZE1vcmUoaW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm5hdmlnYXRpb25TZXJ2aWNlLnNlbGVjdEluZGV4KGluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBlbWl0dGVyID0gZS50eXBlID09PSAnZGJsY2xpY2snID8gdGhpcy5ub2RlRGJsQ2xpY2sgOiB0aGlzLm5vZGVDbGljaztcbiAgICAgICAgICAgIGVtaXR0ZXIuZW1pdCh7XG4gICAgICAgICAgICAgICAgaXRlbTogbG9va3VwLml0ZW0sXG4gICAgICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZSxcbiAgICAgICAgICAgICAgICB0eXBlOiBlLnR5cGVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAga2V5ZG93bkhhbmRsZXIoZSkge1xuICAgICAgICBpZiAodGhpcy5pc0FjdGl2ZSAmJiB0aGlzLm5hdmlnYWJsZSkge1xuICAgICAgICAgICAgdGhpcy5uZ1pvbmUucnVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLm5hdmlnYXRpb25TZXJ2aWNlLm1vdmUoZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2ZXJpZnlMb2FkTW9yZVNlcnZpY2UoKSB7XG4gICAgICAgIGlmIChpc0Rldk1vZGUoKSAmJiAhaXNQcmVzZW50KHRoaXMubG9hZE1vcmVTZXJ2aWNlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUbyB1c2UgdGhlIFRyZWVWaWV3IHBhZ2luZyBmdW5jdGlvbmFsaXR5LCB5b3UgbmVlZCB0byBhc3NpZ24gdGhlIFxcYGtlbmRvVHJlZVZpZXdMb2FkTW9yZVxcYCBkaXJlY3RpdmUuIFNlZSAke0xPQURfTU9SRV9ET0NfTElOS30uYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVnaXN0ZXJMb29rdXBJdGVtcyhkYXRhLCBwYXJlbnRJdGVtID0gbnVsbCkge1xuICAgICAgICBpZiAoIWlzUHJlc2VudChkYXRhKSB8fCBkYXRhLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcmVudEluZGV4ID0gbm9kZUluZGV4KHBhcmVudEl0ZW0pO1xuICAgICAgICBjb25zdCB0cmVlSXRlbXMgPSBkYXRhLm1hcCgobm9kZSwgaW5kZXgpID0+IGJ1aWxkVHJlZUl0ZW0obm9kZSwgaW5kZXgsIHBhcmVudEluZGV4KSk7XG4gICAgICAgIGlmIChpc1ByZXNlbnQocGFyZW50SXRlbSkpIHtcbiAgICAgICAgICAgIHRoaXMudHJlZVZpZXdMb29rdXBTZXJ2aWNlLnJlZ2lzdGVyQ2hpbGRyZW4ocGFyZW50SW5kZXgsIHRyZWVJdGVtcyk7XG4gICAgICAgIH1cbiAgICAgICAgdHJlZUl0ZW1zLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgICB0aGlzLnRyZWVWaWV3TG9va3VwU2VydmljZS5yZWdpc3Rlckl0ZW0oaXRlbSwgcGFyZW50SXRlbSk7XG4gICAgICAgICAgICBpZiAodGhpcy5oYXNDaGlsZHJlbihpdGVtLmRhdGFJdGVtKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2hpbGRyZW4oaXRlbS5kYXRhSXRlbSlcbiAgICAgICAgICAgICAgICAgICAgLnN1YnNjcmliZShjaGlsZHJlbiA9PiB0aGlzLnJlZ2lzdGVyTG9va3VwSXRlbXMoY2hpbGRyZW4sIGl0ZW0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RCaW5kaW5nKFwiY2xhc3Muay13aWRnZXRcIiksXG4gICAgSG9zdEJpbmRpbmcoXCJjbGFzcy5rLXRyZWV2aWV3XCIpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgVHJlZVZpZXdDb21wb25lbnQucHJvdG90eXBlLCBcImNsYXNzTmFtZXNcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RCaW5kaW5nKFwiYXR0ci5yb2xlXCIpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBUcmVlVmlld0NvbXBvbmVudC5wcm90b3R5cGUsIFwicm9sZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSG9zdEJpbmRpbmcoXCJhdHRyLmRpclwiKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBUcmVlVmlld0NvbXBvbmVudC5wcm90b3R5cGUsIFwiZGlyZWN0aW9uXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgVmlld0NoaWxkKCdhc3NldHNDb250YWluZXInLCB7IHJlYWQ6IFZpZXdDb250YWluZXJSZWYsIHN0YXRpYzogdHJ1ZSB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgVmlld0NvbnRhaW5lclJlZilcbl0sIFRyZWVWaWV3Q29tcG9uZW50LnByb3RvdHlwZSwgXCJhc3NldHNDb250YWluZXJcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFRyZWVWaWV3Q29tcG9uZW50LnByb3RvdHlwZSwgXCJmaWx0ZXJJbnB1dFBsYWNlaG9sZGVyXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIEhvc3RCaW5kaW5nKCdALmRpc2FibGVkJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQm9vbGVhbl0pXG5dLCBUcmVlVmlld0NvbXBvbmVudC5wcm90b3R5cGUsIFwiYW5pbWF0ZVwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIE91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXG5dLCBUcmVlVmlld0NvbXBvbmVudC5wcm90b3R5cGUsIFwiY2hpbGRyZW5Mb2FkZWRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIE91dHB1dCgnYmx1cicpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXG5dLCBUcmVlVmlld0NvbXBvbmVudC5wcm90b3R5cGUsIFwib25CbHVyXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBPdXRwdXQoJ2ZvY3VzJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbl0sIFRyZWVWaWV3Q29tcG9uZW50LnByb3RvdHlwZSwgXCJvbkZvY3VzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBPdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxuXSwgVHJlZVZpZXdDb21wb25lbnQucHJvdG90eXBlLCBcImV4cGFuZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbl0sIFRyZWVWaWV3Q29tcG9uZW50LnByb3RvdHlwZSwgXCJjb2xsYXBzZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbl0sIFRyZWVWaWV3Q29tcG9uZW50LnByb3RvdHlwZSwgXCJub2RlRHJhZ1N0YXJ0XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBPdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxuXSwgVHJlZVZpZXdDb21wb25lbnQucHJvdG90eXBlLCBcIm5vZGVEcmFnXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBPdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxuXSwgVHJlZVZpZXdDb21wb25lbnQucHJvdG90eXBlLCBcImZpbHRlclN0YXRlQ2hhbmdlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBPdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxuXSwgVHJlZVZpZXdDb21wb25lbnQucHJvdG90eXBlLCBcIm5vZGVEcm9wXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBPdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxuXSwgVHJlZVZpZXdDb21wb25lbnQucHJvdG90eXBlLCBcIm5vZGVEcmFnRW5kXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBPdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxuXSwgVHJlZVZpZXdDb21wb25lbnQucHJvdG90eXBlLCBcImFkZEl0ZW1cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIE91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXG5dLCBUcmVlVmlld0NvbXBvbmVudC5wcm90b3R5cGUsIFwicmVtb3ZlSXRlbVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbl0sIFRyZWVWaWV3Q29tcG9uZW50LnByb3RvdHlwZSwgXCJjaGVja2VkQ2hhbmdlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBPdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxuXSwgVHJlZVZpZXdDb21wb25lbnQucHJvdG90eXBlLCBcInNlbGVjdGlvbkNoYW5nZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbl0sIFRyZWVWaWV3Q29tcG9uZW50LnByb3RvdHlwZSwgXCJmaWx0ZXJDaGFuZ2VcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIE91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXG5dLCBUcmVlVmlld0NvbXBvbmVudC5wcm90b3R5cGUsIFwibm9kZUNsaWNrXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBPdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxuXSwgVHJlZVZpZXdDb21wb25lbnQucHJvdG90eXBlLCBcIm5vZGVEYmxDbGlja1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgQ29udGVudENoaWxkKE5vZGVUZW1wbGF0ZURpcmVjdGl2ZSwgeyBzdGF0aWM6IHRydWUgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE5vZGVUZW1wbGF0ZURpcmVjdGl2ZSlcbl0sIFRyZWVWaWV3Q29tcG9uZW50LnByb3RvdHlwZSwgXCJub2RlVGVtcGxhdGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCdub2RlVGVtcGxhdGUnKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTm9kZVRlbXBsYXRlRGlyZWN0aXZlKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW05vZGVUZW1wbGF0ZURpcmVjdGl2ZV0pXG5dLCBUcmVlVmlld0NvbXBvbmVudC5wcm90b3R5cGUsIFwibm9kZVRlbXBsYXRlUmVmXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgQ29udGVudENoaWxkKExvYWRNb3JlQnV0dG9uVGVtcGxhdGVEaXJlY3RpdmUsIHsgc3RhdGljOiB0cnVlIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBMb2FkTW9yZUJ1dHRvblRlbXBsYXRlRGlyZWN0aXZlKVxuXSwgVHJlZVZpZXdDb21wb25lbnQucHJvdG90eXBlLCBcImxvYWRNb3JlQnV0dG9uVGVtcGxhdGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCdsb2FkTW9yZUJ1dHRvblRlbXBsYXRlJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIExvYWRNb3JlQnV0dG9uVGVtcGxhdGVEaXJlY3RpdmUpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbTG9hZE1vcmVCdXR0b25UZW1wbGF0ZURpcmVjdGl2ZV0pXG5dLCBUcmVlVmlld0NvbXBvbmVudC5wcm90b3R5cGUsIFwibG9hZE1vcmVCdXR0b25UZW1wbGF0ZVJlZlwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKVxuXSwgVHJlZVZpZXdDb21wb25lbnQucHJvdG90eXBlLCBcInRyYWNrQnlcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEFycmF5KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0FycmF5XSlcbl0sIFRyZWVWaWV3Q29tcG9uZW50LnByb3RvdHlwZSwgXCJub2Rlc1wiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFRyZWVWaWV3Q29tcG9uZW50LnByb3RvdHlwZSwgXCJ0ZXh0RmllbGRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0Z1bmN0aW9uXSlcbl0sIFRyZWVWaWV3Q29tcG9uZW50LnByb3RvdHlwZSwgXCJoYXNDaGlsZHJlblwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0Z1bmN0aW9uXSlcbl0sIFRyZWVWaWV3Q29tcG9uZW50LnByb3RvdHlwZSwgXCJpc0NoZWNrZWRcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbilcbl0sIFRyZWVWaWV3Q29tcG9uZW50LnByb3RvdHlwZSwgXCJpc0Rpc2FibGVkXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtGdW5jdGlvbl0pXG5dLCBUcmVlVmlld0NvbXBvbmVudC5wcm90b3R5cGUsIFwiaXNFeHBhbmRlZFwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0Z1bmN0aW9uXSlcbl0sIFRyZWVWaWV3Q29tcG9uZW50LnByb3RvdHlwZSwgXCJpc1NlbGVjdGVkXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pXG5dLCBUcmVlVmlld0NvbXBvbmVudC5wcm90b3R5cGUsIFwiaXNWaXNpYmxlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgVHJlZVZpZXdDb21wb25lbnQucHJvdG90eXBlLCBcIm5hdmlnYWJsZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pXG5dLCBUcmVlVmlld0NvbXBvbmVudC5wcm90b3R5cGUsIFwiY2hpbGRyZW5cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBUcmVlVmlld0NvbXBvbmVudC5wcm90b3R5cGUsIFwibG9hZE9uRGVtYW5kXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgVHJlZVZpZXdDb21wb25lbnQucHJvdG90eXBlLCBcImZpbHRlcmFibGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFRyZWVWaWV3Q29tcG9uZW50LnByb3RvdHlwZSwgXCJmaWx0ZXJcIiwgdm9pZCAwKTtcblRyZWVWaWV3Q29tcG9uZW50ID0gX19kZWNvcmF0ZShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5EZWZhdWx0LFxuICAgICAgICBleHBvcnRBczogJ2tlbmRvVHJlZVZpZXcnLFxuICAgICAgICBwcm92aWRlcnM6IHByb3ZpZGVycyxcbiAgICAgICAgc2VsZWN0b3I6ICdrZW5kby10cmVldmlldycsXG4gICAgICAgIHRlbXBsYXRlOiBgXG4gICAgICAgIDxrZW5kby10ZXh0Ym94XG4gICAgICAgICAgICAjZmlsdGVySW5wdXRcbiAgICAgICAgICAgICpuZ0lmPVwiZmlsdGVyYWJsZVwiXG4gICAgICAgICAgICBbdmFsdWVdPVwiZmlsdGVyXCJcbiAgICAgICAgICAgIFtjbGVhckJ1dHRvbl09XCJ0cnVlXCJcbiAgICAgICAgICAgICh2YWx1ZUNoYW5nZSk9XCJmaWx0ZXJDaGFuZ2UuZW1pdCgkZXZlbnQpXCJcbiAgICAgICAgICAgIFtwbGFjZWhvbGRlcl09XCJmaWx0ZXJJbnB1dFBsYWNlaG9sZGVyXCJcbiAgICAgICAgPlxuICAgICAgICAgICAgPG5nLXRlbXBsYXRlIGtlbmRvVGV4dEJveFByZWZpeFRlbXBsYXRlPlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiay1pY29uIGstaS1zZWFyY2hcIj48L3NwYW4+XG4gICAgICAgICAgICA8L25nLXRlbXBsYXRlPlxuICAgICAgICA8L2tlbmRvLXRleHRib3g+XG4gICAgICAgIDx1bCBjbGFzcz1cImstdHJlZXZpZXctbGluZXNcIlxuICAgICAgICAgICAga2VuZG9UcmVlVmlld0dyb3VwXG4gICAgICAgICAgICByb2xlPVwiZ3JvdXBcIlxuICAgICAgICAgICAgW2xvYWRPbkRlbWFuZF09XCJsb2FkT25EZW1hbmRcIlxuICAgICAgICAgICAgW2NoZWNrYm94ZXNdPVwiY2hlY2tib3hlc1wiXG4gICAgICAgICAgICBbZXhwYW5kSWNvbnNdPVwiZXhwYW5kSWNvbnNcIlxuICAgICAgICAgICAgW3NlbGVjdGFibGVdPVwic2VsZWN0YWJsZVwiXG4gICAgICAgICAgICBbdG91Y2hBY3Rpb25zXT1cInRvdWNoQWN0aW9uc1wiXG4gICAgICAgICAgICBbY2hpbGRyZW5dPVwiY2hpbGRyZW5cIlxuICAgICAgICAgICAgW2hhc0NoaWxkcmVuXT1cImhhc0NoaWxkcmVuXCJcbiAgICAgICAgICAgIFtpc0NoZWNrZWRdPVwiaXNDaGVja2VkXCJcbiAgICAgICAgICAgIFtpc0Rpc2FibGVkXT1cImlzRGlzYWJsZWRcIlxuICAgICAgICAgICAgW2lzRXhwYW5kZWRdPVwiaXNFeHBhbmRlZFwiXG4gICAgICAgICAgICBbaXNTZWxlY3RlZF09XCJpc1NlbGVjdGVkXCJcbiAgICAgICAgICAgIFtpc1Zpc2libGVdPVwiaXNWaXNpYmxlXCJcbiAgICAgICAgICAgIFtub2RlVGVtcGxhdGVSZWZdPVwibm9kZVRlbXBsYXRlPy50ZW1wbGF0ZVJlZlwiXG4gICAgICAgICAgICBbbG9hZE1vcmVCdXR0b25UZW1wbGF0ZVJlZl09XCJsb2FkTW9yZUJ1dHRvblRlbXBsYXRlPy50ZW1wbGF0ZVJlZlwiXG4gICAgICAgICAgICBbdGV4dEZpZWxkXT1cInRleHRGaWVsZFwiXG4gICAgICAgICAgICBbbm9kZXNdPVwiZmV0Y2hOb2Rlc1wiXG4gICAgICAgICAgICBbbG9hZE1vcmVTZXJ2aWNlXT1cImxvYWRNb3JlU2VydmljZVwiXG4gICAgICAgICAgICBbdHJhY2tCeV09XCJ0cmFja0J5XCJcbiAgICAgICAgPlxuICAgICAgICA8L3VsPlxuICAgICAgICA8bmctY29udGFpbmVyICNhc3NldHNDb250YWluZXI+PC9uZy1jb250YWluZXI+XG4gICAgYFxuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbRWxlbWVudFJlZixcbiAgICAgICAgQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gICAgICAgIEV4cGFuZFN0YXRlU2VydmljZSxcbiAgICAgICAgTmF2aWdhdGlvblNlcnZpY2UsXG4gICAgICAgIE5vZGVDaGlsZHJlblNlcnZpY2UsXG4gICAgICAgIFNlbGVjdGlvblNlcnZpY2UsXG4gICAgICAgIFRyZWVWaWV3TG9va3VwU2VydmljZSxcbiAgICAgICAgTmdab25lLFxuICAgICAgICBSZW5kZXJlcjIsXG4gICAgICAgIERhdGFDaGFuZ2VOb3RpZmljYXRpb25TZXJ2aWNlLFxuICAgICAgICBMb2NhbGl6YXRpb25TZXJ2aWNlXSlcbl0sIFRyZWVWaWV3Q29tcG9uZW50KTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmxldCBUcmVlVmlld0dyb3VwQ29tcG9uZW50ID0gY2xhc3MgVHJlZVZpZXdHcm91cENvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoZXhwYW5kU2VydmljZSwgbG9hZGluZ1NlcnZpY2UsIGluZGV4QnVpbGRlciwgdHJlZVZpZXdMb29rdXBTZXJ2aWNlLCBuYXZpZ2F0aW9uU2VydmljZSwgbm9kZUNoaWxkcmVuU2VydmljZSwgZGF0YUNoYW5nZU5vdGlmaWNhdGlvbiwgY2hhbmdlRGV0ZWN0b3JSZWYpIHtcbiAgICAgICAgdGhpcy5leHBhbmRTZXJ2aWNlID0gZXhwYW5kU2VydmljZTtcbiAgICAgICAgdGhpcy5sb2FkaW5nU2VydmljZSA9IGxvYWRpbmdTZXJ2aWNlO1xuICAgICAgICB0aGlzLmluZGV4QnVpbGRlciA9IGluZGV4QnVpbGRlcjtcbiAgICAgICAgdGhpcy50cmVlVmlld0xvb2t1cFNlcnZpY2UgPSB0cmVlVmlld0xvb2t1cFNlcnZpY2U7XG4gICAgICAgIHRoaXMubmF2aWdhdGlvblNlcnZpY2UgPSBuYXZpZ2F0aW9uU2VydmljZTtcbiAgICAgICAgdGhpcy5ub2RlQ2hpbGRyZW5TZXJ2aWNlID0gbm9kZUNoaWxkcmVuU2VydmljZTtcbiAgICAgICAgdGhpcy5kYXRhQ2hhbmdlTm90aWZpY2F0aW9uID0gZGF0YUNoYW5nZU5vdGlmaWNhdGlvbjtcbiAgICAgICAgdGhpcy5jaGFuZ2VEZXRlY3RvclJlZiA9IGNoYW5nZURldGVjdG9yUmVmO1xuICAgICAgICB0aGlzLmtHcm91cENsYXNzID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5yb2xlID0gJ2dyb3VwJztcbiAgICAgICAgdGhpcy5sb2FkT25EZW1hbmQgPSB0cnVlO1xuICAgICAgICB0aGlzLnRleHRGaWVsZCA9IFwiXCI7XG4gICAgICAgIHRoaXMuaW5pdGlhbE5vZGVzTG9hZGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMubG9hZGluZ01vcmVOb2RlcyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9kYXRhID0gW107XG4gICAgICAgIHRoaXMuc2luZ2xlUmVjb3JkU3Vic2NyaXB0aW9ucyA9IG5ldyBTdWJzY3JpcHRpb24oKTtcbiAgICAgICAgdGhpcy5pc0NoZWNrZWQgPSAoKSA9PiAnbm9uZSc7XG4gICAgICAgIHRoaXMuaXNEaXNhYmxlZCA9ICgpID0+IGZhbHNlO1xuICAgICAgICB0aGlzLmlzRXhwYW5kZWQgPSAoKSA9PiBmYWxzZTtcbiAgICAgICAgdGhpcy5pc1Zpc2libGUgPSAoKSA9PiB0cnVlO1xuICAgICAgICB0aGlzLmlzU2VsZWN0ZWQgPSAoKSA9PiBmYWxzZTtcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9ICgpID0+IG9mKFtdKTtcbiAgICAgICAgdGhpcy5oYXNDaGlsZHJlbiA9ICgpID0+IGZhbHNlO1xuICAgIH1cbiAgICBnZXQgbW9yZU5vZGVzQXZhaWxhYmxlKCkge1xuICAgICAgICBpZiAoIWlzUHJlc2VudCh0aGlzLmxvYWRNb3JlU2VydmljZSkgfHwgdGhpcy5kYXRhLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnBhZ2VTaXplIDwgdGhpcy50b3RhbE5vZGVzQ291bnQ7XG4gICAgfVxuICAgIGdldCBwYWdlU2l6ZSgpIHtcbiAgICAgICAgaWYgKCFpc1ByZXNlbnQodGhpcy5sb2FkTW9yZVNlcnZpY2UpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5sb2FkTW9yZVNlcnZpY2UuZ2V0R3JvdXBTaXplKHRoaXMucGFyZW50RGF0YUl0ZW0pO1xuICAgIH1cbiAgICBzZXQgcGFnZVNpemUocGFnZVNpemUpIHtcbiAgICAgICAgdGhpcy5sb2FkTW9yZVNlcnZpY2Uuc2V0R3JvdXBTaXplKHRoaXMucGFyZW50RGF0YUl0ZW0sIHBhZ2VTaXplKTtcbiAgICB9XG4gICAgZ2V0IGRhdGEoKSB7XG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5wYWdlU2l6ZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRTaXplVmFsdWUgPSB0aGlzLnBhZ2VTaXplID4gMCA/IHRoaXMucGFnZVNpemUgOiAwO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGEuc2xpY2UoMCwgbm9ybWFsaXplZFNpemVWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGE7XG4gICAgfVxuICAgIHNldCBkYXRhKGRhdGEpIHtcbiAgICAgICAgdGhpcy5fZGF0YSA9IGRhdGE7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJMb2FkZWROb2Rlcyh0aGlzLmRhdGEpO1xuICAgIH1cbiAgICBnZXQgbG9hZE1vcmVCdXR0b25JbmRleCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmxvYWRNb3JlU2VydmljZSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZUluZGV4KHRoaXMuZGF0YS5sZW5ndGgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXByZXNlbnRzIHRoZSB0b3RhbCBudW1iZXIgb2Ygbm9kZXMgZm9yIHRoZSBjdXJyZW50IGxldmVsLlxuICAgICAqL1xuICAgIGdldCB0b3RhbE5vZGVzQ291bnQoKSB7XG4gICAgICAgIGlmICghdGhpcy5sb2FkTW9yZVNlcnZpY2UpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGEubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmxvYWRNb3JlU2VydmljZS5nZXRUb3RhbE5vZGVzQ291bnQodGhpcy5wYXJlbnREYXRhSXRlbSwgdGhpcy5fZGF0YS5sZW5ndGgpO1xuICAgIH1cbiAgICBnZXQgaGFzVGVtcGxhdGUoKSB7XG4gICAgICAgIHJldHVybiBpc1ByZXNlbnQodGhpcy5ub2RlVGVtcGxhdGVSZWYpO1xuICAgIH1cbiAgICBleHBhbmROb2RlKGluZGV4LCBkYXRhSXRlbSwgZXhwYW5kKSB7XG4gICAgICAgIGlmIChleHBhbmQpIHtcbiAgICAgICAgICAgIHRoaXMuZXhwYW5kU2VydmljZS5leHBhbmQoaW5kZXgsIGRhdGFJdGVtKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZXhwYW5kU2VydmljZS5jb2xsYXBzZShpbmRleCwgZGF0YUl0ZW0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNoZWNrTm9kZShpbmRleCkge1xuICAgICAgICB0aGlzLm5hdmlnYXRpb25TZXJ2aWNlLmNoZWNrSW5kZXgoaW5kZXgpO1xuICAgICAgICB0aGlzLm5hdmlnYXRpb25TZXJ2aWNlLmFjdGl2YXRlSW5kZXgoaW5kZXgpO1xuICAgIH1cbiAgICBub2RlSW5kZXgoaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5kZXhCdWlsZGVyLm5vZGVJbmRleChpbmRleC50b1N0cmluZygpLCB0aGlzLnBhcmVudEluZGV4KTtcbiAgICB9XG4gICAgbm9kZVRleHQoZGF0YUl0ZW0pIHtcbiAgICAgICAgY29uc3QgdGV4dEZpZWxkID0gaXNBcnJheSh0aGlzLnRleHRGaWVsZCkgPyB0aGlzLnRleHRGaWVsZFswXSA6IHRoaXMudGV4dEZpZWxkO1xuICAgICAgICByZXR1cm4gZ2V0dGVyKHRleHRGaWVsZCkoZGF0YUl0ZW0pO1xuICAgIH1cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLm5vZGVzU3Vic2NyaXB0aW9uKSkge1xuICAgICAgICAgICAgdGhpcy5ub2Rlc1N1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5sb2FkTW9yZU5vZGVzU3Vic2NyaXB0aW9uKSkge1xuICAgICAgICAgICAgdGhpcy5sb2FkTW9yZU5vZGVzU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zaW5nbGVSZWNvcmRTdWJzY3JpcHRpb25zLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxuICAgIG5nT25Jbml0KCkge1xuICAgICAgICB0aGlzLnN1YnNjcmliZVRvTm9kZXNDaGFuZ2UoKTtcbiAgICAgICAgdGhpcy5zaW5nbGVSZWNvcmRTdWJzY3JpcHRpb25zLmFkZCh0aGlzLmRhdGFDaGFuZ2VOb3RpZmljYXRpb25cbiAgICAgICAgICAgIC5jaGFuZ2VzXG4gICAgICAgICAgICAuc3Vic2NyaWJlKHRoaXMuc3Vic2NyaWJlVG9Ob2Rlc0NoYW5nZS5iaW5kKHRoaXMpKSk7XG4gICAgICAgIHRoaXMuc2luZ2xlUmVjb3JkU3Vic2NyaXB0aW9ucy5hZGQodGhpcy5uYXZpZ2F0aW9uU2VydmljZS5sb2FkTW9yZVxuICAgICAgICAgICAgLnBpcGUoZmlsdGVyKGluZGV4ID0+IGluZGV4ID09PSB0aGlzLmxvYWRNb3JlQnV0dG9uSW5kZXgpKVxuICAgICAgICAgICAgLnN1YnNjcmliZSh0aGlzLmxvYWRNb3JlTm9kZXMuYmluZCh0aGlzKSkpO1xuICAgIH1cbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzKSB7XG4gICAgICAgIGlmIChjaGFuZ2VzLnBhcmVudEluZGV4ICYmIHRoaXMubG9hZE9uRGVtYW5kKSB7XG4gICAgICAgICAgICB0aGlzLnNldE5vZGVDaGlsZHJlbih0aGlzLm1hcFRvVHJlZUl0ZW0odGhpcy5kYXRhKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZmV0Y2hDaGlsZHJlbihub2RlLCBpbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGlsZHJlbihub2RlKVxuICAgICAgICAgICAgLnBpcGUoY2F0Y2hFcnJvcigoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmxvYWRpbmdTZXJ2aWNlLm5vdGlmeUxvYWRlZChpbmRleCk7XG4gICAgICAgICAgICByZXR1cm4gRU1QVFk7XG4gICAgICAgIH0pLCB0YXAoKCkgPT4gdGhpcy5sb2FkaW5nU2VydmljZS5ub3RpZnlMb2FkZWQoaW5kZXgpKSk7XG4gICAgfVxuICAgIGdldCBuZXh0RmllbGRzKCkge1xuICAgICAgICBpZiAoaXNBcnJheSh0aGlzLnRleHRGaWVsZCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRleHRGaWVsZC5sZW5ndGggPiAxID8gdGhpcy50ZXh0RmllbGQuc2xpY2UoMSkgOiB0aGlzLnRleHRGaWVsZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW3RoaXMudGV4dEZpZWxkXTtcbiAgICB9XG4gICAgbG9hZE1vcmVOb2RlcygpIHtcbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLmxvYWRNb3JlU2VydmljZS5sb2FkTW9yZU5vZGVzKSkge1xuICAgICAgICAgICAgdGhpcy5mZXRjaE1vcmVOb2RlcygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5sb2FkTW9yZUxvY2FsTm9kZXMoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsb2FkTW9yZUxvY2FsTm9kZXMoKSB7XG4gICAgICAgIGNvbnN0IGluaXRpYWxMb2FkTW9yZUJ1dHRvbkluZGV4ID0gdGhpcy5sb2FkTW9yZUJ1dHRvbkluZGV4O1xuICAgICAgICB0aGlzLnBhZ2VTaXplICs9IHRoaXMubG9hZE1vcmVTZXJ2aWNlLmdldEluaXRpYWxQYWdlU2l6ZSh0aGlzLnBhcmVudERhdGFJdGVtKTtcbiAgICAgICAgdGhpcy5yZWdpc3RlckxvYWRlZE5vZGVzKHRoaXMuZGF0YSk7XG4gICAgICAgIC8vIGZvcmNlcyB0aGUgbmV3IGl0ZW1zIHRvIGJlIHJlZ2lzdGVyZWQgYmVmb3JlIHRoZSBmb2N1cyBpcyBjaGFuZ2VkXG4gICAgICAgIHRoaXMuY2hhbmdlRGV0ZWN0b3JSZWYuZGV0ZWN0Q2hhbmdlcygpO1xuICAgICAgICB0aGlzLnJlc2VsZWN0SXRlbUF0KGluaXRpYWxMb2FkTW9yZUJ1dHRvbkluZGV4KTtcbiAgICB9XG4gICAgZmV0Y2hNb3JlTm9kZXMoKSB7XG4gICAgICAgIGlmICh0aGlzLmxvYWRpbmdNb3JlTm9kZXMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxvYWRpbmdNb3JlTm9kZXMgPSB0cnVlO1xuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMubG9hZE1vcmVOb2Rlc1N1YnNjcmlwdGlvbikpIHtcbiAgICAgICAgICAgIHRoaXMubG9hZE1vcmVOb2Rlc1N1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubG9hZE1vcmVOb2Rlc1N1YnNjcmlwdGlvbiA9IHRoaXMubG9hZE1vcmVTZXJ2aWNlXG4gICAgICAgICAgICAubG9hZE1vcmVOb2Rlcyh7XG4gICAgICAgICAgICBkYXRhSXRlbTogdGhpcy5wYXJlbnREYXRhSXRlbSxcbiAgICAgICAgICAgIHNraXA6IHRoaXMuZGF0YS5sZW5ndGgsXG4gICAgICAgICAgICB0YWtlOiB0aGlzLmxvYWRNb3JlU2VydmljZS5nZXRJbml0aWFsUGFnZVNpemUodGhpcy5wYXJlbnREYXRhSXRlbSlcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5waXBlKGZpbmFsaXplKCgpID0+IHRoaXMubG9hZGluZ01vcmVOb2RlcyA9IGZhbHNlKSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoaXRlbXMgPT4ge1xuICAgICAgICAgICAgaWYgKCEoQXJyYXkuaXNBcnJheShpdGVtcykgJiYgaXRlbXMubGVuZ3RoID4gMCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBpbml0aWFsTG9hZE1vcmVCdXR0b25JbmRleCA9IHRoaXMubG9hZE1vcmVCdXR0b25JbmRleDtcbiAgICAgICAgICAgIHRoaXMucGFnZVNpemUgKz0gaXRlbXMubGVuZ3RoO1xuICAgICAgICAgICAgdGhpcy5kYXRhID0gdGhpcy5kYXRhLmNvbmNhdChpdGVtcyk7XG4gICAgICAgICAgICBpZiAodGhpcy5uYXZpZ2F0aW9uU2VydmljZS5pc0FjdGl2ZShpbml0aWFsTG9hZE1vcmVCdXR0b25JbmRleCkpIHtcbiAgICAgICAgICAgICAgICAvLyBmb3JjZXMgdGhlIG5ldyBpdGVtcyB0byBiZSByZWdpc3RlcmVkIGJlZm9yZSB0aGUgZm9jdXMgaXMgY2hhbmdlZFxuICAgICAgICAgICAgICAgIHRoaXMuY2hhbmdlRGV0ZWN0b3JSZWYuZGV0ZWN0Q2hhbmdlcygpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVzZWxlY3RJdGVtQXQoaW5pdGlhbExvYWRNb3JlQnV0dG9uSW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc2V0Tm9kZUNoaWxkcmVuKGNoaWxkcmVuKSB7XG4gICAgICAgIHRoaXMudHJlZVZpZXdMb29rdXBTZXJ2aWNlLnJlZ2lzdGVyQ2hpbGRyZW4odGhpcy5wYXJlbnRJbmRleCwgY2hpbGRyZW4pO1xuICAgIH1cbiAgICBtYXBUb1RyZWVJdGVtKGRhdGEpIHtcbiAgICAgICAgaWYgKCF0aGlzLnBhcmVudEluZGV4KSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGEubWFwKChkYXRhSXRlbSwgaWR4KSA9PiAoeyBkYXRhSXRlbSwgaW5kZXg6IHRoaXMubm9kZUluZGV4KGlkeCkgfSkpO1xuICAgIH1cbiAgICBlbWl0Q2hpbGRyZW5Mb2FkZWQoY2hpbGRyZW4pIHtcbiAgICAgICAgaWYgKCF0aGlzLnBhcmVudEluZGV4KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWdub3JlcyB0aGUgcmVnaXN0ZXJlZCBsb2FkLW1vcmUgYnV0dG9uXG4gICAgICAgIGNvbnN0IGNvbnRlbnRDaGlsZHJlbiA9IGNoaWxkcmVuLmZpbHRlcihpdGVtID0+IGl0ZW0uZGF0YUl0ZW0pO1xuICAgICAgICB0aGlzLm5vZGVDaGlsZHJlblNlcnZpY2UuY2hpbGRyZW5Mb2FkZWQoeyBkYXRhSXRlbTogdGhpcy5wYXJlbnREYXRhSXRlbSwgaW5kZXg6IHRoaXMucGFyZW50SW5kZXggfSwgY29udGVudENoaWxkcmVuKTtcbiAgICB9XG4gICAgc3Vic2NyaWJlVG9Ob2Rlc0NoYW5nZSgpIHtcbiAgICAgICAgaWYgKHRoaXMubm9kZXNTdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMubm9kZXNTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5vZGVzU3Vic2NyaXB0aW9uID0gdGhpcy5ub2Rlcyh0aGlzLnBhcmVudERhdGFJdGVtLCB0aGlzLnBhcmVudEluZGV4KVxuICAgICAgICAgICAgLnN1YnNjcmliZShkYXRhID0+IHtcbiAgICAgICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgICAgICAgICB0aGlzLmluaXRpYWxOb2Rlc0xvYWRlZCA9IHRydWU7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXNlbGVjdEl0ZW1BdChpbmRleCkge1xuICAgICAgICBpZiAoIWlzUHJlc2VudChpbmRleCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBtYWtlIHN1cmUgdGhlIG9sZCBpbmRleCBpcyBjbGVhcmVkIGZpcnN0XG4gICAgICAgIHRoaXMubmF2aWdhdGlvblNlcnZpY2UuZGVhY3RpdmF0ZSgpO1xuICAgICAgICB0aGlzLm5hdmlnYXRpb25TZXJ2aWNlLmFjdGl2YXRlSW5kZXgoaW5kZXgpO1xuICAgIH1cbiAgICByZWdpc3RlckxvYWRlZE5vZGVzKG5vZGVzID0gW10pIHtcbiAgICAgICAgY29uc3QgbWFwcGVkQ2hpbGRyZW4gPSB0aGlzLm1hcFRvVHJlZUl0ZW0obm9kZXMpO1xuICAgICAgICBpZiAodGhpcy5sb2FkT25EZW1hbmQpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0Tm9kZUNoaWxkcmVuKG1hcHBlZENoaWxkcmVuKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVtaXRDaGlsZHJlbkxvYWRlZChtYXBwZWRDaGlsZHJlbik7XG4gICAgfVxufTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RCaW5kaW5nKFwiY2xhc3Muay1ncm91cFwiKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIFRyZWVWaWV3R3JvdXBDb21wb25lbnQucHJvdG90eXBlLCBcImtHcm91cENsYXNzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBIb3N0QmluZGluZyhcImF0dHIucm9sZVwiKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgVHJlZVZpZXdHcm91cENvbXBvbmVudC5wcm90b3R5cGUsIFwicm9sZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIFRyZWVWaWV3R3JvdXBDb21wb25lbnQucHJvdG90eXBlLCBcImNoZWNrYm94ZXNcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBUcmVlVmlld0dyb3VwQ29tcG9uZW50LnByb3RvdHlwZSwgXCJleHBhbmRJY29uc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIFRyZWVWaWV3R3JvdXBDb21wb25lbnQucHJvdG90eXBlLCBcImRpc2FibGVkXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgVHJlZVZpZXdHcm91cENvbXBvbmVudC5wcm90b3R5cGUsIFwic2VsZWN0YWJsZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIFRyZWVWaWV3R3JvdXBDb21wb25lbnQucHJvdG90eXBlLCBcInRvdWNoQWN0aW9uc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIFRyZWVWaWV3R3JvdXBDb21wb25lbnQucHJvdG90eXBlLCBcImxvYWRPbkRlbWFuZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pXG5dLCBUcmVlVmlld0dyb3VwQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0cmFja0J5XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbilcbl0sIFRyZWVWaWV3R3JvdXBDb21wb25lbnQucHJvdG90eXBlLCBcIm5vZGVzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBUcmVlVmlld0dyb3VwQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0ZXh0RmllbGRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFRyZWVWaWV3R3JvdXBDb21wb25lbnQucHJvdG90eXBlLCBcInBhcmVudERhdGFJdGVtXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBUcmVlVmlld0dyb3VwQ29tcG9uZW50LnByb3RvdHlwZSwgXCJwYXJlbnRJbmRleFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgVGVtcGxhdGVSZWYpXG5dLCBUcmVlVmlld0dyb3VwQ29tcG9uZW50LnByb3RvdHlwZSwgXCJub2RlVGVtcGxhdGVSZWZcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFRlbXBsYXRlUmVmKVxuXSwgVHJlZVZpZXdHcm91cENvbXBvbmVudC5wcm90b3R5cGUsIFwibG9hZE1vcmVCdXR0b25UZW1wbGF0ZVJlZlwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgVHJlZVZpZXdHcm91cENvbXBvbmVudC5wcm90b3R5cGUsIFwibG9hZE1vcmVTZXJ2aWNlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbilcbl0sIFRyZWVWaWV3R3JvdXBDb21wb25lbnQucHJvdG90eXBlLCBcImlzQ2hlY2tlZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pXG5dLCBUcmVlVmlld0dyb3VwQ29tcG9uZW50LnByb3RvdHlwZSwgXCJpc0Rpc2FibGVkXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbilcbl0sIFRyZWVWaWV3R3JvdXBDb21wb25lbnQucHJvdG90eXBlLCBcImlzRXhwYW5kZWRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKVxuXSwgVHJlZVZpZXdHcm91cENvbXBvbmVudC5wcm90b3R5cGUsIFwiaXNWaXNpYmxlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbilcbl0sIFRyZWVWaWV3R3JvdXBDb21wb25lbnQucHJvdG90eXBlLCBcImlzU2VsZWN0ZWRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKVxuXSwgVHJlZVZpZXdHcm91cENvbXBvbmVudC5wcm90b3R5cGUsIFwiY2hpbGRyZW5cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKVxuXSwgVHJlZVZpZXdHcm91cENvbXBvbmVudC5wcm90b3R5cGUsIFwiaGFzQ2hpbGRyZW5cIiwgdm9pZCAwKTtcblRyZWVWaWV3R3JvdXBDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBhbmltYXRpb25zOiBbXG4gICAgICAgICAgICB0cmlnZ2VyKCd0b2dnbGUnLCBbXG4gICAgICAgICAgICAgICAgdHJhbnNpdGlvbigndm9pZCA9PiAqJywgW1xuICAgICAgICAgICAgICAgICAgICBzdHlsZSh7IGhlaWdodDogMCB9KSxcbiAgICAgICAgICAgICAgICAgICAgYW5pbWF0ZSgnMC4xcyBlYXNlLWluJywgc3R5bGUoeyBoZWlnaHQ6IFwiKlwiIH0pKVxuICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgIHRyYW5zaXRpb24oJyogPT4gdm9pZCcsIFtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGUoeyBoZWlnaHQ6IFwiKlwiIH0pLFxuICAgICAgICAgICAgICAgICAgICBhbmltYXRlKCcwLjFzIGVhc2UtaW4nLCBzdHlsZSh7IGhlaWdodDogMCB9KSlcbiAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgXSlcbiAgICAgICAgXSxcbiAgICAgICAgc2VsZWN0b3I6ICdba2VuZG9UcmVlVmlld0dyb3VwXScsXG4gICAgICAgIHRlbXBsYXRlOiBgXG4gICAgICAgIDxsaVxuICAgICAgICAgICAgKm5nRm9yPVwibGV0IG5vZGUgb2YgZGF0YTsgbGV0IGluZGV4ID0gaW5kZXg7IHRyYWNrQnk6IHRyYWNrQnlcIlxuICAgICAgICAgICAgY2xhc3M9XCJrLWl0ZW0gay10cmVldmlldy1pdGVtXCJcbiAgICAgICAgICAgIFtjbGFzcy5rLWRpc3BsYXktbm9uZV09XCIhaXNWaXNpYmxlKG5vZGUsIG5vZGVJbmRleChpbmRleCkpXCJcbiAgICAgICAgICAgIGtlbmRvVHJlZVZpZXdJdGVtXG4gICAgICAgICAgICBbYXR0ci5hcmlhLXNldHNpemVdPVwidG90YWxOb2Rlc0NvdW50XCJcbiAgICAgICAgICAgIFtkYXRhSXRlbV09XCJub2RlXCJcbiAgICAgICAgICAgIFtpbmRleF09XCJub2RlSW5kZXgoaW5kZXgpXCJcbiAgICAgICAgICAgIFtwYXJlbnREYXRhSXRlbV09XCJwYXJlbnREYXRhSXRlbVwiXG4gICAgICAgICAgICBbcGFyZW50SW5kZXhdPVwicGFyZW50SW5kZXhcIlxuICAgICAgICAgICAgW2xvYWRPbkRlbWFuZF09XCJsb2FkT25EZW1hbmRcIlxuICAgICAgICAgICAgW2NoZWNrYWJsZV09XCJjaGVja2JveGVzXCJcbiAgICAgICAgICAgIFtpc0NoZWNrZWRdPVwiaXNDaGVja2VkKG5vZGUsIG5vZGVJbmRleChpbmRleCkpXCJcbiAgICAgICAgICAgIFtpc0Rpc2FibGVkXT1cImRpc2FibGVkIHx8IGlzRGlzYWJsZWQobm9kZSwgbm9kZUluZGV4KGluZGV4KSlcIlxuICAgICAgICAgICAgW2lzVmlzaWJsZV09XCJpc1Zpc2libGUobm9kZSwgbm9kZUluZGV4KGluZGV4KSlcIlxuICAgICAgICAgICAgW2V4cGFuZGFibGVdPVwiZXhwYW5kSWNvbnMgJiYgaGFzQ2hpbGRyZW4obm9kZSlcIlxuICAgICAgICAgICAgW2lzRXhwYW5kZWRdPVwiaXNFeHBhbmRlZChub2RlLCBub2RlSW5kZXgoaW5kZXgpKVwiXG4gICAgICAgICAgICBbc2VsZWN0YWJsZV09XCJzZWxlY3RhYmxlXCJcbiAgICAgICAgICAgIFtpc1NlbGVjdGVkXT1cImlzU2VsZWN0ZWQobm9kZSwgbm9kZUluZGV4KGluZGV4KSlcIlxuICAgICAgICAgICAgW2F0dHIuZGF0YS10cmVlaW5kZXhdPVwibm9kZUluZGV4KGluZGV4KVwiXG4gICAgICAgID5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJrLW1pZFwiPlxuICAgICAgICAgICAgICAgIDxzcGFuXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzPVwiay1pY29uXCJcbiAgICAgICAgICAgICAgICAgICAgW2NsYXNzLmstaS1jb2xsYXBzZV09XCJpc0V4cGFuZGVkKG5vZGUsIG5vZGVJbmRleChpbmRleCkpXCJcbiAgICAgICAgICAgICAgICAgICAgW2NsYXNzLmstaS1leHBhbmRdPVwiIWlzRXhwYW5kZWQobm9kZSwgbm9kZUluZGV4KGluZGV4KSlcIlxuICAgICAgICAgICAgICAgICAgICBba2VuZG9UcmVlVmlld0xvYWRpbmddPVwibm9kZUluZGV4KGluZGV4KVwiXG4gICAgICAgICAgICAgICAgICAgIChjbGljayk9XCJleHBhbmROb2RlKG5vZGVJbmRleChpbmRleCksIG5vZGUsICFpc0V4cGFuZGVkKG5vZGUsIG5vZGVJbmRleChpbmRleCkpKVwiXG4gICAgICAgICAgICAgICAgICAgICpuZ0lmPVwiZXhwYW5kSWNvbnMgJiYgaGFzQ2hpbGRyZW4obm9kZSlcIlxuICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICAgICAgPGtlbmRvLWNoZWNrYm94XG4gICAgICAgICAgICAgICAgICAgICpuZ0lmPVwiY2hlY2tib3hlc1wiXG4gICAgICAgICAgICAgICAgICAgIFtub2RlXT1cIm5vZGVcIlxuICAgICAgICAgICAgICAgICAgICBbaW5kZXhdPVwibm9kZUluZGV4KGluZGV4KVwiXG4gICAgICAgICAgICAgICAgICAgIFtpc0NoZWNrZWRdPVwiaXNDaGVja2VkXCJcbiAgICAgICAgICAgICAgICAgICAgKGNoZWNrU3RhdGVDaGFuZ2UpPVwiY2hlY2tOb2RlKG5vZGVJbmRleChpbmRleCkpXCJcbiAgICAgICAgICAgICAgICAgICAgdGFiaW5kZXg9XCItMVwiXG4gICAgICAgICAgICAgICAgPjwva2VuZG8tY2hlY2tib3g+XG4gICAgICAgICAgICAgICAgPHNwYW4ga2VuZG9UcmVlVmlld0l0ZW1Db250ZW50XG4gICAgICAgICAgICAgICAgICAgIFthdHRyLmRhdGEtdHJlZWluZGV4XT1cIm5vZGVJbmRleChpbmRleClcIlxuICAgICAgICAgICAgICAgICAgICBbZGF0YUl0ZW1dPVwibm9kZVwiXG4gICAgICAgICAgICAgICAgICAgIFtpbmRleF09XCJub2RlSW5kZXgoaW5kZXgpXCJcbiAgICAgICAgICAgICAgICAgICAgW2luaXRpYWxTZWxlY3Rpb25dPVwiaXNTZWxlY3RlZChub2RlLCBub2RlSW5kZXgoaW5kZXgpKVwiXG4gICAgICAgICAgICAgICAgICAgIFtpc1NlbGVjdGVkXT1cImlzU2VsZWN0ZWRcIlxuICAgICAgICAgICAgICAgICAgICBjbGFzcz1cImstaW5cIlxuICAgICAgICAgICAgICAgICAgICBbc3R5bGUudG91Y2gtYWN0aW9uXT1cInRvdWNoQWN0aW9ucyA/ICcnIDogJ25vbmUnXCJcbiAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgIDxuZy1jb250YWluZXIgW25nU3dpdGNoXT1cImhhc1RlbXBsYXRlXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8bmctY29udGFpbmVyICpuZ1N3aXRjaENhc2U9XCJ0cnVlXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPG5nLXRlbXBsYXRlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtuZ1RlbXBsYXRlT3V0bGV0XT1cIm5vZGVUZW1wbGF0ZVJlZlwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtuZ1RlbXBsYXRlT3V0bGV0Q29udGV4dF09XCJ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkaW1wbGljaXQ6IG5vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogbm9kZUluZGV4KGluZGV4KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgICAgICAgICAgICAgICAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdTd2l0Y2hEZWZhdWx0PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHt7bm9kZVRleHQobm9kZSl9fVxuICAgICAgICAgICAgICAgICAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgICAgICAgICAgICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPHVsXG4gICAgICAgICAgICAgICAgKm5nSWY9XCJpc0V4cGFuZGVkKG5vZGUsIG5vZGVJbmRleChpbmRleCkpICYmIGhhc0NoaWxkcmVuKG5vZGUpXCJcbiAgICAgICAgICAgICAgICBrZW5kb1RyZWVWaWV3R3JvdXBcbiAgICAgICAgICAgICAgICByb2xlPVwiZ3JvdXBcIlxuICAgICAgICAgICAgICAgIFtub2Rlc109XCJmZXRjaENoaWxkcmVuXCJcbiAgICAgICAgICAgICAgICBbbG9hZE9uRGVtYW5kXT1cImxvYWRPbkRlbWFuZFwiXG4gICAgICAgICAgICAgICAgW2NoZWNrYm94ZXNdPVwiY2hlY2tib3hlc1wiXG4gICAgICAgICAgICAgICAgW2V4cGFuZEljb25zXT1cImV4cGFuZEljb25zXCJcbiAgICAgICAgICAgICAgICBbc2VsZWN0YWJsZV09XCJzZWxlY3RhYmxlXCJcbiAgICAgICAgICAgICAgICBbdG91Y2hBY3Rpb25zXT1cInRvdWNoQWN0aW9uc1wiXG4gICAgICAgICAgICAgICAgW2NoaWxkcmVuXT1cImNoaWxkcmVuXCJcbiAgICAgICAgICAgICAgICBbaGFzQ2hpbGRyZW5dPVwiaGFzQ2hpbGRyZW5cIlxuICAgICAgICAgICAgICAgIFtpc0NoZWNrZWRdPVwiaXNDaGVja2VkXCJcbiAgICAgICAgICAgICAgICBbaXNEaXNhYmxlZF09XCJpc0Rpc2FibGVkXCJcbiAgICAgICAgICAgICAgICBbZGlzYWJsZWRdPVwiZGlzYWJsZWQgfHwgaXNEaXNhYmxlZChub2RlLCBub2RlSW5kZXgoaW5kZXgpKVwiXG4gICAgICAgICAgICAgICAgW2lzRXhwYW5kZWRdPVwiaXNFeHBhbmRlZFwiXG4gICAgICAgICAgICAgICAgW2lzU2VsZWN0ZWRdPVwiaXNTZWxlY3RlZFwiXG4gICAgICAgICAgICAgICAgW2lzVmlzaWJsZV09XCJpc1Zpc2libGVcIlxuICAgICAgICAgICAgICAgIFtub2RlVGVtcGxhdGVSZWZdPVwibm9kZVRlbXBsYXRlUmVmXCJcbiAgICAgICAgICAgICAgICBbbG9hZE1vcmVCdXR0b25UZW1wbGF0ZVJlZl09XCJsb2FkTW9yZUJ1dHRvblRlbXBsYXRlUmVmXCJcbiAgICAgICAgICAgICAgICBbcGFyZW50SW5kZXhdPVwibm9kZUluZGV4KGluZGV4KVwiXG4gICAgICAgICAgICAgICAgW3BhcmVudERhdGFJdGVtXT1cIm5vZGVcIlxuICAgICAgICAgICAgICAgIFt0ZXh0RmllbGRdPVwibmV4dEZpZWxkc1wiXG4gICAgICAgICAgICAgICAgW2xvYWRNb3JlU2VydmljZV09XCJsb2FkTW9yZVNlcnZpY2VcIlxuICAgICAgICAgICAgICAgIFtAdG9nZ2xlXT1cInRydWVcIlxuICAgICAgICAgICAgICAgIFt0cmFja0J5XT1cInRyYWNrQnlcIlxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgPC91bD5cbiAgICAgICAgPC9saT5cbiAgICAgICAgPGxpXG4gICAgICAgICAgICAqbmdJZj1cImluaXRpYWxOb2Rlc0xvYWRlZCAmJiBtb3JlTm9kZXNBdmFpbGFibGVcIlxuICAgICAgICAgICAgY2xhc3M9XCJrLWl0ZW0gay10cmVldmlldy1pdGVtXCJcbiAgICAgICAgICAgIFtjbGFzcy5rLXRyZWV2aWV3LWxvYWQtbW9yZS1jaGVja2JveGVzLWNvbnRhaW5lcl09XCJjaGVja2JveGVzXCJcbiAgICAgICAgICAgIGtlbmRvVHJlZVZpZXdJdGVtXG4gICAgICAgICAgICByb2xlPVwiYnV0dG9uXCJcbiAgICAgICAgICAgIFtzZWxlY3RhYmxlXT1cImZhbHNlXCJcbiAgICAgICAgICAgIFtjaGVja2FibGVdPVwiZmFsc2VcIlxuICAgICAgICAgICAgW2V4cGFuZGFibGVdPVwiZmFsc2VcIlxuICAgICAgICAgICAgW2luZGV4XT1cImxvYWRNb3JlQnV0dG9uSW5kZXhcIlxuICAgICAgICAgICAgW3BhcmVudERhdGFJdGVtXT1cInBhcmVudERhdGFJdGVtXCJcbiAgICAgICAgICAgIFtwYXJlbnRJbmRleF09XCJwYXJlbnRJbmRleFwiXG4gICAgICAgICAgICBbYXR0ci5kYXRhLXRyZWVpbmRleF09XCJsb2FkTW9yZUJ1dHRvbkluZGV4XCJcbiAgICAgICAgPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImstbWlkXCI+XG4gICAgICAgICAgICAgICAgPHNwYW5cbiAgICAgICAgICAgICAgICAgICAgKm5nSWY9XCJsb2FkaW5nTW9yZU5vZGVzXCJcbiAgICAgICAgICAgICAgICAgICAgY2xhc3M9XCJrLWljb24gay1pLWxvYWRpbmcgay1pLWV4cGFuZFwiXG4gICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgICAgICA8c3BhblxuICAgICAgICAgICAgICAgICAgICBjbGFzcz1cImstaW4gay10cmVldmlldy1sb2FkLW1vcmUtYnV0dG9uXCJcbiAgICAgICAgICAgICAgICAgICAgW2F0dHIuZGF0YS10cmVlaW5kZXhdPVwibG9hZE1vcmVCdXR0b25JbmRleFwiXG4gICAgICAgICAgICAgICAgICAgIGtlbmRvVHJlZVZpZXdJdGVtQ29udGVudFxuICAgICAgICAgICAgICAgICAgICBbaW5kZXhdPVwibG9hZE1vcmVCdXR0b25JbmRleFwiXG4gICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICA8bmctdGVtcGxhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgICpuZ0lmPVwibG9hZE1vcmVCdXR0b25UZW1wbGF0ZVJlZlwiXG4gICAgICAgICAgICAgICAgICAgICAgICBbbmdUZW1wbGF0ZU91dGxldF09XCJsb2FkTW9yZUJ1dHRvblRlbXBsYXRlUmVmXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIFtuZ1RlbXBsYXRlT3V0bGV0Q29udGV4dF09XCJ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGxvYWRNb3JlQnV0dG9uSW5kZXhcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cIlxuICAgICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgIDwvbmctdGVtcGxhdGU+XG4gICAgICAgICAgICAgICAgICAgIDxuZy1jb250YWluZXIgKm5nSWY9XCIhbG9hZE1vcmVCdXR0b25UZW1wbGF0ZVJlZlwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgTG9hZCBtb3JlXG4gICAgICAgICAgICAgICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2xpPlxuICAgIGBcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0V4cGFuZFN0YXRlU2VydmljZSxcbiAgICAgICAgTG9hZGluZ05vdGlmaWNhdGlvblNlcnZpY2UsXG4gICAgICAgIEluZGV4QnVpbGRlclNlcnZpY2UsXG4gICAgICAgIFRyZWVWaWV3TG9va3VwU2VydmljZSxcbiAgICAgICAgTmF2aWdhdGlvblNlcnZpY2UsXG4gICAgICAgIE5vZGVDaGlsZHJlblNlcnZpY2UsXG4gICAgICAgIERhdGFDaGFuZ2VOb3RpZmljYXRpb25TZXJ2aWNlLFxuICAgICAgICBDaGFuZ2VEZXRlY3RvclJlZl0pXG5dLCBUcmVlVmlld0dyb3VwQ29tcG9uZW50KTtcblxuY29uc3QgaW5kZXhDaGVja2VkID0gKGtleXMsIGluZGV4KSA9PiBrZXlzLmZpbHRlcihrID0+IGsgPT09IGluZGV4KS5sZW5ndGggPiAwO1xuY29uc3QgbWF0Y2hLZXkgPSBpbmRleCA9PiBrID0+IHtcbiAgICBpZiAoaW5kZXggPT09IGspIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICghay5zcGxpdCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBrLnNwbGl0KCdfJykucmVkdWNlKCh7IGtleSwgcmVzdWx0IH0sIHBhcnQpID0+IHtcbiAgICAgICAga2V5ICs9IHBhcnQ7XG4gICAgICAgIGlmIChpbmRleCA9PT0ga2V5IHx8IHJlc3VsdCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgcmVzdWx0OiB0cnVlIH07XG4gICAgICAgIH1cbiAgICAgICAga2V5ICs9IFwiX1wiO1xuICAgICAgICByZXR1cm4geyBrZXksIHJlc3VsdDogZmFsc2UgfTtcbiAgICB9LCB7IGtleTogXCJcIiwgcmVzdWx0OiBmYWxzZSB9KS5yZXN1bHQ7XG59O1xuLyoqXG4gKiBBIGRpcmVjdGl2ZSB3aGljaCBtYW5hZ2VzIHRoZSBpbi1tZW1vcnkgY2hlY2tlZCBzdGF0ZSBvZiB0aGUgVHJlZVZpZXcgbm9kZVxuICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBjaGVja2JveGVzX3RyZWV2aWV3ICV9KSkuXG4gKi9cbmxldCBDaGVja0RpcmVjdGl2ZSA9IGNsYXNzIENoZWNrRGlyZWN0aXZlIHtcbiAgICBjb25zdHJ1Y3Rvcih0cmVlVmlldywgem9uZSkge1xuICAgICAgICB0aGlzLnRyZWVWaWV3ID0gdHJlZVZpZXc7XG4gICAgICAgIHRoaXMuem9uZSA9IHpvbmU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyB3aGVuIHRoZSBgY2hlY2tlZEtleXNgIGNvbGxlY3Rpb24gd2FzIHVwZGF0ZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNoZWNrZWRLZXlzQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMgPSBuZXcgU3Vic2NyaXB0aW9uKCk7XG4gICAgICAgIHRoaXMuY2hlY2tBY3Rpb25zID0ge1xuICAgICAgICAgICAgJ211bHRpcGxlJzogKGUpID0+IHRoaXMuY2hlY2tNdWx0aXBsZShlKSxcbiAgICAgICAgICAgICdzaW5nbGUnOiAoZSkgPT4gdGhpcy5jaGVja1NpbmdsZShlKVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9jaGVja2VkS2V5cyA9IFtdO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMuYWRkKHRoaXMudHJlZVZpZXcuY2hlY2tlZENoYW5nZVxuICAgICAgICAgICAgLnN1YnNjcmliZSgoZSkgPT4gdGhpcy5jaGVjayhlKSkpO1xuICAgICAgICBsZXQgZXhwYW5kZWRJdGVtcyA9IFtdO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMuYWRkKHRoaXMudHJlZVZpZXcuY2hpbGRyZW5Mb2FkZWRcbiAgICAgICAgICAgIC5waXBlKGZpbHRlcigoKSA9PiB0aGlzLm9wdGlvbnMuY2hlY2tDaGlsZHJlbiAmJiB0aGlzLnRyZWVWaWV3LmxvYWRPbkRlbWFuZCksIHRhcChpdGVtID0+IGV4cGFuZGVkSXRlbXMucHVzaChpdGVtKSksIHN3aXRjaE1hcCgoKSA9PiB0aGlzLnpvbmUub25TdGFibGUucGlwZSh0YWtlKDEpKSkpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKCgpID0+IHRoaXMuYWRkQ2hlY2tlZEl0ZW1zQ2hpbGRyZW4oZXhwYW5kZWRJdGVtcykpKTtcbiAgICAgICAgdGhpcy50cmVlVmlldy5pc0NoZWNrZWQgPSB0aGlzLmlzSXRlbUNoZWNrZWQuYmluZCh0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHNldCBpc0NoZWNrZWQodmFsdWUpIHtcbiAgICAgICAgdGhpcy50cmVlVmlldy5pc0NoZWNrZWQgPSB2YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVmaW5lcyB0aGUgY29sbGVjdGlvbiB0aGF0IHdpbGwgc3RvcmUgdGhlIGNoZWNrZWQga2V5c1xuICAgICAqIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgY2hlY2tib3hlc190cmVldmlldyAlfSkpLlxuICAgICAqL1xuICAgIGdldCBjaGVja2VkS2V5cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NoZWNrZWRLZXlzO1xuICAgIH1cbiAgICBzZXQgY2hlY2tlZEtleXMoa2V5cykge1xuICAgICAgICB0aGlzLl9jaGVja2VkS2V5cyA9IGtleXM7XG4gICAgfVxuICAgIGdldCBvcHRpb25zKCkge1xuICAgICAgICBjb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGNoZWNrQ2hpbGRyZW46IHRydWUsXG4gICAgICAgICAgICBjaGVja1BhcmVudHM6IHRydWUsXG4gICAgICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICAgICAgbW9kZTogXCJtdWx0aXBsZVwiXG4gICAgICAgIH07XG4gICAgICAgIGlmICghaXNQcmVzZW50KHRoaXMuY2hlY2thYmxlKSB8fCB0eXBlb2YgdGhpcy5jaGVja2FibGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gZGVmYXVsdE9wdGlvbnM7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2hlY2tTZXR0aW5ncyA9IGlzQm9vbGVhbih0aGlzLmNoZWNrYWJsZSlcbiAgICAgICAgICAgID8geyBlbmFibGVkOiB0aGlzLmNoZWNrYWJsZSB9XG4gICAgICAgICAgICA6IHRoaXMuY2hlY2thYmxlO1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihkZWZhdWx0T3B0aW9ucywgY2hlY2tTZXR0aW5ncyk7XG4gICAgfVxuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXMpIHtcbiAgICAgICAgaWYgKGNoYW5nZXMuY2hlY2thYmxlKSB7XG4gICAgICAgICAgICB0aGlzLnRyZWVWaWV3LmNoZWNrYm94ZXMgPSB0aGlzLm9wdGlvbnMuZW5hYmxlZDtcbiAgICAgICAgICAgIHRoaXMudG9nZ2xlQ2hlY2tPbkNsaWNrKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy51bnN1YnNjcmliZSgpO1xuICAgICAgICB0aGlzLnVuc3Vic2NyaWJlQ2xpY2soKTtcbiAgICB9XG4gICAgaXNJdGVtQ2hlY2tlZChkYXRhSXRlbSwgaW5kZXgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNoZWNrS2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pc0luZGV4Q2hlY2tlZChpbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qga2V5SW5kZXggPSB0aGlzLmNoZWNrZWRLZXlzLmluZGV4T2YodGhpcy5pdGVtS2V5KHsgZGF0YUl0ZW0sIGluZGV4IH0pKTtcbiAgICAgICAgcmV0dXJuIGtleUluZGV4ID4gLTEgPyAnY2hlY2tlZCcgOiAnbm9uZSc7XG4gICAgfVxuICAgIGlzSW5kZXhDaGVja2VkKGluZGV4KSB7XG4gICAgICAgIGNvbnN0IGNoZWNrZWRLZXlzID0gdGhpcy5jaGVja2VkS2V5cy5maWx0ZXIobWF0Y2hLZXkoaW5kZXgpKTtcbiAgICAgICAgaWYgKGluZGV4Q2hlY2tlZChjaGVja2VkS2V5cywgaW5kZXgpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2NoZWNrZWQnO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgbW9kZSwgY2hlY2tQYXJlbnRzIH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIGlmIChtb2RlID09PSAnbXVsdGlwbGUnICYmIGNoZWNrUGFyZW50cyAmJiBjaGVja2VkS2V5cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiAnaW5kZXRlcm1pbmF0ZSc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICdub25lJztcbiAgICB9XG4gICAgaXRlbUtleShpdGVtKSB7XG4gICAgICAgIGlmICghaXNQcmVzZW50KHRoaXMuY2hlY2tLZXkpKSB7XG4gICAgICAgICAgICByZXR1cm4gaXRlbS5pbmRleDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHRoaXMuY2hlY2tLZXkgPT09IFwic3RyaW5nXCIgJiYgaXNQcmVzZW50KGl0ZW0uZGF0YUl0ZW0pKSB7XG4gICAgICAgICAgICByZXR1cm4gaXRlbS5kYXRhSXRlbVt0aGlzLmNoZWNrS2V5XTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHRoaXMuY2hlY2tLZXkgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hlY2tLZXkoaXRlbSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2hlY2soZSkge1xuICAgICAgICBjb25zdCB7IGVuYWJsZWQsIG1vZGUgfSA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgY29uc3QgcGVyZm9ybVNlbGVjdGlvbiA9IHRoaXMuY2hlY2tBY3Rpb25zW21vZGVdIHx8IG5vb3A7XG4gICAgICAgIGlmICghZW5hYmxlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHBlcmZvcm1TZWxlY3Rpb24oZSk7XG4gICAgfVxuICAgIGNoZWNrU2luZ2xlKG5vZGUpIHtcbiAgICAgICAgY29uc3Qga2V5ID0gdGhpcy5pdGVtS2V5KG5vZGUuaXRlbSk7XG4gICAgICAgIHRoaXMuY2hlY2tlZEtleXMgPSB0aGlzLmNoZWNrZWRLZXlzWzBdICE9PSBrZXkgPyBba2V5XSA6IFtdO1xuICAgICAgICB0aGlzLm5vdGlmeSgpO1xuICAgIH1cbiAgICBjaGVja011bHRpcGxlKG5vZGUpIHtcbiAgICAgICAgdGhpcy5jaGVja05vZGUobm9kZSk7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuY2hlY2tQYXJlbnRzKSB7XG4gICAgICAgICAgICB0aGlzLmNoZWNrUGFyZW50cyhub2RlLnBhcmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ub3RpZnkoKTtcbiAgICB9XG4gICAgdG9nZ2xlQ2hlY2tPbkNsaWNrKCkge1xuICAgICAgICB0aGlzLnVuc3Vic2NyaWJlQ2xpY2soKTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5jaGVja09uQ2xpY2spIHtcbiAgICAgICAgICAgIHRoaXMuY2xpY2tTdWJzY3JpcHRpb24gPSB0aGlzLnRyZWVWaWV3Lm5vZGVDbGljay5zdWJzY3JpYmUoYXJncyA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGFyZ3MudHlwZSA9PT0gJ2NsaWNrJykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsb29rdXAgPSB0aGlzLnRyZWVWaWV3Lml0ZW1Mb29rdXAoYXJncy5pdGVtLmluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGVjayhsb29rdXApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVuc3Vic2NyaWJlQ2xpY2soKSB7XG4gICAgICAgIGlmICh0aGlzLmNsaWNrU3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmNsaWNrU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB0aGlzLmNsaWNrU3Vic2NyaXB0aW9uID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjaGVja05vZGUobm9kZSkge1xuICAgICAgICBpZiAoIWlzUHJlc2VudChub2RlLml0ZW0uZGF0YUl0ZW0pIHx8IHRoaXMudHJlZVZpZXcuaXNEaXNhYmxlZChub2RlLml0ZW0uZGF0YUl0ZW0sIG5vZGUuaXRlbS5pbmRleCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjdXJyZW50S2V5ID0gdGhpcy5pdGVtS2V5KG5vZGUuaXRlbSk7XG4gICAgICAgIGlmICghaXNQcmVzZW50KGN1cnJlbnRLZXkpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2hlY2tlZEtleXMgPSBuZXcgU2V0KHRoaXMuY2hlY2tlZEtleXMpO1xuICAgICAgICBjb25zdCBwZW5kaW5nQ2hlY2sgPSBbY3VycmVudEtleV07XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuY2hlY2tDaGlsZHJlbikge1xuICAgICAgICAgICAgY29uc3QgZGVzY2VuZGFudHMgPSBmZXRjaExvYWRlZERlc2NlbmRhbnRzKG5vZGUsICh7IGl0ZW0gfSkgPT4gdGhpcy50cmVlVmlldy5pc1Zpc2libGUoaXRlbS5kYXRhSXRlbSwgaXRlbS5pbmRleCkgJiZcbiAgICAgICAgICAgICAgICAhdGhpcy50cmVlVmlldy5pc0Rpc2FibGVkKGl0ZW0uZGF0YUl0ZW0sIGl0ZW0uaW5kZXgpKVxuICAgICAgICAgICAgICAgIC5tYXAoKHsgaXRlbSB9KSA9PiB0aGlzLml0ZW1LZXkoaXRlbSkpO1xuICAgICAgICAgICAgcGVuZGluZ0NoZWNrLnB1c2goLi4uZGVzY2VuZGFudHMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNob3VsZENoZWNrID0gIWNoZWNrZWRLZXlzLmhhcyhjdXJyZW50S2V5KTtcbiAgICAgICAgcGVuZGluZ0NoZWNrLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIGlmIChzaG91bGRDaGVjaykge1xuICAgICAgICAgICAgICAgIGNoZWNrZWRLZXlzLmFkZChrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY2hlY2tlZEtleXMuZGVsZXRlKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNoZWNrZWRLZXlzID0gQXJyYXkuZnJvbShjaGVja2VkS2V5cyk7XG4gICAgfVxuICAgIGNoZWNrUGFyZW50cyhwYXJlbnQpIHtcbiAgICAgICAgaWYgKCFpc1ByZXNlbnQocGFyZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNoZWNrZWRLZXlzID0gbmV3IFNldCh0aGlzLmNoZWNrZWRLZXlzKTtcbiAgICAgICAgbGV0IGN1cnJlbnRQYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgIHdoaWxlIChjdXJyZW50UGFyZW50KSB7XG4gICAgICAgICAgICBjb25zdCBwYXJlbnRLZXkgPSB0aGlzLml0ZW1LZXkoY3VycmVudFBhcmVudC5pdGVtKTtcbiAgICAgICAgICAgIGNvbnN0IGFsbENoaWxkcmVuU2VsZWN0ZWQgPSBjdXJyZW50UGFyZW50LmNoaWxkcmVuLmV2ZXJ5KGl0ZW0gPT4gY2hlY2tlZEtleXMuaGFzKHRoaXMuaXRlbUtleShpdGVtKSkpO1xuICAgICAgICAgICAgaWYgKGFsbENoaWxkcmVuU2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICBjaGVja2VkS2V5cy5hZGQocGFyZW50S2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNoZWNrZWRLZXlzLmRlbGV0ZShwYXJlbnRLZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudFBhcmVudCA9IGN1cnJlbnRQYXJlbnQucGFyZW50O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2hlY2tlZEtleXMgPSBBcnJheS5mcm9tKGNoZWNrZWRLZXlzKTtcbiAgICB9XG4gICAgbm90aWZ5KCkge1xuICAgICAgICB0aGlzLmNoZWNrZWRLZXlzQ2hhbmdlLmVtaXQodGhpcy5jaGVja2VkS2V5cy5zbGljZSgpKTtcbiAgICB9XG4gICAgYWRkQ2hlY2tlZEl0ZW1zQ2hpbGRyZW4obG9va3Vwcykge1xuICAgICAgICBpZiAoIWlzUHJlc2VudChsb29rdXBzKSB8fCBsb29rdXBzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGluaXRpYWxseUNoZWNrZWRJdGVtc0NvdW50ID0gdGhpcy5jaGVja2VkS2V5cy5sZW5ndGg7XG4gICAgICAgIGNvbnN0IGNoZWNrZWRLZXlzID0gbmV3IFNldCh0aGlzLmNoZWNrZWRLZXlzKTtcbiAgICAgICAgbG9va3Vwcy5mb3JFYWNoKGxvb2t1cCA9PiB7XG4gICAgICAgICAgICBjb25zdCBpdGVtS2V5ID0gdGhpcy5pdGVtS2V5KGxvb2t1cC5pdGVtKTtcbiAgICAgICAgICAgIGlmICghY2hlY2tlZEtleXMuaGFzKGl0ZW1LZXkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9va3VwLmNoaWxkcmVuLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gZW5zdXJlIGJvdGggdGhlIHBhcmVudCBpdGVtIGFuZCBlYWNoIGNoaWxkIG5vZGUgaXMgZW5hYmxlZFxuICAgICAgICAgICAgICAgIGlmICghdGhpcy50cmVlVmlldy5pc0Rpc2FibGVkKGxvb2t1cC5pdGVtLmRhdGFJdGVtLCBsb29rdXAuaXRlbS5pbmRleCkgJiZcbiAgICAgICAgICAgICAgICAgICAgIXRoaXMudHJlZVZpZXcuaXNEaXNhYmxlZChpdGVtLmRhdGFJdGVtLCBpdGVtLmluZGV4KSkge1xuICAgICAgICAgICAgICAgICAgICBjaGVja2VkS2V5cy5hZGQodGhpcy5pdGVtS2V5KGl0ZW0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGhhc05ld2x5Q2hlY2tlZEl0ZW1zID0gaW5pdGlhbGx5Q2hlY2tlZEl0ZW1zQ291bnQgIT09IGNoZWNrZWRLZXlzLnNpemU7XG4gICAgICAgIGlmIChoYXNOZXdseUNoZWNrZWRJdGVtcykge1xuICAgICAgICAgICAgdGhpcy5jaGVja2VkS2V5cyA9IEFycmF5LmZyb20oY2hlY2tlZEtleXMpO1xuICAgICAgICAgICAgdGhpcy56b25lLnJ1bigoKSA9PiB0aGlzLm5vdGlmeSgpKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtGdW5jdGlvbl0pXG5dLCBDaGVja0RpcmVjdGl2ZS5wcm90b3R5cGUsIFwiaXNDaGVja2VkXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoXCJjaGVja0J5XCIpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBDaGVja0RpcmVjdGl2ZS5wcm90b3R5cGUsIFwiY2hlY2tLZXlcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEFycmF5KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0FycmF5XSlcbl0sIENoZWNrRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJjaGVja2VkS2V5c1wiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCdrZW5kb1RyZWVWaWV3Q2hlY2thYmxlJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIENoZWNrRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJjaGVja2FibGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIE91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXG5dLCBDaGVja0RpcmVjdGl2ZS5wcm90b3R5cGUsIFwiY2hlY2tlZEtleXNDaGFuZ2VcIiwgdm9pZCAwKTtcbkNoZWNrRGlyZWN0aXZlID0gX19kZWNvcmF0ZShbXG4gICAgRGlyZWN0aXZlKHsgc2VsZWN0b3I6ICdba2VuZG9UcmVlVmlld0NoZWNrYWJsZV0nIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbVHJlZVZpZXdDb21wb25lbnQsXG4gICAgICAgIE5nWm9uZV0pXG5dLCBDaGVja0RpcmVjdGl2ZSk7XG5cbi8qKlxuICogQSBkaXJlY3RpdmUgd2hpY2ggbWFuYWdlcyB0aGUgZGlzYWJsZWQgaW4tbWVtb3J5IHN0YXRlIG9mIHRoZSBUcmVlVmlldyBub2RlXG4gKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGRpc2FibGVkc3RhdGVfdHJlZXZpZXcgJX0pKS5cbiAqL1xubGV0IERpc2FibGVEaXJlY3RpdmUgPSBjbGFzcyBEaXNhYmxlRGlyZWN0aXZlIHtcbiAgICBjb25zdHJ1Y3Rvcih0cmVlVmlldywgY2RyKSB7XG4gICAgICAgIHRoaXMudHJlZVZpZXcgPSB0cmVlVmlldztcbiAgICAgICAgdGhpcy5jZHIgPSBjZHI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWZpbmVzIHRoZSBjb2xsZWN0aW9uIHRoYXQgd2lsbCBzdG9yZSB0aGUgZGlzYWJsZWQga2V5cy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZGlzYWJsZWRLZXlzID0gW107XG4gICAgICAgIHRoaXMudHJlZVZpZXcuaXNEaXNhYmxlZCA9IChkYXRhSXRlbSwgaW5kZXgpID0+ICh0aGlzLmRpc2FibGVkS2V5cy5pbmRleE9mKHRoaXMuaXRlbUtleSh7IGRhdGFJdGVtLCBpbmRleCB9KSkgPiAtMSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBzZXQgaXNEaXNhYmxlZCh2YWx1ZSkge1xuICAgICAgICB0aGlzLnRyZWVWaWV3LmlzRGlzYWJsZWQgPSB2YWx1ZTtcbiAgICB9XG4gICAgbmdPbkNoYW5nZXMoY2hhbmdlcyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IHsgZGlzYWJsZWRLZXlzIH0gPSBjaGFuZ2VzO1xuICAgICAgICBpZiAoZGlzYWJsZWRLZXlzICYmICFkaXNhYmxlZEtleXMuZmlyc3RDaGFuZ2UpIHtcbiAgICAgICAgICAgIHRoaXMuY2RyLm1hcmtGb3JDaGVjaygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGl0ZW1LZXkoZSkge1xuICAgICAgICBpZiAoIXRoaXMuZGlzYWJsZUtleSkge1xuICAgICAgICAgICAgcmV0dXJuIGUuaW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmRpc2FibGVLZXkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBlLmRhdGFJdGVtW3RoaXMuZGlzYWJsZUtleV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmRpc2FibGVLZXkgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGlzYWJsZUtleShlKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtGdW5jdGlvbl0pXG5dLCBEaXNhYmxlRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJpc0Rpc2FibGVkXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoXCJrZW5kb1RyZWVWaWV3RGlzYWJsZVwiKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgRGlzYWJsZURpcmVjdGl2ZS5wcm90b3R5cGUsIFwiZGlzYWJsZUtleVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpXG5dLCBEaXNhYmxlRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJkaXNhYmxlZEtleXNcIiwgdm9pZCAwKTtcbkRpc2FibGVEaXJlY3RpdmUgPSBfX2RlY29yYXRlKFtcbiAgICBEaXJlY3RpdmUoeyBzZWxlY3RvcjogJ1trZW5kb1RyZWVWaWV3RGlzYWJsZV0nIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbVHJlZVZpZXdDb21wb25lbnQsXG4gICAgICAgIENoYW5nZURldGVjdG9yUmVmXSlcbl0sIERpc2FibGVEaXJlY3RpdmUpO1xuXG5jb25zdCBERUZBVUxUX0ZJTFRFUl9FWFBBTkRfU0VUVElOR1MgPSB7XG4gICAgbWF4QXV0b0V4cGFuZFJlc3VsdHM6IC0xLFxuICAgIGV4cGFuZE1hdGNoZXM6IGZhbHNlLFxuICAgIGV4cGFuZGVkT25DbGVhcjogXCJub25lXCJcbn07XG4vKipcbiAqIEEgZGlyZWN0aXZlIHdoaWNoIG1hbmFnZXMgdGhlIGV4cGFuZGVkIHN0YXRlIG9mIHRoZSBUcmVlVmlldy5cbiAqIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgZXhwYW5kZWRzdGF0ZV90cmVldmlldyAlfSkpLlxuICovXG5sZXQgRXhwYW5kRGlyZWN0aXZlID0gY2xhc3MgRXhwYW5kRGlyZWN0aXZlIHtcbiAgICBjb25zdHJ1Y3Rvcihjb21wb25lbnQpIHtcbiAgICAgICAgdGhpcy5jb21wb25lbnQgPSBjb21wb25lbnQ7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIG9yIG5vdCB0byBhdXRvLWV4cGFuZCB0aGUgbm9kZXMgbGVhZGluZyBmcm9tIHRoZSByb290IG5vZGUgdG8gZWFjaCBmaWx0ZXIgcmVzdWx0LlxuICAgICAgICAgKiBUbyBmaW5lLXR1bmUgdGhpcyBiZWhhdmlvciwgcGFzcyBhIFtgRmlsdGVyRXhwYW5kU2V0dGluZ3NgXSh7JSBzbHVnIGFwaV90cmVldmlld19maWx0ZXJleHBhbmRzZXR0aW5ncyAlfSkgb2JqZWN0IHRvIHRoaXMgaW5wdXQuXG4gICAgICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmV4cGFuZE9uRmlsdGVyID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyB3aGVuIHRoZSBgZXhwYW5kZWRLZXlzYCBjb2xsZWN0aW9uIHdhcyB1cGRhdGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5leHBhbmRlZEtleXNDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucyA9IG5ldyBTdWJzY3JpcHRpb24oKTtcbiAgICAgICAgdGhpcy5fZXhwYW5kZWRLZXlzID0gW107XG4gICAgICAgIHRoaXMub3JpZ2luYWxFeHBhbmRlZEtleXMgPSBbXTtcbiAgICAgICAgdGhpcy5pc0ZpbHRlcmVkID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaWxscyBhcnJheSB3aXRoIHRoZSBjb3JyZWN0IGV4cGFuZCBrZXlzIGFjY29yZGluZyB0byB3cmFwcGVyIG1ldGFkYXRhLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy51cGRhdGVFeHBhbmRlZE5vZGVzID0gKGNvbGxlY3Rpb24sIG5vZGUsIGF1dG9FeHBhbmRNYXRjaGVzKSA9PiB7XG4gICAgICAgICAgICBpZiAobm9kZS5jb250YWluc01hdGNoZXMgfHwgbm9kZS5pc01hdGNoICYmIGF1dG9FeHBhbmRNYXRjaGVzICYmIGlzQXJyYXlXaXRoQXRMZWFzdE9uZUl0ZW0obm9kZS5jaGlsZHJlbikpIHtcbiAgICAgICAgICAgICAgICBjb2xsZWN0aW9uLnB1c2godGhpcy5pdGVtS2V5KHsgZGF0YUl0ZW06IG5vZGUuZGF0YUl0ZW0sIGluZGV4OiBub2RlLmluZGV4IH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0FycmF5V2l0aEF0TGVhc3RPbmVJdGVtKG5vZGUuY2hpbGRyZW4pKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5jaGlsZHJlbi5mb3JFYWNoKGNoaWxkID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVFeHBhbmRlZE5vZGVzKGNvbGxlY3Rpb24sIGNoaWxkLCBhdXRvRXhwYW5kTWF0Y2hlcyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaWxscyBhcnJheSB3aXRoIHRoZSBleHBhbmQga2V5IG9mIGV2ZXJ5IG5vZGUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmdldEV2ZXJ5RXhwYW5kS2V5ID0gKGNvbGxlY3Rpb24sIG5vZGUpID0+IHtcbiAgICAgICAgICAgIGlmIChpc0FycmF5V2l0aEF0TGVhc3RPbmVJdGVtKG5vZGUuY2hpbGRyZW4pKSB7XG4gICAgICAgICAgICAgICAgY29sbGVjdGlvbi5wdXNoKHRoaXMuaXRlbUtleSh7IGRhdGFJdGVtOiBub2RlLmRhdGFJdGVtLCBpbmRleDogbm9kZS5pbmRleCB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNBcnJheVdpdGhBdExlYXN0T25lSXRlbShub2RlLmNoaWxkcmVuKSkge1xuICAgICAgICAgICAgICAgIG5vZGUuY2hpbGRyZW4uZm9yRWFjaChjaGlsZCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2V0RXZlcnlFeHBhbmRLZXkoY29sbGVjdGlvbiwgY2hpbGQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMuYWRkKG1lcmdlKHRoaXMuY29tcG9uZW50LmV4cGFuZC5waXBlKG1hcChlID0+IChPYmplY3QuYXNzaWduKHsgZXhwYW5kOiB0cnVlIH0sIGUpKSkpLCB0aGlzLmNvbXBvbmVudC5jb2xsYXBzZS5waXBlKG1hcChlID0+IChPYmplY3QuYXNzaWduKHsgZXhwYW5kOiBmYWxzZSB9LCBlKSkpKSkuc3Vic2NyaWJlKHRoaXMudG9nZ2xlRXhwYW5kLmJpbmQodGhpcykpKTtcbiAgICAgICAgaWYgKHRoaXMuY29tcG9uZW50LmZpbHRlclN0YXRlQ2hhbmdlKSB7XG4gICAgICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMuYWRkKHRoaXMuY29tcG9uZW50LmZpbHRlclN0YXRlQ2hhbmdlLnN1YnNjcmliZSh0aGlzLmhhbmRsZUF1dG9FeHBhbmQuYmluZCh0aGlzKSkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29tcG9uZW50LmlzRXhwYW5kZWQgPSAoZGF0YUl0ZW0sIGluZGV4KSA9PiB0aGlzLmV4cGFuZGVkS2V5cy5pbmRleE9mKHRoaXMuaXRlbUtleSh7IGRhdGFJdGVtLCBpbmRleCB9KSkgPiAtMTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHNldCBpc0V4cGFuZGVkKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuY29tcG9uZW50LmlzRXhwYW5kZWQgPSB2YWx1ZTtcbiAgICB9XG4gICAgZ2V0IGZpbHRlckV4cGFuZFNldHRpbmdzKCkge1xuICAgICAgICBjb25zdCBzZXR0aW5ncyA9IGlzQm9vbGVhbih0aGlzLmV4cGFuZE9uRmlsdGVyKSA/IHsgZW5hYmxlZDogdGhpcy5leHBhbmRPbkZpbHRlciB9IDogT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5leHBhbmRPbkZpbHRlciwgeyBlbmFibGVkOiB0cnVlIH0pO1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgREVGQVVMVF9GSUxURVJfRVhQQU5EX1NFVFRJTkdTLCBzZXR0aW5ncyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlZmluZXMgdGhlIGNvbGxlY3Rpb24gdGhhdCB3aWxsIHN0b3JlIHRoZSBleHBhbmRlZCBrZXlzLlxuICAgICAqL1xuICAgIGdldCBleHBhbmRlZEtleXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9leHBhbmRlZEtleXM7XG4gICAgfVxuICAgIHNldCBleHBhbmRlZEtleXMoa2V5cykge1xuICAgICAgICB0aGlzLl9leHBhbmRlZEtleXMgPSBBcnJheS5mcm9tKG5ldyBTZXQoa2V5cykpO1xuICAgIH1cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBpdGVtS2V5KGUpIHtcbiAgICAgICAgaWYgKHRoaXMuZXhwYW5kS2V5KSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMuZXhwYW5kS2V5ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGUuZGF0YUl0ZW1bdGhpcy5leHBhbmRLZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmV4cGFuZEtleSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXhwYW5kS2V5KGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlLmluZGV4O1xuICAgIH1cbiAgICB0b2dnbGVFeHBhbmQoeyBpbmRleCwgZGF0YUl0ZW0sIGV4cGFuZCB9KSB7XG4gICAgICAgIGNvbnN0IGl0ZW0gPSB0aGlzLml0ZW1LZXkoeyBpbmRleCwgZGF0YUl0ZW0gfSk7XG4gICAgICAgIGNvbnN0IGlkeCA9IHRoaXMuZXhwYW5kZWRLZXlzLmluZGV4T2YoaXRlbSk7XG4gICAgICAgIGxldCBub3RpZnkgPSBmYWxzZTtcbiAgICAgICAgaWYgKGlkeCA+IC0xICYmICFleHBhbmQpIHtcbiAgICAgICAgICAgIHRoaXMuZXhwYW5kZWRLZXlzLnNwbGljZShpZHgsIDEpO1xuICAgICAgICAgICAgbm90aWZ5ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpZHggPT09IC0xICYmIGV4cGFuZCkge1xuICAgICAgICAgICAgdGhpcy5leHBhbmRlZEtleXMucHVzaChpdGVtKTtcbiAgICAgICAgICAgIG5vdGlmeSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vdGlmeSkge1xuICAgICAgICAgICAgdGhpcy5leHBhbmRlZEtleXNDaGFuZ2UuZW1pdCh0aGlzLmV4cGFuZGVkS2V5cyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaGFuZGxlQXV0b0V4cGFuZCh7IG5vZGVzLCBtYXRjaENvdW50LCB0ZXJtIH0pIHtcbiAgICAgICAgaWYgKCF0aGlzLmZpbHRlckV4cGFuZFNldHRpbmdzLmVuYWJsZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IG1heEF1dG9FeHBhbmRSZXN1bHRzLCBleHBhbmRNYXRjaGVzOiBhdXRvRXhwYW5kTWF0Y2hlcywgZXhwYW5kZWRPbkNsZWFyIH0gPSB0aGlzLmZpbHRlckV4cGFuZFNldHRpbmdzO1xuICAgICAgICBpZiAoIXRoaXMuaXNGaWx0ZXJlZCkge1xuICAgICAgICAgICAgdGhpcy5vcmlnaW5hbEV4cGFuZGVkS2V5cyA9IHRoaXMuZXhwYW5kZWRLZXlzLnNsaWNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZXhpdGluZ0ZpbHRlcmVkU3RhdGUgPSB0aGlzLmlzRmlsdGVyZWQgJiYgIXRlcm07XG4gICAgICAgIGNvbnN0IG1heEV4Y2VlZGVkID0gbWF4QXV0b0V4cGFuZFJlc3VsdHMgIT09IC0xICYmIG1hdGNoQ291bnQgPiBtYXhBdXRvRXhwYW5kUmVzdWx0cztcbiAgICAgICAgY29uc3QgZXhpdEF1dG9FeHBhbmRlZFN0YXRlID0gZXhpdGluZ0ZpbHRlcmVkU3RhdGUgfHwgbWF4RXhjZWVkZWQ7XG4gICAgICAgIGlmIChleGl0QXV0b0V4cGFuZGVkU3RhdGUpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoZXhwYW5kZWRPbkNsZWFyKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcImluaXRpYWxcIjoge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXNhbWVWYWx1ZXModGhpcy5leHBhbmRlZEtleXMsIHRoaXMub3JpZ2luYWxFeHBhbmRlZEtleXMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmV4cGFuZGVkS2V5cyA9IHRoaXMub3JpZ2luYWxFeHBhbmRlZEtleXM7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmV4cGFuZGVkS2V5c0NoYW5nZS5lbWl0KHRoaXMuZXhwYW5kZWRLZXlzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBcImFsbFwiOiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZXhwYW5kZWRLZXlzID0gbm9kZXMucmVkdWNlKChhY2MsIHJvb3ROb2RlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdldEV2ZXJ5RXhwYW5kS2V5KGFjYywgcm9vdE5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgICAgICAgICAgICAgfSwgW10pO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmV4cGFuZGVkS2V5c0NoYW5nZS5lbWl0KHRoaXMuZXhwYW5kZWRLZXlzKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgXCJ1bmNoYW5nZWRcIjoge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBcIm5vbmVcIjpcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmV4cGFuZGVkS2V5cy5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZXhwYW5kZWRLZXlzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmV4cGFuZGVkS2V5c0NoYW5nZS5lbWl0KHRoaXMuZXhwYW5kZWRLZXlzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmlzRmlsdGVyZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpbmRpY2VzVG9FeHBhbmQgPSBub2Rlcy5yZWR1Y2UoKGFjYywgcm9vdE5vZGUpID0+IHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlRXhwYW5kZWROb2RlcyhhY2MsIHJvb3ROb2RlLCBhdXRvRXhwYW5kTWF0Y2hlcyk7XG4gICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICB9LCBbXSk7XG4gICAgICAgIGlmICghc2FtZVZhbHVlcyh0aGlzLmV4cGFuZGVkS2V5cywgaW5kaWNlc1RvRXhwYW5kKSkge1xuICAgICAgICAgICAgdGhpcy5leHBhbmRlZEtleXMgPSBpbmRpY2VzVG9FeHBhbmQ7XG4gICAgICAgICAgICB0aGlzLmV4cGFuZGVkS2V5c0NoYW5nZS5lbWl0KHRoaXMuZXhwYW5kZWRLZXlzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzRmlsdGVyZWQgPSB0cnVlO1xuICAgIH1cbn07XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtGdW5jdGlvbl0pXG5dLCBFeHBhbmREaXJlY3RpdmUucHJvdG90eXBlLCBcImlzRXhwYW5kZWRcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dChcImV4cGFuZEJ5XCIpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBFeHBhbmREaXJlY3RpdmUucHJvdG90eXBlLCBcImV4cGFuZEtleVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgRXhwYW5kRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJleHBhbmRPbkZpbHRlclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbl0sIEV4cGFuZERpcmVjdGl2ZS5wcm90b3R5cGUsIFwiZXhwYW5kZWRLZXlzQ2hhbmdlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtBcnJheV0pXG5dLCBFeHBhbmREaXJlY3RpdmUucHJvdG90eXBlLCBcImV4cGFuZGVkS2V5c1wiLCBudWxsKTtcbkV4cGFuZERpcmVjdGl2ZSA9IF9fZGVjb3JhdGUoW1xuICAgIERpcmVjdGl2ZSh7IHNlbGVjdG9yOiAnW2tlbmRvVHJlZVZpZXdFeHBhbmRhYmxlXScgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtFeHBhbmRhYmxlQ29tcG9uZW50XSlcbl0sIEV4cGFuZERpcmVjdGl2ZSk7XG5cbi8qKlxuICogQSBkaXJlY3RpdmUgd2hpY2ggbWFuYWdlcyB0aGUgaW4tbWVtb3J5IHNlbGVjdGlvbiBzdGF0ZSBvZiB0aGUgVHJlZVZpZXcgbm9kZVxuICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBzZWxlY3Rpb25fdHJlZXZpZXcgJX0pKS5cbiAqL1xubGV0IFNlbGVjdERpcmVjdGl2ZSA9IGNsYXNzIFNlbGVjdERpcmVjdGl2ZSB7XG4gICAgY29uc3RydWN0b3IodHJlZVZpZXcpIHtcbiAgICAgICAgdGhpcy50cmVlVmlldyA9IHRyZWVWaWV3O1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgd2hlbiB0aGUgYHNlbGVjdGVkS2V5c2AgY29sbGVjdGlvbiB3YXMgdXBkYXRlZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2VsZWN0ZWRLZXlzQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMgPSBuZXcgU3Vic2NyaXB0aW9uKCk7XG4gICAgICAgIHRoaXMuc2VsZWN0QWN0aW9ucyA9IHtcbiAgICAgICAgICAgICdtdWx0aXBsZSc6IChlKSA9PiB0aGlzLnNlbGVjdE11bHRpcGxlKGUpLFxuICAgICAgICAgICAgJ3NpbmdsZSc6IChlKSA9PiB0aGlzLnNlbGVjdFNpbmdsZShlKVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9zZWxlY3RlZEtleXMgPSBbXTtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLmFkZCh0aGlzLnRyZWVWaWV3LnNlbGVjdGlvbkNoYW5nZS5zdWJzY3JpYmUodGhpcy5zZWxlY3QuYmluZCh0aGlzKSkpO1xuICAgICAgICB0aGlzLnRyZWVWaWV3LmlzU2VsZWN0ZWQgPSAoZGF0YUl0ZW0sIGluZGV4KSA9PiAodGhpcy5zZWxlY3RlZEtleXMuaW5kZXhPZih0aGlzLml0ZW1LZXkoeyBkYXRhSXRlbSwgaW5kZXggfSkpID4gLTEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgc2V0IGlzU2VsZWN0ZWQodmFsdWUpIHtcbiAgICAgICAgdGhpcy50cmVlVmlldy5pc1NlbGVjdGVkID0gdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlZmluZXMgdGhlIGNvbGxlY3Rpb24gdGhhdCB3aWxsIHN0b3JlIHRoZSBzZWxlY3RlZCBrZXlzXG4gICAgICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBzZWxlY3Rpb25fdHJlZXZpZXcgJX0jdG9jLXNlbGVjdGlvbi1tb2RlcykpLlxuICAgICAqL1xuICAgIGdldCBzZWxlY3RlZEtleXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zZWxlY3RlZEtleXM7XG4gICAgfVxuICAgIHNldCBzZWxlY3RlZEtleXMoa2V5cykge1xuICAgICAgICB0aGlzLl9zZWxlY3RlZEtleXMgPSBrZXlzO1xuICAgIH1cbiAgICBnZXQgZ2V0QXJpYU11bHRpc2VsZWN0YWJsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5tb2RlID09PSAnbXVsdGlwbGUnO1xuICAgIH1cbiAgICBnZXQgb3B0aW9ucygpIHtcbiAgICAgICAgY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICAgICAgbW9kZTogJ3NpbmdsZSdcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCFpc1ByZXNlbnQodGhpcy5zZWxlY3Rpb24pIHx8IHR5cGVvZiB0aGlzLnNlbGVjdGlvbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBkZWZhdWx0T3B0aW9ucztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzZWxlY3Rpb25TZXR0aW5ncyA9IGlzQm9vbGVhbih0aGlzLnNlbGVjdGlvbikgPyB7IGVuYWJsZWQ6IHRoaXMuc2VsZWN0aW9uIH0gOiB0aGlzLnNlbGVjdGlvbjtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oZGVmYXVsdE9wdGlvbnMsIHNlbGVjdGlvblNldHRpbmdzKTtcbiAgICB9XG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy51bnN1YnNjcmliZSgpO1xuICAgIH1cbiAgICBpdGVtS2V5KGUpIHtcbiAgICAgICAgaWYgKCF0aGlzLnNlbGVjdEtleSkge1xuICAgICAgICAgICAgcmV0dXJuIGUuaW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnNlbGVjdEtleSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBlLmRhdGFJdGVtW3RoaXMuc2VsZWN0S2V5XTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHRoaXMuc2VsZWN0S2V5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3RLZXkoZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2VsZWN0KGUpIHtcbiAgICAgICAgY29uc3QgeyBlbmFibGVkLCBtb2RlIH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIGNvbnN0IHBlcmZvcm1TZWxlY3Rpb24gPSB0aGlzLnNlbGVjdEFjdGlvbnNbbW9kZV0gfHwgbm9vcDtcbiAgICAgICAgaWYgKCFlbmFibGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcGVyZm9ybVNlbGVjdGlvbihlKTtcbiAgICB9XG4gICAgc2VsZWN0U2luZ2xlKG5vZGUpIHtcbiAgICAgICAgY29uc3Qga2V5ID0gdGhpcy5pdGVtS2V5KG5vZGUpO1xuICAgICAgICBpZiAodGhpcy5zZWxlY3RlZEtleXNbMF0gPT09IGtleSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2VsZWN0ZWRLZXlzID0gW2tleV07XG4gICAgICAgIHRoaXMubm90aWZ5KCk7XG4gICAgfVxuICAgIHNlbGVjdE11bHRpcGxlKG5vZGUpIHtcbiAgICAgICAgY29uc3Qga2V5ID0gdGhpcy5pdGVtS2V5KG5vZGUpO1xuICAgICAgICBjb25zdCBpZHggPSB0aGlzLnNlbGVjdGVkS2V5cy5pbmRleE9mKGtleSk7XG4gICAgICAgIGNvbnN0IGlzU2VsZWN0ZWQgPSBpZHggPiAtMTtcbiAgICAgICAgaWYgKCFpc1ByZXNlbnQoa2V5KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1NlbGVjdGVkKSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGVkS2V5cy5zcGxpY2UoaWR4LCAxKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRLZXlzLnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5vdGlmeSgpO1xuICAgIH1cbiAgICBub3RpZnkoKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWRLZXlzQ2hhbmdlLmVtaXQodGhpcy5zZWxlY3RlZEtleXMuc2xpY2UoKSk7XG4gICAgfVxufTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0Z1bmN0aW9uXSlcbl0sIFNlbGVjdERpcmVjdGl2ZS5wcm90b3R5cGUsIFwiaXNTZWxlY3RlZFwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCdzZWxlY3RCeScpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBTZWxlY3REaXJlY3RpdmUucHJvdG90eXBlLCBcInNlbGVjdEtleVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoJ2tlbmRvVHJlZVZpZXdTZWxlY3RhYmxlJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFNlbGVjdERpcmVjdGl2ZS5wcm90b3R5cGUsIFwic2VsZWN0aW9uXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtBcnJheV0pXG5dLCBTZWxlY3REaXJlY3RpdmUucHJvdG90eXBlLCBcInNlbGVjdGVkS2V5c1wiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIE91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXG5dLCBTZWxlY3REaXJlY3RpdmUucHJvdG90eXBlLCBcInNlbGVjdGVkS2V5c0NoYW5nZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSG9zdEJpbmRpbmcoJ2F0dHIuYXJpYS1tdWx0aXNlbGVjdGFibGUnKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgU2VsZWN0RGlyZWN0aXZlLnByb3RvdHlwZSwgXCJnZXRBcmlhTXVsdGlzZWxlY3RhYmxlXCIsIG51bGwpO1xuU2VsZWN0RGlyZWN0aXZlID0gX19kZWNvcmF0ZShbXG4gICAgRGlyZWN0aXZlKHsgc2VsZWN0b3I6ICdba2VuZG9UcmVlVmlld1NlbGVjdGFibGVdJyB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW1RyZWVWaWV3Q29tcG9uZW50XSlcbl0sIFNlbGVjdERpcmVjdGl2ZSk7XG5cbi8qKlxuICogRGVzY3JpYmVzIHRoZSBhdHRlbXB0ZWQgZHJvcCBhY3Rpb24gZHVyaW5nIGRyYWdnaW5nLlxuICogUGFzc2VkIGFzIGBhY3Rpb25gIHZhbHVlIHRvIHRoZSBbYGtlbmRvVHJlZVZpZXdEcmFnQ2x1ZVRlbXBsYXRlYF0oeyUgc2x1ZyBhcGlfdHJlZXZpZXdfZHJhZ2NsdWV0ZW1wbGF0ZWRpcmVjdGl2ZSAlfSkgZGlyZWN0aXZlLlxuICogQnkgZGVmYXVsdCwgdGhpcyB2YWx1ZSBkZWZpbmVzIHRoZSByZW5kZXJlZCBpY29uIGluIHRoZSBkcmFnIGNsdWUuXG4gKi9cbnZhciBEcm9wQWN0aW9uO1xuKGZ1bmN0aW9uIChEcm9wQWN0aW9uKSB7XG4gICAgRHJvcEFjdGlvbltEcm9wQWN0aW9uW1wiQWRkXCJdID0gMF0gPSBcIkFkZFwiO1xuICAgIERyb3BBY3Rpb25bRHJvcEFjdGlvbltcIkluc2VydFRvcFwiXSA9IDFdID0gXCJJbnNlcnRUb3BcIjtcbiAgICBEcm9wQWN0aW9uW0Ryb3BBY3Rpb25bXCJJbnNlcnRCb3R0b21cIl0gPSAyXSA9IFwiSW5zZXJ0Qm90dG9tXCI7XG4gICAgRHJvcEFjdGlvbltEcm9wQWN0aW9uW1wiSW5zZXJ0TWlkZGxlXCJdID0gM10gPSBcIkluc2VydE1pZGRsZVwiO1xuICAgIERyb3BBY3Rpb25bRHJvcEFjdGlvbltcIkludmFsaWRcIl0gPSA0XSA9IFwiSW52YWxpZFwiO1xufSkoRHJvcEFjdGlvbiB8fCAoRHJvcEFjdGlvbiA9IHt9KSk7XG5cbi8qKlxuICogRGVzY3JpYmVzIHdoZXJlIHRoZSBkcmFnZ2VkIGl0ZW0gaXMgZHJvcHBlZCByZWxhdGl2ZSB0byB0aGUgZHJvcCB0YXJnZXQgaXRlbS5cbiAqL1xudmFyIERyb3BQb3NpdGlvbjtcbihmdW5jdGlvbiAoRHJvcFBvc2l0aW9uKSB7XG4gICAgRHJvcFBvc2l0aW9uW0Ryb3BQb3NpdGlvbltcIk92ZXJcIl0gPSAwXSA9IFwiT3ZlclwiO1xuICAgIERyb3BQb3NpdGlvbltEcm9wUG9zaXRpb25bXCJCZWZvcmVcIl0gPSAxXSA9IFwiQmVmb3JlXCI7XG4gICAgRHJvcFBvc2l0aW9uW0Ryb3BQb3NpdGlvbltcIkFmdGVyXCJdID0gMl0gPSBcIkFmdGVyXCI7XG59KShEcm9wUG9zaXRpb24gfHwgKERyb3BQb3NpdGlvbiA9IHt9KSk7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG52YXIgU2Nyb2xsRGlyZWN0aW9uO1xuKGZ1bmN0aW9uIChTY3JvbGxEaXJlY3Rpb24pIHtcbiAgICBTY3JvbGxEaXJlY3Rpb25bU2Nyb2xsRGlyZWN0aW9uW1wiVXBcIl0gPSAtMV0gPSBcIlVwXCI7XG4gICAgU2Nyb2xsRGlyZWN0aW9uW1Njcm9sbERpcmVjdGlvbltcIkRvd25cIl0gPSAxXSA9IFwiRG93blwiO1xufSkoU2Nyb2xsRGlyZWN0aW9uIHx8IChTY3JvbGxEaXJlY3Rpb24gPSB7fSkpO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgUHJldmVudGFibGVFdmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMucHJldmVudGVkID0gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByZXZlbnRzIHRoZSBkZWZhdWx0IGFjdGlvbiBmb3IgYSBzcGVjaWZpZWQgZXZlbnQuXG4gICAgICogSW4gdGhpcyB3YXksIHRoZSBzb3VyY2UgY29tcG9uZW50IHN1cHByZXNzZXMgdGhlIGJ1aWx0LWluIGJlaGF2aW9yIHRoYXQgZm9sbG93cyB0aGUgZXZlbnQuXG4gICAgICovXG4gICAgcHJldmVudERlZmF1bHQoKSB7XG4gICAgICAgIHRoaXMucHJldmVudGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSWYgdGhlIGV2ZW50IGlzIHByZXZlbnRlZCBieSBhbnkgb2YgaXRzIHN1YnNjcmliZXJzLCByZXR1cm5zIGB0cnVlYC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgZGVmYXVsdCBhY3Rpb24gd2FzIHByZXZlbnRlZC4gT3RoZXJ3aXNlLCByZXR1cm5zIGBmYWxzZWAuXG4gICAgICovXG4gICAgaXNEZWZhdWx0UHJldmVudGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcmV2ZW50ZWQ7XG4gICAgfVxufVxuXG4vKipcbiAqIEFyZ3VtZW50cyBmb3IgdGhlIFRyZWVWaWV3IFtgbm9kZURyb3BgXSh7JSBzbHVnIGFwaV90cmVldmlld190cmVldmlld2NvbXBvbmVudCAlfSN0b2Mtbm9kZWRyb3ApIGV2ZW50LlxuICovXG5jbGFzcyBUcmVlSXRlbURyb3BFdmVudCBleHRlbmRzIFByZXZlbnRhYmxlRXZlbnQge1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihpbml0aWFsaXplciwgb3JpZ2luYWxFdmVudCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQGhpZGRlblxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pc1ZhbGlkID0gdHJ1ZTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCBpbml0aWFsaXplcik7XG4gICAgICAgIHRoaXMub3JpZ2luYWxFdmVudCA9IG9yaWdpbmFsRXZlbnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNwZWNpZmllcyBpZiB0aGUgZHJvcCBhY3Rpb24gc2hvdWxkIGJlIG1hcmtlZCBhcyB2YWxpZC5cbiAgICAgKiBJZiBzZXQgdG8gYGZhbHNlYCwgdGhlIFtgYWRkSXRlbWBdKHslIHNsdWcgYXBpX3RyZWV2aWV3X3RyZWV2aWV3Y29tcG9uZW50ICV9I3RvYy1hZGRpdGVtKSBhbmRcbiAgICAgKiBbYHJlbW92ZUl0ZW1gXSh7JSBzbHVnIGFwaV90cmVldmlld190cmVldmlld2NvbXBvbmVudCAlfSN0b2MtcmVtb3ZlaXRlbSkgZXZlbnRzIHdpbGwgbm90IGJlIGZpcmVkIGFuZCB0aGUgZHJhZyBjbHVlXG4gICAgICogd2lsbCBiZSBhbmltYXRlZCBiYWNrIHRvIHRoZSBzb3VyY2UgaXRlbSB0byBpbmRpY2F0ZSB0aGUgYWN0aW9uIGlzIG1hcmtlZCBhcyBpbnZhbGlkLlxuICAgICAqL1xuICAgIHNldFZhbGlkKGlzVmFsaWQpIHtcbiAgICAgICAgdGhpcy5pc1ZhbGlkID0gaXNWYWxpZDtcbiAgICB9XG59XG5cbi8qKlxuICogQXJndW1lbnRzIGZvciB0aGUgVHJlZVZpZXcgW2Bub2RlRHJhZ1N0YXJ0YF0oeyUgc2x1ZyBhcGlfdHJlZXZpZXdfdHJlZXZpZXdjb21wb25lbnQgJX0jdG9jLW5vZGVkcmFnc3RhcnQpIGV2ZW50LlxuICovXG5jbGFzcyBUcmVlSXRlbURyYWdTdGFydEV2ZW50IGV4dGVuZHMgUHJldmVudGFibGVFdmVudCB7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGluaXRpYWxpemVyKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgaW5pdGlhbGl6ZXIpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBBcmd1bWVudHMgZm9yIHRoZSBUcmVlVmlldyBbYG5vZGVEcmFnYF0oeyUgc2x1ZyBhcGlfdHJlZXZpZXdfdHJlZXZpZXdjb21wb25lbnQgJX0jdG9jLW5vZGVkcmFnKSBhbmRcbiAqIFtgbm9kZURyYWdFbmRgXSh7JSBzbHVnIGFwaV90cmVldmlld190cmVldmlld2NvbXBvbmVudCAlfSN0b2Mtbm9kZWRyYWdlbmQpIGV2ZW50cy5cbiAqL1xuY2xhc3MgVHJlZUl0ZW1EcmFnRXZlbnQge1xufVxuXG5jb25zdCDJtTAkMyA9ICgpID0+IHtcbiAgICBpZiAoIShpc0RvY3VtZW50QXZhaWxhYmxlKCkgJiYgaXNQcmVzZW50KGRvY3VtZW50LmJvZHkpKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHRvcCA9IDEwO1xuICAgIGNvbnN0IHBhcmVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgcGFyZW50LnN0eWxlLnRyYW5zZm9ybSA9IFwibWF0cml4KDEwLCAwLCAwLCAxMCwgMCwgMClcIjtcbiAgICBwYXJlbnQuaW5uZXJIVE1MID0gYDxkaXYgc3R5bGU9XCJwb3NpdGlvbjogZml4ZWQ7IHRvcDogJHt0b3B9cHg7XCI+Y2hpbGQ8L2Rpdj5gO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQocGFyZW50KTtcbiAgICBjb25zdCBpc0RpZmZlcmVudCA9IHBhcmVudC5jaGlsZHJlblswXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3AgIT09IHRvcDtcbiAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKHBhcmVudCk7XG4gICAgcmV0dXJuIGlzRGlmZmVyZW50O1xufTtcbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBicm93c2VyIHN1cHBvcnRzIHJlbGF0aXZlIHN0YWNraW5nIGNvbnRleHQuXG4gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvQ1NTX1Bvc2l0aW9uaW5nL1VuZGVyc3RhbmRpbmdfel9pbmRleC9UaGVfc3RhY2tpbmdfY29udGV4dFxuICovXG5jb25zdCBoYXNSZWxhdGl2ZVN0YWNraW5nQ29udGV4dCA9IG1lbW9pemUoybUwJDMpO1xuLyoqXG4gKiBTdG9yZXMgdGhlIHJlc3VsdCBvZiB0aGUgcGFzc2VkIGZ1bmN0aW9uJ3MgZmlyc3QgaW52b2thdGlvbiBhbmQgcmV0dXJucyBpdCBpbnN0ZWFkIG9mIGludm9raW5nIGl0IGFnYWluIGFmdGVyd2FyZHMuXG4gKi9cbmZ1bmN0aW9uIG1lbW9pemUoZm4pIHtcbiAgICBsZXQgcmVzdWx0O1xuICAgIGxldCBjYWxsZWQgPSBmYWxzZTtcbiAgICByZXR1cm4gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgaWYgKGNhbGxlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgPSBmbiguLi5hcmdzKTtcbiAgICAgICAgY2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xufVxuLyoqXG4gKiBAaGlkZGVuXG4gKlxuICogR2V0cyB0aGUgb2Zmc2V0IG9mIHRoZSBwYXJlbnQgZWxlbWVudCBpZiB0aGUgbGF0dGVyIGhhcyB0aGUgYHRyYW5zZm9ybWAgQ1NTIHByb3AgYXBwbGllZC5cbiAqIFRyYW5zZm9ybWVkIHBhcmVudHMgY3JlYXRlIG5ldyBzdGFja2luZyBjb250ZXh0IGFuZCB0aGUgYGZpeGVkYCBjaGlsZHJlbiBtdXN0IGJlIHBvc2l0aW9uIGJhc2VkIG9uIHRoZSB0cmFuc2Zvcm1lZCBwYXJlbnQuXG4gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvQ1NTX1Bvc2l0aW9uaW5nL1VuZGVyc3RhbmRpbmdfel9pbmRleC9UaGVfc3RhY2tpbmdfY29udGV4dFxuICpcbiAqIElmIG5vIHBhcmVudCBjb250YWluZXIgaXMgYHRyYW5zZm9ybWAtZWQgdGhlIGZ1bmN0aW9uIHdpbGwgcmV0dXJuIGB7IGxlZnQ6IDAsIHRvcDogMCB9YDtcbiAqL1xuY29uc3QgZ2V0Q29udGFpbmVyT2Zmc2V0ID0gKGVsZW1lbnQpID0+IHtcbiAgICBpZiAoIShlbGVtZW50ICYmIGhhc1JlbGF0aXZlU3RhY2tpbmdDb250ZXh0KCkpKSB7XG4gICAgICAgIHJldHVybiB7IGxlZnQ6IDAsIHRvcDogMCB9O1xuICAgIH1cbiAgICBsZXQgb2Zmc2V0UGFyZW50ID0gZWxlbWVudC5wYXJlbnRFbGVtZW50O1xuICAgIHdoaWxlIChvZmZzZXRQYXJlbnQpIHtcbiAgICAgICAgaWYgKHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKG9mZnNldFBhcmVudCkudHJhbnNmb3JtICE9PSAnbm9uZScpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIG9mZnNldFBhcmVudCA9IG9mZnNldFBhcmVudC5wYXJlbnRFbGVtZW50O1xuICAgIH1cbiAgICBpZiAob2Zmc2V0UGFyZW50KSB7XG4gICAgICAgIGNvbnN0IHJlY3QgPSBvZmZzZXRQYXJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsZWZ0OiByZWN0LmxlZnQgLSBvZmZzZXRQYXJlbnQuc2Nyb2xsTGVmdCxcbiAgICAgICAgICAgIHRvcDogcmVjdC50b3AgLSBvZmZzZXRQYXJlbnQuc2Nyb2xsVG9wXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7IGxlZnQ6IDAsIHRvcDogMCB9O1xufTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBnZXREcm9wQWN0aW9uID0gKGRyb3BQb3NpdGlvbiwgZHJvcFRhcmdldCkgPT4ge1xuICAgIGlmICghKGlzUHJlc2VudChkcm9wUG9zaXRpb24pICYmIGlzUHJlc2VudChkcm9wVGFyZ2V0KSkpIHtcbiAgICAgICAgcmV0dXJuIERyb3BBY3Rpb24uSW52YWxpZDtcbiAgICB9XG4gICAgc3dpdGNoIChkcm9wUG9zaXRpb24pIHtcbiAgICAgICAgY2FzZSBEcm9wUG9zaXRpb24uT3ZlcjpcbiAgICAgICAgICAgIHJldHVybiBEcm9wQWN0aW9uLkFkZDtcbiAgICAgICAgY2FzZSBEcm9wUG9zaXRpb24uQmVmb3JlOlxuICAgICAgICAgICAgcmV0dXJuIGlzUHJlc2VudChjbG9zZXN0Tm9kZShkcm9wVGFyZ2V0KS5wcmV2aW91c0VsZW1lbnRTaWJsaW5nKSA/IERyb3BBY3Rpb24uSW5zZXJ0TWlkZGxlIDogRHJvcEFjdGlvbi5JbnNlcnRUb3A7XG4gICAgICAgIGNhc2UgRHJvcFBvc2l0aW9uLkFmdGVyOlxuICAgICAgICAgICAgcmV0dXJuIGlzUHJlc2VudChjbG9zZXN0Tm9kZShkcm9wVGFyZ2V0KS5uZXh0RWxlbWVudFNpYmxpbmcpID8gRHJvcEFjdGlvbi5JbnNlcnRNaWRkbGUgOiBEcm9wQWN0aW9uLkluc2VydEJvdHRvbTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBEcm9wQWN0aW9uLkludmFsaWQ7XG4gICAgfVxufTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBnZXREcm9wUG9zaXRpb24gPSAoZHJhZ2dlZEl0ZW0sIHRhcmdldCwgY2xpZW50WSwgdGFyZ2V0VHJlZVZpZXcsIGNvbnRhaW5lck9mZnNldCkgPT4ge1xuICAgIGlmICghKGlzUHJlc2VudChkcmFnZ2VkSXRlbSkgJiYgaXNQcmVzZW50KHRhcmdldCkgJiYgaXNQcmVzZW50KHRhcmdldFRyZWVWaWV3KSAmJiBpc1ByZXNlbnQoY29udGFpbmVyT2Zmc2V0KSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyB0aGUgLmstbWlkIGVsZW1lbnQgc3RhcnRzIGp1c3QgYWZ0ZXIgdGhlIGNoZWNrYm94L2V4cGFuZCBhcnJvdyBhbmQgc3RyZXRjaGVzIHRpbGwgdGhlIGVuZCBvZiB0aGUgdHJlZXZpZXcgb24gdGhlIHJpZ2h0XG4gICAgY29uc3QgaXRlbSA9IGNsb3Nlc3RXaXRoTWF0Y2godGFyZ2V0LCAnLmstbWlkJyk7XG4gICAgaWYgKCFpc1ByZXNlbnQoaXRlbSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyB0aGUgY29udGVudCBlbGVtZW50ICguay1pbjpub3QoLmstdHJlZXZpZXctbG9hZC1tb3JlLWJ1dHRvbikpIGhvbGRzIGp1c3QgdGhlIHRyZWV2aWV3IGl0ZW0gdGV4dFxuICAgIGNvbnN0IGNvbnRlbnQgPSBnZXRDb250ZW50RWxlbWVudChpdGVtKTtcbiAgICBjb25zdCB0YXJnZXRDaGlsZE9mRHJhZ2dlZEl0ZW0gPSBoYXNQYXJlbnQoaXRlbSwgY2xvc2VzdE5vZGUoZHJhZ2dlZEl0ZW0pKTtcbiAgICBpZiAoIWlzUHJlc2VudChjb250ZW50KSB8fCAoY29udGVudCA9PT0gZHJhZ2dlZEl0ZW0pIHx8IHRhcmdldENoaWxkT2ZEcmFnZ2VkSXRlbSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGl0ZW1WaWV3UG9ydENvb3JkcyA9IGNvbnRlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgLypcbiAgICAgICAgaWYgdGhlIHVzZXIgaXMgaG92ZXJpbmcgYSB0cmVldmlldyBpdGVtLCBzcGxpdCB0aGUgaXRlbSBoZWlnaHQgaW50byBmb3VyIHBhcnRzOlxuICAgICAgICAgICAgLSBkcm9wcGluZyBpbnRvIHRoZSB0b3AgcXVhcnRlciBzaG91bGQgaW5zZXJ0IHRoZSBkcmFnZ2VkIGl0ZW0gYmVmb3JlIHRoZSBkcm9wIHRhcmdldFxuICAgICAgICAgICAgLSBkcm9wcGluZyBpbnRvIHRoZSBib3R0b20gcXVhcnRlciBzaG91bGQgaW5zZXJ0IHRoZSBkcmFnZ2VkIGl0ZW0gYWZ0ZXIgdGhlIGRyb3AgdGFyZ2V0XG4gICAgICAgICAgICAtIGRyb3BwaW5nIGludG8gdGhlIHNlY29uZCBvciB0aGlyZCBxdWFydGVyIHNob3VsZCBhZGQgdGhlIGl0ZW0gYXMgY2hpbGQgbm9kZSBvZiB0aGUgZHJvcCB0YXJnZXRcblxuICAgICAgICBpZiB0aGUgdXNlciBpcyBOT1QgaG92ZXJpbmcgYSB0cmVldmlldyBpdGVtIChoZSdzIGRyYWdnaW5nIHNvbWV3aGVyZSBvbiB0aGUgcmlnaHQpLCBzcGxpdCB0aGUgaXRlbSBoZWlnaHQgdG8ganVzdCB0d28gcGFydHM6XG4gICAgICAgICAgICAtIGRyb3BwaW5nIHNob3VsZCBpbnNlcnQgYmVmb3JlIG9yIGFmdGVyXG4gICAgKi9cbiAgICBjb25zdCBpdGVtRGl2aXNpb25IZWlnaHQgPSBpdGVtVmlld1BvcnRDb29yZHMuaGVpZ2h0IC8gKGlzQ29udGVudCh0YXJnZXQpID8gNCA6IDIpO1xuICAgIC8vIGNsZWFyIGFueSBwb3NzaWJsZSBjb250YWluZXIgb2Zmc2V0IGNyZWF0ZWQgYnkgcGFyZW50IGVsZW1lbnRzIHdpdGggYHRyYW5zZm9ybWAgY3NzIHByb3BlcnR5IHNldFxuICAgIGNvbnN0IHBvaW50ZXJQb3NpdGlvbiA9IGNsaWVudFkgLSBjb250YWluZXJPZmZzZXQudG9wO1xuICAgIGNvbnN0IGl0ZW1Ub3AgPSBpdGVtVmlld1BvcnRDb29yZHMudG9wIC0gY29udGFpbmVyT2Zmc2V0LnRvcDtcbiAgICBpZiAocG9pbnRlclBvc2l0aW9uIDwgaXRlbVRvcCArIGl0ZW1EaXZpc2lvbkhlaWdodCkge1xuICAgICAgICByZXR1cm4gRHJvcFBvc2l0aW9uLkJlZm9yZTtcbiAgICB9XG4gICAgaWYgKHBvaW50ZXJQb3NpdGlvbiA+PSBpdGVtVG9wICsgaXRlbVZpZXdQb3J0Q29vcmRzLmhlaWdodCAtIGl0ZW1EaXZpc2lvbkhlaWdodCkge1xuICAgICAgICByZXR1cm4gRHJvcFBvc2l0aW9uLkFmdGVyO1xuICAgIH1cbiAgICByZXR1cm4gRHJvcFBvc2l0aW9uLk92ZXI7XG59O1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IHRyZWVJdGVtRnJvbUV2ZW50VGFyZ2V0ID0gKHRyZWVWaWV3LCBkcm9wVGFyZ2V0KSA9PiB7XG4gICAgaWYgKCEoaXNQcmVzZW50KHRyZWVWaWV3KSAmJiBpc1ByZXNlbnQoZHJvcFRhcmdldCkpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBub2RlID0gY2xvc2VzdE5vZGUoZHJvcFRhcmdldCk7XG4gICAgY29uc3QgaW5kZXggPSBub2RlSWQobm9kZSk7XG4gICAgY29uc3QgbG9va3VwID0gdHJlZVZpZXcuaXRlbUxvb2t1cChpbmRleCk7XG4gICAgaWYgKCEoaXNQcmVzZW50KGxvb2t1cCkgJiYgaXNQcmVzZW50KGxvb2t1cC5pdGVtLmRhdGFJdGVtKSkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBsb29rdXA7XG59O1xuLyoqXG4gKiBAaGlkZGVuXG4gKlxuICogRW1pdHMgYGNvbGxhcHNlYCBvbiB0aGUgc3BlY2lmaWVkIFRyZWVWaWV3IG5vZGUgaWYgdGhlIGxhdHRlciBpcyBsZWZ0IGVtcHR5IGFmdGVyIGl0cyBsYXN0IGNoaWxkIG5vZGUgd2FzIGRyYWdnZWQgb3V0LlxuICovXG5jb25zdCBjb2xsYXBzZUVtcHR5UGFyZW50ID0gKHBhcmVudCwgcGFyZW50Tm9kZXMsIHRyZWV2aWV3KSA9PiB7XG4gICAgaWYgKGlzUHJlc2VudChwYXJlbnQpICYmIHBhcmVudE5vZGVzLmxlbmd0aCA9PT0gMCAmJiB0cmVldmlldy5pc0V4cGFuZGVkKHBhcmVudC5pdGVtLmRhdGFJdGVtLCBwYXJlbnQuaXRlbS5pbmRleCkpIHtcbiAgICAgICAgdHJlZXZpZXcuY29sbGFwc2VOb2RlKHBhcmVudC5pdGVtLmRhdGFJdGVtLCBwYXJlbnQuaXRlbS5pbmRleCk7XG4gICAgfVxufTtcbi8qKlxuICogQGhpZGRlblxuICpcbiAqIEV4cGFuZHMgdGhlIG5vZGUgaWYgaXQncyBkcm9wcGVkIGludG8gYW5kIGl0J3Mgbm90IHlldCBleHBhbmRlZC5cbiAqL1xuY29uc3QgZXhwYW5kRHJvcFRhcmdldCA9IChkcm9wVGFyZ2V0LCB0cmVlVmlldykgPT4ge1xuICAgIGlmICghdHJlZVZpZXcuaXNFeHBhbmRlZChkcm9wVGFyZ2V0Lml0ZW0uZGF0YUl0ZW0sIGRyb3BUYXJnZXQuaXRlbS5pbmRleCkpIHtcbiAgICAgICAgdHJlZVZpZXcuZXhwYW5kTm9kZShkcm9wVGFyZ2V0Lml0ZW0uZGF0YUl0ZW0sIGRyb3BUYXJnZXQuaXRlbS5pbmRleCk7XG4gICAgfVxufTtcbi8qKlxuICogQGhpZGRlblxuICpcbiAqIEV4dHJhY3RzIHRoZSBldmVudCB0YXJnZXQgZnJvbSB0aGUgdmlld3BvcnQgY29vcmRzLiBSZXF1aXJlZCBmb3IgdG91Y2ggZGV2aWNlc1xuICogd2hlcmUgdGhlIGBldmVudC50YXJnZXRgIG9mIGEgYHBvaW50ZXJtb3ZlYCBldmVudCBpcyBhbHdheXMgdGhlIGluaXRpYWxseSBkcmFnZ2VkIGl0ZW0uXG4gKi9cbmNvbnN0IGdldERyb3BUYXJnZXQgPSAoZXZlbnQpID0+IHtcbiAgICBpZiAoIShpc0RvY3VtZW50QXZhaWxhYmxlKCkgJiYgaXNQcmVzZW50KGRvY3VtZW50LmVsZW1lbnRGcm9tUG9pbnQpKSkge1xuICAgICAgICByZXR1cm4gZXZlbnQudGFyZ2V0O1xuICAgIH1cbiAgICByZXR1cm4gZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludChldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZKTtcbn07XG4vKipcbiAqIEBoaWRkZW5cbiAqXG4gKiBDaGVja3MgaWYgdGhlIG9yaWdpbmFsIGluZGV4IGlzIGJlZm9yZSB0aGUgbmV3IG9uZSBhbmQgY29ycmVjdHMgdGhlIG5ldyBvbmUgYnkgZGVjcmVtZW50aW5nIHRoZSBpbmRleCBmb3IgdGhlIGxldmVsLCB3aGVyZSB0aGUgb3JpZ2luYWwgaXRlbSBzdG9vZC5cbiAqL1xuY29uc3QgdXBkYXRlTW92ZWRJdGVtSW5kZXggPSAobmV3SW5kZXgsIG9yaWdpbmFsSW5kZXgpID0+IHtcbiAgICBjb25zdCBtb3ZlZEl0ZW1OZXdJbmRleFBhcnRzID0gbmV3SW5kZXguc3BsaXQoJ18nKTtcbiAgICBjb25zdCBvcmlnaW5hbEl0ZW1JbmRleFBhcnRzID0gb3JpZ2luYWxJbmRleC5zcGxpdCgnXycpO1xuICAgIC8vIGlmIHRoZSBvcmlnaW5hbCBpdGVtIHdhcyBtb3ZlZCBmcm9tIGEgZGVlcGVyIGxldmVsLCB0aGVyZSdzIG5vIG5lZWQgZm9yIGluZGV4IGNvcnJlY3Rpb25cbiAgICAvLyBlLmcuIDRfMF8xIGlzIG1vdmVkIHRvIDVfMCA9PiByZW1vdmluZyA0XzBfMSB3aWxsIG5vdCBjYXVzZSA1XzAgdG8gYmUgbW92ZWRcbiAgICBpZiAobW92ZWRJdGVtTmV3SW5kZXhQYXJ0cy5sZW5ndGggPCBvcmlnaW5hbEl0ZW1JbmRleFBhcnRzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gbmV3SW5kZXg7XG4gICAgfVxuICAgIC8vIGNoZWNrIGlmIHRoZSBwYXJlbnQgaXRlbSBwYXRocyBhcmUgdGhlIHNhbWUgLSBpbmRleCBjb3JyZWN0aW9uIGlzIG5vdCByZXF1aXJlZCB3aGVuIHRoZSBvcmlnaW5hbCBpdGVtIHBhdGggZGlmZmVycyBmcm9tIHRoZSBwYXRoIG9mIHRoZSBtb3ZlZCBpdGVtIC0gdGhleSBiZWxvbmcgdG8gZGlmZmVyZW50IGhpZXJhcmNoaWVzXG4gICAgLy8gZS5nLiA0XzEgaXMgbW92ZWQgdG8gNV8xIC0gdGhlIHBhcmVudCBpdGVtIHBhdGhzIGFyZSBkaWZmZXJlbiAoNCBjb21wYXJlZCB0byA1KSA9PiByZW1vdmluZyA0XzEgd2lsbCBub3QgY2F1c2UgNV8xIHRvIGJlIG1vdmVkXG4gICAgLy8gZS5nIDRfMSBpcyBtb3ZlZCB0byA0XzMgLSB0aGUgcGFyZW50IHBhdGhzIGFyZSB0aGUgc2FtZSAoYm90aCA0KSA9PiByZW1vdmluZyA0XzEgd2lsbCBjYXVzZSA0XzMgdG8gYmUgbW92ZWRcbiAgICBjb25zdCBvcmlnaW5hbEl0ZW1QYXJlbnRQYXRoTGVuZ3RoID0gb3JpZ2luYWxJdGVtSW5kZXhQYXJ0cy5sZW5ndGggLSAxO1xuICAgIGNvbnN0IG9yaWdpbmFsSXRlbVBhcmVudFBhdGggPSBvcmlnaW5hbEl0ZW1JbmRleFBhcnRzLnNsaWNlKDAsIG9yaWdpbmFsSXRlbVBhcmVudFBhdGhMZW5ndGgpLmpvaW4oJ18nKTtcbiAgICBjb25zdCBtb3ZlZEl0ZW1QYXJlbnRQYXRoID0gbW92ZWRJdGVtTmV3SW5kZXhQYXJ0cy5zbGljZSgwLCBvcmlnaW5hbEl0ZW1QYXJlbnRQYXRoTGVuZ3RoKS5qb2luKCdfJyk7XG4gICAgLy8gY2hlY2sgaWYgdGhlIHRoZSBpbmRleCBvZiB0aGUgbGV2ZWwgd2hlcmUgdGhlIG9yaWdpbmFsIGl0ZW0gaXMgdGFrZW4gZnJvbSBpcyBncmVhdGVyIHRoYW4gdGhlIG9uZSBvZiB0aGUgbW92ZWQgaXRlbVxuICAgIC8vIGUuZy4gNF81IGlzIG1vdmVkIHRvIDRfMSAoY29tYXByZSA1IGFuZCAxKSA9PiByZW1vdmluZyA0XzUgd2lsbCBub3QgY2F1c2UgNF8xIHRvIGJlIG1vdmVkXG4gICAgLy8gZS5nLiA0XzEgaXMgbW92ZWQgdG8gNF81IChjb21hcHJlIDEgYW5kIDUpID0+IHJlbW92aW5nIDRfMSB3aWxsIGNhdXNlIDRfNSB0byBiZSBtb3ZlZFxuICAgIGNvbnN0IG9yaWdpbmFsSXRlbUluZGV4TGV2ZWwgPSBvcmlnaW5hbEl0ZW1JbmRleFBhcnRzLmxlbmd0aCAtIDE7XG4gICAgY29uc3Qgb3JpZ2luYWxJdGVtTGV2ZWxJbmRleCA9IE51bWJlcihvcmlnaW5hbEl0ZW1JbmRleFBhcnRzW29yaWdpbmFsSXRlbUluZGV4TGV2ZWxdKTtcbiAgICBjb25zdCBtb3ZlZEl0ZW1MZXZlbEluZGV4ID0gTnVtYmVyKG1vdmVkSXRlbU5ld0luZGV4UGFydHNbb3JpZ2luYWxJdGVtSW5kZXhMZXZlbF0pO1xuICAgIGlmICgob3JpZ2luYWxJdGVtUGFyZW50UGF0aCA9PT0gbW92ZWRJdGVtUGFyZW50UGF0aCkgJiYgKG1vdmVkSXRlbUxldmVsSW5kZXggPiBvcmlnaW5hbEl0ZW1MZXZlbEluZGV4KSkge1xuICAgICAgICAvLyBpZiB0aGUgcmVtb3ZlZCBpdGVtIGNhdXNlcyB0aGUgZHJvcHBlZCBpdGVtIHRvIGJlIG1vdmVkIGEgcG9zaXRpb24gdXAgLSBkZWNyZW1lbnQgdGhlIGluZGV4IGF0IHRoYXQgbGV2ZWxcbiAgICAgICAgbW92ZWRJdGVtTmV3SW5kZXhQYXJ0c1tvcmlnaW5hbEl0ZW1JbmRleExldmVsXSA9IFN0cmluZyhtb3ZlZEl0ZW1MZXZlbEluZGV4IC0gMSk7XG4gICAgICAgIHJldHVybiBtb3ZlZEl0ZW1OZXdJbmRleFBhcnRzLmpvaW4oJ18nKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ld0luZGV4O1xufTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBTQ1JPTExCQVJfUkVHX0VYUCA9IG5ldyBSZWdFeHAoJyhhdXRvfHNjcm9sbCknKTtcbi8qKlxuICogQGhpZGRlblxuICpcbiAqIFJldHJpdmVzIHRoZSBmaXJzdCBzY3JvbGxhYmxlIGVsZW1lbnQgc3RhcnRpbmcgdGhlIHNlYXJjaCBmcm9tIHRoZSBwcm92aWRlZCBvbmUsIHRyYXZlcnNpbmcgdG8gdGhlIHRvcCBvZiB0aGUgRE9NIHRyZWUuXG4gKi9cbmNvbnN0IGdldFNjcm9sbGFibGVDb250YWluZXIgPSAobm9kZSkgPT4ge1xuICAgIHdoaWxlIChpc1ByZXNlbnQobm9kZSkgJiYgbm9kZS5ub2RlTmFtZSAhPT0gJ0hUTUwnKSB7XG4gICAgICAgIGNvbnN0IGhhc092ZXJmbG93ID0gbm9kZS5zY3JvbGxIZWlnaHQgPiBub2RlLmNsaWVudEhlaWdodDtcbiAgICAgICAgY29uc3QgaGFzU2Nyb2xsYmFyID0gU0NST0xMQkFSX1JFR19FWFAudGVzdChnZXRDb21wdXRlZFN0eWxlKG5vZGUpLm92ZXJmbG93WSk7XG4gICAgICAgIGlmIChoYXNPdmVyZmxvdyAmJiBoYXNTY3JvbGxiYXIpIHtcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xufTtcbi8qKlxuICogQGhpZGRlblxuICpcbiAqIENoZWNrcyBpZiB0aGUgdG9wIG9mIHRoZSBzY3JvbGxhYmxlIGVsZW1lbnQgaXMgcmVhY2hlZC5cbiAqIEZsb29ycyB0aGUgc2Nyb2xsVG9wIHZhbHVlLlxuICovXG5jb25zdCBpc1RvcFJlYWNoZWQgPSAoZWxlbWVudCkgPT4gTWF0aC5mbG9vcihlbGVtZW50LnNjcm9sbFRvcCkgPD0gMDtcbi8qKlxuICogQGhpZGRlblxuICpcbiAqIENoZWNrcyBpZiB0aGUgYm90dG9tIG9mIHRoZSBzY3JvbGxhYmxlIGVsZW1lbnQgaXMgcmVhY2hlZC5cbiAqIENlaWxzIHRoZSBzY3JvbGxUb3AgdmFsdWUuXG4gKi9cbmNvbnN0IGlzQm90dG9tUmVhY2hlZCA9IChlbGVtZW50KSA9PiBNYXRoLmNlaWwoZWxlbWVudC5zY3JvbGxUb3ApID49IGVsZW1lbnQuc2Nyb2xsSGVpZ2h0IC0gZWxlbWVudC5jbGllbnRIZWlnaHQ7XG4vKipcbiAqIEBoaWRkZW5cbiAqXG4gKiBTY3JvbGxzIHRoZSBlbGVtZW50IGluIHRoZSBnaXZlbiBkaXJlY3Rpb24gYnkgdGhlIHByb3ZpZGVkIHN0ZXAuXG4gKlxuICogSWYgdGhlIHRhcmdldGVkIHNjcm9sbCBpbmNyZW1lbnRhdGlvbiBkb2Vzbid0IHlpZWxkIGFueSByZXN1bHQgZHVlIHRvIGRldmljZSBwaXhlbCByYXRpbyBpc3N1ZXMgKGh0dHBzOi8vZ2l0aHViLmNvbS9kaW1pdGFyLXBlY2hldi9SZW5kZXJpbmdJbmRlcGVuZGVudFNjcm9sbE9mZnNldHMjcmVhZG1lKSxcbiAqIGluY3JlbWVudHMgdGhlIHN0ZXAgd2l0aCAxcHggYW5kIGFnYWluIGF0dGVtcHRzIHRvIGNoYW5nZSB0aGUgc2Nyb2xsVG9wIG9mIHRoZSBlbGVtZW50LCB1bnRpbCB0aGUgY29udGVudCBpcyBhY3R1YWxseSBzY3JvbGxlZC5cbiAqXG4gKiBDdXRzIHRoZSBvcGVyYXRpb24gc2hvcnQgYWZ0ZXIgMjAgdW5zdWNjZXNzZnVsIGF0dGVtcHRzIHRvIHByZXZlbnQgaW5maW5pdGUgbG9vcHMgaW4gcG9zc2libGUgY29ybmVyLWNhc2Ugc2NlbmFyaW9zLlxuICovXG5jb25zdCBzY3JvbGxFbGVtZW50QnkgPSAoZWxlbWVudCwgc3RlcCwgZGlyZWN0aW9uKSA9PiB7XG4gICAgaWYgKCEoaXNQcmVzZW50KGVsZW1lbnQpICYmIGlzRG9jdW1lbnRBdmFpbGFibGUoKSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBpbml0aWFsU2Nyb2xsVG9wID0gZWxlbWVudC5zY3JvbGxUb3A7XG4gICAgbGV0IGN1cnJlbnRTdGVwID0gc3RlcDtcbiAgICBsZXQgaXRlcmF0aW9ucyA9IDA7XG4gICAgd2hpbGUgKGluaXRpYWxTY3JvbGxUb3AgPT09IGVsZW1lbnQuc2Nyb2xsVG9wICYmXG4gICAgICAgICEoZGlyZWN0aW9uID09PSBTY3JvbGxEaXJlY3Rpb24uVXAgJiYgaXNUb3BSZWFjaGVkKGVsZW1lbnQpKSAmJlxuICAgICAgICAhKGRpcmVjdGlvbiA9PT0gU2Nyb2xsRGlyZWN0aW9uLkRvd24gJiYgaXNCb3R0b21SZWFjaGVkKGVsZW1lbnQpKSAmJlxuICAgICAgICBpdGVyYXRpb25zIDwgMjAgLy8gYXMgdGhlIGJ1bGdhcmlhbiBzYXlpbmcgZ29lcyAtIHRvIHRpZXMgb3VyIHVuZGVycGFudHNcbiAgICApIHtcbiAgICAgICAgZWxlbWVudC5zY3JvbGxUb3AgKz0gKGN1cnJlbnRTdGVwICogZGlyZWN0aW9uKTtcbiAgICAgICAgY3VycmVudFN0ZXAgKz0gMTtcbiAgICAgICAgaXRlcmF0aW9ucyArPSAxO1xuICAgIH1cbn07XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBjb3B5UGFnZVNpemUgPSAodHJlZXZpZXcsIHNvdXJjZSwgdGFyZ2V0KSA9PiB7XG4gICAgaWYgKCFpc1ByZXNlbnQodHJlZXZpZXcubG9hZE1vcmVTZXJ2aWNlKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHNvdXJjZUdyb3VwU2l6ZSA9IHRyZWV2aWV3LmdldE5vZGVQYWdlU2l6ZShzb3VyY2UpO1xuICAgIHRyZWV2aWV3LnNldE5vZGVQYWdlU2l6ZSh0YXJnZXQsIHNvdXJjZUdyb3VwU2l6ZSk7XG59O1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGluY3JlbWVudFBhZ2VTaXplID0gKHRyZWV2aWV3LCBkYXRhSXRlbSkgPT4ge1xuICAgIGlmICghaXNQcmVzZW50KHRyZWV2aWV3LmxvYWRNb3JlU2VydmljZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjdXJyZW50UGFnZVNpemUgPSB0cmVldmlldy5nZXROb2RlUGFnZVNpemUoZGF0YUl0ZW0pO1xuICAgIHRyZWV2aWV3LnNldE5vZGVQYWdlU2l6ZShkYXRhSXRlbSwgY3VycmVudFBhZ2VTaXplICsgMSk7XG59O1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGRlY3JlbWVudFBhZ2VTaXplID0gKHRyZWV2aWV3LCBkYXRhSXRlbSkgPT4ge1xuICAgIGlmICghaXNQcmVzZW50KHRyZWV2aWV3LmxvYWRNb3JlU2VydmljZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjdXJyZW50UGFnZVNpemUgPSB0cmVldmlldy5nZXROb2RlUGFnZVNpemUoZGF0YUl0ZW0pO1xuICAgIHRyZWV2aWV3LnNldE5vZGVQYWdlU2l6ZShkYXRhSXRlbSwgY3VycmVudFBhZ2VTaXplIC0gMSk7XG59O1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgSGllcmFyY2h5RWRpdGluZ1NlcnZpY2Uge1xuICAgIGNvbnN0cnVjdG9yKGhpZXJhcmNoeUJpbmRpbmcpIHtcbiAgICAgICAgdGhpcy5oaWVyYXJjaHlCaW5kaW5nID0gaGllcmFyY2h5QmluZGluZztcbiAgICB9XG4gICAgYWRkKHsgc291cmNlSXRlbSwgZGVzdGluYXRpb25JdGVtLCBkcm9wUG9zaXRpb24sIHNvdXJjZVRyZWUsIGRlc3RpbmF0aW9uVHJlZSB9KSB7XG4gICAgICAgIC8vIHNoYWxsb3cgY2xvbmUgdGhlIGl0ZW0gYXMgbm90IHRvIG1pc3Rha2UgaXQgZm9yIGl0cyAnb2xkZXInIHZlcnNpb24gd2hlbiB0aGUgcmVtb3ZlIGhhbmRsZXIga2lja3MgaW4gdG8gc3BsaWNlIHRoZSBpdGVtIGF0IGl0cyBvbGQgcG9zaXRpb25cbiAgICAgICAgY29uc3QgY2xvbmVkU291cmNlRGF0YUl0ZW0gPSBPYmplY3QuYXNzaWduKHt9LCBnZXREYXRhSXRlbShzb3VyY2VJdGVtKSk7XG4gICAgICAgIGlmIChkcm9wUG9zaXRpb24gPT09IERyb3BQb3NpdGlvbi5PdmVyKSB7XG4gICAgICAgICAgICAvLyBleHBhbmQgdGhlIGl0ZW0gdGhhdCB3YXMgZHJvcHBlZCBpbnRvXG4gICAgICAgICAgICBleHBhbmREcm9wVGFyZ2V0KGRlc3RpbmF0aW9uSXRlbSwgZGVzdGluYXRpb25UcmVlKTtcbiAgICAgICAgICAgIGNvbnN0IGRlc3RpbmF0aW9uQ2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuRm9yKGdldERhdGFJdGVtKGRlc3RpbmF0aW9uSXRlbSkpO1xuICAgICAgICAgICAgLy8gYWRkIHRoZSBtb3ZlZCBub2RlIGp1c3QgYmVmb3JlIHRoZSBsb2FkIG1vcmUgYnV0dG9uIGlmIGxvYWQgbW9yZSBpcyBlbmFibGVkXG4gICAgICAgICAgICBjb25zdCB0YXJnZXRJbmRleCA9IGlzUHJlc2VudChkZXN0aW5hdGlvblRyZWUubG9hZE1vcmVTZXJ2aWNlKSA/XG4gICAgICAgICAgICAgICAgTWF0aC5taW4oZGVzdGluYXRpb25UcmVlLmxvYWRNb3JlU2VydmljZS5nZXRHcm91cFNpemUoZ2V0RGF0YUl0ZW0oZGVzdGluYXRpb25JdGVtKSksIGRlc3RpbmF0aW9uQ2hpbGRyZW4ubGVuZ3RoKSA6IC8vIHRoZSBwYWdlIHNpemUgbWlnaHQgYmUgZ3JlYXRlciB0aGFuIHRoZSBhY3R1YWwgY2hpbGRyZW4gYXJyYXkgbGVuZ3RoXG4gICAgICAgICAgICAgICAgZGVzdGluYXRpb25DaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgICAgICBkZXN0aW5hdGlvbkNoaWxkcmVuLnNwbGljZSh0YXJnZXRJbmRleCwgMCwgY2xvbmVkU291cmNlRGF0YUl0ZW0pO1xuICAgICAgICAgICAgc2V0dGVyKHRoaXMuaGllcmFyY2h5QmluZGluZy5jaGlsZHJlbkZpZWxkKShnZXREYXRhSXRlbShkZXN0aW5hdGlvbkl0ZW0pLCBkZXN0aW5hdGlvbkNoaWxkcmVuKTtcbiAgICAgICAgICAgIHRoaXMubW92ZWRJdGVtTmV3SW5kZXggPSBidWlsZFRyZWVJbmRleChkZXN0aW5hdGlvbkl0ZW0uaXRlbS5pbmRleCwgdGFyZ2V0SW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgZGVzdGluYXRpb25QYXJlbnROb2RlcyA9IHRoaXMuZ2V0UGFyZW50Tm9kZXMoZGVzdGluYXRpb25JdGVtLCBkZXN0aW5hdGlvblRyZWUpO1xuICAgICAgICAgICAgY29uc3Qgc2hpZnRJbmRleCA9IGRyb3BQb3NpdGlvbiA9PT0gRHJvcFBvc2l0aW9uLkFmdGVyID8gMSA6IDA7XG4gICAgICAgICAgICBjb25zdCB0YXJnZXRJbmRleCA9IGRlc3RpbmF0aW9uUGFyZW50Tm9kZXMuaW5kZXhPZihnZXREYXRhSXRlbShkZXN0aW5hdGlvbkl0ZW0pKSArIHNoaWZ0SW5kZXg7XG4gICAgICAgICAgICBkZXN0aW5hdGlvblBhcmVudE5vZGVzLnNwbGljZSh0YXJnZXRJbmRleCwgMCwgY2xvbmVkU291cmNlRGF0YUl0ZW0pO1xuICAgICAgICAgICAgY29uc3QgcGFyZW50SW5kZXggPSBkZXN0aW5hdGlvbkl0ZW0ucGFyZW50ID8gZGVzdGluYXRpb25JdGVtLnBhcmVudC5pdGVtLmluZGV4IDogbnVsbDtcbiAgICAgICAgICAgIHRoaXMubW92ZWRJdGVtTmV3SW5kZXggPSBidWlsZFRyZWVJbmRleChwYXJlbnRJbmRleCwgdGFyZ2V0SW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGluY3JlbWVudCB0aGUgcGFyZW50IHBhZ2Ugc2l6ZSA9PiBhbiBpdGVtIGlzIG1vdmVkIGludG8gaXRcbiAgICAgICAgY29uc3QgdXBkYXRlZFBhcmVudCA9IGRyb3BQb3NpdGlvbiA9PT0gRHJvcFBvc2l0aW9uLk92ZXIgPyBnZXREYXRhSXRlbShkZXN0aW5hdGlvbkl0ZW0pIDogZ2V0RGF0YUl0ZW0oZGVzdGluYXRpb25JdGVtLnBhcmVudCk7XG4gICAgICAgIGluY3JlbWVudFBhZ2VTaXplKGRlc3RpbmF0aW9uVHJlZSwgdXBkYXRlZFBhcmVudCk7XG4gICAgICAgIC8vIHRoZSBwYWdlIHNpemVzIGFyZSBzdG9yZWQgYnkgZGF0YS1pdGVtIHJlZmVyZW5jZSA9PiBjb3B5IHRoZSBvbGQgaXRlbSByZWYgcGFnZSBzaXplIHRvIHRoZSBuZXcgaXRlbSByZWZlcmVuY2VcbiAgICAgICAgY29weVBhZ2VTaXplKGRlc3RpbmF0aW9uVHJlZSwgZ2V0RGF0YUl0ZW0oc291cmNlSXRlbSksIGNsb25lZFNvdXJjZURhdGFJdGVtKTtcbiAgICAgICAgLy8gdGhlIHNvdXJjZSB0cmVlIG5vZGVzIGFyZSByZWxvYWRlZCBvbiBgcmVtb3ZlSXRlbWAgLSByZWxvYWQgdGhlIGRlc3RpbmF0aW9uIHRyZWUgbm9kZXMgaWYgdGhlIHNvcnVjZSBhbmQgdGhlIGRlc3RpbmF0aW9uIHRyZWUgYXJlIGRpZmZlcmVudFxuICAgICAgICBpZiAoc291cmNlVHJlZSAhPT0gZGVzdGluYXRpb25UcmVlICYmICFkZXN0aW5hdGlvblRyZWUubG9hZE9uRGVtYW5kKSB7XG4gICAgICAgICAgICBkZXN0aW5hdGlvblRyZWUucHJlbG9hZENoaWxkTm9kZXMoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpZiB0aGUgc291cmNlIGFuZCBkZXN0aW5hdGlvbiB0cmVlcyBhcmUgdGhlIHNhbWUsIGZvY3VzaW5nIHRoZSBtb3ZlZCBpdGVtIGhlcmUgd2lsbCBub3QgaGF2ZSB0aGUgZGVzaXJlZCBlZmZlY3RcbiAgICAgICAgLy8gYXMgdGhlIGByZW1vdmVgIGhhbmRsZXIgaGFzIG5vdCB5ZXQga2lja2VkLWluIHRvIHJlbW92ZSB0aGUgaXRlbSBmcm9tIGl0cyBvbGQgcG9zaXRpb25cbiAgICAgICAgaWYgKHNvdXJjZVRyZWUgIT09IGRlc3RpbmF0aW9uVHJlZSkge1xuICAgICAgICAgICAgLy8gZW5zdXJlIHRoZSBmb2N1cyB0YXJnZXQgaXMgcmVuZGVyZWQgYW5kIHJlZ2lzdGVyZWRcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uVHJlZS5jaGFuZ2VEZXRlY3RvclJlZi5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgICAgICAgICBkZXN0aW5hdGlvblRyZWUuZm9jdXModGhpcy5tb3ZlZEl0ZW1OZXdJbmRleCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVtb3ZlKHsgc291cmNlSXRlbSwgc291cmNlVHJlZSwgZGVzdGluYXRpb25UcmVlIH0pIHtcbiAgICAgICAgY29uc3Qgc291cmNlUGFyZW50Tm9kZXMgPSB0aGlzLmdldFBhcmVudE5vZGVzKHNvdXJjZUl0ZW0sIHNvdXJjZVRyZWUpO1xuICAgICAgICBjb25zdCBzb3VyY2VJdGVtSW5kZXggPSBzb3VyY2VQYXJlbnROb2Rlcy5pbmRleE9mKGdldERhdGFJdGVtKHNvdXJjZUl0ZW0pKTtcbiAgICAgICAgc291cmNlUGFyZW50Tm9kZXMuc3BsaWNlKHNvdXJjZUl0ZW1JbmRleCwgMSk7XG4gICAgICAgIC8vIGVtaXQgY29sbGFwc2UgZm9yIHRoZSBwYXJlbnQgbm9kZSBpZiBpdHMgbGFzdCBjaGlsZCBub2RlIHdhcyBzcGxpY2VkXG4gICAgICAgIGNvbGxhcHNlRW1wdHlQYXJlbnQoc291cmNlSXRlbS5wYXJlbnQsIHNvdXJjZVBhcmVudE5vZGVzLCBzb3VyY2VUcmVlKTtcbiAgICAgICAgLy8gZGVjcmVtZW50IHNvdXJjZSBpdGVtIHBhcmVudCBwYWdlIHNpemUgPT4gYW4gaXRlbSBoYXMgYmVlbiByZW1vdmVkIGZyb20gaXRcbiAgICAgICAgZGVjcmVtZW50UGFnZVNpemUoc291cmNlVHJlZSwgZ2V0RGF0YUl0ZW0oc291cmNlSXRlbS5wYXJlbnQpKTtcbiAgICAgICAgLy8gcmVsb2FkIHRoZSB0cmVldmlldyBub2Rlc1xuICAgICAgICBpZiAoIXNvdXJjZVRyZWUubG9hZE9uRGVtYW5kKSB7XG4gICAgICAgICAgICBzb3VyY2VUcmVlLnByZWxvYWRDaGlsZE5vZGVzKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgdGhlIHNvdXJjZSBhbmQgZGVzdGluYXRpb24gdHJlZXMgYXJlIGRpZmZlcmVudCB3ZSB3YW50IHRvIGZvY3VzIG9ubHkgdGhlIG1vdmVkIGl0ZW0gaW4gdGhlIGRlc3RpbmF0aW9uIHRyZWVcbiAgICAgICAgaWYgKHNvdXJjZVRyZWUgPT09IGRlc3RpbmF0aW9uVHJlZSkge1xuICAgICAgICAgICAgLy8gZW5zdXJlIHRoZSBmb2N1cyB0YXJnZXQgaXMgcmVuZGVyZWQgYW5kIHJlZ2lzdGVyZWRcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uVHJlZS5jaGFuZ2VEZXRlY3RvclJlZi5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgICAgICAgICAvLyBhZnRlciB0aGUgc291cmNlIGl0ZW0gaXMgcmVtb3ZlZCBmcm9tIGl0cyBvcmlnaW5hbCBwb3NpdGlvbiwgdGhlIGNhbmRpZGF0ZSBpbmRleCBtaWdodCBoYXZlIHRvIGJlIGNvcnJlY3RlZFxuICAgICAgICAgICAgY29uc3QgaW5kZXggPSB1cGRhdGVNb3ZlZEl0ZW1JbmRleCh0aGlzLm1vdmVkSXRlbU5ld0luZGV4LCBzb3VyY2VJdGVtLml0ZW0uaW5kZXgpO1xuICAgICAgICAgICAgZGVzdGluYXRpb25UcmVlLmZvY3VzKGluZGV4KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRQYXJlbnROb2Rlcyhub2RlLCB0cmVlVmlldykge1xuICAgICAgICByZXR1cm4gaXNQcmVzZW50KG5vZGUucGFyZW50KSA/XG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuRm9yKGdldERhdGFJdGVtKG5vZGUucGFyZW50KSkgOlxuICAgICAgICAgICAgdHJlZVZpZXcubm9kZXM7XG4gICAgfVxuICAgIGNoaWxkcmVuRm9yKGRhdGFJdGVtKSB7XG4gICAgICAgIHJldHVybiBnZXR0ZXIodGhpcy5oaWVyYXJjaHlCaW5kaW5nLmNoaWxkcmVuRmllbGQpKGRhdGFJdGVtKSB8fCBbXTtcbiAgICB9XG59XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5sZXQgRHJhZ0NsdWVDb21wb25lbnQgPSBjbGFzcyBEcmFnQ2x1ZUNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoY2RyKSB7XG4gICAgICAgIHRoaXMuY2RyID0gY2RyO1xuICAgICAgICB0aGlzLmhvc3RDbGFzc2VzID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5wb3Npc3Rpb25TdHlsZSA9ICdmaXhlZCc7XG4gICAgfVxuICAgIGdldCBzdGF0dXNJY29uQ2xhc3MoKSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy5hY3Rpb24pIHtcbiAgICAgICAgICAgIGNhc2UgRHJvcEFjdGlvbi5BZGQ6IHJldHVybiAnay1pLXBsdXMnO1xuICAgICAgICAgICAgY2FzZSBEcm9wQWN0aW9uLkluc2VydFRvcDogcmV0dXJuICdrLWktaW5zZXJ0LXVwJztcbiAgICAgICAgICAgIGNhc2UgRHJvcEFjdGlvbi5JbnNlcnRCb3R0b206IHJldHVybiAnay1pLWluc2VydC1kb3duJztcbiAgICAgICAgICAgIGNhc2UgRHJvcEFjdGlvbi5JbnNlcnRNaWRkbGU6IHJldHVybiAnay1pLWluc2VydC1taWRkbGUnO1xuICAgICAgICAgICAgY2FzZSBEcm9wQWN0aW9uLkludmFsaWQ6XG4gICAgICAgICAgICBkZWZhdWx0OiByZXR1cm4gJ2staS1jYW5jZWwnO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGV4cG9zZWQgYXMgYSBwdWJsaWMgbWV0aG9kIHRoYXQgY2FuIGJlIGNhbGxlZCBmcm9tIG91dHNpZGUgYXMgdGhlIGNvbXBvbmVudCB1c2VzIGBPblB1c2hgIHN0cmF0ZWd5XG4gICAgZGV0ZWN0Q2hhbmdlcygpIHtcbiAgICAgICAgdGhpcy5jZHIuZGV0ZWN0Q2hhbmdlcygpO1xuICAgIH1cbn07XG5fX2RlY29yYXRlKFtcbiAgICBIb3N0QmluZGluZygnY2xhc3Muay1oZWFkZXInKSxcbiAgICBIb3N0QmluZGluZygnY2xhc3Muay1kcmFnLWNsdWUnKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIERyYWdDbHVlQ29tcG9uZW50LnByb3RvdHlwZSwgXCJob3N0Q2xhc3Nlc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSG9zdEJpbmRpbmcoJ3N0eWxlLnBvc2l0aW9uJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIERyYWdDbHVlQ29tcG9uZW50LnByb3RvdHlwZSwgXCJwb3Npc3Rpb25TdHlsZVwiLCB2b2lkIDApO1xuRHJhZ0NsdWVDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICAgICAgc2VsZWN0b3I6ICdrZW5kby10cmVldmlldy1kcmFnLWNsdWUnLFxuICAgICAgICB0ZW1wbGF0ZTogYFxuICAgICAgICA8bmctY29udGFpbmVyICpuZ0lmPVwiIXRlbXBsYXRlXCI+XG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cImstaWNvbiB7e3N0YXR1c0ljb25DbGFzc319IGstZHJhZy1zdGF0dXNcIj48L3NwYW4+XG4gICAgICAgICAgICA8c3Bhbj57e3RleHR9fTwvc3Bhbj5cbiAgICAgICAgPC9uZy1jb250YWluZXI+XG5cbiAgICAgICAgPG5nLXRlbXBsYXRlXG4gICAgICAgICAgICAqbmdJZj1cInRlbXBsYXRlXCJcbiAgICAgICAgICAgIFtuZ1RlbXBsYXRlT3V0bGV0XT1cInRlbXBsYXRlXCJcbiAgICAgICAgICAgIFtuZ1RlbXBsYXRlT3V0bGV0Q29udGV4dF09XCJ7XG4gICAgICAgICAgICAgICAgdGV4dDogdGV4dCxcbiAgICAgICAgICAgICAgICBhY3Rpb246IGFjdGlvbixcbiAgICAgICAgICAgICAgICBzb3VyY2VJdGVtOiBzb3VyY2VJdGVtLFxuICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uSXRlbTogZGVzdGluYXRpb25JdGVtXG4gICAgICAgICAgICB9XCJcbiAgICAgICAgPlxuICAgICAgICA8L25nLXRlbXBsYXRlPlxuICAgIGBcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0NoYW5nZURldGVjdG9yUmVmXSlcbl0sIERyYWdDbHVlQ29tcG9uZW50KTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIERyYWdBbmREcm9wQXNzZXRTZXJ2aWNlIHtcbiAgICBnZXQgY29tcG9uZW50UmVmKCkge1xuICAgICAgICBpZiAoIWlzUHJlc2VudCh0aGlzLl9jb21wb25lbnRSZWYpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBgaW5pdGFsaXplYCBtZXRob2QgbXVzdCBiZSBjYWxsZWQgYmVmb3JlIGNhbGxpbmcgb3RoZXIgc2VydmljZSBtZXRob2RzLicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9jb21wb25lbnRSZWY7XG4gICAgfVxuICAgIHNldCBjb21wb25lbnRSZWYoY29tcG9uZW50UmVmKSB7XG4gICAgICAgIHRoaXMuX2NvbXBvbmVudFJlZiA9IGNvbXBvbmVudFJlZjtcbiAgICB9XG4gICAgZ2V0IGVsZW1lbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBvbmVudFJlZi5sb2NhdGlvbi5uYXRpdmVFbGVtZW50O1xuICAgIH1cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgaWYgKCFpc1ByZXNlbnQodGhpcy5fY29tcG9uZW50UmVmKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZWxlbWVudC5wYXJlbnRFbGVtZW50LnJlbW92ZUNoaWxkKHRoaXMuZWxlbWVudCk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50UmVmLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5jb21wb25lbnRSZWYgPSBudWxsO1xuICAgIH1cbiAgICBzaG93KCkge1xuICAgICAgICB0aGlzLmVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICcnO1xuICAgIH1cbiAgICBoaWRlKCkge1xuICAgICAgICB0aGlzLmVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICB9XG4gICAgbW92ZShsZWZ0LCB0b3AsIG9mZnNldCA9IDApIHtcbiAgICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLmxlZnQgPSBgJHtsZWZ0ICsgb2Zmc2V0fXB4YDtcbiAgICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLnRvcCA9IGAke3RvcCArIG9mZnNldH1weGA7XG4gICAgfVxufVxuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgQ0xVRV9PRkZTRVQgPSAxMDtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBSRVRVUk5fQU5JTUFUSU9OX0RVUkFUSU9OID0gMjAwO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmxldCBEcmFnQ2x1ZVNlcnZpY2UgPSBjbGFzcyBEcmFnQ2x1ZVNlcnZpY2UgZXh0ZW5kcyBEcmFnQW5kRHJvcEFzc2V0U2VydmljZSB7XG4gICAgY29uc3RydWN0b3IoY29tcG9uZW50RmFjdG9yeVJlc29sdmVyKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50RmFjdG9yeVJlc29sdmVyID0gY29tcG9uZW50RmFjdG9yeVJlc29sdmVyO1xuICAgIH1cbiAgICBpbml0aWFsaXplKGNvbnRhaW5lciwgdGVtcGxhdGUpIHtcbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLl9jb21wb25lbnRSZWYpKSB7XG4gICAgICAgICAgICB0aGlzLm5nT25EZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2x1ZUNvbXBvbmVudEZhY3RvcnkgPSB0aGlzLmNvbXBvbmVudEZhY3RvcnlSZXNvbHZlci5yZXNvbHZlQ29tcG9uZW50RmFjdG9yeShEcmFnQ2x1ZUNvbXBvbmVudCk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50UmVmID0gY29udGFpbmVyLmNyZWF0ZUNvbXBvbmVudChjbHVlQ29tcG9uZW50RmFjdG9yeSk7XG4gICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgICB0aGlzLmNvbXBvbmVudFJlZi5pbnN0YW5jZS50ZW1wbGF0ZSA9IHRlbXBsYXRlO1xuICAgICAgICB0aGlzLmNvbXBvbmVudFJlZi5jaGFuZ2VEZXRlY3RvclJlZi5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgfVxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICB0aGlzLmNhbmNlbFJldHVybkFuaW1hdGlvbigpO1xuICAgICAgICB0aGlzLmNhbmNlbFNjcm9sbCgpO1xuICAgICAgICBzdXBlci5uZ09uRGVzdHJveSgpO1xuICAgIH1cbiAgICBtb3ZlKGxlZnQsIHRvcCkge1xuICAgICAgICBzdXBlci5tb3ZlKGxlZnQsIHRvcCwgQ0xVRV9PRkZTRVQpO1xuICAgIH1cbiAgICBhbmltYXRlRHJhZ0NsdWVUb0VsZW1lbnRQb3NpdGlvbih0YXJnZXQpIHtcbiAgICAgICAgaWYgKCEoaXNQcmVzZW50KHRhcmdldCkgJiYgaXNQcmVzZW50KHRoaXMuZWxlbWVudC5hbmltYXRlKSkpIHtcbiAgICAgICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRhcmdldEVsZW1lbnRWaWV3UG9ydENvb3JkcyA9IHRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgY29uc3QgY2x1ZUVsZW1lbnRWaWV3UG9ydENvb3JkcyA9IHRoaXMuZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgdGhpcy5yZXR1cm5BbmltYXRpb24gPSB0aGlzLmVsZW1lbnQuYW5pbWF0ZShbXG4gICAgICAgICAgICB7IHRyYW5zZm9ybTogJ3RyYW5zbGF0ZSgwLCAwKScgfSxcbiAgICAgICAgICAgIHsgdHJhbnNmb3JtOiBgdHJhbnNsYXRlKCR7dGFyZ2V0RWxlbWVudFZpZXdQb3J0Q29vcmRzLmxlZnQgLSBjbHVlRWxlbWVudFZpZXdQb3J0Q29vcmRzLmxlZnR9cHgsICR7dGFyZ2V0RWxlbWVudFZpZXdQb3J0Q29vcmRzLnRvcCAtIGNsdWVFbGVtZW50Vmlld1BvcnRDb29yZHMudG9wfXB4KWAgfVxuICAgICAgICBdLCBSRVRVUk5fQU5JTUFUSU9OX0RVUkFUSU9OKTtcbiAgICAgICAgdGhpcy5yZXR1cm5BbmltYXRpb24ub25maW5pc2ggPSAoKSA9PiB0aGlzLmhpZGUoKTtcbiAgICB9XG4gICAgY2FuY2VsUmV0dXJuQW5pbWF0aW9uKCkge1xuICAgICAgICBpZiAoIWlzUHJlc2VudCh0aGlzLnJldHVybkFuaW1hdGlvbikpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJldHVybkFuaW1hdGlvbi5jYW5jZWwoKTtcbiAgICAgICAgdGhpcy5yZXR1cm5BbmltYXRpb24gPSBudWxsO1xuICAgIH1cbiAgICB1cGRhdGVEcmFnQ2x1ZURhdGEoYWN0aW9uLCBzb3VyY2VJdGVtLCBkZXN0aW5hdGlvbkl0ZW0pIHtcbiAgICAgICAgY29uc3QgZHJhZ0NsdWUgPSB0aGlzLmNvbXBvbmVudFJlZi5pbnN0YW5jZTtcbiAgICAgICAgaWYgKGFjdGlvbiA9PT0gZHJhZ0NsdWUuYWN0aW9uICYmIGRhdGFJdGVtc0VxdWFsKHNvdXJjZUl0ZW0sIGRyYWdDbHVlLnNvdXJjZUl0ZW0pICYmIGRhdGFJdGVtc0VxdWFsKGRlc3RpbmF0aW9uSXRlbSwgZHJhZ0NsdWUuZGVzdGluYXRpb25JdGVtKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGRyYWdDbHVlLmFjdGlvbiA9IGFjdGlvbjtcbiAgICAgICAgZHJhZ0NsdWUuc291cmNlSXRlbSA9IHNvdXJjZUl0ZW07XG4gICAgICAgIGRyYWdDbHVlLmRlc3RpbmF0aW9uSXRlbSA9IGRlc3RpbmF0aW9uSXRlbTtcbiAgICAgICAgZHJhZ0NsdWUuZGV0ZWN0Q2hhbmdlcygpO1xuICAgIH1cbiAgICB1cGRhdGVUZXh0KHRleHQpIHtcbiAgICAgICAgaWYgKHRleHQgPT09IHRoaXMuY29tcG9uZW50UmVmLmluc3RhbmNlLnRleHQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbXBvbmVudFJlZi5pbnN0YW5jZS50ZXh0ID0gdGV4dDtcbiAgICAgICAgdGhpcy5jb21wb25lbnRSZWYuaW5zdGFuY2UuZGV0ZWN0Q2hhbmdlcygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VycyB0aGUgZmlyc3Qgc2Nyb2xsYWJsZSBwYXJlbnQgdG8gc2Nyb2xsIHVwd2FyZHMgb3IgZG93bndhcmRzLlxuICAgICAqIFVzZXMgc2V0SW50ZXJ2YWwsIHNvIHNob3VsZCBiZSBjYWxsZWQgb3V0c2lkZSB0aGUgYW5ndWxhciB6b25lLlxuICAgICAqL1xuICAgIHNjcm9sbEludG9WaWV3KHsgc3RlcCwgaW50ZXJ2YWwgfSkge1xuICAgICAgICB0aGlzLmNhbmNlbFNjcm9sbCgpO1xuICAgICAgICBjb25zdCBzY3JvbGxhYmxlQ29udGFpbmVyID0gZ2V0U2Nyb2xsYWJsZUNvbnRhaW5lcih0aGlzLmVsZW1lbnQpO1xuICAgICAgICBpZiAoIWlzUHJlc2VudChzY3JvbGxhYmxlQ29udGFpbmVyKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lclJlY3QgPSBzY3JvbGxhYmxlQ29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBjb25zdCBjbHVlUmVjdCA9IHRoaXMuZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgLy8gaWYgdGhlIGJlZ2lubmluZyBvZiB0aGUgc2Nyb2xsYWJsZSBjb250YWluZXIgaXMgYWJvdmUgdGhlIGN1cnJlbnQgdmlld3BvcnQsIGZhbGwtYmFjayB0byAwXG4gICAgICAgIGNvbnN0IGZpcnN0VmlzaWJsZUNsaWVudFRvcFBhcnQgPSBNYXRoLm1heChjb250YWluZXJSZWN0LnRvcCwgMCk7XG4gICAgICAgIC8vIHN0YXJ0IHNjcm9sbGluZyB1cCB3aGVuIHRoZSBmaXJzdCB2aXNpYmxlIGl0ZW0gaXMgZHJhZ2dlZCBvdmVyXG4gICAgICAgIGNvbnN0IHRvcExpbWl0ID0gZmlyc3RWaXNpYmxlQ2xpZW50VG9wUGFydCArIGNsdWVSZWN0LmhlaWdodDtcbiAgICAgICAgLy8gaWYgdGhlIGVuZCBvZiB0aGUgc2Nyb2xsYWJsZSBjb250YWluZXIgaXMgYmVuZWF0aCB0aGUgY3VycmVudCB2aWV3cG9ydCwgZmFsbC1iYWNrIHRvIGl0cyBjbGllbnQgaGVpZ2h0XG4gICAgICAgIC8vIGFkZCB0aGUgZGlzdGFuY2UgZnJvbSB0aGUgc3RhcnQgb2YgdGhlIHZpZXdwb3J0IHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGNvbnRhaW5lciB0byBlbnN1cmUgc2Nyb2xsaW5nIGJvdHRvbSBiZWdpbnMgd2hlbiB0aGUgYWN0dWFsIGVuZCBvZiB0aGUgY29udGFpbmVyIGlzIHJlYWNoZWRcbiAgICAgICAgY29uc3QgYm90dG9tTGltaXQgPSBmaXJzdFZpc2libGVDbGllbnRUb3BQYXJ0ICsgTWF0aC5taW4oY29udGFpbmVyUmVjdC5ib3R0b20sIHNjcm9sbGFibGVDb250YWluZXIuY2xpZW50SGVpZ2h0KTtcbiAgICAgICAgaWYgKGNsdWVSZWN0LnRvcCA8IHRvcExpbWl0KSB7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbEludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4gc2Nyb2xsRWxlbWVudEJ5KHNjcm9sbGFibGVDb250YWluZXIsIHN0ZXAsIFNjcm9sbERpcmVjdGlvbi5VcCksIGludGVydmFsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjbHVlUmVjdC5ib3R0b20gPiBib3R0b21MaW1pdCkge1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxJbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHNjcm9sbEVsZW1lbnRCeShzY3JvbGxhYmxlQ29udGFpbmVyLCBzdGVwLCBTY3JvbGxEaXJlY3Rpb24uRG93biksIGludGVydmFsKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYW5jZWxzIG91dCB0aGUgb24tZ29pbmcgc2Nyb2xsIGFuaW1hdGlvbiwgaWYgcHJlc2VudC5cbiAgICAgKi9cbiAgICBjYW5jZWxTY3JvbGwoKSB7XG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5zY3JvbGxJbnRlcnZhbCkpIHtcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5zY3JvbGxJbnRlcnZhbCk7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbEludGVydmFsID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbn07XG5EcmFnQ2x1ZVNlcnZpY2UgPSBfX2RlY29yYXRlKFtcbiAgICBJbmplY3RhYmxlKCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXJdKVxuXSwgRHJhZ0NsdWVTZXJ2aWNlKTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmxldCBEcm9wSGludENvbXBvbmVudCA9IGNsYXNzIERyb3BIaW50Q29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcihjaGFuZ2VEZXRlY3RvclJlZikge1xuICAgICAgICB0aGlzLmNoYW5nZURldGVjdG9yUmVmID0gY2hhbmdlRGV0ZWN0b3JSZWY7XG4gICAgICAgIHRoaXMuaG9zdENsYXNzID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9ICdmaXhlZCc7XG4gICAgICAgIHRoaXMucG9pbnRlckV2ZW50cyA9ICdub25lJztcbiAgICB9XG4gICAgLy8gZXhwb3NlZCBhcyBhIHB1YmxpYyBtZXRob2QgdGhhdCBjYW4gYmUgY2FsbGVkIGZyb20gb3V0c2lkZSBhcyB0aGUgY29tcG9uZW50IHVzZXMgYE9uUHVzaGAgc3RyYXRlZ3lcbiAgICBkZXRlY3RDaGFuZ2VzKCkge1xuICAgICAgICB0aGlzLmNoYW5nZURldGVjdG9yUmVmLmRldGVjdENoYW5nZXMoKTtcbiAgICB9XG59O1xuX19kZWNvcmF0ZShbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLmstZHJvcC1oaW50LWNvbnRhaW5lcicpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgRHJvcEhpbnRDb21wb25lbnQucHJvdG90eXBlLCBcImhvc3RDbGFzc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSG9zdEJpbmRpbmcoJ3N0eWxlLnBvc2l0aW9uJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIERyb3BIaW50Q29tcG9uZW50LnByb3RvdHlwZSwgXCJwb3NpdGlvblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSG9zdEJpbmRpbmcoJ3N0eWxlLnBvaW50ZXItZXZlbnRzJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIERyb3BIaW50Q29tcG9uZW50LnByb3RvdHlwZSwgXCJwb2ludGVyRXZlbnRzXCIsIHZvaWQgMCk7XG5Ecm9wSGludENvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLXRyZWV2aWV3LWRyb3AtaGludCcsXG4gICAgICAgIHRlbXBsYXRlOiBgXG4gICAgICAgIDxkaXZcbiAgICAgICAgICAgICpuZ0lmPVwiIXRlbXBsYXRlXCJcbiAgICAgICAgICAgIGNsYXNzPVwiay1kcm9wLWhpbnQgay1kcm9wLWhpbnQtaFwiXG4gICAgICAgID5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9J2stZHJvcC1oaW50LXN0YXJ0Jz48L2Rpdj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9J2stZHJvcC1oaW50LWxpbmUnPjwvZGl2PlxuICAgICAgICA8L2Rpdj5cblxuICAgICAgICA8bmctdGVtcGxhdGVcbiAgICAgICAgICAgICpuZ0lmPVwidGVtcGxhdGVcIlxuICAgICAgICAgICAgW25nVGVtcGxhdGVPdXRsZXRdPVwidGVtcGxhdGVcIlxuICAgICAgICAgICAgW25nVGVtcGxhdGVPdXRsZXRDb250ZXh0XT1cIntcbiAgICAgICAgICAgICAgICBhY3Rpb246IGFjdGlvbixcbiAgICAgICAgICAgICAgICBzb3VyY2VJdGVtOiBzb3VyY2VJdGVtLFxuICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uSXRlbTogZGVzdGluYXRpb25JdGVtXG4gICAgICAgICAgICB9XCJcbiAgICAgICAgPlxuICAgICAgICA8bmctdGVtcGxhdGU+XG4gICAgYFxuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQ2hhbmdlRGV0ZWN0b3JSZWZdKVxuXSwgRHJvcEhpbnRDb21wb25lbnQpO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xubGV0IERyb3BIaW50U2VydmljZSA9IGNsYXNzIERyb3BIaW50U2VydmljZSBleHRlbmRzIERyYWdBbmREcm9wQXNzZXRTZXJ2aWNlIHtcbiAgICBjb25zdHJ1Y3Rvcihjb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5jb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIgPSBjb21wb25lbnRGYWN0b3J5UmVzb2x2ZXI7XG4gICAgfVxuICAgIGluaXRpYWxpemUoY29udGFpbmVyLCB0ZW1wbGF0ZSkge1xuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMuX2NvbXBvbmVudFJlZikpIHtcbiAgICAgICAgICAgIHRoaXMubmdPbkRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBoaW50Q29tcG9uZW50RmFjdG9yeSA9IHRoaXMuY29tcG9uZW50RmFjdG9yeVJlc29sdmVyLnJlc29sdmVDb21wb25lbnRGYWN0b3J5KERyb3BIaW50Q29tcG9uZW50KTtcbiAgICAgICAgdGhpcy5jb21wb25lbnRSZWYgPSBjb250YWluZXIuY3JlYXRlQ29tcG9uZW50KGhpbnRDb21wb25lbnRGYWN0b3J5KTtcbiAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50UmVmLmluc3RhbmNlLnRlbXBsYXRlID0gdGVtcGxhdGU7XG4gICAgICAgIHRoaXMuY29tcG9uZW50UmVmLmNoYW5nZURldGVjdG9yUmVmLmRldGVjdENoYW5nZXMoKTtcbiAgICB9XG4gICAgdXBkYXRlRHJvcEhpbnREYXRhKGFjdGlvbiwgc291cmNlSXRlbSwgZGVzdGluYXRpb25JdGVtKSB7XG4gICAgICAgIGNvbnN0IGRyb3BIaW50ID0gdGhpcy5jb21wb25lbnRSZWYuaW5zdGFuY2U7XG4gICAgICAgIGlmIChhY3Rpb24gPT09IGRyb3BIaW50LmFjdGlvbiAmJiBkYXRhSXRlbXNFcXVhbChzb3VyY2VJdGVtLCBkcm9wSGludC5zb3VyY2VJdGVtKSAmJiBkYXRhSXRlbXNFcXVhbChkZXN0aW5hdGlvbkl0ZW0sIGRyb3BIaW50LmRlc3RpbmF0aW9uSXRlbSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBkcm9wSGludC5hY3Rpb24gPSBhY3Rpb247XG4gICAgICAgIGRyb3BIaW50LnNvdXJjZUl0ZW0gPSBzb3VyY2VJdGVtO1xuICAgICAgICBkcm9wSGludC5kZXN0aW5hdGlvbkl0ZW0gPSBkZXN0aW5hdGlvbkl0ZW07XG4gICAgICAgIGRyb3BIaW50LmRldGVjdENoYW5nZXMoKTtcbiAgICB9XG59O1xuRHJvcEhpbnRTZXJ2aWNlID0gX19kZWNvcmF0ZShbXG4gICAgSW5qZWN0YWJsZSgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyXSlcbl0sIERyb3BIaW50U2VydmljZSk7XG5cbi8qKlxuICogUmVwcmVzZW50cyB0aGUgdGVtcGxhdGUgZm9yIHRoZSBUcmVlVmlldyBkcmFnIGNsdWUgd2hlbiBhbiBpdGVtIGlzIGRyYWdnZWQuIFRvIGRlZmluZSB0aGUgY2x1ZSB0ZW1wbGF0ZSxcbiAqIG5lc3QgYW4gYDxuZy10ZW1wbGF0ZT5gIHRhZyB3aXRoIHRoZSBga2VuZG9UcmVlVmlld0RyYWdDbHVlVGVtcGxhdGVgIGRpcmVjdGl2ZSBpbnNpZGUgYSBgPGtlbmRvLXRyZWV2aWV3PmAgdGFnXG4gKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGRyYWdhbmRkcm9wX3RyZWV2aWV3ICV9I3RvYy10ZW1wbGF0ZXMpKS5cbiAqXG4gKlxuICogVGhlIHRleHQsIGF0dGVtcHRlZCBkcm9wIGFjdGlvbiwgc291cmNlIGl0ZW0gYW5kIGRlc3RpbmF0aW9uIGl0ZW0gYXJlIGF2YWlsYWJsZSBhcyBjb250ZXh0IHZhcmlhYmxlcyBpbiB0aGUgdGVtcGxhdGU6XG4gKlxuICpcbiAqIC0gYGxldC10ZXh0PVwidGV4dFwiYCAoYHN0cmluZ2ApXG4gKiAtIGBsZXQtYWN0aW9uPVwiYWN0aW9uXCJgIChbYERyb3BBY3Rpb25gXSh7JSBzbHVnIGFwaV90cmVldmlld19kcm9wYWN0aW9uICV9KSlcbiAqIC0gYGxldC1zb3VyY2VJdGVtPVwic291cmNlSXRlbVwiYCAoW2BUcmVlSXRlbUxvb2t1cGBdKHslIHNsdWcgYXBpX3RyZWV2aWV3X3RyZWVpdGVtbG9va3VwICV9KSlcbiAqIC0gYGxldC1kZXN0aW5hdGlvbkl0ZW09XCJkZXN0aW5hdGlvbkl0ZW1cImAgKFtgVHJlZUl0ZW1Mb29rdXBgXSh7JSBzbHVnIGFwaV90cmVldmlld190cmVlaXRlbWxvb2t1cCAlfSkpXG4gKi9cbmxldCBEcmFnQ2x1ZVRlbXBsYXRlRGlyZWN0aXZlID0gY2xhc3MgRHJhZ0NsdWVUZW1wbGF0ZURpcmVjdGl2ZSB7XG4gICAgY29uc3RydWN0b3IodGVtcGxhdGVSZWYpIHtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZVJlZiA9IHRlbXBsYXRlUmVmO1xuICAgIH1cbn07XG5EcmFnQ2x1ZVRlbXBsYXRlRGlyZWN0aXZlID0gX19kZWNvcmF0ZShbXG4gICAgRGlyZWN0aXZlKHtcbiAgICAgICAgc2VsZWN0b3I6ICdba2VuZG9UcmVlVmlld0RyYWdDbHVlVGVtcGxhdGVdJ1xuICAgIH0pLFxuICAgIF9fcGFyYW0oMCwgT3B0aW9uYWwoKSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtUZW1wbGF0ZVJlZl0pXG5dLCBEcmFnQ2x1ZVRlbXBsYXRlRGlyZWN0aXZlKTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSB0ZW1wbGF0ZSBmb3IgdGhlIFRyZWVWaWV3IGRyb3AgaGludCB3aGVuIGFuIGl0ZW0gaXMgZHJhZ2dlZC4gVG8gZGVmaW5lIHRoZSBoaW50IHRlbXBsYXRlLFxuICogbmVzdCBhbiBgPG5nLXRlbXBsYXRlPmAgdGFnIHdpdGggdGhlIGBrZW5kb1RyZWVWaWV3RHJvcEhpbnRUZW1wbGF0ZWAgZGlyZWN0aXZlIGluc2lkZSBhIGA8a2VuZG8tdHJlZXZpZXc+YCB0YWdcbiAqIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgZHJhZ2FuZGRyb3BfdHJlZXZpZXcgJX0jdG9jLXRlbXBsYXRlcykpLlxuICpcbiAqIFRoZSBhdHRlbXB0ZWQgZHJvcCBhY3Rpb24sIHNvdXJjZSBpdGVtIGFuZCBkZXN0aW5hdGlvbiBpdGVtIGFyZSBhdmFpbGFibGUgYXMgY29udGV4dCB2YXJpYWJsZXMgaW4gdGhlIHRlbXBsYXRlOlxuICpcbiAqIC0gYGxldC1hY3Rpb249XCJhY3Rpb25cImAgKFtgRHJvcEFjdGlvbmBdKHslIHNsdWcgYXBpX3RyZWV2aWV3X2Ryb3BhY3Rpb24gJX0pKVxuICogLSBgbGV0LXNvdXJjZUl0ZW09XCJzb3VyY2VJdGVtXCJgIChbYFRyZWVJdGVtTG9va3VwYF0oeyUgc2x1ZyBhcGlfdHJlZXZpZXdfdHJlZWl0ZW1sb29rdXAgJX0pKVxuICogLSBgbGV0LWRlc3RpbmF0aW9uSXRlbT1cImRlc3RpbmF0aW9uSXRlbVwiYCAoW2BUcmVlSXRlbUxvb2t1cGBdKHslIHNsdWcgYXBpX3RyZWV2aWV3X3RyZWVpdGVtbG9va3VwICV9KSlcbiAqL1xubGV0IERyb3BIaW50VGVtcGxhdGVEaXJlY3RpdmUgPSBjbGFzcyBEcm9wSGludFRlbXBsYXRlRGlyZWN0aXZlIHtcbiAgICBjb25zdHJ1Y3Rvcih0ZW1wbGF0ZVJlZikge1xuICAgICAgICB0aGlzLnRlbXBsYXRlUmVmID0gdGVtcGxhdGVSZWY7XG4gICAgfVxufTtcbkRyb3BIaW50VGVtcGxhdGVEaXJlY3RpdmUgPSBfX2RlY29yYXRlKFtcbiAgICBEaXJlY3RpdmUoe1xuICAgICAgICBzZWxlY3RvcjogJ1trZW5kb1RyZWVWaWV3RHJvcEhpbnRUZW1wbGF0ZV0nXG4gICAgfSksXG4gICAgX19wYXJhbSgwLCBPcHRpb25hbCgpKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW1RlbXBsYXRlUmVmXSlcbl0sIERyb3BIaW50VGVtcGxhdGVEaXJlY3RpdmUpO1xuXG5jb25zdCBERUZBVUxUX1NDUk9MTF9TRVRUSU5HUyA9IHtcbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIHN0ZXA6IDEsXG4gICAgaW50ZXJ2YWw6IDFcbn07XG4vKipcbiAqIEEgZGlyZWN0aXZlIHdoaWNoIGVuYWJsZXMgdGhlIGRyYWdnaW5nIGFuZCBkcm9wcGluZyBpdGVtcyBpbnNpZGUgdGhlIGN1cnJlbnQgVHJlZVZpZXcgb3IgYmV0d2VlbiBtdWx0aXBsZSBsaW5rZWQgVHJlZVZpZXcgY29tcG9uZW50IGluc3RhbmNlc1xuICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBkcmFnYW5kZHJvcF90cmVldmlldyAlfSkpLlxuICpcbiAqIFRyaWdnZXJzIHRoZSBbYG5vZGVEcmFnU3RhcnRgXSh7JSBzbHVnIGFwaV90cmVldmlld190cmVldmlld2NvbXBvbmVudCAlfSN0b2Mtbm9kZWRyYWdzdGFydCksXG4gKiBbYG5vZGVEcmFnYF0oeyUgc2x1ZyBhcGlfdHJlZXZpZXdfdHJlZXZpZXdjb21wb25lbnQgJX0jdG9jLW5vZGVkcmFnKSxcbiAqIFtgbm9kZURyb3BgXSh7JSBzbHVnIGFwaV90cmVldmlld190cmVldmlld2NvbXBvbmVudCAlfSN0b2Mtbm9kZWRyb3ApLFxuICogW2Bub2RlRHJhZ0VuZGBdKHslIHNsdWcgYXBpX3RyZWV2aWV3X3RyZWV2aWV3Y29tcG9uZW50ICV9I3RvYy1ub2RlZHJhZ2VuZCksXG4gKiBbYGFkZEl0ZW1gXSh7JSBzbHVnIGFwaV90cmVldmlld190cmVldmlld2NvbXBvbmVudCAlfSN0b2MtYWRkaXRlbSkgYW5kXG4gKiBbYHJlbW92ZUl0ZW1gXSh7JSBzbHVnIGFwaV90cmVldmlld190cmVldmlld2NvbXBvbmVudCAlfSN0b2MtcmVtb3ZlaXRlbSlcbiAqIGV2ZW50cyB3aGVuIHRoZSBjb3JyZXNwb25kaW5nIGFjdGlvbnMgb2NjdXIgb24gdGhlIHJlc3BlY3RpdmUgVHJlZVZpZXcgaW5zdGFuY2UuXG4gKi9cbmxldCBEcmFnQW5kRHJvcERpcmVjdGl2ZSA9IGNsYXNzIERyYWdBbmREcm9wRGlyZWN0aXZlIHtcbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50LCB6b25lLCB0cmVldmlldywgZHJhZ0NsdWVTZXJ2aWNlLCBkcm9wSGludFNlcnZpY2UpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICAgICAgdGhpcy56b25lID0gem9uZTtcbiAgICAgICAgdGhpcy50cmVldmlldyA9IHRyZWV2aWV3O1xuICAgICAgICB0aGlzLmRyYWdDbHVlU2VydmljZSA9IGRyYWdDbHVlU2VydmljZTtcbiAgICAgICAgdGhpcy5kcm9wSGludFNlcnZpY2UgPSBkcm9wSGludFNlcnZpY2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVjaWZpZXMgd2hldGhlciB0aGUgYHJlbW92ZUl0ZW1gIGV2ZW50IHdpbGwgYmUgZmlyZWQgYWZ0ZXIgYW4gaXRlbSBpcyBkcm9wcGVkIHdoZW4gdGhlIGBjdHJsYCBrZXkgaXMgcHJlc3NlZC5cbiAgICAgICAgICogSWYgZW5hYmxlZCwgdGhlIGByZW1vdmVJdGVtYCBldmVudCB3aWxsIG5vdCBiZSBmaXJlZCBvbiB0aGUgc291cmNlIFRyZWVWaWV3XG4gICAgICAgICAqIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgZHJhZ2FuZGRyb3BfdHJlZXZpZXcgJX0jdG9jLW11bHRpcGxlLXRyZWV2aWV3cykpLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hbGxvd0NvcHkgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZmVzIHRoZSBUcmVlVmlld0NvbXBvbmVudCBpbnN0YW5jZXMgaW50byB3aGljaCBkcmFnZ2VkIGl0ZW1zIGZyb20gdGhlIGN1cnJlbnQgVHJlZVZpZXdDb21wb25lbnQgY2FuIGJlIGRyb3BwZWRcbiAgICAgICAgICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBkcmFnYW5kZHJvcF90cmVldmlldyAlfSN0b2MtbXVsdGlwbGUtdHJlZXZpZXdzKSkuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRyb3Bab25lVHJlZVZpZXdzID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVjaWZpZXMgdGhlIGRpc3RhbmNlIGluIHBpeGVscyBmcm9tIHRoZSBpbml0aWFsIGl0ZW0gcG9pbnRlcmRvd24gZXZlbnQsIGJlZm9yZSB0aGUgZHJhZ2dpbmcgaXMgaW5pdGlhdGVkLlxuICAgICAgICAgKiBUaGUgYG5vZGVEcmFnU3RhcnRgIGFuZCBhbGwgY29uc2VxdWVudCBUcmVlVmlldyBkcmFnIGV2ZW50cyB3aWxsIG5vdCBiZSBmaXJlZCB1bnRpbCB0aGUgYWN0dWFsIGRyYWdnaW5nIGJlZ2lucy5cbiAgICAgICAgICpcbiAgICAgICAgICogQGRlZmF1bHQgNVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdGFydERyYWdBZnRlciA9IDU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb250cm9sbHMgdGhlIGF1dG8tc2Nyb2xsaW5nIGJlaGF2aW9yIGR1cmluZyBkcmFnLWFuZC1kcm9wIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgZHJhZ2FuZGRyb3BfdHJlZXZpZXcgJX0jdG9jLWF1dG8tc2Nyb2xsaW5nKSkuXG4gICAgICAgICAqIEVuYmFsZWQgYnkgZGVmYXVsdC4gVG8gdHVybiB0aGUgYXV0by1zY3JvbGxpbmcgb2ZmLCBzZXQgdGhpcyBwcm9wIHRvIGBmYWxzZWAuXG4gICAgICAgICAqXG4gICAgICAgICAqIEJ5IGRlZmF1bHQsIHRoZSBzY3JvbGxpbmcgd2lsbCBiZSBwZXJmb3JtZWQgYnkgMSBwaXhlbCBhdCBldmVyeSAxIG1pbGxpc2Vjb25kLCB3aGVuIHRoZSBkcmFnZ2VkIGl0ZW0gcmVhY2hlcyB0aGUgdG9wIG9yIHRoZSBib3R0b20gb2YgdGhlIHNjcm9sbGFibGUgY29udGFpbmVyLlxuICAgICAgICAgKiBUaGUgYHN0ZXBgIGFuZCBgaW50ZXJ2YWxgIGNhbiBiZSBvdmVycmlkZGVuIGJ5IHByb3ZpZGluZyBhIGBEcmFnQW5kRHJvcFNjcm9sbFNldHRpbmdzYCBvYmplY3QgdG8gdGhpcyBwcm9wLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZGVmYXVsdCB0cnVlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmF1dG9TY3JvbGwgPSB0cnVlO1xuICAgICAgICAvKipcbiAgICAgICAgICogQGhpZGRlblxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy51c2VyU2VsZWN0U3R5bGUgPSAnbm9uZSc7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZXNjcmliZXMgdGhlIG9mZnNldCBvZiB0aGUgcGFyZW50IGVsZW1lbnQgaWYgdGhlIGxhdHRlciBoYXMgdGhlIGB0cmFuc2Zvcm1gIENTUyBwcm9wIGFwcGxpZWQuXG4gICAgICAgICAqIFRyYW5zZm9ybWVkIHBhcmVudHMgY3JlYXRlIG5ldyBzdGFja2luZyBjb250ZXh0IGFuZCB0aGUgZml4ZWQgY2hpbGRyZW4gbXVzdCBiZSBwb3NpdGlvbiBiYXNlZCBvbiB0aGUgdHJhbnNmb3JtZWQgcGFyZW50LlxuICAgICAgICAgKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvQ1NTX1Bvc2l0aW9uaW5nL1VuZGVyc3RhbmRpbmdfel9pbmRleC9UaGVfc3RhY2tpbmdfY29udGV4dFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jb250YWluZXJPZmZzZXQgPSB7IHRvcDogMCwgbGVmdDogMCB9O1xuICAgICAgICB0aGlzLnRyZWV2aWV3LnRvdWNoQWN0aW9ucyA9IGZhbHNlO1xuICAgIH1cbiAgICBnZXQgc2Nyb2xsU2V0dGluZ3MoKSB7XG4gICAgICAgIGNvbnN0IHVzZXJQcm92aWRlZFNldHRpbmdzID0gdHlwZW9mIHRoaXMuYXV0b1Njcm9sbCA9PT0gJ2Jvb2xlYW4nID9cbiAgICAgICAgICAgIHsgZW5hYmxlZDogdGhpcy5hdXRvU2Nyb2xsIH0gOlxuICAgICAgICAgICAgdGhpcy5hdXRvU2Nyb2xsO1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgREVGQVVMVF9TQ1JPTExfU0VUVElOR1MsIHVzZXJQcm92aWRlZFNldHRpbmdzKTtcbiAgICB9XG4gICAgbmdBZnRlckNvbnRlbnRJbml0KCkge1xuICAgICAgICB0aGlzLmluaXRhbGl6ZURyYWdnYWJsZSgpO1xuICAgICAgICB0aGlzLmRyYWdDbHVlU2VydmljZS5pbml0aWFsaXplKHRoaXMudHJlZXZpZXcuYXNzZXRzQ29udGFpbmVyLCB0aGlzLmRyYWdDbHVlVGVtcGxhdGUgJiYgdGhpcy5kcmFnQ2x1ZVRlbXBsYXRlLnRlbXBsYXRlUmVmKTtcbiAgICAgICAgdGhpcy5kcm9wSGludFNlcnZpY2UuaW5pdGlhbGl6ZSh0aGlzLnRyZWV2aWV3LmFzc2V0c0NvbnRhaW5lciwgdGhpcy5kcm9wSGludFRlbXBsYXRlICYmIHRoaXMuZHJvcEhpbnRUZW1wbGF0ZS50ZW1wbGF0ZVJlZik7XG4gICAgfVxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICB0aGlzLmRyYWdnYWJsZS5kZXN0cm95KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBoYW5kbGVQcmVzcyh7IG9yaWdpbmFsRXZlbnQgfSkge1xuICAgICAgICBpZiAoIWlzQ29udGVudChvcmlnaW5hbEV2ZW50LnRhcmdldCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBzdG9yZSB0aGUgZHJhZyB0YXJnZXQgb24gcHJlc3MsIHNob3cgaXQgb25seSB3aGVuIGl0J3MgYWN0dWFsbHkgZHJhZ2dlZFxuICAgICAgICB0aGlzLmRyYWdnZWRJdGVtID0gY2xvc2VzdFdpdGhNYXRjaChvcmlnaW5hbEV2ZW50LnRhcmdldCwgJy5rLWluJyk7XG4gICAgICAgIC8vIHJlY29yZCB0aGUgY3VycmVudCBwb2ludGVyIGRvd24gY29vcmRzIC0gY29wYXJlZCB0byB0aGUgYHN0YXJ0RHJhZ0FmdGVyYCB2YWx1ZSB0byBjYWxjdWxhdGUgd2hldGhlciB0byBpbml0aWF0ZSBkcmFnZ2luZ1xuICAgICAgICB0aGlzLnBlbmRpbmdEcmFnU3RhcnRFdmVudCA9IG9yaWdpbmFsRXZlbnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBoYW5kbGVEcmFnKHsgb3JpZ2luYWxFdmVudCwgY2xpZW50WCwgY2xpZW50WSB9KSB7XG4gICAgICAgIGlmICh0aGlzLnNob3VsZEluaXRpYXRlRHJhZ1N0YXJ0KHsgY2xpZW50WCwgY2xpZW50WSB9KSkge1xuICAgICAgICAgICAgdGhpcy5pbml0aWF0ZURyYWdTdGFydCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNQcmVzZW50KHRoaXMuZHJhZ2dlZEl0ZW0pIHx8IGlzUHJlc2VudCh0aGlzLnBlbmRpbmdEcmFnU3RhcnRFdmVudCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkcm9wVGFyZ2V0ID0gZ2V0RHJvcFRhcmdldChvcmlnaW5hbEV2ZW50KTtcbiAgICAgICAgaWYgKGhhc09ic2VydmVycyh0aGlzLnRyZWV2aWV3Lm5vZGVEcmFnKSkge1xuICAgICAgICAgICAgdGhpcy56b25lLnJ1bigoKSA9PiB0aGlzLm5vdGlmeURyYWcob3JpZ2luYWxFdmVudCwgZHJvcFRhcmdldCkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRhcmdldFRyZWVWaWV3ID0gdGhpcy5nZXRUYXJnZXRUcmVlVmlldyhkcm9wVGFyZ2V0KTtcbiAgICAgICAgY29uc3QgZHJvcFBvc2l0aW9uID0gZ2V0RHJvcFBvc2l0aW9uKHRoaXMuZHJhZ2dlZEl0ZW0sIGRyb3BUYXJnZXQsIGNsaWVudFksIHRhcmdldFRyZWVWaWV3LCB0aGlzLmNvbnRhaW5lck9mZnNldCk7XG4gICAgICAgIGNvbnN0IGRyb3BIaW50QW5jaG9yID0gY2xvc2VzdFdpdGhNYXRjaChkcm9wVGFyZ2V0LCAnLmstbWlkJyk7XG4gICAgICAgIGNvbnN0IGRyb3BBY3Rpb24gPSBnZXREcm9wQWN0aW9uKGRyb3BQb3NpdGlvbiwgZHJvcFRhcmdldCk7XG4gICAgICAgIGNvbnN0IHNvdXJjZUl0ZW0gPSB0cmVlSXRlbUZyb21FdmVudFRhcmdldCh0aGlzLnRyZWV2aWV3LCB0aGlzLmRyYWdnZWRJdGVtKTtcbiAgICAgICAgY29uc3QgZGVzdGluYXRpb25JdGVtID0gdHJlZUl0ZW1Gcm9tRXZlbnRUYXJnZXQodGFyZ2V0VHJlZVZpZXcsIGRyb3BUYXJnZXQpO1xuICAgICAgICB0aGlzLnVwZGF0ZURyb3BIaW50U3RhdGUoZHJvcFBvc2l0aW9uLCBkcm9wSGludEFuY2hvciwgZHJvcEFjdGlvbiwgc291cmNlSXRlbSwgZGVzdGluYXRpb25JdGVtKTtcbiAgICAgICAgdGhpcy51cGRhdGVEcmFnQ2x1ZVN0YXRlKGRyb3BBY3Rpb24sIGNsaWVudFgsIGNsaWVudFksIHNvdXJjZUl0ZW0sIGRlc3RpbmF0aW9uSXRlbSk7XG4gICAgICAgIGlmICh0aGlzLnNjcm9sbFNldHRpbmdzLmVuYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZHJhZ0NsdWVTZXJ2aWNlLnNjcm9sbEludG9WaWV3KHRoaXMuc2Nyb2xsU2V0dGluZ3MpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBoYW5kbGVSZWxlYXNlKHsgb3JpZ2luYWxFdmVudCwgY2xpZW50WSB9KSB7XG4gICAgICAgIGlmICh0aGlzLnNjcm9sbFNldHRpbmdzLmVuYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZHJhZ0NsdWVTZXJ2aWNlLmNhbmNlbFNjcm9sbCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNQcmVzZW50KHRoaXMuZHJhZ2dlZEl0ZW0pIHx8IGlzUHJlc2VudCh0aGlzLnBlbmRpbmdEcmFnU3RhcnRFdmVudCkpIHtcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ0RyYWdTdGFydEV2ZW50ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuZHJhZ2dlZEl0ZW0gPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRyb3BUYXJnZXQgPSBnZXREcm9wVGFyZ2V0KG9yaWdpbmFsRXZlbnQpO1xuICAgICAgICBjb25zdCBzb3VyY2VUcmVlID0gdGhpcy50cmVldmlldztcbiAgICAgICAgY29uc3QgZGVzdGluYXRpb25UcmVlID0gdGhpcy5nZXRUYXJnZXRUcmVlVmlldyhkcm9wVGFyZ2V0KTtcbiAgICAgICAgY29uc3QgZHJvcFBvc2l0aW9uID0gZ2V0RHJvcFBvc2l0aW9uKHRoaXMuZHJhZ2dlZEl0ZW0sIGRyb3BUYXJnZXQsIGNsaWVudFksIHRoaXMuZ2V0VGFyZ2V0VHJlZVZpZXcoZHJvcFRhcmdldCksIHRoaXMuY29udGFpbmVyT2Zmc2V0KTtcbiAgICAgICAgY29uc3Qgc291cmNlSXRlbSA9IHRyZWVJdGVtRnJvbUV2ZW50VGFyZ2V0KHNvdXJjZVRyZWUsIHRoaXMuZHJhZ2dlZEl0ZW0pO1xuICAgICAgICBjb25zdCBkZXN0aW5hdGlvbkl0ZW0gPSB0cmVlSXRlbUZyb21FdmVudFRhcmdldChkZXN0aW5hdGlvblRyZWUsIGRyb3BUYXJnZXQpO1xuICAgICAgICBpZiAoaXNQcmVzZW50KGRlc3RpbmF0aW9uSXRlbSkgJiYgaXNQcmVzZW50KGRyb3BQb3NpdGlvbikpIHtcbiAgICAgICAgICAgIHRoaXMuem9uZS5ydW4oKCkgPT4gdGhpcy5ub3RpZnlEcm9wKHsgc291cmNlSXRlbSwgZGVzdGluYXRpb25JdGVtLCBkcm9wUG9zaXRpb24sIHNvdXJjZVRyZWUsIGRlc3RpbmF0aW9uVHJlZSB9LCBvcmlnaW5hbEV2ZW50KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRyYWdDbHVlU2VydmljZS5hbmltYXRlRHJhZ0NsdWVUb0VsZW1lbnRQb3NpdGlvbih0aGlzLmRyYWdnZWRJdGVtKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFzT2JzZXJ2ZXJzKHRoaXMudHJlZXZpZXcubm9kZURyYWdFbmQpKSB7XG4gICAgICAgICAgICB0aGlzLnpvbmUucnVuKCgpID0+IHRoaXMubm90aWZ5RHJhZ0VuZCh7IHNvdXJjZUl0ZW0sIGRlc3RpbmF0aW9uSXRlbSwgb3JpZ2luYWxFdmVudCB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kcm9wSGludFNlcnZpY2UuaGlkZSgpO1xuICAgICAgICB0aGlzLmRyYWdnZWRJdGVtID0gbnVsbDtcbiAgICB9XG4gICAgdXBkYXRlRHJvcEhpbnRTdGF0ZShkcm9wUG9zaXRpb24sIGRyb3BIaW50QW5jaG9yLCBkcm9wQWN0aW9uLCBzb3VyY2VJdGVtLCBkZXN0aW5hdGlvbkl0ZW0pIHtcbiAgICAgICAgaWYgKCFpc1ByZXNlbnQoZHJvcEhpbnRBbmNob3IpIHx8IGRyb3BQb3NpdGlvbiA9PT0gRHJvcFBvc2l0aW9uLk92ZXIgfHwgIWlzUHJlc2VudChkcm9wUG9zaXRpb24pKSB7XG4gICAgICAgICAgICB0aGlzLmRyb3BIaW50U2VydmljZS5oaWRlKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYW5jaG9yVmlld1BvcnRDb29yZHMgPSBkcm9wSGludEFuY2hvci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgY29uc3QgaW5zZXJ0QmVmb3JlID0gZHJvcFBvc2l0aW9uID09PSBEcm9wUG9zaXRpb24uQmVmb3JlO1xuICAgICAgICBjb25zdCB0b3AgPSBpbnNlcnRCZWZvcmUgPyBhbmNob3JWaWV3UG9ydENvb3Jkcy50b3AgOiAoYW5jaG9yVmlld1BvcnRDb29yZHMudG9wICsgYW5jaG9yVmlld1BvcnRDb29yZHMuaGVpZ2h0KTtcbiAgICAgICAgdGhpcy5kcm9wSGludFNlcnZpY2UudXBkYXRlRHJvcEhpbnREYXRhKGRyb3BBY3Rpb24sIHNvdXJjZUl0ZW0sIGRlc3RpbmF0aW9uSXRlbSk7XG4gICAgICAgIC8vIGNsZWFyIGFueSBwb3NzaWJsZSBjb250YWluZXIgb2Zmc2V0IGNyZWF0ZWQgYnkgcGFyZW50IGVsZW1lbnRzIHdpdGggYHRyYW5zZm9ybWAgY3NzIHByb3BlcnR5IHNldFxuICAgICAgICB0aGlzLmRyb3BIaW50U2VydmljZS5tb3ZlKGFuY2hvclZpZXdQb3J0Q29vcmRzLmxlZnQgLSB0aGlzLmNvbnRhaW5lck9mZnNldC5sZWZ0LCB0b3AgLSB0aGlzLmNvbnRhaW5lck9mZnNldC50b3ApO1xuICAgICAgICB0aGlzLmRyb3BIaW50U2VydmljZS5zaG93KCk7XG4gICAgfVxuICAgIHVwZGF0ZURyYWdDbHVlU3RhdGUoZHJvcEFjdGlvbiwgY2xpZW50WCwgY2xpZW50WSwgc291cmNlSXRlbSwgZGVzdGluYXRpb25JdGVtKSB7XG4gICAgICAgIC8vIGNsZWFyIGFueSBwb3NzaWJsZSBjb250YWluZXIgb2Zmc2V0IGNyZWF0ZWQgYnkgcGFyZW50IGVsZW1lbnRzIHdpdGggYHRyYW5zZm9ybWAgY3NzIHByb3BlcnR5IHNldFxuICAgICAgICB0aGlzLmRyYWdDbHVlU2VydmljZS5tb3ZlKGNsaWVudFggLSB0aGlzLmNvbnRhaW5lck9mZnNldC5sZWZ0LCBjbGllbnRZIC0gdGhpcy5jb250YWluZXJPZmZzZXQudG9wKTtcbiAgICAgICAgdGhpcy5kcmFnQ2x1ZVNlcnZpY2UudXBkYXRlRHJhZ0NsdWVEYXRhKGRyb3BBY3Rpb24sIHNvdXJjZUl0ZW0sIGRlc3RpbmF0aW9uSXRlbSk7XG4gICAgICAgIHRoaXMuZHJhZ0NsdWVTZXJ2aWNlLnNob3coKTtcbiAgICB9XG4gICAgaW5pdGFsaXplRHJhZ2dhYmxlKCkge1xuICAgICAgICB0aGlzLmRyYWdnYWJsZSA9IG5ldyBEcmFnZ2FibGUoe1xuICAgICAgICAgICAgcHJlc3M6IHRoaXMuaGFuZGxlUHJlc3MuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIGRyYWc6IHRoaXMuaGFuZGxlRHJhZy5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgcmVsZWFzZTogdGhpcy5oYW5kbGVSZWxlYXNlLmJpbmQodGhpcylcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuem9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB0aGlzLmRyYWdnYWJsZS5iaW5kVG8odGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQpKTtcbiAgICB9XG4gICAgbm90aWZ5RHJhZ1N0YXJ0KG9yaWdpbmFsRXZlbnQsIGRyb3BUYXJnZXQpIHtcbiAgICAgICAgY29uc3Qgc291cmNlSXRlbSA9IHRyZWVJdGVtRnJvbUV2ZW50VGFyZ2V0KHRoaXMudHJlZXZpZXcsIGRyb3BUYXJnZXQpO1xuICAgICAgICBjb25zdCBldmVudCA9IG5ldyBUcmVlSXRlbURyYWdTdGFydEV2ZW50KHsgc291cmNlSXRlbSwgb3JpZ2luYWxFdmVudCB9KTtcbiAgICAgICAgdGhpcy50cmVldmlldy5ub2RlRHJhZ1N0YXJ0LmVtaXQoZXZlbnQpO1xuICAgICAgICByZXR1cm4gZXZlbnQ7XG4gICAgfVxuICAgIG5vdGlmeURyYWcob3JpZ2luYWxFdmVudCwgZHJvcFRhcmdldCkge1xuICAgICAgICBjb25zdCBkcmFnRXZlbnQgPSB7XG4gICAgICAgICAgICBzb3VyY2VJdGVtOiB0cmVlSXRlbUZyb21FdmVudFRhcmdldCh0aGlzLnRyZWV2aWV3LCB0aGlzLmRyYWdnZWRJdGVtKSxcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uSXRlbTogdHJlZUl0ZW1Gcm9tRXZlbnRUYXJnZXQodGhpcy5nZXRUYXJnZXRUcmVlVmlldyhkcm9wVGFyZ2V0KSwgZHJvcFRhcmdldCksXG4gICAgICAgICAgICBvcmlnaW5hbEV2ZW50XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudHJlZXZpZXcubm9kZURyYWcuZW1pdChkcmFnRXZlbnQpO1xuICAgIH1cbiAgICBub3RpZnlEcm9wKGFyZ3MsIG9yaWdpbmFsRXZlbnQpIHtcbiAgICAgICAgY29uc3QgZXZlbnQgPSBuZXcgVHJlZUl0ZW1Ecm9wRXZlbnQoYXJncywgb3JpZ2luYWxFdmVudCk7XG4gICAgICAgIGFyZ3MuZGVzdGluYXRpb25UcmVlLm5vZGVEcm9wLmVtaXQoZXZlbnQpO1xuICAgICAgICAvLyBkaXNhYmxlIHRoZSBhbmltYXRpb25zIG9uIGRyb3AgYW5kIHJlc3RvcmUgdGhlbSBhZnRlcndhcmRzIChpZiB0aGV5IHdlcmUgaW5pdGlhbGx5IHR1cm5lZCBvbilcbiAgICAgICAgdGhpcy5kaXNhYmxlQW5pbWF0aW9uc0Zvck5leHRUaWNrKGFyZ3MuZGVzdGluYXRpb25UcmVlKTtcbiAgICAgICAgaWYgKGFyZ3Muc291cmNlVHJlZSAhPT0gYXJncy5kZXN0aW5hdGlvblRyZWUpIHtcbiAgICAgICAgICAgIHRoaXMuZGlzYWJsZUFuaW1hdGlvbnNGb3JOZXh0VGljayhhcmdzLnNvdXJjZVRyZWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkgJiYgZXZlbnQuaXNWYWxpZCkge1xuICAgICAgICAgICAgdGhpcy5kcmFnQ2x1ZVNlcnZpY2UuaGlkZSgpO1xuICAgICAgICAgICAgLy8gb3JkZXIgbWF0dGVycyBpbiBhIGZsYXQgZGF0YSBiaW5kaW5nIHNjZW5hcmlvIChmaXJzdCBhZGQsIHRoZW4gcmVtb3ZlKVxuICAgICAgICAgICAgYXJncy5kZXN0aW5hdGlvblRyZWUuYWRkSXRlbS5lbWl0KGFyZ3MpO1xuICAgICAgICAgICAgaWYgKCEob3JpZ2luYWxFdmVudC5jdHJsS2V5ICYmIHRoaXMuYWxsb3dDb3B5KSkge1xuICAgICAgICAgICAgICAgIGFyZ3Muc291cmNlVHJlZS5yZW1vdmVJdGVtLmVtaXQoYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkpIHtcbiAgICAgICAgICAgIC8vIGRpcmVjdGx5IGhpZGUgdGhlIGNsdWUgaWYgdGhlIGRlZmF1bHQgaXMgcHJldmVudGVkXG4gICAgICAgICAgICB0aGlzLmRyYWdDbHVlU2VydmljZS5oaWRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWV2ZW50LmlzVmFsaWQpIHtcbiAgICAgICAgICAgIC8vIGFuaW1hdGUgdGhlIGNsdWUgYmFjayB0byB0aGUgc291cmNlIGl0ZW0gcG9zaXRpb24gaWYgbWFya2VkIGFzIGludmFsaWRcbiAgICAgICAgICAgIHRoaXMuZHJhZ0NsdWVTZXJ2aWNlLmFuaW1hdGVEcmFnQ2x1ZVRvRWxlbWVudFBvc2l0aW9uKHRoaXMuZHJhZ2dlZEl0ZW0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIG5vdGlmeURyYWdFbmQoZHJhZ0VuZEV2ZW50KSB7XG4gICAgICAgIHRoaXMudHJlZXZpZXcubm9kZURyYWdFbmQuZW1pdChkcmFnRW5kRXZlbnQpO1xuICAgIH1cbiAgICBnZXRUYXJnZXRUcmVlVmlldyhkcm9wVGFyZ2V0KSB7XG4gICAgICAgIGNvbnN0IHRyZWVWaWV3VGFnTmFtZSA9IHRoaXMudHJlZXZpZXcuZWxlbWVudC5uYXRpdmVFbGVtZW50LnRhZ05hbWU7XG4gICAgICAgIGNvbnN0IHRhcmdldFRyZWVWaWV3ID0gY2xvc2VzdFdpdGhNYXRjaChkcm9wVGFyZ2V0LCB0cmVlVmlld1RhZ05hbWUpO1xuICAgICAgICByZXR1cm4gW3RoaXMudHJlZXZpZXcsIC4uLnRoaXMuZHJvcFpvbmVUcmVlVmlld3NdLmZpbmQodHJlZVZpZXcgPT4gaXNQcmVzZW50KHRyZWVWaWV3KSAmJiB0cmVlVmlldy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQgPT09IHRhcmdldFRyZWVWaWV3KTtcbiAgICB9XG4gICAgZGlzYWJsZUFuaW1hdGlvbnNGb3JOZXh0VGljayh0cmVlVmlldykge1xuICAgICAgICAvLyB0aGUgdHJlZVZpZXcuYW5pbWF0ZSBnZXR0ZXIgcmV0dXJucyBgdHJ1ZWAgd2hlbiB0aGUgYW5pbWF0aW9ucyBhcmUgdHVybmVkIG9mZlxuICAgICAgICAvLyBjb25mdXNpbmcsIGJ1dCBzZWVtcyBvbiBwdXJwb3NlICh0aGUgYGFuaW1hdGVgIHByb3Agc2V0cyB0aGUgdmFsdWUgb2YgdGhlIEAuZGlzYWJsZWQgaG9zdC1ib3VuZCBhdHRyaWJ1dGUpXG4gICAgICAgIGlmICh0cmVlVmlldy5hbmltYXRlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdHJlZVZpZXcuYW5pbWF0ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnpvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4gc2V0VGltZW91dCgoKSA9PiB0cmVlVmlldy5hbmltYXRlID0gdHJ1ZSkpO1xuICAgIH1cbiAgICBzaG91bGRJbml0aWF0ZURyYWdTdGFydChjdXJyZW50UG9pbnRlckNvb3Jkcykge1xuICAgICAgICBpZiAoIWlzUHJlc2VudCh0aGlzLnBlbmRpbmdEcmFnU3RhcnRFdmVudCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkaXN0YW5jZUZyb21Qb2ludGVyRG93biA9IE1hdGguc3FydChNYXRoLnBvdygodGhpcy5wZW5kaW5nRHJhZ1N0YXJ0RXZlbnQuY2xpZW50WCAtIGN1cnJlbnRQb2ludGVyQ29vcmRzLmNsaWVudFgpLCAyKSArXG4gICAgICAgICAgICBNYXRoLnBvdygodGhpcy5wZW5kaW5nRHJhZ1N0YXJ0RXZlbnQuY2xpZW50WSAtIGN1cnJlbnRQb2ludGVyQ29vcmRzLmNsaWVudFkpLCAyKSk7XG4gICAgICAgIHJldHVybiBkaXN0YW5jZUZyb21Qb2ludGVyRG93biA+PSB0aGlzLnN0YXJ0RHJhZ0FmdGVyO1xuICAgIH1cbiAgICBpbml0aWF0ZURyYWdTdGFydCgpIHtcbiAgICAgICAgaWYgKGhhc09ic2VydmVycyh0aGlzLnRyZWV2aWV3Lm5vZGVEcmFnU3RhcnQpKSB7XG4gICAgICAgICAgICBjb25zdCBkcmFnU3RhcnRFdmVudCA9IHRoaXMuem9uZS5ydW4oKCkgPT4gdGhpcy5ub3RpZnlEcmFnU3RhcnQodGhpcy5wZW5kaW5nRHJhZ1N0YXJ0RXZlbnQsIGdldERyb3BUYXJnZXQodGhpcy5wZW5kaW5nRHJhZ1N0YXJ0RXZlbnQpKSk7XG4gICAgICAgICAgICBpZiAoZHJhZ1N0YXJ0RXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdEcmFnU3RhcnRFdmVudCA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy5kcmFnZ2VkSXRlbSA9IG51bGw7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuZHJhZ0NsdWVTZXJ2aWNlLmNhbmNlbFJldHVybkFuaW1hdGlvbigpO1xuICAgICAgICB0aGlzLmRyYWdDbHVlU2VydmljZS51cGRhdGVUZXh0KHRoaXMuZHJhZ2dlZEl0ZW0uaW5uZXJUZXh0KTtcbiAgICAgICAgdGhpcy5jb250YWluZXJPZmZzZXQgPSBnZXRDb250YWluZXJPZmZzZXQodGhpcy5kcmFnZ2VkSXRlbSk7XG4gICAgICAgIHRoaXMucGVuZGluZ0RyYWdTdGFydEV2ZW50ID0gbnVsbDtcbiAgICB9XG59O1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIERyYWdBbmREcm9wRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJhbGxvd0NvcHlcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEFycmF5KVxuXSwgRHJhZ0FuZERyb3BEaXJlY3RpdmUucHJvdG90eXBlLCBcImRyb3Bab25lVHJlZVZpZXdzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBEcmFnQW5kRHJvcERpcmVjdGl2ZS5wcm90b3R5cGUsIFwic3RhcnREcmFnQWZ0ZXJcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIERyYWdBbmREcm9wRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJhdXRvU2Nyb2xsXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBDb250ZW50Q2hpbGQoRHJhZ0NsdWVUZW1wbGF0ZURpcmVjdGl2ZSwgeyBzdGF0aWM6IGZhbHNlIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBEcmFnQ2x1ZVRlbXBsYXRlRGlyZWN0aXZlKVxuXSwgRHJhZ0FuZERyb3BEaXJlY3RpdmUucHJvdG90eXBlLCBcImRyYWdDbHVlVGVtcGxhdGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIENvbnRlbnRDaGlsZChEcm9wSGludFRlbXBsYXRlRGlyZWN0aXZlLCB7IHN0YXRpYzogZmFsc2UgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIERyb3BIaW50VGVtcGxhdGVEaXJlY3RpdmUpXG5dLCBEcmFnQW5kRHJvcERpcmVjdGl2ZS5wcm90b3R5cGUsIFwiZHJvcEhpbnRUZW1wbGF0ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSG9zdEJpbmRpbmcoJ3N0eWxlLnVzZXItc2VsZWN0JyksXG4gICAgSG9zdEJpbmRpbmcoJ3N0eWxlLi1tcy11c2VyLXNlbGVjdCcpLFxuICAgIEhvc3RCaW5kaW5nKCdzdHlsZS4tbW96LXVzZXItc2VsZWN0JyksXG4gICAgSG9zdEJpbmRpbmcoJ3N0eWxlLi13ZWJraXQtdXNlci1zZWxlY3QnKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgRHJhZ0FuZERyb3BEaXJlY3RpdmUucHJvdG90eXBlLCBcInVzZXJTZWxlY3RTdHlsZVwiLCB2b2lkIDApO1xuRHJhZ0FuZERyb3BEaXJlY3RpdmUgPSBfX2RlY29yYXRlKFtcbiAgICBEaXJlY3RpdmUoe1xuICAgICAgICBzZWxlY3RvcjogJ1trZW5kb1RyZWVWaWV3RHJhZ0FuZERyb3BdJyxcbiAgICAgICAgcHJvdmlkZXJzOiBbXG4gICAgICAgICAgICBEcmFnQ2x1ZVNlcnZpY2UsXG4gICAgICAgICAgICBEcm9wSGludFNlcnZpY2VcbiAgICAgICAgXVxuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbRWxlbWVudFJlZixcbiAgICAgICAgTmdab25lLFxuICAgICAgICBUcmVlVmlld0NvbXBvbmVudCxcbiAgICAgICAgRHJhZ0NsdWVTZXJ2aWNlLFxuICAgICAgICBEcm9wSGludFNlcnZpY2VdKVxuXSwgRHJhZ0FuZERyb3BEaXJlY3RpdmUpO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgREVGQVVMVF9GSUxURVJfU0VUVElOR1MgPSB7XG4gICAgb3BlcmF0b3I6ICdjb250YWlucycsXG4gICAgaWdub3JlQ2FzZTogdHJ1ZSxcbiAgICBtb2RlOiBcImxlbmllbnRcIlxufTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIEZpbHRlcmluZ0Jhc2Uge1xuICAgIGNvbnN0cnVjdG9yKGNvbXBvbmVudCkge1xuICAgICAgICB0aGlzLmNvbXBvbmVudCA9IGNvbXBvbmVudDtcbiAgICAgICAgdGhpcy52aXNpYmxlTm9kZXMgPSBuZXcgU2V0KCk7XG4gICAgICAgIHRoaXMuX2ZpbHRlclNldHRpbmdzID0gREVGQVVMVF9GSUxURVJfU0VUVElOR1M7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBzZXR0aW5ncyB3aGljaCBhcmUgYXBwbGllZCB3aGVuIHBlcmZvcm1pbmcgYSBmaWx0ZXIgb24gdGhlIGNvbXBvbmVudCdzIGRhdGEuXG4gICAgICovXG4gICAgc2V0IGZpbHRlclNldHRpbmdzKHNldHRpbmdzKSB7XG4gICAgICAgIHRoaXMuX2ZpbHRlclNldHRpbmdzID0gT2JqZWN0LmFzc2lnbih7fSwgREVGQVVMVF9GSUxURVJfU0VUVElOR1MsIHNldHRpbmdzKTtcbiAgICB9XG4gICAgZ2V0IGZpbHRlclNldHRpbmdzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZmlsdGVyU2V0dGluZ3M7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgYSBmaWx0ZXIgYW5kIGNoYW5nZXMgdGhlIHZpc2liaWxpdHkgb2YgdGhlIGNvbXBvbmVudCdzIG5vZGVzIGFjY29yZGluZ2x5LlxuICAgICAqL1xuICAgIHNldCBmaWx0ZXIodGVybSkge1xuICAgICAgICB0aGlzLmhhbmRsZUZpbHRlckNoYW5nZSh0ZXJtKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGhhbmRsZUZpbHRlckNoYW5nZSh0ZXJtKSB7XG4gICAgICAgIGlmICghdGhpcy5maWx0ZXJEYXRhKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZXNldE5vZGVzVmlzaWJpbGl0eSh0aGlzLmZpbHRlckRhdGEpO1xuICAgICAgICBpZiAodGVybSkge1xuICAgICAgICAgICAgZmlsdGVyVHJlZSh0aGlzLmZpbHRlckRhdGEsIHRlcm0sIHRoaXMuZmlsdGVyU2V0dGluZ3MsIHRoaXMuY29tcG9uZW50LnRleHRGaWVsZCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51cGRhdGVWaXNpYmxlTm9kZXModGhpcy5maWx0ZXJEYXRhKTtcbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLmNvbXBvbmVudC5maWx0ZXJTdGF0ZUNoYW5nZSkpIHtcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50LmZpbHRlclN0YXRlQ2hhbmdlLmVtaXQoe1xuICAgICAgICAgICAgICAgIG5vZGVzOiB0aGlzLmZpbHRlckRhdGEsXG4gICAgICAgICAgICAgICAgbWF0Y2hDb3VudDogdGhpcy52aXNpYmxlTm9kZXMuc2l6ZSxcbiAgICAgICAgICAgICAgICB0ZXJtLFxuICAgICAgICAgICAgICAgIGZpbHRlclNldHRpbmdzOiB0aGlzLmZpbHRlclNldHRpbmdzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGVWaXNpYmxlTm9kZXMoaXRlbXMpIHtcbiAgICAgICAgaXRlbXMuZm9yRWFjaCgod3JhcHBlcikgPT4ge1xuICAgICAgICAgICAgaWYgKHdyYXBwZXIudmlzaWJsZSkge1xuICAgICAgICAgICAgICAgIHRoaXMudmlzaWJsZU5vZGVzLmFkZCh3cmFwcGVyLmRhdGFJdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh3cmFwcGVyLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVWaXNpYmxlTm9kZXMod3JhcHBlci5jaGlsZHJlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXNldE5vZGVzVmlzaWJpbGl0eShpdGVtcykge1xuICAgICAgICB0aGlzLnZpc2libGVOb2Rlcy5jbGVhcigpO1xuICAgICAgICBpdGVtcy5mb3JFYWNoKCh3cmFwcGVyKSA9PiB7XG4gICAgICAgICAgICB3cmFwcGVyLnZpc2libGUgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKHdyYXBwZXIuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc2V0Tm9kZXNWaXNpYmlsaXR5KHdyYXBwZXIuY2hpbGRyZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbT2JqZWN0XSlcbl0sIEZpbHRlcmluZ0Jhc2UucHJvdG90eXBlLCBcImZpbHRlclNldHRpbmdzXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW1N0cmluZ10pXG5dLCBGaWx0ZXJpbmdCYXNlLnByb3RvdHlwZSwgXCJmaWx0ZXJcIiwgbnVsbCk7XG5cbmNvbnN0IGluZGV4QnVpbGRlciA9IG5ldyBJbmRleEJ1aWxkZXJTZXJ2aWNlKCk7XG5jb25zdCBtYXBUb1dyYXBwZXJzID0gKGN1cnJlbnRMZXZlbE5vZGVzLCBjaGlsZHJlbkZpZWxkLCBwYXJlbnQgPSBudWxsLCBwYXJlbnRJbmRleCA9ICcnKSA9PiB7XG4gICAgaWYgKCFpc0FycmF5V2l0aEF0TGVhc3RPbmVJdGVtKGN1cnJlbnRMZXZlbE5vZGVzKSkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIHJldHVybiBjdXJyZW50TGV2ZWxOb2Rlcy5tYXAoKG5vZGUsIGlkeCkgPT4ge1xuICAgICAgICBjb25zdCBpbmRleCA9IGluZGV4QnVpbGRlci5ub2RlSW5kZXgoaWR4LnRvU3RyaW5nKCksIHBhcmVudEluZGV4KTtcbiAgICAgICAgY29uc3Qgd3JhcHBlciA9IHtcbiAgICAgICAgICAgIGRhdGFJdGVtOiBub2RlLFxuICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICBwYXJlbnQsXG4gICAgICAgICAgICB2aXNpYmxlOiB0cnVlXG4gICAgICAgIH07XG4gICAgICAgIHdyYXBwZXIuY2hpbGRyZW4gPSBtYXBUb1dyYXBwZXJzKGdldHRlcihjaGlsZHJlbkZpZWxkKShub2RlKSwgY2hpbGRyZW5GaWVsZCwgd3JhcHBlciwgaW5kZXgpO1xuICAgICAgICByZXR1cm4gd3JhcHBlcjtcbiAgICB9KTtcbn07XG4vKipcbiAqIEEgZGlyZWN0aXZlIHdoaWNoIGVuY2Fwc3VsYXRlcyB0aGUgcmV0cmlldmFsIG9mIGNoaWxkIG5vZGVzLlxuICovXG5sZXQgSGllcmFyY2h5QmluZGluZ0RpcmVjdGl2ZSA9IGNsYXNzIEhpZXJhcmNoeUJpbmRpbmdEaXJlY3RpdmUgZXh0ZW5kcyBGaWx0ZXJpbmdCYXNlIHtcbiAgICBjb25zdHJ1Y3Rvcihjb21wb25lbnQsIGRyYWdBbmREcm9wRGlyZWN0aXZlKSB7XG4gICAgICAgIHN1cGVyKGNvbXBvbmVudCk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50ID0gY29tcG9uZW50O1xuICAgICAgICB0aGlzLmRyYWdBbmREcm9wRGlyZWN0aXZlID0gZHJhZ0FuZERyb3BEaXJlY3RpdmU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaGlkZGVuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmxvYWRPbkRlbWFuZCA9IHRydWU7XG4gICAgICAgIHRoaXMub3JpZ2luYWxEYXRhID0gW107XG4gICAgICAgIGNvbnN0IHNob3VsZEZpbHRlciA9ICFpc1ByZXNlbnQodGhpcy5kcmFnQW5kRHJvcERpcmVjdGl2ZSk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50LmlzVmlzaWJsZSA9IHNob3VsZEZpbHRlciA/IChub2RlKSA9PiB0aGlzLnZpc2libGVOb2Rlcy5oYXMobm9kZSkgOiBpc1Zpc2libGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBmaWVsZCBuYW1lIHdoaWNoIGhvbGRzIHRoZSBkYXRhIGl0ZW1zIG9mIHRoZSBjaGlsZCBjb21wb25lbnQuXG4gICAgICovXG4gICAgc2V0IGNoaWxkcmVuRmllbGQodmFsdWUpIHtcbiAgICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiJ2NoaWxkcmVuRmllbGQnIGNhbm5vdCBiZSBlbXB0eVwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jaGlsZHJlbkZpZWxkID0gdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBub2RlcyB3aGljaCB3aWxsIGJlIGRpc3BsYXllZCBieSB0aGUgVHJlZVZpZXcuXG4gICAgICovXG4gICAgc2V0IG5vZGVzKHZhbHVlcykge1xuICAgICAgICB0aGlzLm9yaWdpbmFsRGF0YSA9IHZhbHVlcyB8fCBbXTtcbiAgICAgICAgdGhpcy5maWx0ZXJEYXRhID0gbWFwVG9XcmFwcGVycyh2YWx1ZXMsIHRoaXMuY2hpbGRyZW5GaWVsZCkgfHwgW107XG4gICAgICAgIHRoaXMudXBkYXRlVmlzaWJsZU5vZGVzKHRoaXMuZmlsdGVyRGF0YSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBBIGNhbGxiYWNrIHdoaWNoIGRldGVybWluZXMgd2hldGhlciBhIFRyZWVWaWV3IG5vZGUgc2hvdWxkIGJlIHJlbmRlcmVkIGFzIGhpZGRlbi5cbiAgICAgKi9cbiAgICBzZXQgaXNWaXNpYmxlKGZuKSB7XG4gICAgICAgIHRoaXMuY29tcG9uZW50LmlzVmlzaWJsZSA9IGZuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgZmllbGQgbmFtZSB3aGljaCBob2xkcyB0aGUgZGF0YSBpdGVtcyBvZiB0aGUgY2hpbGQgY29tcG9uZW50LlxuICAgICAqL1xuICAgIGdldCBjaGlsZHJlbkZpZWxkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2hpbGRyZW5GaWVsZDtcbiAgICB9XG4gICAgbmdPbkluaXQoKSB7XG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5jaGlsZHJlbkZpZWxkKSkge1xuICAgICAgICAgICAgdGhpcy5jb21wb25lbnQuY2hpbGRyZW4gPSBpdGVtID0+IG9mKGdldHRlcih0aGlzLmNoaWxkcmVuRmllbGQpKGl0ZW0pKTtcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50Lmhhc0NoaWxkcmVuID0gaXRlbSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBnZXR0ZXIodGhpcy5jaGlsZHJlbkZpZWxkKShpdGVtKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gQm9vbGVhbihjaGlsZHJlbiAmJiBjaGlsZHJlbi5sZW5ndGgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50LmVkaXRTZXJ2aWNlID0gbmV3IEhpZXJhcmNoeUVkaXRpbmdTZXJ2aWNlKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5jb21wb25lbnQuZmlsdGVyQ2hhbmdlLnN1YnNjcmliZSh0aGlzLmhhbmRsZUZpbHRlckNoYW5nZS5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbXBvbmVudC5maWx0ZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZUZpbHRlckNoYW5nZSh0aGlzLmNvbXBvbmVudC5maWx0ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLmxvYWRPbkRlbWFuZCAmJiBpc1ByZXNlbnQodGhpcy5jb21wb25lbnQucHJlbG9hZENoaWxkTm9kZXMpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb21wb25lbnQucHJlbG9hZENoaWxkTm9kZXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzKSB7XG4gICAgICAgIGlmIChpc0NoYW5nZWQoJ2NoaWxkcmVuRmllbGQnLCBjaGFuZ2VzLCBmYWxzZSkpIHtcbiAgICAgICAgICAgIHRoaXMubm9kZXMgPSB0aGlzLm9yaWdpbmFsRGF0YTtcbiAgICAgICAgfVxuICAgICAgICAvLyBzaG91bGQgcmVhY3QgdG8gY2hhbmdlcy5sb2FkT25EZW1hbmQgYXMgd2VsbCAtIHNob3VsZCBwcmVsb2FkIHRoZSBkYXRhIG9yIGNsZWFyIHRoZSBhbHJlYWR5IGNhY2hlZCBpdGVtc1xuICAgICAgICBpZiAoYW55Q2hhbmdlZChbJ25vZGVzJywgJ2xvYWRPbkRlbWFuZCddLCBjaGFuZ2VzKSAmJiAhdGhpcy5sb2FkT25EZW1hbmQgJiYgaXNQcmVzZW50KHRoaXMuY29tcG9uZW50LnByZWxvYWRDaGlsZE5vZGVzKSkge1xuICAgICAgICAgICAgdGhpcy5jb21wb25lbnQucHJlbG9hZENoaWxkTm9kZXMoKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbU3RyaW5nXSlcbl0sIEhpZXJhcmNoeUJpbmRpbmdEaXJlY3RpdmUucHJvdG90eXBlLCBcImNoaWxkcmVuRmllbGRcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtBcnJheV0pXG5dLCBIaWVyYXJjaHlCaW5kaW5nRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJub2Rlc1wiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0Z1bmN0aW9uXSlcbl0sIEhpZXJhcmNoeUJpbmRpbmdEaXJlY3RpdmUucHJvdG90eXBlLCBcImlzVmlzaWJsZVwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBIaWVyYXJjaHlCaW5kaW5nRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJsb2FkT25EZW1hbmRcIiwgdm9pZCAwKTtcbkhpZXJhcmNoeUJpbmRpbmdEaXJlY3RpdmUgPSBfX2RlY29yYXRlKFtcbiAgICBEaXJlY3RpdmUoeyBzZWxlY3RvcjogJ1trZW5kb1RyZWVWaWV3SGllcmFyY2h5QmluZGluZ10nIH0pLFxuICAgIF9fcGFyYW0oMSwgT3B0aW9uYWwoKSksIF9fcGFyYW0oMSwgSG9zdCgpKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0RhdGFCb3VuZENvbXBvbmVudCxcbiAgICAgICAgRHJhZ0FuZERyb3BEaXJlY3RpdmVdKVxuXSwgSGllcmFyY2h5QmluZGluZ0RpcmVjdGl2ZSk7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5sZXQgTG9hZGluZ0luZGljYXRvckRpcmVjdGl2ZSA9IGNsYXNzIExvYWRpbmdJbmRpY2F0b3JEaXJlY3RpdmUge1xuICAgIGNvbnN0cnVjdG9yKGV4cGFuZFNlcnZpY2UsIGxvYWRpbmdTZXJ2aWNlLCBjZCkge1xuICAgICAgICB0aGlzLmV4cGFuZFNlcnZpY2UgPSBleHBhbmRTZXJ2aWNlO1xuICAgICAgICB0aGlzLmxvYWRpbmdTZXJ2aWNlID0gbG9hZGluZ1NlcnZpY2U7XG4gICAgICAgIHRoaXMuY2QgPSBjZDtcbiAgICAgICAgdGhpcy5fbG9hZGluZyA9IGZhbHNlO1xuICAgIH1cbiAgICBnZXQgbG9hZGluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvYWRpbmc7XG4gICAgfVxuICAgIHNldCBsb2FkaW5nKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX2xvYWRpbmcgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5jZC5tYXJrRm9yQ2hlY2soKTtcbiAgICB9XG4gICAgbmdPbkluaXQoKSB7XG4gICAgICAgIGNvbnN0IGxvYWRpbmdOb3RpZmljYXRpb25zID0gdGhpcy5sb2FkaW5nU2VydmljZVxuICAgICAgICAgICAgLmNoYW5nZXNcbiAgICAgICAgICAgIC5waXBlKGZpbHRlcihpbmRleCA9PiBpbmRleCA9PT0gdGhpcy5pbmRleCkpO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbiA9IHRoaXMuZXhwYW5kU2VydmljZVxuICAgICAgICAgICAgLmNoYW5nZXNcbiAgICAgICAgICAgIC5waXBlKGZpbHRlcigoeyBpbmRleCB9KSA9PiBpbmRleCA9PT0gdGhpcy5pbmRleCksIHRhcCgoeyBleHBhbmQgfSkgPT4ge1xuICAgICAgICAgICAgaWYgKCFleHBhbmQgJiYgdGhpcy5sb2FkaW5nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2FkaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLCBmaWx0ZXIoKHsgZXhwYW5kIH0pID0+IGV4cGFuZCksIHN3aXRjaE1hcCh4ID0+IG9mKHgpLnBpcGUoZGVsYXkoMTAwKSwgdGFrZVVudGlsKGxvYWRpbmdOb3RpZmljYXRpb25zKSkpKVxuICAgICAgICAgICAgLnN1YnNjcmliZSgoKSA9PiB0aGlzLmxvYWRpbmcgPSB0cnVlKTtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb24uYWRkKGxvYWRpbmdOb3RpZmljYXRpb25zLnN1YnNjcmliZSgoKSA9PiB0aGlzLmxvYWRpbmcgPSBmYWxzZSkpO1xuICAgIH1cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgaWYgKHRoaXMuc3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgfVxufTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RCaW5kaW5nKFwiY2xhc3Muay1pLWxvYWRpbmdcIiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQm9vbGVhbl0pXG5dLCBMb2FkaW5nSW5kaWNhdG9yRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJsb2FkaW5nXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoXCJrZW5kb1RyZWVWaWV3TG9hZGluZ1wiKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgTG9hZGluZ0luZGljYXRvckRpcmVjdGl2ZS5wcm90b3R5cGUsIFwiaW5kZXhcIiwgdm9pZCAwKTtcbkxvYWRpbmdJbmRpY2F0b3JEaXJlY3RpdmUgPSBfX2RlY29yYXRlKFtcbiAgICBEaXJlY3RpdmUoeyBzZWxlY3RvcjogJ1trZW5kb1RyZWVWaWV3TG9hZGluZ10nIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbRXhwYW5kU3RhdGVTZXJ2aWNlLFxuICAgICAgICBMb2FkaW5nTm90aWZpY2F0aW9uU2VydmljZSxcbiAgICAgICAgQ2hhbmdlRGV0ZWN0b3JSZWZdKVxuXSwgTG9hZGluZ0luZGljYXRvckRpcmVjdGl2ZSk7XG5cbi8qKlxuICogQGhpZGRlblxuICogUGVyZm9ybXMgdGhlIHJpZ2h0LXRvLWxlZnQgZnVuY3Rpb24gY29tcG9zaXRpb24uIEZ1bmN0aW9ucyBtdXN0IGhhdmUgYSB1bmFyeS5cbiAqL1xuY29uc3QgY29tcG9zZSA9ICguLi5hcmdzKSA9PiAoZGF0YSkgPT4gYXJncy5yZWR1Y2VSaWdodCgoYWNjLCBjdXJyKSA9PiBjdXJyKGFjYyksIGRhdGEpO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgRmxhdEVkaXRpbmdTZXJ2aWNlIHtcbiAgICBjb25zdHJ1Y3RvcihmbGF0QmluZGluZykge1xuICAgICAgICB0aGlzLmZsYXRCaW5kaW5nID0gZmxhdEJpbmRpbmc7XG4gICAgfVxuICAgIGFkZCh7IHNvdXJjZUl0ZW0sIGRlc3RpbmF0aW9uSXRlbSwgZHJvcFBvc2l0aW9uLCBzb3VyY2VUcmVlLCBkZXN0aW5hdGlvblRyZWUgfSkge1xuICAgICAgICAvLyBzaGFsbG93IGNsb25lIHRoZSBpdGVtIGFzIG5vdCB0byBtaXN0YWtlIGl0IGZvciBpdHMgJ29sZGVyJyB2ZXJzaW9uIHdoZW4gdGhlIHJlbW92ZSBoYW5kbGVyIGtpY2tzIGluIHRvIHNwbGljZSB0aGUgaXRlbSBhdCBpdHMgb2xkIHBvc2l0aW9uXG4gICAgICAgIGNvbnN0IGNsb25lZFNvdXJjZURhdGFJdGVtID0gT2JqZWN0LmFzc2lnbih7fSwgZ2V0RGF0YUl0ZW0oc291cmNlSXRlbSkpO1xuICAgICAgICBpZiAoZHJvcFBvc2l0aW9uID09PSBEcm9wUG9zaXRpb24uT3Zlcikge1xuICAgICAgICAgICAgLy8gZXhwYW5kIHRoZSBpdGVtIHRoYXQgd2FzIGRyb3BwZWQgaW50b1xuICAgICAgICAgICAgZXhwYW5kRHJvcFRhcmdldChkZXN0aW5hdGlvbkl0ZW0sIGRlc3RpbmF0aW9uVHJlZSk7XG4gICAgICAgICAgICBjb25zdCBkZXN0aW5hdGlvbkl0ZW1JZCA9IGdldHRlcih0aGlzLmZsYXRCaW5kaW5nLmlkRmllbGQpKGdldERhdGFJdGVtKGRlc3RpbmF0aW9uSXRlbSkpO1xuICAgICAgICAgICAgc2V0dGVyKHRoaXMuZmxhdEJpbmRpbmcucGFyZW50SWRGaWVsZCkoY2xvbmVkU291cmNlRGF0YUl0ZW0sIGRlc3RpbmF0aW9uSXRlbUlkKTtcbiAgICAgICAgICAgIGNvbnN0IGxhc3RDaGlsZE5vZGVJbmRleCA9IHRoaXMuZ2V0TGFzdFZpc2libGVDaGlsZE5vZGVJbmRleChkZXN0aW5hdGlvblRyZWUsIHRoaXMuZmxhdEJpbmRpbmcub3JpZ2luYWxEYXRhLCBnZXREYXRhSXRlbShkZXN0aW5hdGlvbkl0ZW0pKTtcbiAgICAgICAgICAgIC8vIGluc2VydCBhZnRlciB0aGUgbGFzdCB2aXNpYmxlIGNoaWxkXG4gICAgICAgICAgICBjb25zdCB0YXJnZXRJbmRleCA9IGxhc3RDaGlsZE5vZGVJbmRleCArIDE7XG4gICAgICAgICAgICB0aGlzLmZsYXRCaW5kaW5nLm9yaWdpbmFsRGF0YS5zcGxpY2UodGFyZ2V0SW5kZXgsIDAsIGNsb25lZFNvdXJjZURhdGFJdGVtKTtcbiAgICAgICAgICAgIC8vIHJlYmluZCB0aGUgdHJlZXZpZXcgZGF0YSBiZWZvcmUgc2VhcmNoaW5nIGZvciB0aGUgZm9jdXMgdGFyZ2V0IGluZGV4XG4gICAgICAgICAgICB0aGlzLnJlYmluZERhdGEoKTtcbiAgICAgICAgICAgIGNvbnN0IGZvY3VzVGFyZ2V0ID0gdGhpcy5mZXRjaENoaWxkTm9kZXMoZ2V0RGF0YUl0ZW0oZGVzdGluYXRpb25JdGVtKSwgZGVzdGluYXRpb25UcmVlKS5pbmRleE9mKGNsb25lZFNvdXJjZURhdGFJdGVtKTtcbiAgICAgICAgICAgIHRoaXMubW92ZWRJdGVtTmV3SW5kZXggPSBidWlsZFRyZWVJbmRleChkZXN0aW5hdGlvbkl0ZW0uaXRlbS5pbmRleCwgZm9jdXNUYXJnZXQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3Qgc2hpZnRJbmRleCA9IGRyb3BQb3NpdGlvbiA9PT0gRHJvcFBvc2l0aW9uLkFmdGVyID8gMSA6IDA7XG4gICAgICAgICAgICBjb25zdCB0YXJnZXRJbmRleCA9IHRoaXMuZmxhdEJpbmRpbmcub3JpZ2luYWxEYXRhLmluZGV4T2YoZ2V0RGF0YUl0ZW0oZGVzdGluYXRpb25JdGVtKSkgKyBzaGlmdEluZGV4O1xuICAgICAgICAgICAgdGhpcy5mbGF0QmluZGluZy5vcmlnaW5hbERhdGEuc3BsaWNlKHRhcmdldEluZGV4LCAwLCBjbG9uZWRTb3VyY2VEYXRhSXRlbSk7XG4gICAgICAgICAgICBjb25zdCBkZXN0aW5hdGlvbkl0ZW1QYXJlbnRJZCA9IGdldHRlcih0aGlzLmZsYXRCaW5kaW5nLnBhcmVudElkRmllbGQpKGdldERhdGFJdGVtKGRlc3RpbmF0aW9uSXRlbSkpO1xuICAgICAgICAgICAgc2V0dGVyKHRoaXMuZmxhdEJpbmRpbmcucGFyZW50SWRGaWVsZCkoY2xvbmVkU291cmNlRGF0YUl0ZW0sIGRlc3RpbmF0aW9uSXRlbVBhcmVudElkKTtcbiAgICAgICAgICAgIC8vIHJlYmluZCB0aGUgdHJlZXZpZXcgZGF0YSBiZWZvcmUgc2VhcmNoaW5nIGZvciB0aGUgZm9jdXMgdGFyZ2V0IGluZGV4XG4gICAgICAgICAgICB0aGlzLnJlYmluZERhdGEoKTtcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudEluZGV4ID0gZGVzdGluYXRpb25JdGVtLnBhcmVudCA/XG4gICAgICAgICAgICAgICAgZGVzdGluYXRpb25JdGVtLnBhcmVudC5pdGVtLmluZGV4IDpcbiAgICAgICAgICAgICAgICBudWxsO1xuICAgICAgICAgICAgY29uc3QgcGFyZW50Q29udGFpbmVyID0gZGVzdGluYXRpb25JdGVtLnBhcmVudCA/XG4gICAgICAgICAgICAgICAgdGhpcy5mZXRjaENoaWxkTm9kZXMoZ2V0RGF0YUl0ZW0oZGVzdGluYXRpb25JdGVtLnBhcmVudCksIGRlc3RpbmF0aW9uVHJlZSkgOlxuICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uVHJlZS5ub2RlcztcbiAgICAgICAgICAgIGNvbnN0IGZvY3VzVGFyZ2V0ID0gcGFyZW50Q29udGFpbmVyLmluZGV4T2YoY2xvbmVkU291cmNlRGF0YUl0ZW0pO1xuICAgICAgICAgICAgdGhpcy5tb3ZlZEl0ZW1OZXdJbmRleCA9IGJ1aWxkVHJlZUluZGV4KHBhcmVudEluZGV4LCBmb2N1c1RhcmdldCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNvdXJjZVRyZWUgIT09IGRlc3RpbmF0aW9uVHJlZSkge1xuICAgICAgICAgICAgdGhpcy5hZGRDaGlsZE5vZGVzKGNsb25lZFNvdXJjZURhdGFJdGVtLCBzb3VyY2VUcmVlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpbmNyZW1lbnQgdGhlIHBhcmVudCBwYWdlIHNpemUgPT4gYW4gaXRlbSBpcyBtb3ZlZCBpbnRvIGl0XG4gICAgICAgIGNvbnN0IHVwZGF0ZWRQYXJlbnQgPSBkcm9wUG9zaXRpb24gPT09IERyb3BQb3NpdGlvbi5PdmVyID8gZ2V0RGF0YUl0ZW0oZGVzdGluYXRpb25JdGVtKSA6IGdldERhdGFJdGVtKGRlc3RpbmF0aW9uSXRlbS5wYXJlbnQpO1xuICAgICAgICBpbmNyZW1lbnRQYWdlU2l6ZShkZXN0aW5hdGlvblRyZWUsIHVwZGF0ZWRQYXJlbnQpO1xuICAgICAgICAvLyB0aGUgcGFnZSBzaXplcyBhcmUgc3RvcmVkIGJ5IGRhdGEtaXRlbSByZWZlcmVuY2UgPT4gY29weSB0aGUgb2xkIGl0ZW0gcmVmIHBhZ2Ugc2l6ZSB0byB0aGUgbmV3IGl0ZW0gcmVmZXJlbmNlXG4gICAgICAgIGNvcHlQYWdlU2l6ZShkZXN0aW5hdGlvblRyZWUsIGdldERhdGFJdGVtKHNvdXJjZUl0ZW0pLCBjbG9uZWRTb3VyY2VEYXRhSXRlbSk7XG4gICAgICAgIC8vIHRoZSBzb3VyY2UgdHJlZSBub2RlcyBhcmUgcmVsb2FkZWQgb24gYHJlbW92ZUl0ZW1gIC0gcmVsb2FkIHRoZSBkZXN0aW5hdGlvbiB0cmVlIG5vZGVzIGlmIHRoZSBzb3J1Y2UgYW5kIHRoZSBkZXN0aW5hdGlvbiB0cmVlIGFyZSBkaWZmZXJlbnRcbiAgICAgICAgaWYgKHNvdXJjZVRyZWUgIT09IGRlc3RpbmF0aW9uVHJlZSAmJiAhZGVzdGluYXRpb25UcmVlLmxvYWRPbkRlbWFuZCkge1xuICAgICAgICAgICAgZGVzdGluYXRpb25UcmVlLnByZWxvYWRDaGlsZE5vZGVzKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgdGhlIHNvdXJjZSBhbmQgZGVzdGluYXRpb24gdHJlZXMgYXJlIHRoZSBzYW1lLCBmb2N1c2luZyB0aGUgbW92ZWQgaXRlbSBoZXJlIHdpbGwgbm90IGhhdmUgdGhlIGRlc2lyZWQgZWZmZWN0XG4gICAgICAgIC8vIGFzIHRoZSBgcmVtb3ZlYCBoYW5kbGVyIGhhcyBub3QgeWV0IGtpY2tlZC1pbiB0byByZW1vdmUgdGhlIGl0ZW0gZnJvbSBpdHMgb2xkIHBvc2l0aW9uXG4gICAgICAgIGlmIChzb3VyY2VUcmVlICE9PSBkZXN0aW5hdGlvblRyZWUpIHtcbiAgICAgICAgICAgIC8vIGVuc3VyZSB0aGUgZm9jdXMgdGFyZ2V0IGlzIHJlbmRlcmVkIGFuZCByZWdpc3RlcmVkXG4gICAgICAgICAgICBkZXN0aW5hdGlvblRyZWUuY2hhbmdlRGV0ZWN0b3JSZWYuZGV0ZWN0Q2hhbmdlcygpO1xuICAgICAgICAgICAgZGVzdGluYXRpb25UcmVlLmZvY3VzKHRoaXMubW92ZWRJdGVtTmV3SW5kZXgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlbW92ZSh7IHNvdXJjZUl0ZW0sIHNvdXJjZVRyZWUsIGRlc3RpbmF0aW9uVHJlZSB9KSB7XG4gICAgICAgIGNvbnN0IHNvdXJjZURhdGFJdGVtID0gZ2V0RGF0YUl0ZW0oc291cmNlSXRlbSk7XG4gICAgICAgIGNvbnN0IHNvdXJjZUl0ZW1JbmRleCA9IHRoaXMuZmxhdEJpbmRpbmcub3JpZ2luYWxEYXRhLmluZGV4T2Yoc291cmNlRGF0YUl0ZW0pO1xuICAgICAgICB0aGlzLmZsYXRCaW5kaW5nLm9yaWdpbmFsRGF0YS5zcGxpY2Uoc291cmNlSXRlbUluZGV4LCAxKTtcbiAgICAgICAgaWYgKHNvdXJjZVRyZWUgIT09IGRlc3RpbmF0aW9uVHJlZSkge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVDaGlsZE5vZGVzKHNvdXJjZURhdGFJdGVtLCBzb3VyY2VUcmVlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlYmluZERhdGEoKTtcbiAgICAgICAgLy8gZW1pdCBjb2xsYXBzZSBmb3IgdGhlIHBhcmVudCBub2RlIGlmIGl0cyBsYXN0IGNoaWxkIG5vZGUgd2FzIHNwbGljZWRcbiAgICAgICAgY29uc3QgcGFyZW50Q2hpbGRyZW4gPSBzb3VyY2VJdGVtLnBhcmVudCA/IHNvdXJjZUl0ZW0ucGFyZW50LmNoaWxkcmVuIDogW107XG4gICAgICAgIGNvbGxhcHNlRW1wdHlQYXJlbnQoc291cmNlSXRlbS5wYXJlbnQsIHBhcmVudENoaWxkcmVuLCBzb3VyY2VUcmVlKTtcbiAgICAgICAgLy8gZGVjcmVtZW50IHNvdXJjZSBpdGVtIHBhcmVudCBwYWdlIHNpemUgPT4gYW4gaXRlbSBoYXMgYmVlbiByZW1vdmVkIGZyb20gaXRcbiAgICAgICAgZGVjcmVtZW50UGFnZVNpemUoc291cmNlVHJlZSwgZ2V0RGF0YUl0ZW0oc291cmNlSXRlbS5wYXJlbnQpKTtcbiAgICAgICAgLy8gcmVsb2FkIHRoZSB0cmVldmlldyBub2Rlc1xuICAgICAgICBpZiAoIXNvdXJjZVRyZWUubG9hZE9uRGVtYW5kKSB7XG4gICAgICAgICAgICBzb3VyY2VUcmVlLnByZWxvYWRDaGlsZE5vZGVzKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgdGhlIHNvdXJjZSBhbmQgZGVzdGluYXRpb24gdHJlZXMgYXJlIGRpZmZlcmVudCB3ZSB3YW50IHRvIGZvY3VzIG9ubHkgdGhlIG1vdmVkIGl0ZW0gaW4gdGhlIGRlc3RpbmF0aW9uIHRyZWVcbiAgICAgICAgaWYgKHNvdXJjZVRyZWUgPT09IGRlc3RpbmF0aW9uVHJlZSkge1xuICAgICAgICAgICAgLy8gZW5zdXJlIHRoZSBmb2N1cyB0YXJnZXQgaXMgcmVuZGVyZWQgYW5kIHJlZ2lzdGVyZWRcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uVHJlZS5jaGFuZ2VEZXRlY3RvclJlZi5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgICAgICAgICAvLyBhZnRlciB0aGUgc291cmNlIGl0ZW0gaXMgcmVtb3ZlZCBmcm9tIGl0cyBvcmlnaW5hbCBwb3NpdGlvbiwgdGhlIGNhbmRpZGF0ZSBpbmRleCBtaWdodCBoYXZlIHRvIGJlIGNvcnJlY3RlZFxuICAgICAgICAgICAgY29uc3QgaW5kZXggPSB1cGRhdGVNb3ZlZEl0ZW1JbmRleCh0aGlzLm1vdmVkSXRlbU5ld0luZGV4LCBzb3VyY2VJdGVtLml0ZW0uaW5kZXgpO1xuICAgICAgICAgICAgZGVzdGluYXRpb25UcmVlLmZvY3VzKGluZGV4KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhZGRDaGlsZE5vZGVzKGRhdGFJdGVtLCBzb3VyY2UpIHtcbiAgICAgICAgY29uc3QgaXRlbUNoaWxkcmVuID0gdGhpcy5mZXRjaEFsbERlc2NlbmRhbnROb2RlcyhkYXRhSXRlbSwgc291cmNlKTtcbiAgICAgICAgdGhpcy5mbGF0QmluZGluZy5vcmlnaW5hbERhdGEucHVzaCguLi5pdGVtQ2hpbGRyZW4pO1xuICAgIH1cbiAgICByZW1vdmVDaGlsZE5vZGVzKGRhdGFJdGVtLCBzb3VyY2UpIHtcbiAgICAgICAgY29uc3Qgc291cmNlQ2hpbGRyZW4gPSB0aGlzLmZldGNoQWxsRGVzY2VuZGFudE5vZGVzKGRhdGFJdGVtLCBzb3VyY2UpO1xuICAgICAgICBzb3VyY2VDaGlsZHJlbi5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLmZsYXRCaW5kaW5nLm9yaWdpbmFsRGF0YS5pbmRleE9mKGl0ZW0pO1xuICAgICAgICAgICAgdGhpcy5mbGF0QmluZGluZy5vcmlnaW5hbERhdGEuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZldGNoQWxsRGVzY2VuZGFudE5vZGVzKG5vZGUsIHRyZWV2aWV3KSB7XG4gICAgICAgIGxldCBub2RlcyA9IHRoaXMuZmV0Y2hDaGlsZE5vZGVzKG5vZGUsIHRyZWV2aWV3KTtcbiAgICAgICAgbm9kZXMuZm9yRWFjaChub2RlID0+IG5vZGVzID0gbm9kZXMuY29uY2F0KHRoaXMuZmV0Y2hBbGxEZXNjZW5kYW50Tm9kZXMobm9kZSwgdHJlZXZpZXcpIHx8IFtdKSk7XG4gICAgICAgIHJldHVybiBub2RlcztcbiAgICB9XG4gICAgZmV0Y2hDaGlsZE5vZGVzKG5vZGUsIHRyZWV2aWV3KSB7XG4gICAgICAgIGlmICghbm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIGxldCBub2RlcyA9IFtdO1xuICAgICAgICB0cmVldmlld1xuICAgICAgICAgICAgLmNoaWxkcmVuKG5vZGUpXG4gICAgICAgICAgICAucGlwZSh0YWtlKDEpKVxuICAgICAgICAgICAgLnN1YnNjcmliZShjaGlsZHJlbiA9PiBub2RlcyA9IG5vZGVzLmNvbmNhdChjaGlsZHJlbiB8fCBbXSkpO1xuICAgICAgICByZXR1cm4gbm9kZXM7XG4gICAgfVxuICAgIGdldExhc3RWaXNpYmxlQ2hpbGROb2RlSW5kZXgodHJlZXZpZXcsIGRhdGEsIG5vZGUpIHtcbiAgICAgICAgaWYgKCFpc1ByZXNlbnQodHJlZXZpZXcubG9hZE1vcmVTZXJ2aWNlKSB8fCAhdHJlZXZpZXcuaGFzQ2hpbGRyZW4obm9kZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRhLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2aXNpYmxlTm9kZXNDb3VudCA9IHRyZWV2aWV3LmxvYWRNb3JlU2VydmljZS5nZXRHcm91cFNpemUobm9kZSk7XG4gICAgICAgIGNvbnN0IHZpc2libGVDaGlsZHJlbiA9IHRoaXMuZmV0Y2hDaGlsZE5vZGVzKG5vZGUsIHRyZWV2aWV3KS5zbGljZSgwLCB2aXNpYmxlTm9kZXNDb3VudCk7XG4gICAgICAgIGNvbnN0IGxhc3ROb2RlID0gdmlzaWJsZUNoaWxkcmVuW3Zpc2libGVDaGlsZHJlbi5sZW5ndGggLSAxXTtcbiAgICAgICAgY29uc3QgbGFzdE5vZGVJbmRleCA9IGRhdGEuaW5kZXhPZihsYXN0Tm9kZSk7XG4gICAgICAgIHJldHVybiBsYXN0Tm9kZUluZGV4O1xuICAgIH1cbiAgICByZWJpbmREYXRhKCkge1xuICAgICAgICB0aGlzLmZsYXRCaW5kaW5nLm5vZGVzID0gdGhpcy5mbGF0QmluZGluZy5vcmlnaW5hbERhdGE7XG4gICAgfVxufVxuXG5jb25zdCBmaW5kQ2hpbGRyZW4gPSAocHJvcCwgbm9kZXMsIHZhbHVlKSA9PiBub2Rlcy5maWx0ZXIoKHgpID0+IHByb3AoeCkgPT09IHZhbHVlKTtcbmNvbnN0IGluZGV4QnVpbGRlciQxID0gbmV3IEluZGV4QnVpbGRlclNlcnZpY2UoKTtcbmNvbnN0IG1hcFRvVHJlZSA9IChjdXJyZW50TGV2ZWxOb2RlcywgYWxsTm9kZXMsIHBhcmVudElkRmllbGQsIGlkRmllbGQsIHBhcmVudCA9IG51bGwsIHBhcmVudEluZGV4ID0gJycpID0+IHtcbiAgICBpZiAoIWlzQXJyYXlXaXRoQXRMZWFzdE9uZUl0ZW0oY3VycmVudExldmVsTm9kZXMpKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgcmV0dXJuIGN1cnJlbnRMZXZlbE5vZGVzLm1hcCgobm9kZSwgaWR4KSA9PiB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gaW5kZXhCdWlsZGVyJDEubm9kZUluZGV4KGlkeC50b1N0cmluZygpLCBwYXJlbnRJbmRleCk7XG4gICAgICAgIGNvbnN0IHdyYXBwZXIgPSB7XG4gICAgICAgICAgICBkYXRhSXRlbTogbm9kZSxcbiAgICAgICAgICAgIGluZGV4LFxuICAgICAgICAgICAgcGFyZW50LFxuICAgICAgICAgICAgdmlzaWJsZTogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgICB3cmFwcGVyLmNoaWxkcmVuID0gbWFwVG9UcmVlKGZpbmRDaGlsZHJlbihnZXR0ZXIocGFyZW50SWRGaWVsZCksIGFsbE5vZGVzIHx8IFtdLCBnZXR0ZXIoaWRGaWVsZCkobm9kZSkpLCBhbGxOb2RlcywgcGFyZW50SWRGaWVsZCwgaWRGaWVsZCwgd3JhcHBlciwgaW5kZXgpO1xuICAgICAgICByZXR1cm4gd3JhcHBlcjtcbiAgICB9KTtcbn07XG4vKipcbiAqIEEgZGlyZWN0aXZlIHdoaWNoIGVuY2Fwc3VsYXRlcyB0aGUgcmV0cmlldmFsIG9mIHRoZSBjaGlsZCBub2Rlcy5cbiAqL1xubGV0IEZsYXREYXRhQmluZGluZ0RpcmVjdGl2ZSA9IGNsYXNzIEZsYXREYXRhQmluZGluZ0RpcmVjdGl2ZSBleHRlbmRzIEZpbHRlcmluZ0Jhc2Uge1xuICAgIGNvbnN0cnVjdG9yKGNvbXBvbmVudCkge1xuICAgICAgICBzdXBlcihjb21wb25lbnQpO1xuICAgICAgICB0aGlzLmNvbXBvbmVudCA9IGNvbXBvbmVudDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBoaWRkZW5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubG9hZE9uRGVtYW5kID0gdHJ1ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBoaWRkZW5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub3JpZ2luYWxEYXRhID0gW107XG4gICAgICAgIHRoaXMuY29tcG9uZW50LmlzVmlzaWJsZSA9IChub2RlKSA9PiB0aGlzLnZpc2libGVOb2Rlcy5oYXMobm9kZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBub2RlcyB3aGljaCB3aWxsIGJlIGRpc3BsYXllZCBieSB0aGUgVHJlZVZpZXcuXG4gICAgICovXG4gICAgc2V0IG5vZGVzKHZhbHVlcykge1xuICAgICAgICB0aGlzLm9yaWdpbmFsRGF0YSA9IHZhbHVlcyB8fCBbXTtcbiAgICAgICAgaWYgKCFpc051bGxPckVtcHR5U3RyaW5nKHRoaXMucGFyZW50SWRGaWVsZCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHByb3AgPSBnZXR0ZXIodGhpcy5wYXJlbnRJZEZpZWxkKTtcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50Lm5vZGVzID0gdGhpcy5vcmlnaW5hbERhdGEuZmlsdGVyKGNvbXBvc2UoaXNCbGFuaywgcHJvcCkpO1xuICAgICAgICAgICAgdGhpcy5maWx0ZXJEYXRhID0gbWFwVG9UcmVlKHRoaXMuY29tcG9uZW50Lm5vZGVzLCB0aGlzLm9yaWdpbmFsRGF0YSwgdGhpcy5wYXJlbnRJZEZpZWxkLCB0aGlzLmlkRmllbGQpO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVWaXNpYmxlTm9kZXModGhpcy5maWx0ZXJEYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50Lm5vZGVzID0gdGhpcy5vcmlnaW5hbERhdGEuc2xpY2UoMCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIEEgY2FsbGJhY2sgd2hpY2ggZGV0ZXJtaW5lcyB3aGV0aGVyIGEgVHJlZVZpZXcgbm9kZSBzaG91bGQgYmUgcmVuZGVyZWQgYXMgaGlkZGVuLlxuICAgICAqL1xuICAgIHNldCBpc1Zpc2libGUoZm4pIHtcbiAgICAgICAgdGhpcy5jb21wb25lbnQuaXNWaXNpYmxlID0gZm47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLnBhcmVudElkRmllbGQpICYmIGlzUHJlc2VudCh0aGlzLmlkRmllbGQpKSB7XG4gICAgICAgICAgICBjb25zdCBmZXRjaENoaWxkcmVuID0gKG5vZGUpID0+IGZpbmRDaGlsZHJlbihnZXR0ZXIodGhpcy5wYXJlbnRJZEZpZWxkKSwgdGhpcy5vcmlnaW5hbERhdGEgfHwgW10sIGdldHRlcih0aGlzLmlkRmllbGQpKG5vZGUpKTtcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50Lmhhc0NoaWxkcmVuID0gKG5vZGUpID0+IGZldGNoQ2hpbGRyZW4obm9kZSkubGVuZ3RoID4gMDtcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50LmNoaWxkcmVuID0gKG5vZGUpID0+IG9mKGZldGNoQ2hpbGRyZW4obm9kZSkpO1xuICAgICAgICAgICAgdGhpcy5jb21wb25lbnQuZWRpdFNlcnZpY2UgPSBuZXcgRmxhdEVkaXRpbmdTZXJ2aWNlKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5jb21wb25lbnQuZmlsdGVyQ2hhbmdlLnN1YnNjcmliZSh0aGlzLmhhbmRsZUZpbHRlckNoYW5nZS5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbXBvbmVudC5maWx0ZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZUZpbHRlckNoYW5nZSh0aGlzLmNvbXBvbmVudC5maWx0ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLmxvYWRPbkRlbWFuZCAmJiBpc1ByZXNlbnQodGhpcy5jb21wb25lbnQucHJlbG9hZENoaWxkTm9kZXMpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb21wb25lbnQucHJlbG9hZENoaWxkTm9kZXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgbmdPbkNoYW5nZXMoY2hhbmdlcykge1xuICAgICAgICBpZiAoaXNDaGFuZ2VkKCdwYXJlbnRJZEZpZWxkJywgY2hhbmdlcywgZmFsc2UpKSB7XG4gICAgICAgICAgICB0aGlzLm5vZGVzID0gdGhpcy5vcmlnaW5hbERhdGE7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2hvdWxkIHJlYWN0IHRvIGNoYW5nZXMubG9hZE9uRGVtYW5kIGFzIHdlbGwgLSBzaG91bGQgcHJlbG9hZCB0aGUgZGF0YSBvciBjbGVhciB0aGUgYWxyZWFkeSBjYWNoZWQgaXRlbXNcbiAgICAgICAgaWYgKGFueUNoYW5nZWQoWydub2RlcycsICdsb2FkT25EZW1hbmQnXSwgY2hhbmdlcykgJiYgIXRoaXMubG9hZE9uRGVtYW5kICYmIGlzUHJlc2VudCh0aGlzLmNvbXBvbmVudC5wcmVsb2FkQ2hpbGROb2RlcykpIHtcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50LnByZWxvYWRDaGlsZE5vZGVzKCk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQXJyYXldKVxuXSwgRmxhdERhdGFCaW5kaW5nRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJub2Rlc1wiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIEZsYXREYXRhQmluZGluZ0RpcmVjdGl2ZS5wcm90b3R5cGUsIFwicGFyZW50SWRGaWVsZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgRmxhdERhdGFCaW5kaW5nRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJpZEZpZWxkXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgRmxhdERhdGFCaW5kaW5nRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJsb2FkT25EZW1hbmRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0Z1bmN0aW9uXSlcbl0sIEZsYXREYXRhQmluZGluZ0RpcmVjdGl2ZS5wcm90b3R5cGUsIFwiaXNWaXNpYmxlXCIsIG51bGwpO1xuRmxhdERhdGFCaW5kaW5nRGlyZWN0aXZlID0gX19kZWNvcmF0ZShbXG4gICAgRGlyZWN0aXZlKHsgc2VsZWN0b3I6IFwiW2tlbmRvVHJlZVZpZXdGbGF0RGF0YUJpbmRpbmddXCIgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtEYXRhQm91bmRDb21wb25lbnRdKVxuXSwgRmxhdERhdGFCaW5kaW5nRGlyZWN0aXZlKTtcblxuY29uc3QgYnVpbGRJdGVtID0gKGluZGV4LCBkYXRhSXRlbSkgPT4gKHsgZGF0YUl0ZW0sIGluZGV4IH0pO1xubGV0IGlkID0gMDtcbmNvbnN0IFRSRUVfSVRFTV9ST0xFID0gJ3RyZWVpdGVtJztcbmNvbnN0IEJVVFRPTl9ST0xFID0gJ2J1dHRvbic7XG4vKipcbiAqIEBoaWRkZW5cbiAqXG4gKiBBIGRpcmVjdGl2ZSB3aGljaCBtYW5hZ2VzIHRoZSBleHBhbmRlZCBzdGF0ZSBvZiB0aGUgVHJlZVZpZXcuXG4gKi9cbmxldCBUcmVlVmlld0l0ZW1EaXJlY3RpdmUgPSBjbGFzcyBUcmVlVmlld0l0ZW1EaXJlY3RpdmUge1xuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnQsIGV4cGFuZFNlcnZpY2UsIG5hdmlnYXRpb25TZXJ2aWNlLCBzZWxlY3Rpb25TZXJ2aWNlLCBsb29rdXBTZXJ2aWNlLCByZW5kZXJlciwgaWIpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICAgICAgdGhpcy5leHBhbmRTZXJ2aWNlID0gZXhwYW5kU2VydmljZTtcbiAgICAgICAgdGhpcy5uYXZpZ2F0aW9uU2VydmljZSA9IG5hdmlnYXRpb25TZXJ2aWNlO1xuICAgICAgICB0aGlzLnNlbGVjdGlvblNlcnZpY2UgPSBzZWxlY3Rpb25TZXJ2aWNlO1xuICAgICAgICB0aGlzLmxvb2t1cFNlcnZpY2UgPSBsb29rdXBTZXJ2aWNlO1xuICAgICAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgICAgIHRoaXMuaWIgPSBpYjtcbiAgICAgICAgdGhpcy5yb2xlID0gVFJFRV9JVEVNX1JPTEU7XG4gICAgICAgIHRoaXMubG9hZE9uRGVtYW5kID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5pc0Rpc2FibGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXNWaXNpYmxlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5hcmlhQ2hlY2tlZCA9ICdmYWxzZSc7XG4gICAgICAgIHRoaXMuaWQgPSBpZCsrO1xuICAgICAgICB0aGlzLmlzSW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zID0gW107XG4gICAgICAgIHRoaXMuc3Vic2NyaWJlKCk7XG4gICAgfVxuICAgIHNldCBpc0NoZWNrZWQoY2hlY2tlZCkge1xuICAgICAgICBpZiAoY2hlY2tlZCA9PT0gJ2NoZWNrZWQnKSB7XG4gICAgICAgICAgICB0aGlzLmFyaWFDaGVja2VkID0gJ3RydWUnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNoZWNrZWQgPT09ICdpbmRldGVybWluYXRlJykge1xuICAgICAgICAgICAgdGhpcy5hcmlhQ2hlY2tlZCA9ICdtaXhlZCc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmFyaWFDaGVja2VkID0gJ2ZhbHNlJztcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgaXNFeHBhbmRlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzRXhwYW5kZWQgfHwgZmFsc2U7XG4gICAgfVxuICAgIHNldCBpc0V4cGFuZGVkKGlzRXhwYW5kZWQpIHtcbiAgICAgICAgdGhpcy5faXNFeHBhbmRlZCA9IGlzRXhwYW5kZWQ7XG4gICAgfVxuICAgIGdldCBpc1NlbGVjdGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNTZWxlY3RlZCB8fCBmYWxzZTtcbiAgICB9XG4gICAgc2V0IGlzU2VsZWN0ZWQoaXNTZWxlY3RlZCkge1xuICAgICAgICB0aGlzLl9pc1NlbGVjdGVkID0gaXNTZWxlY3RlZDtcbiAgICB9XG4gICAgZ2V0IGlzQnV0dG9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yb2xlID09PSBCVVRUT05fUk9MRTtcbiAgICB9XG4gICAgZ2V0IHRyZWVJdGVtKCkge1xuICAgICAgICByZXR1cm4gYnVpbGRJdGVtKHRoaXMuaW5kZXgsIHRoaXMuZGF0YUl0ZW0pO1xuICAgIH1cbiAgICBnZXQgcGFyZW50VHJlZUl0ZW0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcmVudERhdGFJdGVtID8gYnVpbGRJdGVtKHRoaXMucGFyZW50SW5kZXgsIHRoaXMucGFyZW50RGF0YUl0ZW0pIDogbnVsbDtcbiAgICB9XG4gICAgbmdPbkluaXQoKSB7XG4gICAgICAgIGlmICh0aGlzLmxvYWRPbkRlbWFuZCAmJiAhdGhpcy5pc0J1dHRvbikge1xuICAgICAgICAgICAgdGhpcy5sb29rdXBTZXJ2aWNlLnJlZ2lzdGVySXRlbSh0aGlzLnRyZWVJdGVtLCB0aGlzLnBhcmVudFRyZWVJdGVtKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlZ2lzdGVyTmF2aWdhdGlvbkl0ZW0oKTtcbiAgICAgICAgdGhpcy5pc0luaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCB0aGlzLnJvbGUpO1xuICAgICAgICB0aGlzLnNldEFyaWFBdHRyaWJ1dGVzKCk7XG4gICAgICAgIHRoaXMuc2V0RGlzYWJsZWRDbGFzcygpO1xuICAgICAgICB0aGlzLnVwZGF0ZVRhYkluZGV4KCk7XG4gICAgfVxuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXMpIHtcbiAgICAgICAgY29uc3QgeyBpbmRleCwgaXNEaXNhYmxlZCB9ID0gY2hhbmdlcztcbiAgICAgICAgaWYgKGFueUNoYW5nZWQoWydpbmRleCcsICdjaGVja2FibGUnLCAnaXNDaGVja2VkJywgJ2V4cGFuZGFibGUnLCAnaXNFeHBhbmRlZCcsICdzZWxlY3RhYmxlJywgJ2lzU2VsZWN0ZWQnXSwgY2hhbmdlcykpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0QXJpYUF0dHJpYnV0ZXMoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNEaXNhYmxlZCkge1xuICAgICAgICAgICAgdGhpcy5zZXREaXNhYmxlZENsYXNzKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubG9hZE9uRGVtYW5kICYmICF0aGlzLmlzQnV0dG9uKSB7XG4gICAgICAgICAgICB0aGlzLm1vdmVMb29rdXBJdGVtKGNoYW5nZXMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubW92ZU5hdmlnYXRpb25JdGVtKGluZGV4KTtcbiAgICAgICAgaWYgKGFueUNoYW5nZWQoWydpc0Rpc2FibGVkJywgJ2lzVmlzaWJsZSddLCBjaGFuZ2VzKSkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVOb2RlQXZhaWxhYmlsaXR5KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMubmF2aWdhdGlvblNlcnZpY2UudW5yZWdpc3Rlckl0ZW0odGhpcy5pZCwgdGhpcy5pbmRleCk7XG4gICAgICAgIGlmICh0aGlzLmxvYWRPbkRlbWFuZCAmJiAhdGhpcy5pc0J1dHRvbikge1xuICAgICAgICAgICAgdGhpcy5sb29rdXBTZXJ2aWNlLnVucmVnaXN0ZXJJdGVtKHRoaXMuaW5kZXgsIHRoaXMuZGF0YUl0ZW0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucyA9IHRoaXMuc3Vic2NyaXB0aW9ucy5yZWR1Y2UoKGxpc3QsIGNhbGxiYWNrKSA9PiAoY2FsbGJhY2sudW5zdWJzY3JpYmUoKSwgbGlzdCksIFtdKTtcbiAgICB9XG4gICAgc3Vic2NyaWJlKCkge1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMgPSBbXG4gICAgICAgICAgICB0aGlzLm5hdmlnYXRpb25TZXJ2aWNlLm1vdmVzXG4gICAgICAgICAgICAgICAgLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVUYWJJbmRleCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuZm9jdXNJdGVtKCk7XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHRoaXMubmF2aWdhdGlvblNlcnZpY2UuZXhwYW5kc1xuICAgICAgICAgICAgICAgIC5waXBlKGZpbHRlcigoeyBpbmRleCB9KSA9PiBpbmRleCA9PT0gdGhpcy5pbmRleCAmJiAhdGhpcy5pc0Rpc2FibGVkKSlcbiAgICAgICAgICAgICAgICAuc3Vic2NyaWJlKCh7IGV4cGFuZCB9KSA9PiB0aGlzLmV4cGFuZChleHBhbmQpKVxuICAgICAgICBdO1xuICAgIH1cbiAgICByZWdpc3Rlck5hdmlnYXRpb25JdGVtKCkge1xuICAgICAgICB0aGlzLm5hdmlnYXRpb25TZXJ2aWNlLnJlZ2lzdGVySXRlbSh0aGlzLmlkLCB0aGlzLmluZGV4LCB0aGlzLmlzRGlzYWJsZWQsIHRoaXMuaXNCdXR0b24sIHRoaXMuaXNWaXNpYmxlKTtcbiAgICAgICAgdGhpcy5hY3RpdmF0ZUl0ZW0oKTtcbiAgICB9XG4gICAgYWN0aXZhdGVJdGVtKCkge1xuICAgICAgICBpZiAodGhpcy5pc0Rpc2FibGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmF2aWdhdGlvblNlcnZpY2UgPSB0aGlzLm5hdmlnYXRpb25TZXJ2aWNlO1xuICAgICAgICBjb25zdCBzZWxlY3Rpb25TZXJ2aWNlID0gdGhpcy5zZWxlY3Rpb25TZXJ2aWNlO1xuICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuaW5kZXg7XG4gICAgICAgIHNlbGVjdGlvblNlcnZpY2Uuc2V0Rmlyc3RTZWxlY3RlZChpbmRleCwgdGhpcy5pc1NlbGVjdGVkKTtcbiAgICAgICAgaWYgKCFuYXZpZ2F0aW9uU2VydmljZS5pc0FjdGl2ZShpbmRleCkgJiYgc2VsZWN0aW9uU2VydmljZS5pc0ZpcnN0U2VsZWN0ZWQoaW5kZXgpKSB7XG4gICAgICAgICAgICBuYXZpZ2F0aW9uU2VydmljZS5hY3RpdmF0ZUluZGV4KGluZGV4KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBleHBhbmQoc2hvdWxkRXhwYW5kKSB7XG4gICAgICAgIHRoaXMuZXhwYW5kU2VydmljZVtzaG91bGRFeHBhbmQgPyAnZXhwYW5kJyA6ICdjb2xsYXBzZSddKHRoaXMuaW5kZXgsIHRoaXMuZGF0YUl0ZW0pO1xuICAgIH1cbiAgICBpc0ZvY3VzYWJsZSgpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLmlzRGlzYWJsZWQgJiYgdGhpcy5uYXZpZ2F0aW9uU2VydmljZS5pc0ZvY3VzYWJsZSh0aGlzLmluZGV4KTtcbiAgICB9XG4gICAgZm9jdXNJdGVtKCkge1xuICAgICAgICBpZiAodGhpcy5pc0luaXRpYWxpemVkICYmIHRoaXMubmF2aWdhdGlvblNlcnZpY2UuaXNBY3RpdmUodGhpcy5pbmRleCkpIHtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbW92ZUxvb2t1cEl0ZW0oY2hhbmdlcyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IHsgZGF0YUl0ZW0sIGluZGV4LCBwYXJlbnREYXRhSXRlbSwgcGFyZW50SW5kZXggfSA9IGNoYW5nZXM7XG4gICAgICAgIGlmICgoaW5kZXggJiYgaW5kZXguZmlyc3RDaGFuZ2UpIHx8IC8vc2tpcCBmaXJzdCBjaGFuZ2VcbiAgICAgICAgICAgICghZGF0YUl0ZW0gJiYgIWluZGV4ICYmICFwYXJlbnREYXRhSXRlbSAmJiAhcGFyZW50SW5kZXgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb2xkSW5kZXggPSAoaW5kZXggfHwge30pLnByZXZpb3VzVmFsdWUgfHwgdGhpcy5pbmRleDtcbiAgICAgICAgdGhpcy5sb29rdXBTZXJ2aWNlLnJlcGxhY2VJdGVtKG9sZEluZGV4LCB0aGlzLnRyZWVJdGVtLCB0aGlzLnBhcmVudFRyZWVJdGVtKTtcbiAgICB9XG4gICAgbW92ZU5hdmlnYXRpb25JdGVtKGluZGV4Q2hhbmdlID0ge30pIHtcbiAgICAgICAgY29uc3QgeyBjdXJyZW50VmFsdWUsIGZpcnN0Q2hhbmdlLCBwcmV2aW91c1ZhbHVlIH0gPSBpbmRleENoYW5nZTtcbiAgICAgICAgaWYgKCFmaXJzdENoYW5nZSAmJiBpc1ByZXNlbnQoY3VycmVudFZhbHVlKSAmJiBpc1ByZXNlbnQocHJldmlvdXNWYWx1ZSkpIHtcbiAgICAgICAgICAgIHRoaXMubmF2aWdhdGlvblNlcnZpY2UudW5yZWdpc3Rlckl0ZW0odGhpcy5pZCwgcHJldmlvdXNWYWx1ZSk7XG4gICAgICAgICAgICB0aGlzLm5hdmlnYXRpb25TZXJ2aWNlLnJlZ2lzdGVySXRlbSh0aGlzLmlkLCBjdXJyZW50VmFsdWUsIHRoaXMuaXNEaXNhYmxlZCwgdGhpcy5pc0J1dHRvbik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlTm9kZUF2YWlsYWJpbGl0eSgpIHtcbiAgICAgICAgY29uc3Qgc2VydmljZSA9IHRoaXMubmF2aWdhdGlvblNlcnZpY2U7XG4gICAgICAgIGlmICh0aGlzLmlzRGlzYWJsZWQgfHwgIXRoaXMuaXNWaXNpYmxlKSB7XG4gICAgICAgICAgICBzZXJ2aWNlLmFjdGl2YXRlQ2xvc2VzdCh0aGlzLmluZGV4KTsgLy8gYWN0aXZhdGUgYmVmb3JlIHVucmVnaXN0ZXIgdGhlIGl0ZW1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNlcnZpY2UuYWN0aXZhdGVGb2N1c2FibGUoKTtcbiAgICAgICAgfVxuICAgICAgICBzZXJ2aWNlLnVucmVnaXN0ZXJJdGVtKHRoaXMuaWQsIHRoaXMuaW5kZXgpO1xuICAgICAgICBzZXJ2aWNlLnJlZ2lzdGVySXRlbSh0aGlzLmlkLCB0aGlzLmluZGV4LCB0aGlzLmlzRGlzYWJsZWQsIHRoaXMuaXNCdXR0b24sIHRoaXMuaXNWaXNpYmxlKTtcbiAgICB9XG4gICAgc2V0QXJpYUF0dHJpYnV0ZXMoKSB7XG4gICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCdhcmlhLWxldmVsJywgdGhpcy5pYi5sZXZlbCh0aGlzLmluZGV4KS50b1N0cmluZygpKTtcbiAgICAgICAgLy8gZG9uJ3QgcmVuZGVyIGF0dHJpYnV0ZXMgd2hlbiB0aGUgY29tcG9uZW50IGNvbmZpZ3VyYXRpb24gZG9lc24ndCBhbGxvdyB0aGUgc3BlY2lmaWVkIHN0YXRlXG4gICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCdhcmlhLWV4cGFuZGVkJywgdGhpcy5leHBhbmRhYmxlID8gdGhpcy5pc0V4cGFuZGVkLnRvU3RyaW5nKCkgOiBudWxsKTtcbiAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ2FyaWEtc2VsZWN0ZWQnLCB0aGlzLnNlbGVjdGFibGUgPyB0aGlzLmlzU2VsZWN0ZWQudG9TdHJpbmcoKSA6IG51bGwpO1xuICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSgnYXJpYS1jaGVja2VkJywgdGhpcy5jaGVja2FibGUgPyB0aGlzLmFyaWFDaGVja2VkIDogbnVsbCk7XG4gICAgfVxuICAgIHNldERpc2FibGVkQ2xhc3MoKSB7XG4gICAgICAgIHRoaXMuc2V0Q2xhc3MoJ2stc3RhdGUtZGlzYWJsZWQnLCB0aGlzLmlzRGlzYWJsZWQpO1xuICAgIH1cbiAgICBzZXRDbGFzcyhjbGFzc05hbWUsIHRvZ2dsZSkge1xuICAgICAgICBjb25zdCBhY3Rpb24gPSB0b2dnbGUgPyAnYWRkQ2xhc3MnIDogJ3JlbW92ZUNsYXNzJztcbiAgICAgICAgdGhpcy5yZW5kZXJlclthY3Rpb25dKHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LCBjbGFzc05hbWUpO1xuICAgIH1cbiAgICB1cGRhdGVUYWJJbmRleCgpIHtcbiAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ3RhYkluZGV4JywgdGhpcy5pc0ZvY3VzYWJsZSgpID8gJzAnIDogJy0xJyk7XG4gICAgfVxuICAgIHNldEF0dHJpYnV0ZShhdHRyLCB2YWx1ZSkge1xuICAgICAgICBpZiAoIWlzUHJlc2VudCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIucmVtb3ZlQXR0cmlidXRlKHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LCBhdHRyKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlbmRlcmVyLnNldEF0dHJpYnV0ZSh0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudCwgYXR0ciwgdmFsdWUpO1xuICAgIH1cbn07XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBUcmVlVmlld0l0ZW1EaXJlY3RpdmUucHJvdG90eXBlLCBcImRhdGFJdGVtXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBUcmVlVmlld0l0ZW1EaXJlY3RpdmUucHJvdG90eXBlLCBcImluZGV4XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBUcmVlVmlld0l0ZW1EaXJlY3RpdmUucHJvdG90eXBlLCBcInBhcmVudERhdGFJdGVtXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBUcmVlVmlld0l0ZW1EaXJlY3RpdmUucHJvdG90eXBlLCBcInBhcmVudEluZGV4XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBUcmVlVmlld0l0ZW1EaXJlY3RpdmUucHJvdG90eXBlLCBcInJvbGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBUcmVlVmlld0l0ZW1EaXJlY3RpdmUucHJvdG90eXBlLCBcImxvYWRPbkRlbWFuZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIFRyZWVWaWV3SXRlbURpcmVjdGl2ZS5wcm90b3R5cGUsIFwiY2hlY2thYmxlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgVHJlZVZpZXdJdGVtRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJzZWxlY3RhYmxlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgVHJlZVZpZXdJdGVtRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJleHBhbmRhYmxlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbU3RyaW5nXSlcbl0sIFRyZWVWaWV3SXRlbURpcmVjdGl2ZS5wcm90b3R5cGUsIFwiaXNDaGVja2VkXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIFRyZWVWaWV3SXRlbURpcmVjdGl2ZS5wcm90b3R5cGUsIFwiaXNEaXNhYmxlZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIFRyZWVWaWV3SXRlbURpcmVjdGl2ZS5wcm90b3R5cGUsIFwiaXNWaXNpYmxlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0Jvb2xlYW5dKVxuXSwgVHJlZVZpZXdJdGVtRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJpc0V4cGFuZGVkXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtCb29sZWFuXSlcbl0sIFRyZWVWaWV3SXRlbURpcmVjdGl2ZS5wcm90b3R5cGUsIFwiaXNTZWxlY3RlZFwiLCBudWxsKTtcblRyZWVWaWV3SXRlbURpcmVjdGl2ZSA9IF9fZGVjb3JhdGUoW1xuICAgIERpcmVjdGl2ZSh7IHNlbGVjdG9yOiAnW2tlbmRvVHJlZVZpZXdJdGVtXScgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtFbGVtZW50UmVmLFxuICAgICAgICBFeHBhbmRTdGF0ZVNlcnZpY2UsXG4gICAgICAgIE5hdmlnYXRpb25TZXJ2aWNlLFxuICAgICAgICBTZWxlY3Rpb25TZXJ2aWNlLFxuICAgICAgICBUcmVlVmlld0xvb2t1cFNlcnZpY2UsXG4gICAgICAgIFJlbmRlcmVyMixcbiAgICAgICAgSW5kZXhCdWlsZGVyU2VydmljZV0pXG5dLCBUcmVlVmlld0l0ZW1EaXJlY3RpdmUpO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqXG4gKiBBIGRpcmVjdGl2ZSB3aGljaCBtYW5hZ2VzIHRoZSBleHBhbmRlZCBzdGF0ZSBvZiB0aGUgVHJlZVZpZXcuXG4gKi9cbmxldCBUcmVlVmlld0l0ZW1Db250ZW50RGlyZWN0aXZlID0gY2xhc3MgVHJlZVZpZXdJdGVtQ29udGVudERpcmVjdGl2ZSB7XG4gICAgY29uc3RydWN0b3IoZWxlbWVudCwgbmF2aWdhdGlvblNlcnZpY2UsIHNlbGVjdGlvblNlcnZpY2UsIHJlbmRlcmVyKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICAgIHRoaXMubmF2aWdhdGlvblNlcnZpY2UgPSBuYXZpZ2F0aW9uU2VydmljZTtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25TZXJ2aWNlID0gc2VsZWN0aW9uU2VydmljZTtcbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgICAgICB0aGlzLmluaXRpYWxTZWxlY3Rpb24gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pc1NlbGVjdGVkID0gaXNTZWxlY3RlZDtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zID0gbmV3IFN1YnNjcmlwdGlvbigpO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMuYWRkKHRoaXMubmF2aWdhdGlvblNlcnZpY2UubW92ZXNcbiAgICAgICAgICAgIC5zdWJzY3JpYmUodGhpcy51cGRhdGVGb2N1c0NsYXNzLmJpbmQodGhpcykpKTtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLmFkZCh0aGlzLm5hdmlnYXRpb25TZXJ2aWNlLnNlbGVjdHNcbiAgICAgICAgICAgIC5waXBlKGZpbHRlcigoaW5kZXgpID0+IGluZGV4ID09PSB0aGlzLmluZGV4KSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoKGluZGV4KSA9PiB0aGlzLnNlbGVjdGlvblNlcnZpY2Uuc2VsZWN0KGluZGV4LCB0aGlzLmRhdGFJdGVtKSkpO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMuYWRkKHRoaXMuc2VsZWN0aW9uU2VydmljZS5jaGFuZ2VzXG4gICAgICAgICAgICAuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlU2VsZWN0aW9uQ2xhc3ModGhpcy5pc1NlbGVjdGVkKHRoaXMuZGF0YUl0ZW0sIHRoaXMuaW5kZXgpKTtcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzKSB7XG4gICAgICAgIGlmIChjaGFuZ2VzLmluaXRpYWxTZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlU2VsZWN0aW9uQ2xhc3ModGhpcy5pbml0aWFsU2VsZWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhbmdlcy5pbmRleCkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVGb2N1c0NsYXNzKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy51bnN1YnNjcmliZSgpO1xuICAgIH1cbiAgICB1cGRhdGVGb2N1c0NsYXNzKCkge1xuICAgICAgICB0aGlzLnJlbmRlcih0aGlzLm5hdmlnYXRpb25TZXJ2aWNlLmlzQWN0aXZlKHRoaXMuaW5kZXgpLCAnay1zdGF0ZS1mb2N1c2VkJyk7XG4gICAgfVxuICAgIHVwZGF0ZVNlbGVjdGlvbkNsYXNzKHNlbGVjdGVkKSB7XG4gICAgICAgIHRoaXMucmVuZGVyKHNlbGVjdGVkLCAnay1zdGF0ZS1zZWxlY3RlZCcpO1xuICAgIH1cbiAgICByZW5kZXIoYWRkQ2xhc3MsIGNsYXNzTmFtZSkge1xuICAgICAgICBjb25zdCBhY3Rpb24gPSBhZGRDbGFzcyA/ICdhZGRDbGFzcycgOiAncmVtb3ZlQ2xhc3MnO1xuICAgICAgICB0aGlzLnJlbmRlcmVyW2FjdGlvbl0odGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQsIGNsYXNzTmFtZSk7XG4gICAgfVxufTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFRyZWVWaWV3SXRlbUNvbnRlbnREaXJlY3RpdmUucHJvdG90eXBlLCBcImRhdGFJdGVtXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBUcmVlVmlld0l0ZW1Db250ZW50RGlyZWN0aXZlLnByb3RvdHlwZSwgXCJpbmRleFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIFRyZWVWaWV3SXRlbUNvbnRlbnREaXJlY3RpdmUucHJvdG90eXBlLCBcImluaXRpYWxTZWxlY3Rpb25cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKVxuXSwgVHJlZVZpZXdJdGVtQ29udGVudERpcmVjdGl2ZS5wcm90b3R5cGUsIFwiaXNTZWxlY3RlZFwiLCB2b2lkIDApO1xuVHJlZVZpZXdJdGVtQ29udGVudERpcmVjdGl2ZSA9IF9fZGVjb3JhdGUoW1xuICAgIERpcmVjdGl2ZSh7IHNlbGVjdG9yOiAnW2tlbmRvVHJlZVZpZXdJdGVtQ29udGVudF0nIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbRWxlbWVudFJlZixcbiAgICAgICAgTmF2aWdhdGlvblNlcnZpY2UsXG4gICAgICAgIFNlbGVjdGlvblNlcnZpY2UsXG4gICAgICAgIFJlbmRlcmVyMl0pXG5dLCBUcmVlVmlld0l0ZW1Db250ZW50RGlyZWN0aXZlKTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKlxuICogUmVwcmVzZW50cyB0aGUgQ2hlY2tCb3ggY29tcG9uZW50IG9mIHRoZSBLZW5kbyBVSSBUcmVlVmlldyBmb3IgQW5ndWxhci5cbiAqXG4gKi9cbmxldCBDaGVja0JveENvbXBvbmVudCA9IGNsYXNzIENoZWNrQm94Q29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50LCByZW5kZXJlciwgY2hhbmdlRGV0ZWN0b3IpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgICAgICB0aGlzLmNoYW5nZURldGVjdG9yID0gY2hhbmdlRGV0ZWN0b3I7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVjaWZpZXMgdGhlIFtgaWRgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVE1ML0dsb2JhbF9hdHRyaWJ1dGVzL2lkKSBvZiB0aGUgY29tcG9uZW50LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pZCA9IGBfJHtndWlkKCl9YDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZmllcyB0aGUgW2B0YWJpbmRleGBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvR2xvYmFsX2F0dHJpYnV0ZXMvdGFiaW5kZXgpIG9mIHRoZSBjb21wb25lbnQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRhYmluZGV4ID0gMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIHdoZW4gdGhlIHVzZXIgY2hhbmdlcyB0aGUgY2hlY2sgc3RhdGUgb2YgdGhlIGNvbXBvbmVudC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2hlY2tTdGF0ZUNoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5jaGVja1N0YXRlID0gJ25vbmUnO1xuICAgIH1cbiAgICAvL1hYWDogaW1wbGVtZW50IENvbXBvbmVudFZhbHVlQWNjZXNzb3JcbiAgICAvL1hYWDogZm9jdXMvYmx1ciBtZXRob2RzXG4gICAgZ2V0IGNsYXNzV3JhcHBlcigpIHsgcmV0dXJuIHRydWU7IH1cbiAgICBnZXQgaW5kZXRlcm1pbmF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hlY2tTdGF0ZSA9PT0gJ2luZGV0ZXJtaW5hdGUnO1xuICAgIH1cbiAgICBnZXQgY2hlY2tlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hlY2tTdGF0ZSA9PT0gJ2NoZWNrZWQnO1xuICAgIH1cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5yZW1vdmVBdHRyaWJ1dGUodGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQsIFwidGFiaW5kZXhcIik7XG4gICAgfVxuICAgIG5nRG9DaGVjaygpIHtcbiAgICAgICAgdGhpcy5jaGVja1N0YXRlID0gdGhpcy5pc0NoZWNrZWQodGhpcy5ub2RlLCB0aGlzLmluZGV4KTtcbiAgICB9XG4gICAgaGFuZGxlQ2hhbmdlKGUpIHtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSBlLnRhcmdldC5jaGVja2VkID8gJ2NoZWNrZWQnIDogJ25vbmUnO1xuICAgICAgICAvLyB1cGRhdGUgdGhlIFZpZXcgU3RhdGUgc28gdGhhdCBBbmd1bGFyIHVwZGF0ZXMgdGhlIGlucHV0IGlmIHRoZSBpc0NoZWNrZWQgdmFsdWUgaXMgdGhlIHNhbWVcbiAgICAgICAgdGhpcy5jaGVja1N0YXRlID0gc3RhdGU7XG4gICAgICAgIHRoaXMuY2hhbmdlRGV0ZWN0b3IuZGV0ZWN0Q2hhbmdlcygpO1xuICAgICAgICB0aGlzLmNoZWNrU3RhdGVDaGFuZ2UuZW1pdChzdGF0ZSk7XG4gICAgfVxufTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5rLWNoZWNrYm94LXdyYXBwZXInKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgQ2hlY2tCb3hDb21wb25lbnQucHJvdG90eXBlLCBcImNsYXNzV3JhcHBlclwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIENoZWNrQm94Q29tcG9uZW50LnByb3RvdHlwZSwgXCJpZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgQ2hlY2tCb3hDb21wb25lbnQucHJvdG90eXBlLCBcImlzQ2hlY2tlZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgQ2hlY2tCb3hDb21wb25lbnQucHJvdG90eXBlLCBcIm5vZGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIENoZWNrQm94Q29tcG9uZW50LnByb3RvdHlwZSwgXCJpbmRleFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgQ2hlY2tCb3hDb21wb25lbnQucHJvdG90eXBlLCBcImxhYmVsVGV4dFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgQ2hlY2tCb3hDb21wb25lbnQucHJvdG90eXBlLCBcInRhYmluZGV4XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBPdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxuXSwgQ2hlY2tCb3hDb21wb25lbnQucHJvdG90eXBlLCBcImNoZWNrU3RhdGVDaGFuZ2VcIiwgdm9pZCAwKTtcbkNoZWNrQm94Q29tcG9uZW50ID0gX19kZWNvcmF0ZShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1jaGVja2JveCcsXG4gICAgICAgIHRlbXBsYXRlOiBgXG4gICAgICAgIDxpbnB1dFxuICAgICAgICAgICAgY2xhc3M9XCJrLWNoZWNrYm94XCJcbiAgICAgICAgICAgIHR5cGU9XCJjaGVja2JveFwiXG4gICAgICAgICAgICBbaWRdPVwiaWRcIlxuICAgICAgICAgICAgW2NoZWNrZWRdPVwiY2hlY2tlZFwiXG4gICAgICAgICAgICBbaW5kZXRlcm1pbmF0ZV09XCJpbmRldGVybWluYXRlXCJcbiAgICAgICAgICAgIFt0YWJpbmRleF09XCJ0YWJpbmRleFwiXG4gICAgICAgICAgICAoY2hhbmdlKT1cImhhbmRsZUNoYW5nZSgkZXZlbnQpXCJcbiAgICAgICAgLz5cbiAgICAgICAgPGxhYmVsXG4gICAgICAgICAgICBjbGFzcz1cImstY2hlY2tib3gtbGFiZWxcIlxuICAgICAgICAgICAgdGFiaW5kZXg9XCItMVwiXG4gICAgICAgICAgICBbZm9yXT1cImlkXCJcbiAgICAgICAgPnt7bGFiZWxUZXh0fX08L2xhYmVsPlxuICAgIGBcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0VsZW1lbnRSZWYsXG4gICAgICAgIFJlbmRlcmVyMixcbiAgICAgICAgQ2hhbmdlRGV0ZWN0b3JSZWZdKVxuXSwgQ2hlY2tCb3hDb21wb25lbnQpO1xuXG5jb25zdCBDT01QT05FTlRfRElSRUNUSVZFUyA9IFtcbiAgICBDaGVja0JveENvbXBvbmVudFxuXTtcbi8qKlxuICogQGhpZGRlblxuICpcbiAqIFJlcHJlc2VudHMgdGhlIFtOZ01vZHVsZV0oe3sgc2l0ZS5kYXRhLnVybHMuYW5ndWxhclsnbmdtb2R1bGVhcGknXSB9fSkgZGVmaW5pdGlvbiBmb3IgdGhlIENoZWNrQm94IGNvbXBvbmVudC5cbiAqL1xubGV0IENoZWNrQm94TW9kdWxlID0gY2xhc3MgQ2hlY2tCb3hNb2R1bGUge1xufTtcbkNoZWNrQm94TW9kdWxlID0gX19kZWNvcmF0ZShbXG4gICAgTmdNb2R1bGUoe1xuICAgICAgICBkZWNsYXJhdGlvbnM6IFtDT01QT05FTlRfRElSRUNUSVZFU10sXG4gICAgICAgIGV4cG9ydHM6IFtDT01QT05FTlRfRElSRUNUSVZFU11cbiAgICB9KVxuXSwgQ2hlY2tCb3hNb2R1bGUpO1xuXG4vKipcbiAqIEEgZGlyZWN0aXZlIHdoaWNoIGVuYWJsZXMgdGhlIHVwZGF0ZSBvZiB0aGUgaW5pdGlhbGx5IHByb3ZpZGVkIGRhdGEgYXJyYXkgZHVyaW5nIGRyYWctYW5kLWRyb3AuXG4gKlxuICogRWl0aGVyIHVzZSB0aGlzIGRpcmVjdGl2ZSBpbiBjb21iaW5hdGlvbiB3aXRoIG9uZSBvZiB0aGUgZGF0YSBiaW5kaW5nIGRpcmVjdGl2ZXMgKFtga2VuZG9UcmVlVmlld0hpZXJhcmNoeUJpbmRpbmdgXSh7JSBzbHVnIGFwaV90cmVldmlld19oaWVyYXJjaHliaW5kaW5nZGlyZWN0aXZlICV9KVxuICogb3IgW2BrZW5kb1RyZWVWaWV3RmxhdERhdGFCaW5kaW5nYF0oeyUgc2x1ZyBhcGlfdHJlZXZpZXdfZmxhdGRhdGFiaW5kaW5nZGlyZWN0aXZlICV9KSkgd2hpY2ggc2V0IHRoZWlyIG93biBlZGl0IGhhbmRsZXJzLCBvciBwcm92aWRlXG4gKiB5b3VyIG93biBbYGVkaXRTZXJ2aWNlYF0oeyUgc2x1ZyBhcGlfdHJlZXZpZXdfZWRpdHNlcnZpY2UgJX0pIHRvIHRoaXMgZGlyZWN0aXZlLiBUaGUgbGF0dGVyIHN1YnNjcmliZXMgdG8gYW5kIGNhbGxzIHRoZVxuICogW2BhZGRJdGVtYF0oeyUgc2x1ZyBhcGlfdHJlZXZpZXdfdHJlZXZpZXdjb21wb25lbnQgJX0jdG9jLWFkZGl0ZW0pIGFuZCBbYHJlbW92ZUl0ZW1gXSh7JSBzbHVnIGFwaV90cmVldmlld190cmVldmlld2NvbXBvbmVudCAlfSN0b2MtcmVtb3ZlaXRlbSlcbiAqIGhhbmRsZXJzIHdoZW4gdGhlIGNvcnJlc3BvbmRpbmcgZXZlbnRzIGFyZSB0cmlnZ2VyZWQgYnkgdGhlIFRyZWVWaWV3IGNvbXBvbmVudC5cbiAqL1xubGV0IERyYWdBbmREcm9wRWRpdGluZ0RpcmVjdGl2ZSA9IGNsYXNzIERyYWdBbmREcm9wRWRpdGluZ0RpcmVjdGl2ZSB7XG4gICAgY29uc3RydWN0b3IodHJlZXZpZXcpIHtcbiAgICAgICAgdGhpcy50cmVldmlldyA9IHRyZWV2aWV3O1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMgPSBuZXcgU3Vic2NyaXB0aW9uKCk7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5hZGQodGhpcy50cmVldmlldy5hZGRJdGVtLnN1YnNjcmliZSh0aGlzLmhhbmRsZUFkZC5iaW5kKHRoaXMpKSk7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5hZGQodGhpcy50cmVldmlldy5yZW1vdmVJdGVtLnN1YnNjcmliZSh0aGlzLmhhbmRsZVJlbW92ZS5iaW5kKHRoaXMpKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNwZWNpZmllcyB0aGUgaGFuZGxlcnMgY2FsbGVkIG9uIGRyYWctYW5kLWRyb3AgW2BhZGRJdGVtYF0oeyUgc2x1ZyBhcGlfdHJlZXZpZXdfdHJlZXZpZXdjb21wb25lbnQgJX0jdG9jLWFkZGl0ZW0pXG4gICAgICogYW5kIFtgcmVtb3ZlSXRlbWBdKHslIHNsdWcgYXBpX3RyZWV2aWV3X3RyZWV2aWV3Y29tcG9uZW50ICV9I3RvYy1yZW1vdmVpdGVtKSBldmVudHMuXG4gICAgICovXG4gICAgc2V0IGVkaXRTZXJ2aWNlKHNlcnZpY2UpIHtcbiAgICAgICAgdGhpcy50cmVldmlldy5lZGl0U2VydmljZSA9IHNlcnZpY2U7XG4gICAgfVxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMudW5zdWJzY3JpYmUoKTtcbiAgICB9XG4gICAgaGFuZGxlQWRkKGFyZ3MpIHtcbiAgICAgICAgaWYgKCFpc1ByZXNlbnQodGhpcy50cmVldmlldy5lZGl0U2VydmljZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gYGVkaXRTZXJ2aWNlYCBwcm92aWRlZC4gRWl0aGVyIHByb3ZpZGUgeW91ciBvd24gaW1wbGVtZW50YXRpb24gb3IgdXNlIHRoaXMgZGlyZWN0aXZlIGluIGNvbWJpbmF0aW9uIHdpdGggb25lIG9mIHRoZSBkYXRhIGJpbmRpbmcgZGlyZWN0aXZlcyAoYGtlbmRvVHJlZVZpZXdIaWVyYXJjaHlCaW5kaW5nYCBvciBga2VuZG9UcmVlVmlld0ZsYXREYXRhQmluZGluZ2ApLicpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudHJlZXZpZXcuZWRpdFNlcnZpY2UuYWRkKGFyZ3MpO1xuICAgIH1cbiAgICBoYW5kbGVSZW1vdmUoYXJncykge1xuICAgICAgICBpZiAoIWlzUHJlc2VudCh0aGlzLnRyZWV2aWV3LmVkaXRTZXJ2aWNlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBgZWRpdFNlcnZpY2VgIHByb3ZpZGVkLiBFaXRoZXIgcHJvdmlkZSB5b3VyIG93biBpbXBsZW1lbnRhdGlvbiBvciB1c2UgdGhpcyBkaXJlY3RpdmUgaW4gY29tYmluYXRpb24gd2l0aCBvbmUgb2YgdGhlIGRhdGEgYmluZGluZyBkaXJlY3RpdmVzIChga2VuZG9UcmVlVmlld0hpZXJhcmNoeUJpbmRpbmdgIG9yIGBrZW5kb1RyZWVWaWV3RmxhdERhdGFCaW5kaW5nYCkuJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50cmVldmlldy5lZGl0U2VydmljZS5yZW1vdmUoYXJncyk7XG4gICAgfVxufTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtPYmplY3RdKVxuXSwgRHJhZ0FuZERyb3BFZGl0aW5nRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJlZGl0U2VydmljZVwiLCBudWxsKTtcbkRyYWdBbmREcm9wRWRpdGluZ0RpcmVjdGl2ZSA9IF9fZGVjb3JhdGUoW1xuICAgIERpcmVjdGl2ZSh7XG4gICAgICAgIHNlbGVjdG9yOiAnW2tlbmRvVHJlZVZpZXdEcmFnQW5kRHJvcEVkaXRpbmddJ1xuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbVHJlZVZpZXdDb21wb25lbnRdKVxuXSwgRHJhZ0FuZERyb3BFZGl0aW5nRGlyZWN0aXZlKTtcblxuY29uc3QgTE9BRF9NT1JFX0RPQ19MSU5LJDEgPSAnaHR0cDovL3d3dy50ZWxlcmlrLmNvbS9rZW5kby1hbmd1bGFyLXVpL2NvbXBvbmVudHMvdHJlZXZpZXcvbG9hZC1tb3JlLWJ1dHRvbi8nO1xuLyoqXG4gKiBBIGRpcmVjdGl2ZSB0aGF0IGVuYWJsZXMgdGhlIGRpc3BsYXkgb2Ygb25seSBhIGxpbWl0ZWQgYW1vdW50IG9mIG5vZGVzIHBlciBsZXZlbFxuICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBsb2FkbW9yZWJ1dHRvbl90cmVldmlldyAlfSkpLlxuICovXG5sZXQgTG9hZE1vcmVEaXJlY3RpdmUgPSBjbGFzcyBMb2FkTW9yZURpcmVjdGl2ZSB7XG4gICAgY29uc3RydWN0b3IodHJlZXZpZXcpIHtcbiAgICAgICAgdGhpcy50cmVldmlldyA9IHRyZWV2aWV3O1xuICAgICAgICAvKipcbiAgICAgICAgICogS2VlcHMgdHJhY2sgb2YgdGhlIGN1cnJlbnQgcGFnZSBzaXplIG9mIGVhY2ggbm9kZSBvdmVyIGV4cGFuZC9jb2xsYXBzZSBjeWNsZXMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnBhZ2VTaXplcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVzZWQgYXMgYW4gaWRlbnRpZmllciBmb3IgdGhlIHJvb3QgcGFnZSBzaXplIGFzIHRoZSByb290IGNvbGxlY3Rpb24gb2Ygbm9kZXMgaXMgbm90IGFzc29jaWF0ZWQgd2l0aCBhIGRhdGEgaXRlbS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucm9vdExldmVsSWQgPSBndWlkKCk7XG4gICAgICAgIHRoaXMudHJlZXZpZXcubG9hZE1vcmVTZXJ2aWNlID0ge1xuICAgICAgICAgICAgZ2V0SW5pdGlhbFBhZ2VTaXplOiB0aGlzLmdldEluaXRhbFBhZ2VTaXplLmJpbmQodGhpcyksXG4gICAgICAgICAgICBnZXRHcm91cFNpemU6IHRoaXMuZ2V0R3JvdXBTaXplLmJpbmQodGhpcyksXG4gICAgICAgICAgICBzZXRHcm91cFNpemU6IHRoaXMuc2V0R3JvdXBTaXplLmJpbmQodGhpcyksXG4gICAgICAgICAgICBnZXRUb3RhbE5vZGVzQ291bnQ6IHRoaXMuZ2V0VG90YWxOb2Rlc0NvdW50LmJpbmQodGhpcylcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3BlY2lmaWVzIHRoZSBjYWxsYmFjayB0aGF0IHdpbGwgYmUgY2FsbGVkIHdoZW4gdGhlIGxvYWQgbW9yZSBidXR0b24gaXMgY2xpY2tlZC5cbiAgICAgKiBQcm92aWRpbmcgYSBmdW5jdGlvbiBpcyBvbmx5IHJlcXVpcmVkIHdoZW4gYWRkaXRpb25hbCBub2RlcyBhcmUgZmV0Y2hlZCBvbiBkZW1hbmRcbiAgICAgKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGxvYWRtb3JlYnV0dG9uX3RyZWV2aWV3ICV9I3RvYy1yZW1vdGUtZGF0YSkpLlxuICAgICAqL1xuICAgIHNldCBsb2FkTW9yZU5vZGVzKGxvYWRNb3JlTm9kZXMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBsb2FkTW9yZU5vZGVzID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudHJlZXZpZXcubG9hZE1vcmVTZXJ2aWNlLmxvYWRNb3JlTm9kZXMgPSBsb2FkTW9yZU5vZGVzO1xuICAgIH1cbiAgICBuZ09uQ2hhbmdlcygpIHtcbiAgICAgICAgdGhpcy52ZXJpZnlTZXR0aW5ncygpO1xuICAgIH1cbiAgICB2ZXJpZnlTZXR0aW5ncygpIHtcbiAgICAgICAgaWYgKCFpc0Rldk1vZGUoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNQcmVzZW50KHRoaXMucGFnZVNpemUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRvIHVzZSB0aGUgVHJlZVZpZXcgXFxga2VuZG9UcmVlVmlld0xvYWRNb3JlXFxgIGRpcmVjdGl2ZSwgeW91IG5lZWQgdG8gYXNzaWduIGEgXFxgcGFnZVNpemVcXGAgdmFsdWUuIFNlZSAke0xPQURfTU9SRV9ET0NfTElOSyQxfS5gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsb2FkTW9yZU5vZGVzID0gdGhpcy50cmVldmlldy5sb2FkTW9yZVNlcnZpY2UubG9hZE1vcmVOb2RlcztcbiAgICAgICAgaWYgKGlzUHJlc2VudChsb2FkTW9yZU5vZGVzKSAmJiB0eXBlb2YgbG9hZE1vcmVOb2RlcyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgcGFzc2VkIHZhbHVlIHRvIHRoZSBcXGBrZW5kb1RyZWVWaWV3TG9hZE1vcmVcXGAgZGlyZWN0aXZlIG11c3QgYmUgYSBmdW5jdGlvbiB0aGF0IHJldHJpZXZlcyBhZGRpdGlvbmFsIG5vZGVzLiBTZWUgJHtMT0FEX01PUkVfRE9DX0xJTkskMX0uYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzUHJlc2VudChsb2FkTW9yZU5vZGVzKSAmJiAhaXNQcmVzZW50KHRoaXMudG90YWxGaWVsZCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgV2hlbiBhIGZ1bmN0aW9uIHRvIGZldGNoIGFkZGl0aW9uYWwgbm9kZXMgaXMgcHJvdmlkZWQgdG8gdGhlIFxcYGtlbmRvVHJlZVZpZXdMb2FkTW9yZVxcYCBkaXJlY3RpdmUsIHRoZSBcXGB0b3RhbEZpZWxkXFxgIGFuZCBcXGB0b3RhbFJvb3ROb2Rlc1xcYCB2YWx1ZXMgbXVzdCBhbHNvIGJlIHByb3ZpZGVkLiBTZWUgJHtMT0FEX01PUkVfRE9DX0xJTkskMX0uYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0R3JvdXBTaXplKGRhdGFJdGVtKSB7XG4gICAgICAgIGNvbnN0IGl0ZW1LZXkgPSBkYXRhSXRlbSB8fCB0aGlzLnJvb3RMZXZlbElkO1xuICAgICAgICByZXR1cm4gdGhpcy5wYWdlU2l6ZXMuaGFzKGl0ZW1LZXkpID8gdGhpcy5wYWdlU2l6ZXMuZ2V0KGl0ZW1LZXkpIDogdGhpcy5wYWdlU2l6ZTtcbiAgICB9XG4gICAgc2V0R3JvdXBTaXplKGRhdGFJdGVtLCBwYWdlU2l6ZSkge1xuICAgICAgICBjb25zdCBpdGVtS2V5ID0gZGF0YUl0ZW0gfHwgdGhpcy5yb290TGV2ZWxJZDtcbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZFNpemVWYWx1ZSA9IHBhZ2VTaXplID4gMCA/IHBhZ2VTaXplIDogMDtcbiAgICAgICAgdGhpcy5wYWdlU2l6ZXMuc2V0KGl0ZW1LZXksIG5vcm1hbGl6ZWRTaXplVmFsdWUpO1xuICAgIH1cbiAgICBnZXRUb3RhbE5vZGVzQ291bnQoZGF0YUl0ZW0sIGxvYWRlZE5vZGVzQ291bnQpIHtcbiAgICAgICAgaWYgKGlzUHJlc2VudChkYXRhSXRlbSkgJiYgaXNQcmVzZW50KHRoaXMudG90YWxGaWVsZCkpIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRhSXRlbVt0aGlzLnRvdGFsRmllbGRdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFpc1ByZXNlbnQoZGF0YUl0ZW0pICYmIGlzUHJlc2VudCh0aGlzLnRvdGFsUm9vdE5vZGVzKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG90YWxSb290Tm9kZXM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbG9hZGVkTm9kZXNDb3VudDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRJbml0YWxQYWdlU2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFnZVNpemU7XG4gICAgfVxufTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCdrZW5kb1RyZWVWaWV3TG9hZE1vcmUnKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW09iamVjdF0pXG5dLCBMb2FkTW9yZURpcmVjdGl2ZS5wcm90b3R5cGUsIFwibG9hZE1vcmVOb2Rlc1wiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIExvYWRNb3JlRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJwYWdlU2l6ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgTG9hZE1vcmVEaXJlY3RpdmUucHJvdG90eXBlLCBcInRvdGFsUm9vdE5vZGVzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBMb2FkTW9yZURpcmVjdGl2ZS5wcm90b3R5cGUsIFwidG90YWxGaWVsZFwiLCB2b2lkIDApO1xuTG9hZE1vcmVEaXJlY3RpdmUgPSBfX2RlY29yYXRlKFtcbiAgICBEaXJlY3RpdmUoe1xuICAgICAgICBzZWxlY3RvcjogJ1trZW5kb1RyZWVWaWV3TG9hZE1vcmVdJ1xuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbVHJlZVZpZXdDb21wb25lbnRdKVxuXSwgTG9hZE1vcmVEaXJlY3RpdmUpO1xuXG5jb25zdCBDT01QT05FTlRfRElSRUNUSVZFUyQxID0gW1xuICAgIFRyZWVWaWV3Q29tcG9uZW50LFxuICAgIFRyZWVWaWV3R3JvdXBDb21wb25lbnQsXG4gICAgVHJlZVZpZXdJdGVtRGlyZWN0aXZlLFxuICAgIFRyZWVWaWV3SXRlbUNvbnRlbnREaXJlY3RpdmUsXG4gICAgTm9kZVRlbXBsYXRlRGlyZWN0aXZlLFxuICAgIENoZWNrRGlyZWN0aXZlLFxuICAgIERpc2FibGVEaXJlY3RpdmUsXG4gICAgRXhwYW5kRGlyZWN0aXZlLFxuICAgIFNlbGVjdERpcmVjdGl2ZSxcbiAgICBIaWVyYXJjaHlCaW5kaW5nRGlyZWN0aXZlLFxuICAgIExvYWRpbmdJbmRpY2F0b3JEaXJlY3RpdmUsXG4gICAgRmxhdERhdGFCaW5kaW5nRGlyZWN0aXZlLFxuICAgIERyYWdBbmREcm9wRGlyZWN0aXZlLFxuICAgIERyYWdDbHVlVGVtcGxhdGVEaXJlY3RpdmUsXG4gICAgRHJhZ0NsdWVDb21wb25lbnQsXG4gICAgRHJvcEhpbnRUZW1wbGF0ZURpcmVjdGl2ZSxcbiAgICBEcm9wSGludENvbXBvbmVudCxcbiAgICBEcmFnQW5kRHJvcEVkaXRpbmdEaXJlY3RpdmUsXG4gICAgTG9hZE1vcmVEaXJlY3RpdmUsXG4gICAgTG9hZE1vcmVCdXR0b25UZW1wbGF0ZURpcmVjdGl2ZVxuXTtcbi8qKlxuICogQGhpZGRlblxuICovXG5sZXQgU2hhcmVkTW9kdWxlID0gY2xhc3MgU2hhcmVkTW9kdWxlIHtcbn07XG5TaGFyZWRNb2R1bGUgPSBfX2RlY29yYXRlKFtcbiAgICBOZ01vZHVsZSh7XG4gICAgICAgIGRlY2xhcmF0aW9uczogW0NPTVBPTkVOVF9ESVJFQ1RJVkVTJDFdLFxuICAgICAgICBleHBvcnRzOiBbQ09NUE9ORU5UX0RJUkVDVElWRVMkMV0sXG4gICAgICAgIGltcG9ydHM6IFtcbiAgICAgICAgICAgIENvbW1vbk1vZHVsZSxcbiAgICAgICAgICAgIENoZWNrQm94TW9kdWxlLFxuICAgICAgICAgICAgSW5wdXRzTW9kdWxlXG4gICAgICAgIF0sXG4gICAgICAgIGVudHJ5Q29tcG9uZW50czogW1xuICAgICAgICAgICAgRHJhZ0NsdWVDb21wb25lbnQsXG4gICAgICAgICAgICBEcm9wSGludENvbXBvbmVudFxuICAgICAgICBdXG4gICAgfSlcbl0sIFNoYXJlZE1vZHVsZSk7XG5cbmNvbnN0IEVYUE9SVFMgPSBbXG4gICAgVHJlZVZpZXdDb21wb25lbnQsXG4gICAgTm9kZVRlbXBsYXRlRGlyZWN0aXZlLFxuICAgIENoZWNrRGlyZWN0aXZlLFxuICAgIERpc2FibGVEaXJlY3RpdmUsXG4gICAgRXhwYW5kRGlyZWN0aXZlLFxuICAgIFNlbGVjdERpcmVjdGl2ZSxcbiAgICBIaWVyYXJjaHlCaW5kaW5nRGlyZWN0aXZlLFxuICAgIEZsYXREYXRhQmluZGluZ0RpcmVjdGl2ZSxcbiAgICBEcmFnQW5kRHJvcERpcmVjdGl2ZSxcbiAgICBEcmFnQ2x1ZVRlbXBsYXRlRGlyZWN0aXZlLFxuICAgIERyb3BIaW50VGVtcGxhdGVEaXJlY3RpdmUsXG4gICAgRHJhZ0FuZERyb3BFZGl0aW5nRGlyZWN0aXZlLFxuICAgIExvYWRNb3JlRGlyZWN0aXZlLFxuICAgIExvYWRNb3JlQnV0dG9uVGVtcGxhdGVEaXJlY3RpdmVcbl07XG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIFtOZ01vZHVsZV0oe3sgc2l0ZS5kYXRhLnVybHMuYW5ndWxhclsnbmdtb2R1bGVhcGknXSB9fSkgZGVmaW5pdGlvbiBmb3IgdGhlIFRyZWVWaWV3IGNvbXBvbmVudC5cbiAqL1xubGV0IFRyZWVWaWV3TW9kdWxlID0gY2xhc3MgVHJlZVZpZXdNb2R1bGUge1xufTtcblRyZWVWaWV3TW9kdWxlID0gX19kZWNvcmF0ZShbXG4gICAgTmdNb2R1bGUoe1xuICAgICAgICBleHBvcnRzOiBbRVhQT1JUU10sXG4gICAgICAgIGltcG9ydHM6IFtTaGFyZWRNb2R1bGVdXG4gICAgfSlcbl0sIFRyZWVWaWV3TW9kdWxlKTtcblxuLyoqXG4gKiBHZW5lcmF0ZWQgYnVuZGxlIGluZGV4LiBEbyBub3QgZWRpdC5cbiAqL1xuXG5leHBvcnQgeyBDaGVja0JveENvbXBvbmVudCwgQ2hlY2tCb3hNb2R1bGUsIERhdGFDaGFuZ2VOb3RpZmljYXRpb25TZXJ2aWNlLCBEcmFnQ2x1ZUNvbXBvbmVudCwgRHJhZ0NsdWVTZXJ2aWNlLCBEcm9wSGludENvbXBvbmVudCwgRHJvcEhpbnRTZXJ2aWNlLCBEcmFnQW5kRHJvcEFzc2V0U2VydmljZSwgUHJldmVudGFibGVFdmVudCwgRXhwYW5kU3RhdGVTZXJ2aWNlLCBGaWx0ZXJpbmdCYXNlLCBJbmRleEJ1aWxkZXJTZXJ2aWNlLCBMb2FkaW5nSW5kaWNhdG9yRGlyZWN0aXZlLCBMb2FkaW5nTm90aWZpY2F0aW9uU2VydmljZSwgTmF2aWdhdGlvblNlcnZpY2UsIE5vZGVDaGlsZHJlblNlcnZpY2UsIFNlbGVjdGlvblNlcnZpY2UsIFNoYXJlZE1vZHVsZSwgVHJlZVZpZXdHcm91cENvbXBvbmVudCwgVHJlZVZpZXdJdGVtQ29udGVudERpcmVjdGl2ZSwgVHJlZVZpZXdJdGVtRGlyZWN0aXZlLCBUcmVlVmlld0xvb2t1cFNlcnZpY2UsIFRyZWVWaWV3Q29tcG9uZW50LCBUcmVlVmlld01vZHVsZSwgTm9kZVRlbXBsYXRlRGlyZWN0aXZlLCBDaGVja0RpcmVjdGl2ZSwgRGlzYWJsZURpcmVjdGl2ZSwgRXhwYW5kRGlyZWN0aXZlLCBTZWxlY3REaXJlY3RpdmUsIERhdGFCb3VuZENvbXBvbmVudCwgRXhwYW5kYWJsZUNvbXBvbmVudCwgSGllcmFyY2h5QmluZGluZ0RpcmVjdGl2ZSwgRmxhdERhdGFCaW5kaW5nRGlyZWN0aXZlLCBEcmFnQW5kRHJvcERpcmVjdGl2ZSwgRHJhZ0FuZERyb3BFZGl0aW5nRGlyZWN0aXZlLCBEcm9wSGludFRlbXBsYXRlRGlyZWN0aXZlLCBEcmFnQ2x1ZVRlbXBsYXRlRGlyZWN0aXZlLCBEcm9wQWN0aW9uLCBEcm9wUG9zaXRpb24sIFRyZWVJdGVtRHJvcEV2ZW50LCBUcmVlSXRlbURyYWdTdGFydEV2ZW50LCBUcmVlSXRlbURyYWdFdmVudCwgTG9hZE1vcmVEaXJlY3RpdmUsIExvYWRNb3JlQnV0dG9uVGVtcGxhdGVEaXJlY3RpdmUgfTtcbiJdfQ==","map":null,"metadata":{},"sourceType":"module"}