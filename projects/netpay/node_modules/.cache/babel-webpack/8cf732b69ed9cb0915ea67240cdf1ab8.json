{"ast":null,"code":"import Group from './group';\nimport Size from '../geometry/size';\nimport Rect from '../geometry/rect';\nimport Point from '../geometry/point';\nimport createTransform from '../geometry/transform';\nimport translateToPoint from '../alignment/translate-to-point';\nimport alignStart from '../alignment/align-start';\nimport alignStartReverse from '../alignment/align-start-reverse';\nconst DEFAULT_OPTIONS = {\n  alignContent: \"start\",\n  justifyContent: \"start\",\n  alignItems: \"start\",\n  spacing: 0,\n  orientation: \"horizontal\",\n  lineSpacing: 0,\n  wrap: true,\n  revers: false\n};\n\nconst forEach = (elements, callback) => {\n  elements.forEach(callback);\n};\n\nconst forEachReverse = (elements, callback) => {\n  const length = elements.length;\n\n  for (let idx = length - 1; idx >= 0; idx--) {\n    callback(elements[idx], idx);\n  }\n};\n\nclass Layout extends Group {\n  constructor(rect, options) {\n    super(Object.assign({}, DEFAULT_OPTIONS, options));\n    this._rect = rect;\n    this._fieldMap = {};\n  }\n\n  rect(value) {\n    if (value) {\n      this._rect = value;\n      return this;\n    }\n\n    return this._rect;\n  }\n\n  _initMap() {\n    const options = this.options;\n    const fieldMap = this._fieldMap;\n\n    if (options.orientation === \"horizontal\") {\n      fieldMap.sizeField = \"width\";\n      fieldMap.groupsSizeField = \"height\";\n      fieldMap.groupAxis = \"x\";\n      fieldMap.groupsAxis = \"y\";\n    } else {\n      fieldMap.sizeField = \"height\";\n      fieldMap.groupsSizeField = \"width\";\n      fieldMap.groupAxis = \"y\";\n      fieldMap.groupsAxis = \"x\";\n    }\n\n    if (options.reverse) {\n      this.forEach = forEachReverse;\n      this.justifyAlign = alignStartReverse;\n    } else {\n      this.forEach = forEach;\n      this.justifyAlign = alignStart;\n    }\n  }\n\n  reflow() {\n    if (!this._rect || this.children.length === 0) {\n      return;\n    }\n\n    this._initMap();\n\n    if (this.options.transform) {\n      this.transform(null);\n    }\n\n    const options = this.options;\n    const rect = this._rect;\n\n    const {\n      groups,\n      groupsSize\n    } = this._initGroups();\n\n    const {\n      sizeField,\n      groupsSizeField,\n      groupAxis,\n      groupsAxis\n    } = this._fieldMap;\n    const groupOrigin = new Point();\n    const elementOrigin = new Point();\n    const size = new Size();\n    let groupStart = alignStart(groupsSize, rect, options.alignContent, groupsAxis, groupsSizeField);\n    let elementStart, group, groupBox;\n\n    const arrangeElements = (bbox, idx) => {\n      const element = group.elements[idx];\n      elementOrigin[groupAxis] = elementStart;\n      elementOrigin[groupsAxis] = alignStart(bbox.size[groupsSizeField], groupBox, options.alignItems, groupsAxis, groupsSizeField);\n      translateToPoint(elementOrigin, bbox, element);\n      elementStart += bbox.size[sizeField] + options.spacing;\n    };\n\n    for (let groupIdx = 0; groupIdx < groups.length; groupIdx++) {\n      group = groups[groupIdx];\n      groupOrigin[groupAxis] = elementStart = this.justifyAlign(group.size, rect, options.justifyContent, groupAxis, sizeField);\n      groupOrigin[groupsAxis] = groupStart;\n      size[sizeField] = group.size;\n      size[groupsSizeField] = group.lineSize;\n      groupBox = new Rect(groupOrigin, size);\n      this.forEach(group.bboxes, arrangeElements);\n      groupStart += group.lineSize + options.lineSpacing;\n    }\n\n    if (!options.wrap && group.size > rect.size[sizeField]) {\n      const scale = rect.size[sizeField] / groupBox.size[sizeField];\n      const scaledStart = groupBox.topLeft().scale(scale, scale);\n      const scaledSize = groupBox.size[groupsSizeField] * scale;\n      const newStart = alignStart(scaledSize, rect, options.alignContent, groupsAxis, groupsSizeField);\n      const transform = createTransform();\n\n      if (groupAxis === \"x\") {\n        transform.translate(rect.origin.x - scaledStart.x, newStart - scaledStart.y);\n      } else {\n        transform.translate(newStart - scaledStart.x, rect.origin.y - scaledStart.y);\n      }\n\n      transform.scale(scale, scale);\n      this.transform(transform);\n    }\n  }\n\n  _initGroups() {\n    const {\n      options,\n      children\n    } = this;\n    const {\n      lineSpacing,\n      wrap,\n      spacing\n    } = options;\n    const sizeField = this._fieldMap.sizeField;\n\n    let group = this._newGroup();\n\n    const groups = [];\n\n    const addGroup = function () {\n      groups.push(group);\n      groupsSize += group.lineSize + lineSpacing;\n    };\n\n    let groupsSize = -lineSpacing;\n\n    for (let idx = 0; idx < children.length; idx++) {\n      let element = children[idx];\n      let bbox = children[idx].clippedBBox();\n\n      if (element.visible() && bbox) {\n        if (wrap && group.size + bbox.size[sizeField] + spacing > this._rect.size[sizeField]) {\n          if (group.bboxes.length === 0) {\n            this._addToGroup(group, bbox, element);\n\n            addGroup();\n            group = this._newGroup();\n          } else {\n            addGroup();\n            group = this._newGroup();\n\n            this._addToGroup(group, bbox, element);\n          }\n        } else {\n          this._addToGroup(group, bbox, element);\n        }\n      }\n    }\n\n    if (group.bboxes.length) {\n      addGroup();\n    }\n\n    return {\n      groups: groups,\n      groupsSize: groupsSize\n    };\n  }\n\n  _addToGroup(group, bbox, element) {\n    group.size += bbox.size[this._fieldMap.sizeField] + this.options.spacing;\n    group.lineSize = Math.max(bbox.size[this._fieldMap.groupsSizeField], group.lineSize);\n    group.bboxes.push(bbox);\n    group.elements.push(element);\n  }\n\n  _newGroup() {\n    return {\n      lineSize: 0,\n      size: -this.options.spacing,\n      bboxes: [],\n      elements: []\n    };\n  }\n\n}\n\nexport default Layout;","map":null,"metadata":{},"sourceType":"module"}