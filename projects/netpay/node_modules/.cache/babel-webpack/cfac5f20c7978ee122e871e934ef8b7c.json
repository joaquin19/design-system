{"ast":null,"code":"import Class from '../class';\nimport namedColors from './named-colors';\nimport { Bytes, RGB, HSV, HSL } from './parse-color';\nconst DARK_TRESHOLD = 180;\nlet Color = /*#__PURE__*/(() => {\n  class Color extends Class {\n    constructor(value) {\n      super();\n\n      if (arguments.length === 1) {\n        const formats = Color.formats;\n        const resolvedColor = this.resolveColor(value);\n\n        for (let idx = 0; idx < formats.length; idx++) {\n          const formatRegex = formats[idx].re;\n          const processor = formats[idx].process;\n          const parts = formatRegex.exec(resolvedColor);\n\n          if (parts) {\n            const channels = processor(parts);\n            this.r = channels[0];\n            this.g = channels[1];\n            this.b = channels[2];\n          }\n        }\n      } else {\n        this.r = arguments[0];\n        this.g = arguments[1];\n        this.b = arguments[2];\n      }\n\n      this.r = this.normalizeByte(this.r);\n      this.g = this.normalizeByte(this.g);\n      this.b = this.normalizeByte(this.b);\n    }\n\n    toHex() {\n      const pad = this.padDigit;\n      const r = this.r.toString(16);\n      const g = this.g.toString(16);\n      const b = this.b.toString(16);\n      return \"#\" + pad(r) + pad(g) + pad(b);\n    }\n\n    resolveColor(value) {\n      let color = value || \"black\";\n\n      if (color.charAt(0) === \"#\") {\n        color = color.substr(1, 6);\n      }\n\n      color = color.replace(/ /g, \"\");\n      color = color.toLowerCase();\n      color = Color.namedColors[color] || color;\n      return color;\n    }\n\n    normalizeByte(value) {\n      if (value < 0 || isNaN(value)) {\n        return 0;\n      }\n\n      return value > 255 ? 255 : value;\n    }\n\n    padDigit(value) {\n      return value.length === 1 ? \"0\" + value : value;\n    }\n\n    brightness(value) {\n      const round = Math.round;\n      this.r = round(this.normalizeByte(this.r * value));\n      this.g = round(this.normalizeByte(this.g * value));\n      this.b = round(this.normalizeByte(this.b * value));\n      return this;\n    }\n\n    percBrightness() {\n      return Math.sqrt(0.241 * this.r * this.r + 0.691 * this.g * this.g + 0.068 * this.b * this.b);\n    }\n\n    isDark() {\n      return this.percBrightness() < DARK_TRESHOLD;\n    }\n\n    static fromBytes(r, g, b, a) {\n      return new Bytes(r, g, b, a != null ? a : 1);\n    }\n\n    static fromRGB(r, g, b, a) {\n      return new RGB(r, g, b, a != null ? a : 1);\n    }\n\n    static fromHSV(h, s, v, a) {\n      return new HSV(h, s, v, a != null ? a : 1);\n    }\n\n    static fromHSL(h, s, l, a) {\n      return new HSL(h, s, l, a != null ? a : 1);\n    }\n\n  }\n\n  Color.formats = [{\n    re: /^rgb\\((\\d{1,3}),\\s*(\\d{1,3}),\\s*(\\d{1,3})\\)$/,\n    process: function (parts) {\n      return [parseInt(parts[1], 10), parseInt(parts[2], 10), parseInt(parts[3], 10)];\n    }\n  }, {\n    re: /^(\\w{2})(\\w{2})(\\w{2})$/,\n    process: function (parts) {\n      return [parseInt(parts[1], 16), parseInt(parts[2], 16), parseInt(parts[3], 16)];\n    }\n  }, {\n    re: /^(\\w{1})(\\w{1})(\\w{1})$/,\n    process: function (parts) {\n      return [parseInt(parts[1] + parts[1], 16), parseInt(parts[2] + parts[2], 16), parseInt(parts[3] + parts[3], 16)];\n    }\n  }];\n  Color.namedColors = namedColors;\n  return Color;\n})();\nexport default Color;","map":null,"metadata":{},"sourceType":"module"}