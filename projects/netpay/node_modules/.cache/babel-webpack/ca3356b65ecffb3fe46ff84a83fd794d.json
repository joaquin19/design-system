{"ast":null,"code":"import Class from '../class';\nimport support from '../support';\nimport namedColors from './named-colors';\nconst browser = support.browser;\n\nlet matchNamedColor = color => {\n  const colorNames = Object.keys(namedColors);\n  colorNames.push(\"transparent\");\n  const regexp = new RegExp(\"^(\" + colorNames.join(\"|\") + \")(\\\\W|$)\", \"i\");\n\n  matchNamedColor = color => regexp.exec(color);\n\n  return regexp.exec(color);\n};\n\nclass BaseColor extends Class {\n  constructor() {\n    super();\n  }\n\n  toHSV() {\n    return this;\n  }\n\n  toRGB() {\n    return this;\n  }\n\n  toHex() {\n    return this.toBytes().toHex();\n  }\n\n  toBytes() {\n    return this;\n  }\n\n  toCss() {\n    return \"#\" + this.toHex();\n  }\n\n  toCssRgba() {\n    const rgb = this.toBytes();\n    return `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${parseFloat(Number(this.a).toFixed(3))})`;\n  }\n\n  toDisplay() {\n    if (browser.msie && browser.version < 9) {\n      return this.toCss(); // no RGBA support; does it support any opacity in colors?\n    }\n\n    return this.toCssRgba();\n  }\n\n  equals(c) {\n    return c === this || c !== null && this.toCssRgba() === parseColor(c).toCssRgba();\n  }\n\n  diff(other) {\n    if (other === null) {\n      return NaN;\n    }\n\n    const c1 = this.toBytes();\n    const c2 = other.toBytes();\n    return Math.sqrt(Math.pow((c1.r - c2.r) * 0.30, 2) + Math.pow((c1.g - c2.g) * 0.59, 2) + Math.pow((c1.b - c2.b) * 0.11, 2));\n  }\n\n  clone() {\n    let c = this.toBytes();\n\n    if (c === this) {\n      c = new Bytes(c.r, c.g, c.b, c.a);\n    }\n\n    return c;\n  }\n\n}\n\nclass RGB extends BaseColor {\n  constructor(r, g, b, a) {\n    super();\n    this.r = r;\n    this.g = g;\n    this.b = b;\n    this.a = a;\n  }\n\n  toHSV() {\n    const {\n      r,\n      g,\n      b\n    } = this;\n    const min = Math.min(r, g, b);\n    const max = Math.max(r, g, b);\n    const delta = max - min;\n    const v = max;\n    let h, s;\n\n    if (delta === 0) {\n      return new HSV(0, 0, v, this.a);\n    }\n\n    if (max !== 0) {\n      s = delta / max;\n\n      if (r === max) {\n        h = (g - b) / delta;\n      } else if (g === max) {\n        h = 2 + (b - r) / delta;\n      } else {\n        h = 4 + (r - g) / delta;\n      }\n\n      h *= 60;\n\n      if (h < 0) {\n        h += 360;\n      }\n    } else {\n      s = 0;\n      h = -1;\n    }\n\n    return new HSV(h, s, v, this.a);\n  }\n\n  toHSL() {\n    const {\n      r,\n      g,\n      b\n    } = this;\n    const max = Math.max(r, g, b);\n    const min = Math.min(r, g, b);\n    let h,\n        s,\n        l = (max + min) / 2;\n\n    if (max === min) {\n      h = s = 0;\n    } else {\n      const d = max - min;\n      s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n\n      switch (max) {\n        case r:\n          h = (g - b) / d + (g < b ? 6 : 0);\n          break;\n\n        case g:\n          h = (b - r) / d + 2;\n          break;\n\n        case b:\n          h = (r - g) / d + 4;\n          break;\n\n        default:\n          break;\n      }\n    }\n\n    return new HSL(h * 60, s * 100, l * 100, this.a);\n  }\n\n  toBytes() {\n    return new Bytes(this.r * 255, this.g * 255, this.b * 255, this.a);\n  }\n\n}\n\nclass Bytes extends RGB {\n  constructor(r, g, b, a) {\n    super(Math.round(r), Math.round(g), Math.round(b), a);\n  }\n\n  toRGB() {\n    return new RGB(this.r / 255, this.g / 255, this.b / 255, this.a);\n  }\n\n  toHSV() {\n    return this.toRGB().toHSV();\n  }\n\n  toHSL() {\n    return this.toRGB().toHSL();\n  }\n\n  toHex() {\n    return hex(this.r, 2) + hex(this.g, 2) + hex(this.b, 2);\n  }\n\n  toBytes() {\n    return this;\n  }\n\n}\n\nfunction hex(n, width, pad = \"0\") {\n  let result = n.toString(16);\n\n  while (width > result.length) {\n    result = pad + result;\n  }\n\n  return result;\n}\n\nclass HSV extends BaseColor {\n  constructor(h, s, v, a) {\n    super();\n    this.h = h;\n    this.s = s;\n    this.v = v;\n    this.a = a;\n  }\n\n  toRGB() {\n    let {\n      h,\n      s,\n      v\n    } = this;\n    let r, g, b;\n\n    if (s === 0) {\n      r = g = b = v;\n    } else {\n      h /= 60;\n      const i = Math.floor(h);\n      const f = h - i;\n      const p = v * (1 - s);\n      const q = v * (1 - s * f);\n      const t = v * (1 - s * (1 - f));\n\n      switch (i) {\n        case 0:\n          r = v;\n          g = t;\n          b = p;\n          break;\n\n        case 1:\n          r = q;\n          g = v;\n          b = p;\n          break;\n\n        case 2:\n          r = p;\n          g = v;\n          b = t;\n          break;\n\n        case 3:\n          r = p;\n          g = q;\n          b = v;\n          break;\n\n        case 4:\n          r = t;\n          g = p;\n          b = v;\n          break;\n\n        default:\n          r = v;\n          g = p;\n          b = q;\n          break;\n      }\n    }\n\n    return new RGB(r, g, b, this.a);\n  }\n\n  toHSL() {\n    return this.toRGB().toHSL();\n  }\n\n  toBytes() {\n    return this.toRGB().toBytes();\n  }\n\n}\n\nclass HSL extends BaseColor {\n  constructor(h, s, l, a) {\n    super();\n    this.h = h;\n    this.s = s;\n    this.l = l;\n    this.a = a;\n  }\n\n  toRGB() {\n    let h = this.h / 360;\n    let s = this.s / 100;\n    let l = this.l / 100;\n    let r, g, b;\n\n    if (s === 0) {\n      r = g = b = l; // achromatic\n    } else {\n      const q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n      const p = 2 * l - q;\n      r = hue2rgb(p, q, h + 1 / 3);\n      g = hue2rgb(p, q, h);\n      b = hue2rgb(p, q, h - 1 / 3);\n    }\n\n    return new RGB(r, g, b, this.a);\n  }\n\n  toHSV() {\n    return this.toRGB().toHSV();\n  }\n\n  toBytes() {\n    return this.toRGB().toBytes();\n  }\n\n}\n\nfunction hue2rgb(p, q, s) {\n  let t = s;\n\n  if (t < 0) {\n    t += 1;\n  }\n\n  if (t > 1) {\n    t -= 1;\n  }\n\n  if (t < 1 / 6) {\n    return p + (q - p) * 6 * t;\n  }\n\n  if (t < 1 / 2) {\n    return q;\n  }\n\n  if (t < 2 / 3) {\n    return p + (q - p) * (2 / 3 - t) * 6;\n  }\n\n  return p;\n}\n\nexport { RGB, Bytes, HSV, HSL };\nexport default function parseColor(value, safe) {\n  let m, ret;\n\n  if (value == null || value === \"none\") {\n    return null;\n  }\n\n  if (value instanceof BaseColor) {\n    return value;\n  }\n\n  let color = value.toLowerCase();\n\n  if (m = matchNamedColor(color)) {\n    if (m[1] === \"transparent\") {\n      color = new RGB(1, 1, 1, 0);\n    } else {\n      color = parseColor(namedColors[m[1]], safe);\n    }\n\n    color.match = [m[1]];\n    return color;\n  }\n\n  if (m = /^#?([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})\\b/i.exec(color)) {\n    ret = new Bytes(parseInt(m[1], 16), parseInt(m[2], 16), parseInt(m[3], 16), 1);\n  } else if (m = /^#?([0-9a-f])([0-9a-f])([0-9a-f])\\b/i.exec(color)) {\n    ret = new Bytes(parseInt(m[1] + m[1], 16), parseInt(m[2] + m[2], 16), parseInt(m[3] + m[3], 16), 1);\n  } else if (m = /^rgb\\(\\s*([0-9]+)\\s*,\\s*([0-9]+)\\s*,\\s*([0-9]+)\\s*\\)/.exec(color)) {\n    ret = new Bytes(parseInt(m[1], 10), parseInt(m[2], 10), parseInt(m[3], 10), 1);\n  } else if (m = /^rgba\\(\\s*([0-9]+)\\s*,\\s*([0-9]+)\\s*,\\s*([0-9]+)\\s*,\\s*([0-9.]+)\\s*\\)/.exec(color)) {\n    ret = new Bytes(parseInt(m[1], 10), parseInt(m[2], 10), parseInt(m[3], 10), parseFloat(m[4]));\n  } else if (m = /^rgb\\(\\s*([0-9]*\\.?[0-9]+)%\\s*,\\s*([0-9]*\\.?[0-9]+)%\\s*,\\s*([0-9]*\\.?[0-9]+)%\\s*\\)/.exec(color)) {\n    ret = new RGB(parseFloat(m[1]) / 100, parseFloat(m[2]) / 100, parseFloat(m[3]) / 100, 1);\n  } else if (m = /^rgba\\(\\s*([0-9]*\\.?[0-9]+)%\\s*,\\s*([0-9]*\\.?[0-9]+)%\\s*,\\s*([0-9]*\\.?[0-9]+)%\\s*,\\s*([0-9.]+)\\s*\\)/.exec(color)) {\n    ret = new RGB(parseFloat(m[1]) / 100, parseFloat(m[2]) / 100, parseFloat(m[3]) / 100, parseFloat(m[4]));\n  }\n\n  if (ret) {\n    ret.match = m;\n  } else if (!safe) {\n    throw new Error(\"Cannot parse color: \" + color);\n  }\n\n  return ret;\n}","map":null,"metadata":{},"sourceType":"module"}