{"ast":null,"code":"import Node from './node';\nimport { defined, isTransparent } from '../util';\nimport { DASH_ARRAYS, SOLID, BUTT } from '../core/constants';\nimport { NONE } from './constants';\nimport renderAllAttr from './utils/render-all-attributes';\nimport renderAttr from './utils/render-attribute';\nconst ATTRIBUTE_MAP = {\n  \"fill.opacity\": \"fill-opacity\",\n  \"stroke.color\": \"stroke\",\n  \"stroke.width\": \"stroke-width\",\n  \"stroke.opacity\": \"stroke-opacity\"\n};\nconst SPACE = \" \";\n\nclass PathNode extends Node {\n  geometryChange() {\n    this.attr(\"d\", this.renderData());\n    this.invalidate();\n  }\n\n  optionsChange(e) {\n    switch (e.field) {\n      case \"fill\":\n        if (e.value) {\n          this.allAttr(this.mapFill(e.value));\n        } else {\n          this.removeAttr(\"fill\");\n        }\n\n        break;\n\n      case \"fill.color\":\n        this.allAttr(this.mapFill({\n          color: e.value\n        }));\n        break;\n\n      case \"stroke\":\n        if (e.value) {\n          this.allAttr(this.mapStroke(e.value));\n        } else {\n          this.removeAttr(\"stroke\");\n        }\n\n        break;\n\n      case \"transform\":\n        this.transformChange(e.value);\n        break;\n\n      default:\n        const name = ATTRIBUTE_MAP[e.field];\n\n        if (name) {\n          this.attr(name, e.value);\n        }\n\n        break;\n    }\n\n    super.optionsChange(e);\n  }\n\n  content() {\n    if (this.element) {\n      this.element.textContent = this.srcElement.content();\n    }\n  }\n\n  renderData() {\n    return this.printPath(this.srcElement);\n  }\n\n  printPath(path) {\n    const segments = path.segments;\n    const length = segments.length;\n\n    if (length > 0) {\n      const parts = [];\n      let output, currentType;\n\n      for (let i = 1; i < length; i++) {\n        let segmentType = this.segmentType(segments[i - 1], segments[i]);\n\n        if (segmentType !== currentType) {\n          currentType = segmentType;\n          parts.push(segmentType);\n        }\n\n        if (segmentType === \"L\") {\n          parts.push(this.printPoints(segments[i].anchor()));\n        } else {\n          parts.push(this.printPoints(segments[i - 1].controlOut(), segments[i].controlIn(), segments[i].anchor()));\n        }\n      }\n\n      output = \"M\" + this.printPoints(segments[0].anchor()) + SPACE + parts.join(SPACE);\n\n      if (path.options.closed) {\n        output += \"Z\";\n      }\n\n      return output;\n    }\n  }\n\n  printPoints() {\n    const points = arguments;\n    const length = points.length;\n    const result = [];\n\n    for (let i = 0; i < length; i++) {\n      result.push(points[i].toString(3));\n    }\n\n    return result.join(\" \");\n  }\n\n  segmentType(segmentStart, segmentEnd) {\n    return segmentStart.controlOut() && segmentEnd.controlIn() ? \"C\" : \"L\";\n  }\n\n  mapStroke(stroke) {\n    const attrs = [];\n\n    if (stroke && !isTransparent(stroke.color)) {\n      attrs.push([\"stroke\", stroke.color]);\n      attrs.push([\"stroke-width\", stroke.width]);\n      attrs.push([\"stroke-linecap\", this.renderLinecap(stroke)]);\n      attrs.push([\"stroke-linejoin\", stroke.lineJoin]);\n\n      if (defined(stroke.opacity)) {\n        attrs.push([\"stroke-opacity\", stroke.opacity]);\n      }\n\n      if (defined(stroke.dashType)) {\n        attrs.push([\"stroke-dasharray\", this.renderDashType(stroke)]);\n      }\n    } else {\n      attrs.push([\"stroke\", NONE]);\n    }\n\n    return attrs;\n  }\n\n  renderStroke() {\n    return renderAllAttr(this.mapStroke(this.srcElement.options.stroke));\n  }\n\n  renderDashType(stroke) {\n    const {\n      dashType,\n      width = 1\n    } = stroke;\n\n    if (dashType && dashType !== SOLID) {\n      const dashArray = DASH_ARRAYS[dashType.toLowerCase()];\n      const result = [];\n\n      for (let i = 0; i < dashArray.length; i++) {\n        result.push(dashArray[i] * width);\n      }\n\n      return result.join(\" \");\n    }\n  }\n\n  renderLinecap(stroke) {\n    const {\n      dashType,\n      lineCap\n    } = stroke;\n    return dashType && dashType !== \"solid\" ? BUTT : lineCap;\n  }\n\n  mapFill(fill) {\n    const attrs = [];\n\n    if (!(fill && fill.nodeType === \"Gradient\")) {\n      if (fill && !isTransparent(fill.color)) {\n        attrs.push([\"fill\", fill.color]);\n\n        if (defined(fill.opacity)) {\n          attrs.push([\"fill-opacity\", fill.opacity]);\n        }\n      } else {\n        attrs.push([\"fill\", NONE]);\n      }\n    }\n\n    return attrs;\n  }\n\n  renderFill() {\n    return renderAllAttr(this.mapFill(this.srcElement.options.fill));\n  }\n\n  template() {\n    return `<path ${this.renderId()} ${this.renderStyle()} ${this.renderOpacity()} ${renderAttr('d', this.renderData())}` + `${this.renderStroke()}${this.renderFill()}${this.renderDefinitions()}${this.renderTransform()}></path>`;\n  }\n\n}\n\nexport default PathNode;","map":null,"metadata":{},"sourceType":"module"}