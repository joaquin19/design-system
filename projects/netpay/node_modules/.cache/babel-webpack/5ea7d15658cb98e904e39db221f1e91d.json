{"ast":null,"code":"import HasObservers from '../core/has-observers';\nimport Rect from './rect';\nimport Point from './point';\nimport transform from './transform';\nimport { deg, MIN_NUM, MAX_NUM } from '../util';\nimport isOutOfEndPoint from './math/is-out-of-end-point';\nimport calculateCurveAt from './math/calculate-curve-at';\nimport hasRootsInRange from './math/has-roots-in-range';\nimport curveIntersectionsCount from './math/curve-intersections-count';\nimport lineIntersectionsCount from './math/line-intersections-count';\nimport withPoints from '../mixins/with-points';\nconst points = [\"anchor\", \"controlIn\", \"controlOut\"];\n\nclass Segment extends withPoints(HasObservers, points) {\n  constructor(anchor, controlIn, controlOut) {\n    super();\n    this.anchor(anchor || new Point());\n    this.controlIn(controlIn);\n    this.controlOut(controlOut);\n  }\n\n  bboxTo(toSegment, matrix) {\n    const segmentAnchor = this.anchor().transformCopy(matrix);\n    const toSegmentAnchor = toSegment.anchor().transformCopy(matrix);\n    let rect;\n\n    if (this.controlOut() && toSegment.controlIn()) {\n      rect = this._curveBoundingBox(segmentAnchor, this.controlOut().transformCopy(matrix), toSegment.controlIn().transformCopy(matrix), toSegmentAnchor);\n    } else {\n      rect = this._lineBoundingBox(segmentAnchor, toSegmentAnchor);\n    }\n\n    return rect;\n  }\n\n  _lineBoundingBox(p1, p2) {\n    return Rect.fromPoints(p1, p2);\n  }\n\n  _curveBoundingBox(p1, cp1, cp2, p2) {\n    const points = [p1, cp1, cp2, p2];\n\n    const extremesX = this._curveExtremesFor(points, \"x\");\n\n    const extremesY = this._curveExtremesFor(points, \"y\");\n\n    const xLimits = arrayLimits([extremesX.min, extremesX.max, p1.x, p2.x]);\n    const yLimits = arrayLimits([extremesY.min, extremesY.max, p1.y, p2.y]);\n    return Rect.fromPoints(new Point(xLimits.min, yLimits.min), new Point(xLimits.max, yLimits.max));\n  }\n\n  _curveExtremesFor(points, field) {\n    const extremes = this._curveExtremes(points[0][field], points[1][field], points[2][field], points[3][field]);\n\n    return {\n      min: calculateCurveAt(extremes.min, field, points),\n      max: calculateCurveAt(extremes.max, field, points)\n    };\n  }\n\n  _curveExtremes(x1, x2, x3, x4) {\n    const a = x1 - 3 * x2 + 3 * x3 - x4;\n    const b = -2 * (x1 - 2 * x2 + x3);\n    const c = x1 - x2;\n    const sqrt = Math.sqrt(b * b - 4 * a * c);\n    let t1 = 0;\n    let t2 = 1;\n\n    if (a === 0) {\n      if (b !== 0) {\n        t1 = t2 = -c / b;\n      }\n    } else if (!isNaN(sqrt)) {\n      t1 = (-b + sqrt) / (2 * a);\n      t2 = (-b - sqrt) / (2 * a);\n    }\n\n    let min = Math.max(Math.min(t1, t2), 0);\n\n    if (min < 0 || min > 1) {\n      min = 0;\n    }\n\n    let max = Math.min(Math.max(t1, t2), 1);\n\n    if (max > 1 || max < 0) {\n      max = 1;\n    }\n\n    return {\n      min: min,\n      max: max\n    };\n  }\n\n  _intersectionsTo(segment, point) {\n    let intersectionsCount;\n\n    if (this.controlOut() && segment.controlIn()) {\n      intersectionsCount = curveIntersectionsCount([this.anchor(), this.controlOut(), segment.controlIn(), segment.anchor()], point, this.bboxTo(segment));\n    } else {\n      intersectionsCount = lineIntersectionsCount(this.anchor(), segment.anchor(), point);\n    }\n\n    return intersectionsCount;\n  }\n\n  _isOnCurveTo(segment, point, width, endSegment) {\n    const bbox = this.bboxTo(segment).expand(width, width);\n\n    if (bbox.containsPoint(point)) {\n      const p1 = this.anchor();\n      const p2 = this.controlOut();\n      const p3 = segment.controlIn();\n      const p4 = segment.anchor();\n\n      if (endSegment === \"start\" && p1.distanceTo(point) <= width) {\n        return !isOutOfEndPoint(p1, p2, point);\n      } else if (endSegment === \"end\" && p4.distanceTo(point) <= width) {\n        return !isOutOfEndPoint(p4, p3, point);\n      } //the approach is not entirely correct but is close and the alternatives are solving a 6th degree polynomial or testing the segment points\n\n\n      const points = [p1, p2, p3, p4];\n\n      if (hasRootsInRange(points, point, \"x\", \"y\", width) || hasRootsInRange(points, point, \"y\", \"x\", width)) {\n        return true;\n      }\n\n      const rotation = transform().rotate(45, point);\n      const rotatedPoints = [p1.transformCopy(rotation), p2.transformCopy(rotation), p3.transformCopy(rotation), p4.transformCopy(rotation)];\n      return hasRootsInRange(rotatedPoints, point, \"x\", \"y\", width) || hasRootsInRange(rotatedPoints, point, \"y\", \"x\", width);\n    }\n  }\n\n  _isOnLineTo(segment, point, width) {\n    const p1 = this.anchor();\n    const p2 = segment.anchor();\n    const angle = deg(Math.atan2(p2.y - p1.y, p2.x - p1.x));\n    const rect = new Rect([p1.x, p1.y - width / 2], [p1.distanceTo(p2), width]);\n    return rect.containsPoint(point.transformCopy(transform().rotate(-angle, p1)));\n  }\n\n  _isOnPathTo(segment, point, width, endSegment) {\n    let isOnPath;\n\n    if (this.controlOut() && segment.controlIn()) {\n      isOnPath = this._isOnCurveTo(segment, point, width / 2, endSegment);\n    } else {\n      isOnPath = this._isOnLineTo(segment, point, width);\n    }\n\n    return isOnPath;\n  }\n\n}\n\nfunction arrayLimits(arr) {\n  let length = arr.length;\n  let min = MAX_NUM;\n  let max = MIN_NUM;\n\n  for (let i = 0; i < length; i++) {\n    max = Math.max(max, arr[i]);\n    min = Math.min(min, arr[i]);\n  }\n\n  return {\n    min: min,\n    max: max\n  };\n}\n\nexport default Segment;","map":null,"metadata":{},"sourceType":"module"}