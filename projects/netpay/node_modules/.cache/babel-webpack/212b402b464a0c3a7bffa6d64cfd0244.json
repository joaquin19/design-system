{"ast":null,"code":"import Element from './element';\nimport traversable from '../mixins/traversable';\nimport { append } from '../util';\nimport elementsBoundingBox from './utils/elements-bounding-box';\nimport elementsClippedBoundingBox from './utils/elements-clippend-bounding-box';\n\nclass Group extends traversable(Element, \"children\") {\n  get nodeType() {\n    return \"Group\";\n  }\n\n  constructor(options) {\n    super(options);\n    this.children = [];\n  }\n\n  childrenChange(action, items, index) {\n    this.trigger(\"childrenChange\", {\n      action: action,\n      items: items,\n      index: index\n    });\n  }\n\n  append() {\n    append(this.children, arguments);\n\n    this._reparent(arguments, this);\n\n    this.childrenChange(\"add\", arguments);\n    return this;\n  }\n\n  insert(index, element) {\n    this.children.splice(index, 0, element);\n    element.parent = this;\n    this.childrenChange(\"add\", [element], index);\n    return this;\n  }\n\n  insertAt(element, index) {\n    return this.insert(index, element);\n  }\n\n  remove(element) {\n    const index = this.children.indexOf(element);\n\n    if (index >= 0) {\n      this.children.splice(index, 1);\n      element.parent = null;\n      this.childrenChange(\"remove\", [element], index);\n    }\n\n    return this;\n  }\n\n  removeAt(index) {\n    if (0 <= index && index < this.children.length) {\n      let element = this.children[index];\n      this.children.splice(index, 1);\n      element.parent = null;\n      this.childrenChange(\"remove\", [element], index);\n    }\n\n    return this;\n  }\n\n  clear() {\n    const items = this.children;\n    this.children = [];\n\n    this._reparent(items, null);\n\n    this.childrenChange(\"remove\", items, 0);\n    return this;\n  }\n\n  bbox(transformation) {\n    return elementsBoundingBox(this.children, true, this.currentTransform(transformation));\n  }\n\n  rawBBox() {\n    return elementsBoundingBox(this.children, false);\n  }\n\n  _clippedBBox(transformation) {\n    return elementsClippedBoundingBox(this.children, this.currentTransform(transformation));\n  }\n\n  currentTransform(transformation) {\n    return Element.prototype.currentTransform.call(this, transformation) || null;\n  }\n\n  containsPoint(point, parentTransform) {\n    if (this.visible()) {\n      const children = this.children;\n      const transform = this.currentTransform(parentTransform);\n\n      for (let idx = 0; idx < children.length; idx++) {\n        if (children[idx].containsPoint(point, transform)) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  _reparent(elements, newParent) {\n    for (let i = 0; i < elements.length; i++) {\n      const child = elements[i];\n      const parent = child.parent;\n\n      if (parent && parent !== this && parent.remove) {\n        parent.remove(child);\n      }\n\n      child.parent = newParent;\n    }\n  }\n\n}\n\nexport default Group;","map":null,"metadata":{},"sourceType":"module"}